{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/archives/index.md","path":"archives/index.md","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/apple-touch-icon.png","hash":"fbd2744aedd23c6addea809a9e5e7cbb3306e7b9","modified":1569822379618},{"_id":"source/favicon.ico","hash":"92d61ec769765f2fb7bc1882c2c3b18931ac40f2","modified":1569822262504},{"_id":"themes/maupassant/.gitignore","hash":"d7d27e5a9bcffe7f90dc2f4f0752e19020e40f40","modified":1569824776810},{"_id":"themes/maupassant/.travis.yml","hash":"f8da426b97088e4caa5226cff219a5d95087961f","modified":1569824776812},{"_id":"themes/maupassant/LICENSE","hash":"0663fd3a7ea9fc4f4c634b4d73e2da426b536f86","modified":1569824776813},{"_id":"themes/maupassant/_config.yml","hash":"82b200e5f516ba16800daa74bdec1bcd2a24848a","modified":1569990727259},{"_id":"themes/maupassant/README.md","hash":"4e402501b89720f18ffbfce4203663c79b3c0a7f","modified":1569824776815},{"_id":"themes/maupassant/package.json","hash":"5328c4c435cd4a5fe47caae31b9975013cdca5bb","modified":1569824776880},{"_id":"source/about/index.md","hash":"2f2ddc1e0c36f8dfc248834e3f37083ed8836147","modified":1569832245280},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"25d1d8cd8113045a7603c14af1ea1539fc6456ed","modified":1569824776820},{"_id":"themes/maupassant/languages/en.yml","hash":"518beaa8538a772ca697122264d667059797e458","modified":1569824776822},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"3cc9312fbdba4a8f8e8254804121e4724c719bcc","modified":1569824776824},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"3a50568f200b9c1258415b53727e42c6b6c7ea0b","modified":1569824776825},{"_id":"themes/maupassant/languages/ko.yml","hash":"a454bcec60113507bc1d593a699849822386c196","modified":1569824776827},{"_id":"themes/maupassant/languages/ru.yml","hash":"36edc014c6aaef367d58929089bf7915375e71a6","modified":1569824776828},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"a1a9888b6cd0fd3dc45ffed3490f4ca8ce1abfd7","modified":1569824776831},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"34dba7ac67aeb316f629ca73e546fa143cc362d5","modified":1569824776833},{"_id":"themes/maupassant/layout/archive.pug","hash":"05f751cb766616ff96ff22ad0790d9cd28777270","modified":1569824776865},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"b0a0ec63ee0225eaa0996d72164202bc9a28a225","modified":1569824776867},{"_id":"themes/maupassant/layout/base.pug","hash":"7451a590db6943edc099dc0e13b317c38686e8fc","modified":1569824776869},{"_id":"themes/maupassant/layout/index.pug","hash":"d1d56fa62f1293cd0cbefe96dbbde2d35b557a0a","modified":1569824776870},{"_id":"themes/maupassant/layout/page.pug","hash":"a21e638d5459120d88e45e8f18a23dc072d9ca07","modified":1569824776872},{"_id":"themes/maupassant/layout/post.pug","hash":"faa84d65681da6f4697f2b3aec1e27f615569f7a","modified":1569834254736},{"_id":"themes/maupassant/layout/single-column.pug","hash":"8b4b731cdf86379d526821a1fa950bf15ed61f15","modified":1569824776875},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"4c8923bd7fe2a6d413cde7945ac3c34eeef9942b","modified":1569824776877},{"_id":"themes/maupassant/layout/timeline.pug","hash":"04f7efdc45acda1faff409d0f80fa5a0dd2309d0","modified":1569824776878},{"_id":"source/_posts/c/C语言include和变量.md","hash":"d9468efc9e76317029871f161b7407eafa705d61","modified":1570006557706},{"_id":"source/_posts/c/C语言指针、结构体、枚举.md","hash":"220dcc60ead453b8eca8ad3c8e73c5401f9d6dc3","modified":1570006832102},{"_id":"source/_posts/c/C语言初识.md","hash":"4567ed9eb582fb5ae8ba844d406060e30155c500","modified":1570006276236},{"_id":"source/_posts/c/C语言数组和字符串.md","hash":"5c63a818e2bde1ca772fd84b28b6f164784ec2d3","modified":1570006665541},{"_id":"source/_posts/git/Git远程操作详解.md","hash":"b76d1181b8ea588646fc65ba6122fc3d4964088d","modified":1570005738966},{"_id":"source/_posts/c/C语言的预处理指令和关键字.md","hash":"9f983001495b3b7c13fed451a051d6e184ac0e4d","modified":1570006988980},{"_id":"source/_posts/c/C语言表达式和结构控制.md","hash":"41e795d2afac323c314578ef948c3d36b6eb6d18","modified":1570006420484},{"_id":"source/_posts/hexo/hexo配置.md","hash":"1116a8a4096f128a34c65816ca56aaf37a3f3fc8","modified":1570005686962},{"_id":"source/_posts/hexo/利用Hexo+GitHub搭建个人博客.md","hash":"669da26a1627d07f9b13136382b0cb7808150bf2","modified":1570005714758},{"_id":"source/_posts/ide/PHP开发工具ZendStudio10.md","hash":"bc08654f39d3ce648393e37c37fe1352686727bc","modified":1570005751101},{"_id":"source/_posts/ide/Eclipse.ini参数设置.md","hash":"cc883bab830dc8f321a5750de322daaed359c8a4","modified":1570005748543},{"_id":"source/_posts/mysql/Win8(X64)下MySQL5.6版本安装及配置.md","hash":"0ccdaaed2da693a357670d3728a28aec21f29970","modified":1570005635546},{"_id":"source/_posts/mysql/mysql常用信息函数.md","hash":"c36da120b0b01055d6efe33bba5af2a562513c0c","modified":1570005622980},{"_id":"source/_posts/mysql/数据表命令.md","hash":"6275862d5f3fda2925fad63464be0f2a18c3a4a3","modified":1570005970954},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"d2ffd7c34c743ec3c01dc1a1ddb8913ffd025f2a","modified":1569824776836},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"78c9a74bc379feca35342e4753a4cc6330a0fe94","modified":1569824776838},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"92aa15e813bfb411803cc54218feb5410469a9c2","modified":1569824776839},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"235660024477ba0f68dacbbde12492280f82242a","modified":1569824776841},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1569824776843},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1569824776844},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1569824776846},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1569824776848},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1569824776850},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1569824776851},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"eb91a3baf9411188c7c8130f63a674f541ca9c81","modified":1569824776853},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"6fb1d8ee09cfc4fd31e8ae53736e4f479d45e31e","modified":1569824776854},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7707b4c718a935882ee986d0bb0078e50cdbea64","modified":1569824776857},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"7bc7c17cfd498c3e0c3371cef78f08f1dc25db36","modified":1569824776857},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"770b6c41cbf7969ed33adf87eec3be6f50a0911b","modified":1569824776860},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"68bae3eb2f80e6127e03faa7ee1b78fb2e70aafc","modified":1569824776859},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6aa743486f282545f553a4fad6aae037afe26108","modified":1569824776862},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"37f236365b153fc40324391e5a602d6d50014e18","modified":1569824776863},{"_id":"themes/maupassant/source/css/donate.css","hash":"ca39d14a598e1de5c51db4170ceb399c6a7131fe","modified":1569824776885},{"_id":"themes/maupassant/source/archives/index.md","hash":"f6247f6b31fd4fa7723b05264d3757fbffb70e4f","modified":1569824968622},{"_id":"themes/maupassant/source/css/default.css","hash":"b41d95120f9e64fd4530ae00ceaef09c7ea20818","modified":1569824776884},{"_id":"themes/maupassant/source/css/style.scss","hash":"ee0800852fc68c82821b7a7c7a77e933fb00d157","modified":1569824776888},{"_id":"themes/maupassant/source/donate/index.html","hash":"72e48cbc939df9e4f963ebf570e0181e129a51c5","modified":1569824776890},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1569824776893},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"292ea040e865c1d0be259703ff850570b3bdfc97","modified":1569824776899},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1569824776895},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1569824776897},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"eeb2ee8cf44ba5c298baeed84bb90866f4814955","modified":1569824776901},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1569824776902},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1569824776905},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"e916dea1c1bba1bc935510310f65b2c9328a401a","modified":1569824776907},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"30418295bed44bcc4b29076eb7deed49cf4d6c1c","modified":1569824776908},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"c77270e684a60babc1abb7353e700ecdc5a66d30","modified":1569824776911},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1569824776913},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"8a993c1c4ad40789d2960b682cb2130382a0f26a","modified":1569824776914},{"_id":"themes/maupassant/source/js/search.js","hash":"dbda07a03e6edc73f1dc28a068c24a6037b97b56","modified":1569824776920},{"_id":"themes/maupassant/source/js/share.js","hash":"514e726c1efae9f6566600fa0e945b4b9e620f2e","modified":1569824776921},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"150ab1cad40d7ae081b0896b13f7d7cbac4e6338","modified":1569824776924},{"_id":"themes/maupassant/source/js/totop.js","hash":"15de186b089c245fe60766d509b587919f05ff23","modified":1569824776925},{"_id":"source/_posts/android/base/Android应用的基本组件.md","hash":"6571919c912a6b1478d8c93540f5f3ba82803da1","modified":1570005662792},{"_id":"source/_posts/android/base/android发展史及系统架构.md","hash":"dc4df0788593bba9a10994c6706a2d1d5bd9abb9","modified":1570005659303},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"b15998a45d5f386d30905cfbfbb1658336acbb5b","modified":1569824776918},{"_id":"public/atom.xml","hash":"58f73c32745bebc64537c674149d2697f4809bf7","modified":1570007055912},{"_id":"public/archives/index.html","hash":"4a7e82ba66e6af4531864cba4434c1e8baf5d752","modified":1570007056097},{"_id":"public/about/index.html","hash":"b6f0262c64a2c71dd673ee1469b18e1bf5a7e155","modified":1570007056098},{"_id":"public/2019/09/30/hexo/hexo配置/index.html","hash":"54560bb196ba03db4bf307f0f3c29e79748c5d10","modified":1570007056104},{"_id":"public/2019/09/30/hexo/利用Hexo+GitHub搭建个人博客/index.html","hash":"0a64eeab1eed8b9fbdaa09e8f7111f2ad559b1a9","modified":1570007056105},{"_id":"public/2017/01/12/mysql/mysql常用信息函数/index.html","hash":"a87f6f8d45b8fcf467b4118b85e4fd6af779ddd6","modified":1570007056105},{"_id":"public/2015/04/17/ide/PHP开发工具ZendStudio10/index.html","hash":"87cb1a9f76183b74350a8beffa7f869d3f90c6f4","modified":1570007056106},{"_id":"public/2015/04/16/ide/Eclipse.ini参数设置/index.html","hash":"a3f61df797e1afb4f550c9e3e94ca7d187b389e9","modified":1570007056106},{"_id":"public/categories/hexo/index.html","hash":"61332fb23a09ad6ae312ecc475896f9d73af8f3c","modified":1570007056106},{"_id":"public/categories/IDE/index.html","hash":"7fb6f8d9e5502eed963178e0e837e94e685b0b0b","modified":1570007056106},{"_id":"public/categories/MySql/index.html","hash":"1486ae7998e4d53424e1698eb61d8fae9dde6ade","modified":1570007056106},{"_id":"public/categories/Android基础/index.html","hash":"57a5d9818a946f05d5cf477315174ec591cf0cfc","modified":1570007056106},{"_id":"public/archives/2015/index.html","hash":"7b71a8040f80ff50a899a00bc014b9add0be7b8e","modified":1570007056107},{"_id":"public/archives/2015/04/index.html","hash":"36bcaa7afe8f922262e82f1f253aa422f3faf903","modified":1570007056107},{"_id":"public/archives/2016/index.html","hash":"af6186b6273ba942bd2065291dea4fd1731a8257","modified":1570007056107},{"_id":"public/archives/2016/01/index.html","hash":"af6186b6273ba942bd2065291dea4fd1731a8257","modified":1570007056107},{"_id":"public/archives/2019/index.html","hash":"bdbdd4d80691d9fc61685ccb2c4680d7de903ac6","modified":1570007056108},{"_id":"public/archives/2017/01/index.html","hash":"a8170e2de01c435ba779e4042dda132bb2dea45f","modified":1570007056108},{"_id":"public/archives/2017/index.html","hash":"a8170e2de01c435ba779e4042dda132bb2dea45f","modified":1570007056108},{"_id":"public/archives/2019/09/index.html","hash":"bdbdd4d80691d9fc61685ccb2c4680d7de903ac6","modified":1570007056108},{"_id":"public/tags/hexo/index.html","hash":"61332fb23a09ad6ae312ecc475896f9d73af8f3c","modified":1570007056111},{"_id":"public/tags/mysql/index.html","hash":"413882020d1983fe5b5de53e84abfb162abc306b","modified":1570007056111},{"_id":"public/tags/php/index.html","hash":"ee30950af8a6aa3ace7c66c14cea3c95ccfb142a","modified":1570007056111},{"_id":"public/tags/数据库/index.html","hash":"95dc6ff68360253143c3035cf2e7c16957538e0f","modified":1570007056112},{"_id":"public/tags/eclipse/index.html","hash":"ae91e2be17775747a8e9a2b1005e153e6e6ccf62","modified":1570007056112},{"_id":"public/2016/01/11/git/Git远程操作详解/index.html","hash":"e9411496ea12388ca7b0d6b3839562a6828a1620","modified":1570007056112},{"_id":"public/2015/04/29/android/base/Android应用的基本组件/index.html","hash":"5033afbe83eea4cb5e74f01fedae92882a141d2c","modified":1570007056112},{"_id":"public/2015/04/29/android/base/android发展史及系统架构/index.html","hash":"18a230b2b7e9bfff8397f3f001b9ef9a5ddf1b09","modified":1570007056112},{"_id":"public/2015/04/16/mysql/Win8(X64)下MySQL5.6版本安装及配置/index.html","hash":"338a44e08073e892fd827093e5fc98e46b9e83a6","modified":1570007056112},{"_id":"public/index.html","hash":"cb5ff74b44f0798b2320355231154ce48a6d9e0b","modified":1570007056113},{"_id":"public/2015/12/20/c/C语言数组和字符串/index.html","hash":"ece109c2081e71a08259e2cd799eb5021f4fde8b","modified":1570007056123},{"_id":"public/categories/C语言/index.html","hash":"81d0bf7ce4e1fab5add774a1e675a4962f68bc5f","modified":1570007056123},{"_id":"public/page/2/index.html","hash":"45ee684e61c3ed08a2641ee6b8f3bb1c68e65b5d","modified":1570007056124},{"_id":"public/archives/page/2/index.html","hash":"103e95fc26ae35a9c7a982d4da557d08fd1cb64a","modified":1570007056124},{"_id":"public/archives/2015/page/2/index.html","hash":"b567e926b8bf6aa529f5d727b8952155ade0bc2a","modified":1570007056125},{"_id":"public/archives/2015/12/index.html","hash":"6fe4579f67a765ed2e5899bbb580639d499c1b77","modified":1570007056125},{"_id":"public/tags/c/index.html","hash":"06c75ebca3a571abf31e52198149c9f9c7799afb","modified":1570007056125},{"_id":"public/tags/git/index.html","hash":"6d7e2080ebd689e94b06ae6fe5cd3bce56eef0cc","modified":1570007056125},{"_id":"public/tags/Android/index.html","hash":"12bbbea2f0022c4fcb1e140030d3e4d85877c5fc","modified":1570007056126},{"_id":"public/2017/01/12/mysql/数据表命令/index.html","hash":"bdc71a6b8deb8216f7ca4568682049b525bbe02b","modified":1570007056126},{"_id":"public/2015/12/20/c/C语言的预处理指令和关键字/index.html","hash":"7c204e881b529839bd3d3b9f5a4c4a3ab42a1763","modified":1570007056126},{"_id":"public/2015/12/19/c/C语言include和变量/index.html","hash":"c6aaf4f0cc9bce9dfd8c01d407c2ebae08081006","modified":1570007056126},{"_id":"public/2015/12/19/c/C语言指针、结构体、枚举/index.html","hash":"a97ca2f2f8617d9be0cc527214c95a5efb1d1d1e","modified":1570007056126},{"_id":"public/2015/12/19/c/C语言表达式和结构控制/index.html","hash":"c2976109ba26a65a8261d6795c68df5a53e9e627","modified":1570007056128},{"_id":"public/2015/12/19/c/C语言初识/index.html","hash":"39aa45abaed3f8076b919ac3e870a4ed038fefbe","modified":1570007056129},{"_id":"public/favicon.ico","hash":"92d61ec769765f2fb7bc1882c2c3b18931ac40f2","modified":1570007056136},{"_id":"public/apple-touch-icon.png","hash":"fbd2744aedd23c6addea809a9e5e7cbb3306e7b9","modified":1570007056136},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1570007056136},{"_id":"public/img/alipay.svg","hash":"292ea040e865c1d0be259703ff850570b3bdfc97","modified":1570007056137},{"_id":"public/img/bitcoin.svg","hash":"eeb2ee8cf44ba5c298baeed84bb90866f4814955","modified":1570007056137},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1570007056137},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1570007056138},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1570007056138},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1570007056138},{"_id":"public/img/paypal.svg","hash":"e916dea1c1bba1bc935510310f65b2c9328a401a","modified":1570007056138},{"_id":"public/img/wechat.svg","hash":"30418295bed44bcc4b29076eb7deed49cf4d6c1c","modified":1570007056139},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1570007056216},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1570007056216},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1570007056216},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1570007056216},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1570007056216},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1570007056216},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1570007056216},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1570007056217},{"_id":"public/donate/index.html","hash":"7374db74b42ed03f138d25f10f8d47e5aab4efec","modified":1570007056217},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1570007056516},{"_id":"public/css/style.css","hash":"9cffbc12bd2b40733e64d8de9c9e9403cd8fd581","modified":1570007056662},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1570007056685}],"Category":[{"name":"C语言","_id":"ck191nw6t0003b0wkoiqtbnh9"},{"name":"hexo","_id":"ck191nw7x000lb0wkrysujmtj"},{"name":"IDE","_id":"ck191nw88000tb0wk2frb4727"},{"name":"MySql","_id":"ck191nwff001cb0wkx1g12drc"},{"name":"Android基础","_id":"ck191nwg5001vb0wktroumb1z"}],"Data":[],"Page":[{"title":"一个理想主义者","date":"2019-09-30T07:22:57.000Z","_content":"\n随便写写，后面再补充吧","source":"about/index.md","raw":"title: 一个理想主义者\ndate: 2019-09-30 15:22:57\n---\n\n随便写写，后面再补充吧","updated":"2019-09-30T08:30:45.280Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck191nudf0000b0wk8nxmfbup","content":"<p>随便写写，后面再补充吧</p>\n","site":{"data":{}},"excerpt":"","more":"<p>随便写写，后面再补充吧</p>\n"}],"Post":[{"title":"C语言初识","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-19T07:24:00.000Z","_content":"## 计算机发展史\n* 机器语言\n* 所有的代码里面只有0和1\n* 优点：直接对硬件产生作用，程序的执行效率非常高\n* 缺点：指令又多又难记、可读性差、无可移植性\n\n* 汇编语言\n* 符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令\n* 优点：直接对硬件产生作用，程序的执行效率非常高、可读性好\n* 缺点：符号非常多和难记、无可移植性\n\n* 高级语言\n* 非常接近自然语言的高级语言，语法和结构类似于普通英文\n* 优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性\n* 缺点：有些高级语言写出的程序执行效率并不高\n\n# C语言\n## 什么是C语言\n- C语言就是一门计算机编程语言，属于高级语言，可以用来编写程序、开发软件。\n- ios程序的额主要开发语言就是C语言和Object-c，而Object-c是在C语言的基础上衍生出来的。\n- C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，比如C++，C#，Object-c等\n\n## C语言简史\n- 1972年发明，首次使用是用于重写UINX操作系统\n- 它是一门面向过程的语言\n\n## C语言的特点\n- 丰富的运算符\n- 丰富的数据类型\n- 可以直接操作硬件\n- 高效的目标代码\n- 可移植性好\n\n## C语言的用途\n- 编写系统软件、图像处理、单片机程序、嵌入式系统开发等\n- 便携游戏外挂\n- 编写Android程序\n- 编写iOS程序\n\n## C语言的版本问题\n- 1983年美国国家标准（ANSI)成立一个委员，开始定制C语言标准的工作\n- 1989年C语言标准被批准，这个版本的C语言标准成为ANSI C\n- 1999年，国际标准化组织ISO对C语言标准进行修订，命名为C99\n- 2011年12与8日，ISO发布新的标准草案：C11\n\n## C语言的开发过程\n`编写程序`→`编译`→`链接`→`运行`\n\n## C语言程序\n- 构成\n>任何一个C语言的程序都是有一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以说，C语言程序是由函数构成的。\n- 程序入口\n```\n#incluce <stdio.h>\nint main()\n{\nprintf(\"程序入口\");\nreturn 0;\n}\n```\n- c程序源文件的拓展名为.c\n- 常见错误\n- 语法错误：编译器会直接报错\n- 逻辑错误：没有语法错误，只是运行结果不正确\n\n## 关键字\n>被C语言赋予了特殊含义的单词，这些单词是系统自己用的，叫做系统保留字，这些保留字称为关键字\n```c\n // 32个关键字\n auto double int struct break else long switch\n case enum register typedef char extern return\n union const float short unsigned continue for\n signed void default goto sizeof volatile do if\n while static \n```\n\n## 标示符\n标示符就是程序员在程序中起的一些名字，变量名、函数名等\n\n- 命名规范\n    1. 只能有26个英文字母的大小写、10个阿拉伯数字0~9、下划线_组成\n    2. 不能以数字开头\n    3. 不可以和关键字重名\n    4. 严格区分大小写 \n\n- 行业约束\n    1. 尽量取有意义的名称\n    2. 如果标示符包含多个单词，可以用驼峰标识（除第一个单词外，后面每个单词首字母大写 或者 用下划线连接）\n\n## 注释\n在所有计算机语言中都非常重要，用来解释一段程序或者一行代码是什么意思，可以是任何语言，不参与编译\n- 单行注释 `//`\n- 多行注释 `/*  要注释的内容 */` \n","source":"_posts/c/C语言初识.md","raw":"---\ntitle: C语言初识\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-19 15:24:00   \n---\n## 计算机发展史\n* 机器语言\n* 所有的代码里面只有0和1\n* 优点：直接对硬件产生作用，程序的执行效率非常高\n* 缺点：指令又多又难记、可读性差、无可移植性\n\n* 汇编语言\n* 符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令\n* 优点：直接对硬件产生作用，程序的执行效率非常高、可读性好\n* 缺点：符号非常多和难记、无可移植性\n\n* 高级语言\n* 非常接近自然语言的高级语言，语法和结构类似于普通英文\n* 优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性\n* 缺点：有些高级语言写出的程序执行效率并不高\n\n# C语言\n## 什么是C语言\n- C语言就是一门计算机编程语言，属于高级语言，可以用来编写程序、开发软件。\n- ios程序的额主要开发语言就是C语言和Object-c，而Object-c是在C语言的基础上衍生出来的。\n- C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，比如C++，C#，Object-c等\n\n## C语言简史\n- 1972年发明，首次使用是用于重写UINX操作系统\n- 它是一门面向过程的语言\n\n## C语言的特点\n- 丰富的运算符\n- 丰富的数据类型\n- 可以直接操作硬件\n- 高效的目标代码\n- 可移植性好\n\n## C语言的用途\n- 编写系统软件、图像处理、单片机程序、嵌入式系统开发等\n- 便携游戏外挂\n- 编写Android程序\n- 编写iOS程序\n\n## C语言的版本问题\n- 1983年美国国家标准（ANSI)成立一个委员，开始定制C语言标准的工作\n- 1989年C语言标准被批准，这个版本的C语言标准成为ANSI C\n- 1999年，国际标准化组织ISO对C语言标准进行修订，命名为C99\n- 2011年12与8日，ISO发布新的标准草案：C11\n\n## C语言的开发过程\n`编写程序`→`编译`→`链接`→`运行`\n\n## C语言程序\n- 构成\n>任何一个C语言的程序都是有一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以说，C语言程序是由函数构成的。\n- 程序入口\n```\n#incluce <stdio.h>\nint main()\n{\nprintf(\"程序入口\");\nreturn 0;\n}\n```\n- c程序源文件的拓展名为.c\n- 常见错误\n- 语法错误：编译器会直接报错\n- 逻辑错误：没有语法错误，只是运行结果不正确\n\n## 关键字\n>被C语言赋予了特殊含义的单词，这些单词是系统自己用的，叫做系统保留字，这些保留字称为关键字\n```c\n // 32个关键字\n auto double int struct break else long switch\n case enum register typedef char extern return\n union const float short unsigned continue for\n signed void default goto sizeof volatile do if\n while static \n```\n\n## 标示符\n标示符就是程序员在程序中起的一些名字，变量名、函数名等\n\n- 命名规范\n    1. 只能有26个英文字母的大小写、10个阿拉伯数字0~9、下划线_组成\n    2. 不能以数字开头\n    3. 不可以和关键字重名\n    4. 严格区分大小写 \n\n- 行业约束\n    1. 尽量取有意义的名称\n    2. 如果标示符包含多个单词，可以用驼峰标识（除第一个单词外，后面每个单词首字母大写 或者 用下划线连接）\n\n## 注释\n在所有计算机语言中都非常重要，用来解释一段程序或者一行代码是什么意思，可以是任何语言，不参与编译\n- 单行注释 `//`\n- 多行注释 `/*  要注释的内容 */` \n","slug":"c/C语言初识","published":1,"updated":"2019-10-02T08:51:16.236Z","layout":"post","photos":[],"link":"","_id":"ck191nw6b0001b0wk49t69ztu","content":"<h2 id=\"计算机发展史\"><a href=\"#计算机发展史\" class=\"headerlink\" title=\"计算机发展史\"></a>计算机发展史</h2><ul>\n<li><p>机器语言</p>\n</li>\n<li><p>所有的代码里面只有0和1</p>\n</li>\n<li><p>优点：直接对硬件产生作用，程序的执行效率非常高</p>\n</li>\n<li><p>缺点：指令又多又难记、可读性差、无可移植性</p>\n</li>\n<li><p>汇编语言</p>\n</li>\n<li><p>符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令</p>\n</li>\n<li><p>优点：直接对硬件产生作用，程序的执行效率非常高、可读性好</p>\n</li>\n<li><p>缺点：符号非常多和难记、无可移植性</p>\n</li>\n<li><p>高级语言</p>\n</li>\n<li><p>非常接近自然语言的高级语言，语法和结构类似于普通英文</p>\n</li>\n<li><p>优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性</p>\n</li>\n<li><p>缺点：有些高级语言写出的程序执行效率并不高</p>\n</li>\n</ul>\n<h1 id=\"C语言\"><a href=\"#C语言\" class=\"headerlink\" title=\"C语言\"></a>C语言</h1><h2 id=\"什么是C语言\"><a href=\"#什么是C语言\" class=\"headerlink\" title=\"什么是C语言\"></a>什么是C语言</h2><ul>\n<li>C语言就是一门计算机编程语言，属于高级语言，可以用来编写程序、开发软件。</li>\n<li>ios程序的额主要开发语言就是C语言和Object-c，而Object-c是在C语言的基础上衍生出来的。</li>\n<li>C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，比如C++，C#，Object-c等</li>\n</ul>\n<h2 id=\"C语言简史\"><a href=\"#C语言简史\" class=\"headerlink\" title=\"C语言简史\"></a>C语言简史</h2><ul>\n<li>1972年发明，首次使用是用于重写UINX操作系统</li>\n<li>它是一门面向过程的语言</li>\n</ul>\n<h2 id=\"C语言的特点\"><a href=\"#C语言的特点\" class=\"headerlink\" title=\"C语言的特点\"></a>C语言的特点</h2><ul>\n<li>丰富的运算符</li>\n<li>丰富的数据类型</li>\n<li>可以直接操作硬件</li>\n<li>高效的目标代码</li>\n<li>可移植性好</li>\n</ul>\n<h2 id=\"C语言的用途\"><a href=\"#C语言的用途\" class=\"headerlink\" title=\"C语言的用途\"></a>C语言的用途</h2><ul>\n<li>编写系统软件、图像处理、单片机程序、嵌入式系统开发等</li>\n<li>便携游戏外挂</li>\n<li>编写Android程序</li>\n<li>编写iOS程序</li>\n</ul>\n<h2 id=\"C语言的版本问题\"><a href=\"#C语言的版本问题\" class=\"headerlink\" title=\"C语言的版本问题\"></a>C语言的版本问题</h2><ul>\n<li>1983年美国国家标准（ANSI)成立一个委员，开始定制C语言标准的工作</li>\n<li>1989年C语言标准被批准，这个版本的C语言标准成为ANSI C</li>\n<li>1999年，国际标准化组织ISO对C语言标准进行修订，命名为C99</li>\n<li>2011年12与8日，ISO发布新的标准草案：C11</li>\n</ul>\n<h2 id=\"C语言的开发过程\"><a href=\"#C语言的开发过程\" class=\"headerlink\" title=\"C语言的开发过程\"></a>C语言的开发过程</h2><p><code>编写程序</code>→<code>编译</code>→<code>链接</code>→<code>运行</code></p>\n<h2 id=\"C语言程序\"><a href=\"#C语言程序\" class=\"headerlink\" title=\"C语言程序\"></a>C语言程序</h2><ul>\n<li><p>构成</p>\n<blockquote>\n<p>任何一个C语言的程序都是有一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以说，C语言程序是由函数构成的。</p>\n</blockquote>\n</li>\n<li><p>程序入口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#incluce &lt;stdio.h&gt;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">printf(&quot;程序入口&quot;);</span><br><span class=\"line\">return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>c程序源文件的拓展名为.c</p>\n</li>\n<li><p>常见错误</p>\n</li>\n<li><p>语法错误：编译器会直接报错</p>\n</li>\n<li><p>逻辑错误：没有语法错误，只是运行结果不正确</p>\n</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><blockquote>\n<p>被C语言赋予了特殊含义的单词，这些单词是系统自己用的，叫做系统保留字，这些保留字称为关键字</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 32个关键字</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">double</span> <span class=\"keyword\">int</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">break</span> <span class=\"title\">else</span> <span class=\"title\">long</span> <span class=\"title\">switch</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">case</span> <span class=\"title\">enum</span> <span class=\"title\">register</span> <span class=\"title\">typedef</span> <span class=\"title\">char</span> <span class=\"title\">extern</span> <span class=\"title\">return</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">union</span> <span class=\"title\">const</span> <span class=\"title\">float</span> <span class=\"title\">short</span> <span class=\"title\">unsigned</span> <span class=\"title\">continue</span> <span class=\"title\">for</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">signed</span> <span class=\"title\">void</span> <span class=\"title\">default</span> <span class=\"title\">goto</span> <span class=\"title\">sizeof</span> <span class=\"title\">volatile</span> <span class=\"title\">do</span> <span class=\"title\">if</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">while</span> <span class=\"title\">static</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标示符\"><a href=\"#标示符\" class=\"headerlink\" title=\"标示符\"></a>标示符</h2><p>标示符就是程序员在程序中起的一些名字，变量名、函数名等</p>\n<ul>\n<li><p>命名规范</p>\n<ol>\n<li>只能有26个英文字母的大小写、10个阿拉伯数字0~9、下划线_组成</li>\n<li>不能以数字开头</li>\n<li>不可以和关键字重名</li>\n<li>严格区分大小写 </li>\n</ol>\n</li>\n<li><p>行业约束</p>\n<ol>\n<li>尽量取有意义的名称</li>\n<li>如果标示符包含多个单词，可以用驼峰标识（除第一个单词外，后面每个单词首字母大写 或者 用下划线连接）</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>在所有计算机语言中都非常重要，用来解释一段程序或者一行代码是什么意思，可以是任何语言，不参与编译</p>\n<ul>\n<li>单行注释 <code>//</code></li>\n<li>多行注释 <code>/*  要注释的内容 */</code> </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"计算机发展史\"><a href=\"#计算机发展史\" class=\"headerlink\" title=\"计算机发展史\"></a>计算机发展史</h2><ul>\n<li><p>机器语言</p>\n</li>\n<li><p>所有的代码里面只有0和1</p>\n</li>\n<li><p>优点：直接对硬件产生作用，程序的执行效率非常高</p>\n</li>\n<li><p>缺点：指令又多又难记、可读性差、无可移植性</p>\n</li>\n<li><p>汇编语言</p>\n</li>\n<li><p>符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令</p>\n</li>\n<li><p>优点：直接对硬件产生作用，程序的执行效率非常高、可读性好</p>\n</li>\n<li><p>缺点：符号非常多和难记、无可移植性</p>\n</li>\n<li><p>高级语言</p>\n</li>\n<li><p>非常接近自然语言的高级语言，语法和结构类似于普通英文</p>\n</li>\n<li><p>优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性</p>\n</li>\n<li><p>缺点：有些高级语言写出的程序执行效率并不高</p>\n</li>\n</ul>\n<h1 id=\"C语言\"><a href=\"#C语言\" class=\"headerlink\" title=\"C语言\"></a>C语言</h1><h2 id=\"什么是C语言\"><a href=\"#什么是C语言\" class=\"headerlink\" title=\"什么是C语言\"></a>什么是C语言</h2><ul>\n<li>C语言就是一门计算机编程语言，属于高级语言，可以用来编写程序、开发软件。</li>\n<li>ios程序的额主要开发语言就是C语言和Object-c，而Object-c是在C语言的基础上衍生出来的。</li>\n<li>C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，比如C++，C#，Object-c等</li>\n</ul>\n<h2 id=\"C语言简史\"><a href=\"#C语言简史\" class=\"headerlink\" title=\"C语言简史\"></a>C语言简史</h2><ul>\n<li>1972年发明，首次使用是用于重写UINX操作系统</li>\n<li>它是一门面向过程的语言</li>\n</ul>\n<h2 id=\"C语言的特点\"><a href=\"#C语言的特点\" class=\"headerlink\" title=\"C语言的特点\"></a>C语言的特点</h2><ul>\n<li>丰富的运算符</li>\n<li>丰富的数据类型</li>\n<li>可以直接操作硬件</li>\n<li>高效的目标代码</li>\n<li>可移植性好</li>\n</ul>\n<h2 id=\"C语言的用途\"><a href=\"#C语言的用途\" class=\"headerlink\" title=\"C语言的用途\"></a>C语言的用途</h2><ul>\n<li>编写系统软件、图像处理、单片机程序、嵌入式系统开发等</li>\n<li>便携游戏外挂</li>\n<li>编写Android程序</li>\n<li>编写iOS程序</li>\n</ul>\n<h2 id=\"C语言的版本问题\"><a href=\"#C语言的版本问题\" class=\"headerlink\" title=\"C语言的版本问题\"></a>C语言的版本问题</h2><ul>\n<li>1983年美国国家标准（ANSI)成立一个委员，开始定制C语言标准的工作</li>\n<li>1989年C语言标准被批准，这个版本的C语言标准成为ANSI C</li>\n<li>1999年，国际标准化组织ISO对C语言标准进行修订，命名为C99</li>\n<li>2011年12与8日，ISO发布新的标准草案：C11</li>\n</ul>\n<h2 id=\"C语言的开发过程\"><a href=\"#C语言的开发过程\" class=\"headerlink\" title=\"C语言的开发过程\"></a>C语言的开发过程</h2><p><code>编写程序</code>→<code>编译</code>→<code>链接</code>→<code>运行</code></p>\n<h2 id=\"C语言程序\"><a href=\"#C语言程序\" class=\"headerlink\" title=\"C语言程序\"></a>C语言程序</h2><ul>\n<li><p>构成</p>\n<blockquote>\n<p>任何一个C语言的程序都是有一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以说，C语言程序是由函数构成的。</p>\n</blockquote>\n</li>\n<li><p>程序入口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#incluce &lt;stdio.h&gt;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">printf(&quot;程序入口&quot;);</span><br><span class=\"line\">return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>c程序源文件的拓展名为.c</p>\n</li>\n<li><p>常见错误</p>\n</li>\n<li><p>语法错误：编译器会直接报错</p>\n</li>\n<li><p>逻辑错误：没有语法错误，只是运行结果不正确</p>\n</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><blockquote>\n<p>被C语言赋予了特殊含义的单词，这些单词是系统自己用的，叫做系统保留字，这些保留字称为关键字</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 32个关键字</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">double</span> <span class=\"keyword\">int</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">break</span> <span class=\"title\">else</span> <span class=\"title\">long</span> <span class=\"title\">switch</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">case</span> <span class=\"title\">enum</span> <span class=\"title\">register</span> <span class=\"title\">typedef</span> <span class=\"title\">char</span> <span class=\"title\">extern</span> <span class=\"title\">return</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">union</span> <span class=\"title\">const</span> <span class=\"title\">float</span> <span class=\"title\">short</span> <span class=\"title\">unsigned</span> <span class=\"title\">continue</span> <span class=\"title\">for</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">signed</span> <span class=\"title\">void</span> <span class=\"title\">default</span> <span class=\"title\">goto</span> <span class=\"title\">sizeof</span> <span class=\"title\">volatile</span> <span class=\"title\">do</span> <span class=\"title\">if</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">while</span> <span class=\"title\">static</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标示符\"><a href=\"#标示符\" class=\"headerlink\" title=\"标示符\"></a>标示符</h2><p>标示符就是程序员在程序中起的一些名字，变量名、函数名等</p>\n<ul>\n<li><p>命名规范</p>\n<ol>\n<li>只能有26个英文字母的大小写、10个阿拉伯数字0~9、下划线_组成</li>\n<li>不能以数字开头</li>\n<li>不可以和关键字重名</li>\n<li>严格区分大小写 </li>\n</ol>\n</li>\n<li><p>行业约束</p>\n<ol>\n<li>尽量取有意义的名称</li>\n<li>如果标示符包含多个单词，可以用驼峰标识（除第一个单词外，后面每个单词首字母大写 或者 用下划线连接）</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>在所有计算机语言中都非常重要，用来解释一段程序或者一行代码是什么意思，可以是任何语言，不参与编译</p>\n<ul>\n<li>单行注释 <code>//</code></li>\n<li>多行注释 <code>/*  要注释的内容 */</code> </li>\n</ul>\n"},{"title":"C语言数组和字符串","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-20T07:24:00.000Z","_content":"## C程序内存分配\n1. `栈区(stack)` - 由编译器自动分配释放，存放函数的参数名，局部变量名等。\n2. `堆区(heap)` - 有程序员分配和释放，它与数据结构中的`堆`是两回事。\n3. `全局区(静态区)(static)` - 全局变量和静态变量存储位置\n4. `文字常量区` - 常量字符串存放位置\n5. `程序代码区` - 存放函数体的二进制代码\n\n## 数组\n### 说明\n    存储一组数据的容器\n### 特点\n- 只能存储一种类型的数据\n- 有顺序之分，索引从0开始。\n\n### 定义\n元素类型  数组名[元素个数]\nint nums[3];\n### 初始化\n一般会在数组定义的同时进行初始化\nint nums[3] = {2,5,3};\n### 访问\n通用下标（索引)访问：nums[1];\n\n## 二维数组\n### 定义\n### 初始化\n* 按行进行初始化\nint a[2][3] = { {2, 2, 3}, {3, 4, 5} }; \n* 按存储顺序进行初始化(先存放第1行，再存放第2行)\nint a[2][3] = {2, 2, 3, 3, 4, 5}; \n* 对部分元素进行初始化\nint a[2][3] = { {2}, {3, 4} };  \n* 如果只初始化了部分元素，可以省略行数，但是不可以省略列数\nint a[][3] = {1, 2, 3, 4, 5, 6};\n\n## 字符串\n- char a[] = “123”;  和 char a [] = {‘1’,’2’,’3’};的区别，可以比较大小\n- “123”其实是由’1’、’2’、’3’、’\\0’组成\n- 字符串的输出”%s”，’\\0’是不会输出的\n\n## 字符串数组\n1. char names[2][10] = { {'J','a','y','\\0'}, {'J','i','m','\\0'} };  \n2. char names2[2][10] = { {\"Jay\"}, {\"Jim\"} };  \n3. char names3[2][10] = { \"Jay\", \"Jim\" };\n\n## 常用字符串函数\n- strlen(字符数组名或字符指针变量);字符串测长函数\n- strcat(字符串1的地址，字符串2的地址)；将字符串2的内容连接到字符串1的尾部。\n- strcmp(字符串1的地址，字符串2的地址)；比较串1和串2哪个比较大。比较大小的依据是，两个字符串从左往右相应位置上第一个不相等的字符ASCII码值之差\n- strcpy(字符串1的地址，字符串2的地址)；将字符串2的内容复制到字符串1内。","source":"_posts/c/C语言数组和字符串.md","raw":"---\ntitle: C语言数组和字符串\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-20 15:24:00   \n---\n## C程序内存分配\n1. `栈区(stack)` - 由编译器自动分配释放，存放函数的参数名，局部变量名等。\n2. `堆区(heap)` - 有程序员分配和释放，它与数据结构中的`堆`是两回事。\n3. `全局区(静态区)(static)` - 全局变量和静态变量存储位置\n4. `文字常量区` - 常量字符串存放位置\n5. `程序代码区` - 存放函数体的二进制代码\n\n## 数组\n### 说明\n    存储一组数据的容器\n### 特点\n- 只能存储一种类型的数据\n- 有顺序之分，索引从0开始。\n\n### 定义\n元素类型  数组名[元素个数]\nint nums[3];\n### 初始化\n一般会在数组定义的同时进行初始化\nint nums[3] = {2,5,3};\n### 访问\n通用下标（索引)访问：nums[1];\n\n## 二维数组\n### 定义\n### 初始化\n* 按行进行初始化\nint a[2][3] = { {2, 2, 3}, {3, 4, 5} }; \n* 按存储顺序进行初始化(先存放第1行，再存放第2行)\nint a[2][3] = {2, 2, 3, 3, 4, 5}; \n* 对部分元素进行初始化\nint a[2][3] = { {2}, {3, 4} };  \n* 如果只初始化了部分元素，可以省略行数，但是不可以省略列数\nint a[][3] = {1, 2, 3, 4, 5, 6};\n\n## 字符串\n- char a[] = “123”;  和 char a [] = {‘1’,’2’,’3’};的区别，可以比较大小\n- “123”其实是由’1’、’2’、’3’、’\\0’组成\n- 字符串的输出”%s”，’\\0’是不会输出的\n\n## 字符串数组\n1. char names[2][10] = { {'J','a','y','\\0'}, {'J','i','m','\\0'} };  \n2. char names2[2][10] = { {\"Jay\"}, {\"Jim\"} };  \n3. char names3[2][10] = { \"Jay\", \"Jim\" };\n\n## 常用字符串函数\n- strlen(字符数组名或字符指针变量);字符串测长函数\n- strcat(字符串1的地址，字符串2的地址)；将字符串2的内容连接到字符串1的尾部。\n- strcmp(字符串1的地址，字符串2的地址)；比较串1和串2哪个比较大。比较大小的依据是，两个字符串从左往右相应位置上第一个不相等的字符ASCII码值之差\n- strcpy(字符串1的地址，字符串2的地址)；将字符串2的内容复制到字符串1内。","slug":"c/C语言数组和字符串","published":1,"updated":"2019-10-02T08:57:45.541Z","layout":"post","photos":[],"link":"","_id":"ck191nw6o0002b0wkb32180pv","content":"<h2 id=\"C程序内存分配\"><a href=\"#C程序内存分配\" class=\"headerlink\" title=\"C程序内存分配\"></a>C程序内存分配</h2><ol>\n<li><code>栈区(stack)</code> - 由编译器自动分配释放，存放函数的参数名，局部变量名等。</li>\n<li><code>堆区(heap)</code> - 有程序员分配和释放，它与数据结构中的<code>堆</code>是两回事。</li>\n<li><code>全局区(静态区)(static)</code> - 全局变量和静态变量存储位置</li>\n<li><code>文字常量区</code> - 常量字符串存放位置</li>\n<li><code>程序代码区</code> - 存放函数体的二进制代码</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><pre><code>存储一组数据的容器</code></pre><h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>只能存储一种类型的数据</li>\n<li>有顺序之分，索引从0开始。</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>元素类型  数组名[元素个数]<br>int nums[3];</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>一般会在数组定义的同时进行初始化<br>int nums[3] = {2,5,3};</p>\n<h3 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h3><p>通用下标（索引)访问：nums[1];</p>\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>按行进行初始化<br>int a[2][3] = { {2, 2, 3}, {3, 4, 5} }; </li>\n<li>按存储顺序进行初始化(先存放第1行，再存放第2行)<br>int a[2][3] = {2, 2, 3, 3, 4, 5}; </li>\n<li>对部分元素进行初始化<br>int a[2][3] = { {2}, {3, 4} };  </li>\n<li>如果只初始化了部分元素，可以省略行数，但是不可以省略列数<br>int a[][3] = {1, 2, 3, 4, 5, 6};</li>\n</ul>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><ul>\n<li>char a[] = “123”;  和 char a [] = {‘1’,’2’,’3’};的区别，可以比较大小</li>\n<li>“123”其实是由’1’、’2’、’3’、’\\0’组成</li>\n<li>字符串的输出”%s”，’\\0’是不会输出的</li>\n</ul>\n<h2 id=\"字符串数组\"><a href=\"#字符串数组\" class=\"headerlink\" title=\"字符串数组\"></a>字符串数组</h2><ol>\n<li>char names[2][10] = { {‘J’,’a’,’y’,’\\0’}, {‘J’,’i’,’m’,’\\0’} };  </li>\n<li>char names2[2][10] = { {“Jay”}, {“Jim”} };  </li>\n<li>char names3[2][10] = { “Jay”, “Jim” };</li>\n</ol>\n<h2 id=\"常用字符串函数\"><a href=\"#常用字符串函数\" class=\"headerlink\" title=\"常用字符串函数\"></a>常用字符串函数</h2><ul>\n<li>strlen(字符数组名或字符指针变量);字符串测长函数</li>\n<li>strcat(字符串1的地址，字符串2的地址)；将字符串2的内容连接到字符串1的尾部。</li>\n<li>strcmp(字符串1的地址，字符串2的地址)；比较串1和串2哪个比较大。比较大小的依据是，两个字符串从左往右相应位置上第一个不相等的字符ASCII码值之差</li>\n<li>strcpy(字符串1的地址，字符串2的地址)；将字符串2的内容复制到字符串1内。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C程序内存分配\"><a href=\"#C程序内存分配\" class=\"headerlink\" title=\"C程序内存分配\"></a>C程序内存分配</h2><ol>\n<li><code>栈区(stack)</code> - 由编译器自动分配释放，存放函数的参数名，局部变量名等。</li>\n<li><code>堆区(heap)</code> - 有程序员分配和释放，它与数据结构中的<code>堆</code>是两回事。</li>\n<li><code>全局区(静态区)(static)</code> - 全局变量和静态变量存储位置</li>\n<li><code>文字常量区</code> - 常量字符串存放位置</li>\n<li><code>程序代码区</code> - 存放函数体的二进制代码</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><pre><code>存储一组数据的容器</code></pre><h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>只能存储一种类型的数据</li>\n<li>有顺序之分，索引从0开始。</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>元素类型  数组名[元素个数]<br>int nums[3];</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>一般会在数组定义的同时进行初始化<br>int nums[3] = {2,5,3};</p>\n<h3 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h3><p>通用下标（索引)访问：nums[1];</p>\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>按行进行初始化<br>int a[2][3] = { {2, 2, 3}, {3, 4, 5} }; </li>\n<li>按存储顺序进行初始化(先存放第1行，再存放第2行)<br>int a[2][3] = {2, 2, 3, 3, 4, 5}; </li>\n<li>对部分元素进行初始化<br>int a[2][3] = { {2}, {3, 4} };  </li>\n<li>如果只初始化了部分元素，可以省略行数，但是不可以省略列数<br>int a[][3] = {1, 2, 3, 4, 5, 6};</li>\n</ul>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><ul>\n<li>char a[] = “123”;  和 char a [] = {‘1’,’2’,’3’};的区别，可以比较大小</li>\n<li>“123”其实是由’1’、’2’、’3’、’\\0’组成</li>\n<li>字符串的输出”%s”，’\\0’是不会输出的</li>\n</ul>\n<h2 id=\"字符串数组\"><a href=\"#字符串数组\" class=\"headerlink\" title=\"字符串数组\"></a>字符串数组</h2><ol>\n<li>char names[2][10] = { {‘J’,’a’,’y’,’\\0’}, {‘J’,’i’,’m’,’\\0’} };  </li>\n<li>char names2[2][10] = { {“Jay”}, {“Jim”} };  </li>\n<li>char names3[2][10] = { “Jay”, “Jim” };</li>\n</ol>\n<h2 id=\"常用字符串函数\"><a href=\"#常用字符串函数\" class=\"headerlink\" title=\"常用字符串函数\"></a>常用字符串函数</h2><ul>\n<li>strlen(字符数组名或字符指针变量);字符串测长函数</li>\n<li>strcat(字符串1的地址，字符串2的地址)；将字符串2的内容连接到字符串1的尾部。</li>\n<li>strcmp(字符串1的地址，字符串2的地址)；比较串1和串2哪个比较大。比较大小的依据是，两个字符串从左往右相应位置上第一个不相等的字符ASCII码值之差</li>\n<li>strcpy(字符串1的地址，字符串2的地址)；将字符串2的内容复制到字符串1内。</li>\n</ul>\n"},{"title":"C语言include和变量","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-19T15:24:00.000Z","_content":"## 常见函数\n\n- main函数\nmain函数时整个C程序的入口，整个C程序中也有且仅有一个main函数\n- printf函数\n在屏幕上输出内容，使用前必须加 `#incluce <stdio.h>`\n\n## `#include`\n- `#include`指令介绍\n    - `#include` 是C语言的`预处理指令`之一。    \n    在编译之前做的处理，预处理指令一般以`#`开头    \n    - `#include`指令后面会跟着一个文件名，此时，会将该文件内容包含到当前文件中。\n    - 如果本包含的文件拓展名为 `.h` 则称为头文件(Header File)。\n    - `#include`指令不仅限于 `.h` 头文件，可以包含任何白安逸器能识别的C/C++代码文件 \n- `#include <>`和`#include \"\"`区别（主要是检索顺序不同）\n    - `#include <>` 检索顺序：\n    父文件所在文件夹 → 父文件的父文件所在文件夹 → 编译器设置的include路径 → 系统INCLUDE环境变量\n    - `#include \" \"` 检索顺序：\n    编译器设置的include路径 → 系统INCLUDE环境变量\n- `stdio.h`\n    - 是C语言函数库中的一个头文件\n\n## 多源文件开发\n\n1. 在编写第一个C程序的时候已经提到：我们编写的所有C语言代码都保存在拓展名为.c的源文件中，编写完毕后就进行编译、链接，最后运行程序。\n2. 在实际开发过程中，项目做大了，源代码肯定非常多，很容易就上万行 代码了，甚至上十万、百万都有可能。这个时候如果把所有的代码都写到一个.c源文件中，那么这个文件将会非常庞大，也非常恶心，你可以想象一下，一个文件 有十几万行文字，不要说调试程序了，连阅读代码都非常困难。\n3. 公司里面都是以团队开发为主，如果多个开发人员同时修改一个源文件，那就会带来很多麻烦的问题，比如张三修改的代码很有可能会抹掉李四之前添加的代码。\n4. 因此，为了模块化开发，一般会将不同的功能写到不同的.c源文件中，这样的话，每个开发人员都负责修改不同的源文件，达到分工合作的目的，能够大大提高开发效率。也就是说，一个正常的C语言项目是由多个.c源文件构成。\n\n----\n\n## 常用UNIX指令\n| 指令 | 作用|\n| :--- | :----|\n| ls | 列出当前目录下的所有内容（文件\\文件夹）|\n| pwd | 显示出当前目录的名称|\n| cd | 改变当前操作的目录|\n| who | 显示当前用户名|\n| clear | 清除所有内容|\n| mkdir | 创建一个新目录|\n\n## 编译C程序\n- 编译one.c，生成one.o文件\n```cc -c one.c```\n\n- 链接one.o，生成a.out文件\n```cc one.o```\n\n- 运行a.out\n```./a.out```\n\n## 进制\n    进制：一种计数方式\n- 十进制\n由0、1、2….9十个基本数字组成；运算规则是“逢十进一”\n- 二进制\n特点：由0、1两个基本数字组成；运算规则是“逢二进一”\n书写形式：需要以0b或者0B开头，比如0b101\n- 八进制\n特点：由0~7八个基本数字组成；运算规则是“逢八进一”\n书写形式：在前面加个0，比如045\n- 十六进制\n特点：由0~9和A~F组成，A~F分别表示10~15；运算规则是“逢十六进一”\n书写形式：在前面加个0x或者0X，比如0x45\n\n## 位运算符\n运算符 | 作用  | 说明 |举例\n -----|-------|----|---\n&| 按位与|只有对应的两个二进位均为1时，结果位才为1，否则为0|1001 & 0101 = 0001\n&#x7c;| 按位或|只要对应的二个二进位有一个为1时，结果位就为1，否则为0|1001 &#x7c; 0101 = 1101\n^ |按位异或|当对应的二进位相异（不相同）时，结果为1，否则为0|1001 ^ 101 = 1100\n~ |取反|各二进位进行取反（0变1，1变0）|~1001 = 0110\n<< |左移|各二进位全部左移n位，高位丢弃，低位补0|乘以2的n次方\n&#x3e;&#x3e; |右移|各二进位全部右移n位，保持符号位不变|是除以2的n次方    \n```\n//使用位运算实现交换两个数的值\na = a^b;\nb = b^a;\na = a^b;\n```\n## 变量的内存分析\n### 字节和地址\n- 内存以“字节为单位”，不同类型的变量在不同编译器环境下所占的空间也不同\n\n变量类型 | 16位编译器  | 32位编译器  | 64位编译器\n--|--|--|--\nchar |1|1|1\nint |2|4|4\nfloat|4|4|4\ndouble|8|8|8\n- 变量存储单元的第一个字节的地址就是该变量的地址\n- 负数的二进制形式，就是对它的正数的二进制取反后加1\n\n## 类型说明符\n类型|说明|64位编译器\n--|--|--\nshort|短型|2字节（16位）\nlong|长型|8字节（64位）\nsigned|有符号型\nunsigned|无符号型\n>一般就是用来修饰int类型的，所以在使用时省略int。\nshort int等价于short，long int等价于long，long long int等价于long long\n\n- signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。\n- signed：表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是<img src=\"http://www.forkosh.com/mathtex.cgi? -2^{31}\"> ~ <img src=\"http://www.forkosh.com/mathtex.cgi? 2^{31}-1\">\n- unsigned：表示无符号，也就是说最高位并不当做符号位，所 以不包括负数。在64bit编译器环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0~<img src=\"http://www.forkosh.com/mathtex.cgi? 2{32}-1\">\n\n## char类型（字符型）\n- 一个字符型变量占用1个字节，共8位。范围是<img src=\"http://www.forkosh.com/mathtex.cgi? -2^7\">~<img src=\"http://www.forkosh.com/mathtex.cgi? 2^7-1\">。\n- 不能用来存储汉字\n- 前面加\"\\\"形成的字符，称为“转义字符”  \n\n转义字符|意义|ASCII码值\n--|--|--\n\\n|回车|10\n\\t|退格|9\n\\\\|\\|92\n\\'|'|39\n\\\"|\"|34\n\\0|空字符|0\n\n\n\n","source":"_posts/c/C语言include和变量.md","raw":"---\ntitle: C语言include和变量\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-19 23:24:00   \n---\n## 常见函数\n\n- main函数\nmain函数时整个C程序的入口，整个C程序中也有且仅有一个main函数\n- printf函数\n在屏幕上输出内容，使用前必须加 `#incluce <stdio.h>`\n\n## `#include`\n- `#include`指令介绍\n    - `#include` 是C语言的`预处理指令`之一。    \n    在编译之前做的处理，预处理指令一般以`#`开头    \n    - `#include`指令后面会跟着一个文件名，此时，会将该文件内容包含到当前文件中。\n    - 如果本包含的文件拓展名为 `.h` 则称为头文件(Header File)。\n    - `#include`指令不仅限于 `.h` 头文件，可以包含任何白安逸器能识别的C/C++代码文件 \n- `#include <>`和`#include \"\"`区别（主要是检索顺序不同）\n    - `#include <>` 检索顺序：\n    父文件所在文件夹 → 父文件的父文件所在文件夹 → 编译器设置的include路径 → 系统INCLUDE环境变量\n    - `#include \" \"` 检索顺序：\n    编译器设置的include路径 → 系统INCLUDE环境变量\n- `stdio.h`\n    - 是C语言函数库中的一个头文件\n\n## 多源文件开发\n\n1. 在编写第一个C程序的时候已经提到：我们编写的所有C语言代码都保存在拓展名为.c的源文件中，编写完毕后就进行编译、链接，最后运行程序。\n2. 在实际开发过程中，项目做大了，源代码肯定非常多，很容易就上万行 代码了，甚至上十万、百万都有可能。这个时候如果把所有的代码都写到一个.c源文件中，那么这个文件将会非常庞大，也非常恶心，你可以想象一下，一个文件 有十几万行文字，不要说调试程序了，连阅读代码都非常困难。\n3. 公司里面都是以团队开发为主，如果多个开发人员同时修改一个源文件，那就会带来很多麻烦的问题，比如张三修改的代码很有可能会抹掉李四之前添加的代码。\n4. 因此，为了模块化开发，一般会将不同的功能写到不同的.c源文件中，这样的话，每个开发人员都负责修改不同的源文件，达到分工合作的目的，能够大大提高开发效率。也就是说，一个正常的C语言项目是由多个.c源文件构成。\n\n----\n\n## 常用UNIX指令\n| 指令 | 作用|\n| :--- | :----|\n| ls | 列出当前目录下的所有内容（文件\\文件夹）|\n| pwd | 显示出当前目录的名称|\n| cd | 改变当前操作的目录|\n| who | 显示当前用户名|\n| clear | 清除所有内容|\n| mkdir | 创建一个新目录|\n\n## 编译C程序\n- 编译one.c，生成one.o文件\n```cc -c one.c```\n\n- 链接one.o，生成a.out文件\n```cc one.o```\n\n- 运行a.out\n```./a.out```\n\n## 进制\n    进制：一种计数方式\n- 十进制\n由0、1、2….9十个基本数字组成；运算规则是“逢十进一”\n- 二进制\n特点：由0、1两个基本数字组成；运算规则是“逢二进一”\n书写形式：需要以0b或者0B开头，比如0b101\n- 八进制\n特点：由0~7八个基本数字组成；运算规则是“逢八进一”\n书写形式：在前面加个0，比如045\n- 十六进制\n特点：由0~9和A~F组成，A~F分别表示10~15；运算规则是“逢十六进一”\n书写形式：在前面加个0x或者0X，比如0x45\n\n## 位运算符\n运算符 | 作用  | 说明 |举例\n -----|-------|----|---\n&| 按位与|只有对应的两个二进位均为1时，结果位才为1，否则为0|1001 & 0101 = 0001\n&#x7c;| 按位或|只要对应的二个二进位有一个为1时，结果位就为1，否则为0|1001 &#x7c; 0101 = 1101\n^ |按位异或|当对应的二进位相异（不相同）时，结果为1，否则为0|1001 ^ 101 = 1100\n~ |取反|各二进位进行取反（0变1，1变0）|~1001 = 0110\n<< |左移|各二进位全部左移n位，高位丢弃，低位补0|乘以2的n次方\n&#x3e;&#x3e; |右移|各二进位全部右移n位，保持符号位不变|是除以2的n次方    \n```\n//使用位运算实现交换两个数的值\na = a^b;\nb = b^a;\na = a^b;\n```\n## 变量的内存分析\n### 字节和地址\n- 内存以“字节为单位”，不同类型的变量在不同编译器环境下所占的空间也不同\n\n变量类型 | 16位编译器  | 32位编译器  | 64位编译器\n--|--|--|--\nchar |1|1|1\nint |2|4|4\nfloat|4|4|4\ndouble|8|8|8\n- 变量存储单元的第一个字节的地址就是该变量的地址\n- 负数的二进制形式，就是对它的正数的二进制取反后加1\n\n## 类型说明符\n类型|说明|64位编译器\n--|--|--\nshort|短型|2字节（16位）\nlong|长型|8字节（64位）\nsigned|有符号型\nunsigned|无符号型\n>一般就是用来修饰int类型的，所以在使用时省略int。\nshort int等价于short，long int等价于long，long long int等价于long long\n\n- signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。\n- signed：表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是<img src=\"http://www.forkosh.com/mathtex.cgi? -2^{31}\"> ~ <img src=\"http://www.forkosh.com/mathtex.cgi? 2^{31}-1\">\n- unsigned：表示无符号，也就是说最高位并不当做符号位，所 以不包括负数。在64bit编译器环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0~<img src=\"http://www.forkosh.com/mathtex.cgi? 2{32}-1\">\n\n## char类型（字符型）\n- 一个字符型变量占用1个字节，共8位。范围是<img src=\"http://www.forkosh.com/mathtex.cgi? -2^7\">~<img src=\"http://www.forkosh.com/mathtex.cgi? 2^7-1\">。\n- 不能用来存储汉字\n- 前面加\"\\\"形成的字符，称为“转义字符”  \n\n转义字符|意义|ASCII码值\n--|--|--\n\\n|回车|10\n\\t|退格|9\n\\\\|\\|92\n\\'|'|39\n\\\"|\"|34\n\\0|空字符|0\n\n\n\n","slug":"c/C语言include和变量","published":1,"updated":"2019-10-02T08:55:57.706Z","layout":"post","photos":[],"link":"","_id":"ck191nw6z0005b0wk8oglxoul","content":"<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><ul>\n<li>main函数<br>main函数时整个C程序的入口，整个C程序中也有且仅有一个main函数</li>\n<li>printf函数<br>在屏幕上输出内容，使用前必须加 <code>#incluce &lt;stdio.h&gt;</code></li>\n</ul>\n<h2 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"#include\"></a><code>#include</code></h2><ul>\n<li><code>#include</code>指令介绍<ul>\n<li><code>#include</code> 是C语言的<code>预处理指令</code>之一。<br>在编译之前做的处理，预处理指令一般以<code>#</code>开头    </li>\n<li><code>#include</code>指令后面会跟着一个文件名，此时，会将该文件内容包含到当前文件中。</li>\n<li>如果本包含的文件拓展名为 <code>.h</code> 则称为头文件(Header File)。</li>\n<li><code>#include</code>指令不仅限于 <code>.h</code> 头文件，可以包含任何白安逸器能识别的C/C++代码文件 </li>\n</ul>\n</li>\n<li><code>#include &lt;&gt;</code>和<code>#include &quot;&quot;</code>区别（主要是检索顺序不同）<ul>\n<li><code>#include &lt;&gt;</code> 检索顺序：<br>父文件所在文件夹 → 父文件的父文件所在文件夹 → 编译器设置的include路径 → 系统INCLUDE环境变量</li>\n<li><code>#include &quot; &quot;</code> 检索顺序：<br>编译器设置的include路径 → 系统INCLUDE环境变量</li>\n</ul>\n</li>\n<li><code>stdio.h</code><ul>\n<li>是C语言函数库中的一个头文件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多源文件开发\"><a href=\"#多源文件开发\" class=\"headerlink\" title=\"多源文件开发\"></a>多源文件开发</h2><ol>\n<li>在编写第一个C程序的时候已经提到：我们编写的所有C语言代码都保存在拓展名为.c的源文件中，编写完毕后就进行编译、链接，最后运行程序。</li>\n<li>在实际开发过程中，项目做大了，源代码肯定非常多，很容易就上万行 代码了，甚至上十万、百万都有可能。这个时候如果把所有的代码都写到一个.c源文件中，那么这个文件将会非常庞大，也非常恶心，你可以想象一下，一个文件 有十几万行文字，不要说调试程序了，连阅读代码都非常困难。</li>\n<li>公司里面都是以团队开发为主，如果多个开发人员同时修改一个源文件，那就会带来很多麻烦的问题，比如张三修改的代码很有可能会抹掉李四之前添加的代码。</li>\n<li>因此，为了模块化开发，一般会将不同的功能写到不同的.c源文件中，这样的话，每个开发人员都负责修改不同的源文件，达到分工合作的目的，能够大大提高开发效率。也就是说，一个正常的C语言项目是由多个.c源文件构成。</li>\n</ol>\n<hr>\n<h2 id=\"常用UNIX指令\"><a href=\"#常用UNIX指令\" class=\"headerlink\" title=\"常用UNIX指令\"></a>常用UNIX指令</h2><table>\n<thead>\n<tr>\n<th align=\"left\">指令</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ls</td>\n<td align=\"left\">列出当前目录下的所有内容（文件\\文件夹）</td>\n</tr>\n<tr>\n<td align=\"left\">pwd</td>\n<td align=\"left\">显示出当前目录的名称</td>\n</tr>\n<tr>\n<td align=\"left\">cd</td>\n<td align=\"left\">改变当前操作的目录</td>\n</tr>\n<tr>\n<td align=\"left\">who</td>\n<td align=\"left\">显示当前用户名</td>\n</tr>\n<tr>\n<td align=\"left\">clear</td>\n<td align=\"left\">清除所有内容</td>\n</tr>\n<tr>\n<td align=\"left\">mkdir</td>\n<td align=\"left\">创建一个新目录</td>\n</tr>\n</tbody></table>\n<h2 id=\"编译C程序\"><a href=\"#编译C程序\" class=\"headerlink\" title=\"编译C程序\"></a>编译C程序</h2><ul>\n<li><p>编译one.c，生成one.o文件</p>\n<figure class=\"highlight cc\"><figcaption><span>-c one.c```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 链接one.o，生成a.out文件</span><br><span class=\"line\">```cc one.o</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行a.out</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 进制</span><br><span class=\"line\">    进制：一种计数方式</span><br><span class=\"line\">- 十进制</span><br><span class=\"line\">由0、1、2….9十个基本数字组成；运算规则是“逢十进一”</span><br><span class=\"line\">- 二进制</span><br><span class=\"line\">特点：由0、1两个基本数字组成；运算规则是“逢二进一”</span><br><span class=\"line\">书写形式：需要以0b或者0B开头，比如0b101</span><br><span class=\"line\">- 八进制</span><br><span class=\"line\">特点：由0~7八个基本数字组成；运算规则是“逢八进一”</span><br><span class=\"line\">书写形式：在前面加个0，比如045</span><br><span class=\"line\">- 十六进制</span><br><span class=\"line\">特点：由0~9和A~F组成，A~F分别表示10~15；运算规则是“逢十六进一”</span><br><span class=\"line\">书写形式：在前面加个0x或者0X，比如0x45</span><br><span class=\"line\"></span><br><span class=\"line\">## 位运算符</span><br><span class=\"line\">运算符 | 作用  | 说明 |举例</span><br><span class=\"line\"> -----|-------|----|---</span><br><span class=\"line\">&amp;| 按位与|只有对应的两个二进位均为1时，结果位才为1，否则为0|1001 &amp; 0101 = 0001</span><br><span class=\"line\">&amp;#x7c;| 按位或|只要对应的二个二进位有一个为1时，结果位就为1，否则为0|1001 &amp;#x7c; 0101 = 1101</span><br><span class=\"line\">^ |按位异或|当对应的二进位相异（不相同）时，结果为1，否则为0|1001 ^ 101 = 1100</span><br><span class=\"line\">~ |取反|各二进位进行取反（0变1，1变0）|~1001 = 0110</span><br><span class=\"line\">&lt;&lt; |左移|各二进位全部左移n位，高位丢弃，低位补0|乘以2的n次方</span><br><span class=\"line\">&amp;#x3e;&amp;#x3e; |右移|各二进位全部右移n位，保持符号位不变|是除以2的n次方</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>//使用位运算实现交换两个数的值<br>a = a^b;<br>b = b^a;<br>a = a^b;</p>\n<pre><code>## 变量的内存分析\n### 字节和地址\n- 内存以“字节为单位”，不同类型的变量在不同编译器环境下所占的空间也不同\n\n变量类型 | 16位编译器  | 32位编译器  | 64位编译器\n--|--|--|--\nchar |1|1|1\nint |2|4|4\nfloat|4|4|4\ndouble|8|8|8\n- 变量存储单元的第一个字节的地址就是该变量的地址\n- 负数的二进制形式，就是对它的正数的二进制取反后加1\n\n## 类型说明符\n类型|说明|64位编译器\n--|--|--\nshort|短型|2字节（16位）\nlong|长型|8字节（64位）\nsigned|有符号型\nunsigned|无符号型\n&gt;一般就是用来修饰int类型的，所以在使用时省略int。\nshort int等价于short，long int等价于long，long long int等价于long long\n\n- signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。\n- signed：表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? -2^{31}&quot;&gt; ~ &lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2^{31}-1&quot;&gt;\n- unsigned：表示无符号，也就是说最高位并不当做符号位，所 以不包括负数。在64bit编译器环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0~&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2{32}-1&quot;&gt;\n\n## char类型（字符型）\n- 一个字符型变量占用1个字节，共8位。范围是&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? -2^7&quot;&gt;~&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2^7-1&quot;&gt;。\n- 不能用来存储汉字\n- 前面加&quot;\\&quot;形成的字符，称为“转义字符”  \n\n转义字符|意义|ASCII码值\n--|--|--\n\\n|回车|10\n\\t|退格|9\n\\\\|\\|92\n\\&apos;|&apos;|39\n\\&quot;|&quot;|34\n\\0|空字符|0\n\n\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><ul>\n<li>main函数<br>main函数时整个C程序的入口，整个C程序中也有且仅有一个main函数</li>\n<li>printf函数<br>在屏幕上输出内容，使用前必须加 <code>#incluce &lt;stdio.h&gt;</code></li>\n</ul>\n<h2 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"#include\"></a><code>#include</code></h2><ul>\n<li><code>#include</code>指令介绍<ul>\n<li><code>#include</code> 是C语言的<code>预处理指令</code>之一。<br>在编译之前做的处理，预处理指令一般以<code>#</code>开头    </li>\n<li><code>#include</code>指令后面会跟着一个文件名，此时，会将该文件内容包含到当前文件中。</li>\n<li>如果本包含的文件拓展名为 <code>.h</code> 则称为头文件(Header File)。</li>\n<li><code>#include</code>指令不仅限于 <code>.h</code> 头文件，可以包含任何白安逸器能识别的C/C++代码文件 </li>\n</ul>\n</li>\n<li><code>#include &lt;&gt;</code>和<code>#include &quot;&quot;</code>区别（主要是检索顺序不同）<ul>\n<li><code>#include &lt;&gt;</code> 检索顺序：<br>父文件所在文件夹 → 父文件的父文件所在文件夹 → 编译器设置的include路径 → 系统INCLUDE环境变量</li>\n<li><code>#include &quot; &quot;</code> 检索顺序：<br>编译器设置的include路径 → 系统INCLUDE环境变量</li>\n</ul>\n</li>\n<li><code>stdio.h</code><ul>\n<li>是C语言函数库中的一个头文件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多源文件开发\"><a href=\"#多源文件开发\" class=\"headerlink\" title=\"多源文件开发\"></a>多源文件开发</h2><ol>\n<li>在编写第一个C程序的时候已经提到：我们编写的所有C语言代码都保存在拓展名为.c的源文件中，编写完毕后就进行编译、链接，最后运行程序。</li>\n<li>在实际开发过程中，项目做大了，源代码肯定非常多，很容易就上万行 代码了，甚至上十万、百万都有可能。这个时候如果把所有的代码都写到一个.c源文件中，那么这个文件将会非常庞大，也非常恶心，你可以想象一下，一个文件 有十几万行文字，不要说调试程序了，连阅读代码都非常困难。</li>\n<li>公司里面都是以团队开发为主，如果多个开发人员同时修改一个源文件，那就会带来很多麻烦的问题，比如张三修改的代码很有可能会抹掉李四之前添加的代码。</li>\n<li>因此，为了模块化开发，一般会将不同的功能写到不同的.c源文件中，这样的话，每个开发人员都负责修改不同的源文件，达到分工合作的目的，能够大大提高开发效率。也就是说，一个正常的C语言项目是由多个.c源文件构成。</li>\n</ol>\n<hr>\n<h2 id=\"常用UNIX指令\"><a href=\"#常用UNIX指令\" class=\"headerlink\" title=\"常用UNIX指令\"></a>常用UNIX指令</h2><table>\n<thead>\n<tr>\n<th align=\"left\">指令</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ls</td>\n<td align=\"left\">列出当前目录下的所有内容（文件\\文件夹）</td>\n</tr>\n<tr>\n<td align=\"left\">pwd</td>\n<td align=\"left\">显示出当前目录的名称</td>\n</tr>\n<tr>\n<td align=\"left\">cd</td>\n<td align=\"left\">改变当前操作的目录</td>\n</tr>\n<tr>\n<td align=\"left\">who</td>\n<td align=\"left\">显示当前用户名</td>\n</tr>\n<tr>\n<td align=\"left\">clear</td>\n<td align=\"left\">清除所有内容</td>\n</tr>\n<tr>\n<td align=\"left\">mkdir</td>\n<td align=\"left\">创建一个新目录</td>\n</tr>\n</tbody></table>\n<h2 id=\"编译C程序\"><a href=\"#编译C程序\" class=\"headerlink\" title=\"编译C程序\"></a>编译C程序</h2><ul>\n<li><p>编译one.c，生成one.o文件</p>\n<figure class=\"highlight cc\"><figcaption><span>-c one.c```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 链接one.o，生成a.out文件</span><br><span class=\"line\">```cc one.o</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行a.out</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 进制</span><br><span class=\"line\">    进制：一种计数方式</span><br><span class=\"line\">- 十进制</span><br><span class=\"line\">由0、1、2….9十个基本数字组成；运算规则是“逢十进一”</span><br><span class=\"line\">- 二进制</span><br><span class=\"line\">特点：由0、1两个基本数字组成；运算规则是“逢二进一”</span><br><span class=\"line\">书写形式：需要以0b或者0B开头，比如0b101</span><br><span class=\"line\">- 八进制</span><br><span class=\"line\">特点：由0~7八个基本数字组成；运算规则是“逢八进一”</span><br><span class=\"line\">书写形式：在前面加个0，比如045</span><br><span class=\"line\">- 十六进制</span><br><span class=\"line\">特点：由0~9和A~F组成，A~F分别表示10~15；运算规则是“逢十六进一”</span><br><span class=\"line\">书写形式：在前面加个0x或者0X，比如0x45</span><br><span class=\"line\"></span><br><span class=\"line\">## 位运算符</span><br><span class=\"line\">运算符 | 作用  | 说明 |举例</span><br><span class=\"line\"> -----|-------|----|---</span><br><span class=\"line\">&amp;| 按位与|只有对应的两个二进位均为1时，结果位才为1，否则为0|1001 &amp; 0101 = 0001</span><br><span class=\"line\">&amp;#x7c;| 按位或|只要对应的二个二进位有一个为1时，结果位就为1，否则为0|1001 &amp;#x7c; 0101 = 1101</span><br><span class=\"line\">^ |按位异或|当对应的二进位相异（不相同）时，结果为1，否则为0|1001 ^ 101 = 1100</span><br><span class=\"line\">~ |取反|各二进位进行取反（0变1，1变0）|~1001 = 0110</span><br><span class=\"line\">&lt;&lt; |左移|各二进位全部左移n位，高位丢弃，低位补0|乘以2的n次方</span><br><span class=\"line\">&amp;#x3e;&amp;#x3e; |右移|各二进位全部右移n位，保持符号位不变|是除以2的n次方</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>//使用位运算实现交换两个数的值<br>a = a^b;<br>b = b^a;<br>a = a^b;</p>\n<pre><code>## 变量的内存分析\n### 字节和地址\n- 内存以“字节为单位”，不同类型的变量在不同编译器环境下所占的空间也不同\n\n变量类型 | 16位编译器  | 32位编译器  | 64位编译器\n--|--|--|--\nchar |1|1|1\nint |2|4|4\nfloat|4|4|4\ndouble|8|8|8\n- 变量存储单元的第一个字节的地址就是该变量的地址\n- 负数的二进制形式，就是对它的正数的二进制取反后加1\n\n## 类型说明符\n类型|说明|64位编译器\n--|--|--\nshort|短型|2字节（16位）\nlong|长型|8字节（64位）\nsigned|有符号型\nunsigned|无符号型\n&gt;一般就是用来修饰int类型的，所以在使用时省略int。\nshort int等价于short，long int等价于long，long long int等价于long long\n\n- signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。\n- signed：表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? -2^{31}&quot;&gt; ~ &lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2^{31}-1&quot;&gt;\n- unsigned：表示无符号，也就是说最高位并不当做符号位，所 以不包括负数。在64bit编译器环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0~&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2{32}-1&quot;&gt;\n\n## char类型（字符型）\n- 一个字符型变量占用1个字节，共8位。范围是&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? -2^7&quot;&gt;~&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2^7-1&quot;&gt;。\n- 不能用来存储汉字\n- 前面加&quot;\\&quot;形成的字符，称为“转义字符”  \n\n转义字符|意义|ASCII码值\n--|--|--\n\\n|回车|10\n\\t|退格|9\n\\\\|\\|92\n\\&apos;|&apos;|39\n\\&quot;|&quot;|34\n\\0|空字符|0\n\n\n</code></pre>"},{"title":"C语言表达式和结构控制","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-19T09:24:00.000Z","_content":"# 输入输出\n## printf和scanf的使用\n### printf和scanf输出输入格式\n| Type      | Example \n| :--:      | :-----: \n| char      | %c\n| short int | %hd\n| int       | %d\n| long int  | %ld\n| float     | %f\n| double    | %f\n\n# 表达式\n## 算数运算符\n### 常见运算符\n运算符 | 意义\n-|:--\n+|加法运算符\n-|减法运算符，或者负数云算法\n*|乘法运算符\n/|除法运算符（整数相除，省略小数）\n%|模运算符，取余运算符（%两侧均为整数）\n### 运算循序\n1> 算术表达式:用算术运算符将数据连接起来的式子，例如 2 + 4，3 `*` 5等。\n    表达式的运算顺序是按照运算符的`结合方向`和`优先级`进行的。\n2> 结合方向\n    算术运算符的结合方向从左到右。\n3> 优先级\n    优先级越高，就越先计算，当优先级相同时，参考结合方向。下面是优先级的排序\n    负值运算符(-) > 乘(*)、除(/)、模(%) > 加(+)、减(-)\n4> 小括号\n    如果被()括起来，那么优先级是最高。\n### 注意点\n1. 自动类型转换， 自动将大类型转换称小类型，会丢失精度    \n2. 强制类型转换\n\n## 赋值运算符\n1. 简单赋值运算符\n    赋值运算符的结合方向：从右到左，而且优先级低于算数运算符\n2. 复合赋值运算符\n    += : 如 a+=2等价于，a = a+2;\n    -= : 如 a-=2等价于，a = a-2;\n   `*`= : 如 a`*`=2等价于，a = a`*`2;\n    /= : 如 a+=2等价于，a = a+2;\n    %= : 如 a+=2等价于，a = a+2;\n\n## 自增和自减\n1. ++\n    - 先加，后用 `++a`\n    - 先用，后加 `a++`\n2. --\n    - 先减，后用 `--a`\n    - 先用，后减 `a--`\n    \n## sizeof\n>用来计算一个变量或者一个常量、一种数据类型所占的内存字节数\n\n## 逗号运算符\n- 主要用于连接表达式\n- 从左到右依次计算\n- 整个都好运算符，是最后一个表达式的值\n\n## 关系运算符\n- C语言中条件成立成为“真”，条件不成立成为“假”\n- C语言中规定，任何数值都有真假性，任何非0的值都为“真”，只有0才为“假”\n### 关系运算符\n\n运算符 | 意义\n-|-\n<|小于\n<=|小于等于\n>|大于\n>=|大于等于\n==|等于\n！=|不等于\n\n关系运算符的结果只有两种，条件成立结果是“1”，不成立为“0”；\n### 优先级\n1. <、<=、>、>=优先级大于 ==、!=优先级\n2. 结合方向，“从左到右”\n3. 优先级低于算术运算符\n\n## 逻辑运算符\n\n运算符|意义|计算规则\n-|- | -\n&&|与|两个为真才为真\n&#124;&#124; | 或|一个为真就为真\n！ | 非|！真为假，！假为真\n\n## 三目运算符\n- 条件运算符\n> 表达式1？表达式2：表达式3;\n    表达式1为真，执行表达式2，反之执行表达式3\n\n# 控制结构\n## 3种流程控制结构\n- 顺序结构：默认的流程结构。\n- 选择结构：对给定的条件进行判断，再根据判断来决定执行哪一段代码。\n- 循环结构：在给定条件成立的情况下，反复执行莫一段代码。\n\n### 选择结构\n1. if(){}else{}\n2. switch(){case :}\n\n### 循环结构\n1. while\n```\nwhile(条件）｛\n    语句1；\n    ……\n}\n//条件成立（为真），就执行{}中内容，条件不成立，就不执行\n```\n\n2. do-while\n```\ndo{\n    语句1；\n}while(条件);\n// 先执行一遍{}中内容，再判断'条件'是否成立，成立继续执行，不成立，不执行。\n```\n\n3. for\n```\n/*\n执行循序：\n1.初始化表达式（只在开始的时候执行一次）\n2.循环条件表达式（返回值只有两种，真 或 假）\n3.2返回为真时，执行{}中内容。为假时，退出循环\n4.执行一次{}后，执行“循环后的操作表达式”\n5.再执行第2步，循环下去。\n*/\nfor(初始化表达式；循环条件表达式；循环后的操作表达式){\n    执行语句；\n}\n```\n- break和continue\n    break常使用与switch和循环结构中，用于跳出switch或循环\n    continue常用于循环结构中，用于跳出本次循环","source":"_posts/c/C语言表达式和结构控制.md","raw":"---\ntitle: C语言表达式和结构控制\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-19 17:24:00   \n---\n# 输入输出\n## printf和scanf的使用\n### printf和scanf输出输入格式\n| Type      | Example \n| :--:      | :-----: \n| char      | %c\n| short int | %hd\n| int       | %d\n| long int  | %ld\n| float     | %f\n| double    | %f\n\n# 表达式\n## 算数运算符\n### 常见运算符\n运算符 | 意义\n-|:--\n+|加法运算符\n-|减法运算符，或者负数云算法\n*|乘法运算符\n/|除法运算符（整数相除，省略小数）\n%|模运算符，取余运算符（%两侧均为整数）\n### 运算循序\n1> 算术表达式:用算术运算符将数据连接起来的式子，例如 2 + 4，3 `*` 5等。\n    表达式的运算顺序是按照运算符的`结合方向`和`优先级`进行的。\n2> 结合方向\n    算术运算符的结合方向从左到右。\n3> 优先级\n    优先级越高，就越先计算，当优先级相同时，参考结合方向。下面是优先级的排序\n    负值运算符(-) > 乘(*)、除(/)、模(%) > 加(+)、减(-)\n4> 小括号\n    如果被()括起来，那么优先级是最高。\n### 注意点\n1. 自动类型转换， 自动将大类型转换称小类型，会丢失精度    \n2. 强制类型转换\n\n## 赋值运算符\n1. 简单赋值运算符\n    赋值运算符的结合方向：从右到左，而且优先级低于算数运算符\n2. 复合赋值运算符\n    += : 如 a+=2等价于，a = a+2;\n    -= : 如 a-=2等价于，a = a-2;\n   `*`= : 如 a`*`=2等价于，a = a`*`2;\n    /= : 如 a+=2等价于，a = a+2;\n    %= : 如 a+=2等价于，a = a+2;\n\n## 自增和自减\n1. ++\n    - 先加，后用 `++a`\n    - 先用，后加 `a++`\n2. --\n    - 先减，后用 `--a`\n    - 先用，后减 `a--`\n    \n## sizeof\n>用来计算一个变量或者一个常量、一种数据类型所占的内存字节数\n\n## 逗号运算符\n- 主要用于连接表达式\n- 从左到右依次计算\n- 整个都好运算符，是最后一个表达式的值\n\n## 关系运算符\n- C语言中条件成立成为“真”，条件不成立成为“假”\n- C语言中规定，任何数值都有真假性，任何非0的值都为“真”，只有0才为“假”\n### 关系运算符\n\n运算符 | 意义\n-|-\n<|小于\n<=|小于等于\n>|大于\n>=|大于等于\n==|等于\n！=|不等于\n\n关系运算符的结果只有两种，条件成立结果是“1”，不成立为“0”；\n### 优先级\n1. <、<=、>、>=优先级大于 ==、!=优先级\n2. 结合方向，“从左到右”\n3. 优先级低于算术运算符\n\n## 逻辑运算符\n\n运算符|意义|计算规则\n-|- | -\n&&|与|两个为真才为真\n&#124;&#124; | 或|一个为真就为真\n！ | 非|！真为假，！假为真\n\n## 三目运算符\n- 条件运算符\n> 表达式1？表达式2：表达式3;\n    表达式1为真，执行表达式2，反之执行表达式3\n\n# 控制结构\n## 3种流程控制结构\n- 顺序结构：默认的流程结构。\n- 选择结构：对给定的条件进行判断，再根据判断来决定执行哪一段代码。\n- 循环结构：在给定条件成立的情况下，反复执行莫一段代码。\n\n### 选择结构\n1. if(){}else{}\n2. switch(){case :}\n\n### 循环结构\n1. while\n```\nwhile(条件）｛\n    语句1；\n    ……\n}\n//条件成立（为真），就执行{}中内容，条件不成立，就不执行\n```\n\n2. do-while\n```\ndo{\n    语句1；\n}while(条件);\n// 先执行一遍{}中内容，再判断'条件'是否成立，成立继续执行，不成立，不执行。\n```\n\n3. for\n```\n/*\n执行循序：\n1.初始化表达式（只在开始的时候执行一次）\n2.循环条件表达式（返回值只有两种，真 或 假）\n3.2返回为真时，执行{}中内容。为假时，退出循环\n4.执行一次{}后，执行“循环后的操作表达式”\n5.再执行第2步，循环下去。\n*/\nfor(初始化表达式；循环条件表达式；循环后的操作表达式){\n    执行语句；\n}\n```\n- break和continue\n    break常使用与switch和循环结构中，用于跳出switch或循环\n    continue常用于循环结构中，用于跳出本次循环","slug":"c/C语言表达式和结构控制","published":1,"updated":"2019-10-02T08:53:40.484Z","layout":"post","photos":[],"link":"","_id":"ck191nw720006b0wkt6goi5dt","content":"<h1 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h1><h2 id=\"printf和scanf的使用\"><a href=\"#printf和scanf的使用\" class=\"headerlink\" title=\"printf和scanf的使用\"></a>printf和scanf的使用</h2><h3 id=\"printf和scanf输出输入格式\"><a href=\"#printf和scanf输出输入格式\" class=\"headerlink\" title=\"printf和scanf输出输入格式\"></a>printf和scanf输出输入格式</h3><table>\n<thead>\n<tr>\n<th align=\"center\">Type</th>\n<th align=\"center\">Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char</td>\n<td align=\"center\">%c</td>\n</tr>\n<tr>\n<td align=\"center\">short int</td>\n<td align=\"center\">%hd</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">%d</td>\n</tr>\n<tr>\n<td align=\"center\">long int</td>\n<td align=\"center\">%ld</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">%f</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">%f</td>\n</tr>\n</tbody></table>\n<h1 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h1><h2 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h2><h3 id=\"常见运算符\"><a href=\"#常见运算符\" class=\"headerlink\" title=\"常见运算符\"></a>常见运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th align=\"left\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td align=\"left\">加法运算符</td>\n</tr>\n<tr>\n<td>-</td>\n<td align=\"left\">减法运算符，或者负数云算法</td>\n</tr>\n<tr>\n<td>*</td>\n<td align=\"left\">乘法运算符</td>\n</tr>\n<tr>\n<td>/</td>\n<td align=\"left\">除法运算符（整数相除，省略小数）</td>\n</tr>\n<tr>\n<td>%</td>\n<td align=\"left\">模运算符，取余运算符（%两侧均为整数）</td>\n</tr>\n<tr>\n<td>### 运算循序</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>1&gt; 算术表达式:用算术运算符将数据连接起来的式子，例如 2 + 4，3 <code>*</code> 5等。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>表达式的运算顺序是按照运算符的<code>结合方向</code>和<code>优先级</code>进行的。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>2&gt; 结合方向</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>算术运算符的结合方向从左到右。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>3&gt; 优先级</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>优先级越高，就越先计算，当优先级相同时，参考结合方向。下面是优先级的排序</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>负值运算符(-) &gt; 乘(*)、除(/)、模(%) &gt; 加(+)、减(-)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>4&gt; 小括号</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>如果被()括起来，那么优先级是最高。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>### 注意点</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>1. 自动类型转换， 自动将大类型转换称小类型，会丢失精度</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>2. 强制类型转换</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><ol>\n<li>简单赋值运算符<br> 赋值运算符的结合方向：从右到左，而且优先级低于算数运算符</li>\n<li>复合赋值运算符<br> += : 如 a+=2等价于，a = a+2;<br> -= : 如 a-=2等价于，a = a-2;<br><code>*</code>= : 如 a<code>*</code>=2等价于，a = a<code>*</code>2;<br> /= : 如 a+=2等价于，a = a+2;<br> %= : 如 a+=2等价于，a = a+2;</li>\n</ol>\n<h2 id=\"自增和自减\"><a href=\"#自增和自减\" class=\"headerlink\" title=\"自增和自减\"></a>自增和自减</h2><ol>\n<li>++<ul>\n<li>先加，后用 <code>++a</code></li>\n<li>先用，后加 <code>a++</code></li>\n</ul>\n</li>\n<li>–<ul>\n<li>先减，后用 <code>--a</code></li>\n<li>先用，后减 <code>a--</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"sizeof\"><a href=\"#sizeof\" class=\"headerlink\" title=\"sizeof\"></a>sizeof</h2><blockquote>\n<p>用来计算一个变量或者一个常量、一种数据类型所占的内存字节数</p>\n</blockquote>\n<h2 id=\"逗号运算符\"><a href=\"#逗号运算符\" class=\"headerlink\" title=\"逗号运算符\"></a>逗号运算符</h2><ul>\n<li>主要用于连接表达式</li>\n<li>从左到右依次计算</li>\n<li>整个都好运算符，是最后一个表达式的值</li>\n</ul>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><ul>\n<li>C语言中条件成立成为“真”，条件不成立成为“假”</li>\n<li>C语言中规定，任何数值都有真假性，任何非0的值都为“真”，只有0才为“假”<h3 id=\"关系运算符-1\"><a href=\"#关系运算符-1\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>！=</td>\n<td>不等于</td>\n</tr>\n</tbody></table>\n<p>关系运算符的结果只有两种，条件成立结果是“1”，不成立为“0”；</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><ol>\n<li>&lt;、&lt;=、&gt;、&gt;=优先级大于 ==、!=优先级</li>\n<li>结合方向，“从左到右”</li>\n<li>优先级低于算术运算符</li>\n</ol>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>意义</th>\n<th>计算规则</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>与</td>\n<td>两个为真才为真</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>或</td>\n<td>一个为真就为真</td>\n</tr>\n<tr>\n<td>！</td>\n<td>非</td>\n<td>！真为假，！假为真</td>\n</tr>\n</tbody></table>\n<h2 id=\"三目运算符\"><a href=\"#三目运算符\" class=\"headerlink\" title=\"三目运算符\"></a>三目运算符</h2><ul>\n<li>条件运算符<blockquote>\n<p>表达式1？表达式2：表达式3;<br>  表达式1为真，执行表达式2，反之执行表达式3</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h1><h2 id=\"3种流程控制结构\"><a href=\"#3种流程控制结构\" class=\"headerlink\" title=\"3种流程控制结构\"></a>3种流程控制结构</h2><ul>\n<li>顺序结构：默认的流程结构。</li>\n<li>选择结构：对给定的条件进行判断，再根据判断来决定执行哪一段代码。</li>\n<li>循环结构：在给定条件成立的情况下，反复执行莫一段代码。</li>\n</ul>\n<h3 id=\"选择结构\"><a href=\"#选择结构\" class=\"headerlink\" title=\"选择结构\"></a>选择结构</h3><ol>\n<li>if(){}else{}</li>\n<li>switch(){case :}</li>\n</ol>\n<h3 id=\"循环结构\"><a href=\"#循环结构\" class=\"headerlink\" title=\"循环结构\"></a>循环结构</h3><ol>\n<li><p>while</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(条件）｛</span><br><span class=\"line\">    语句1；</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//条件成立（为真），就执行&#123;&#125;中内容，条件不成立，就不执行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>do-while</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do&#123;</span><br><span class=\"line\">    语句1；</span><br><span class=\"line\">&#125;while(条件);</span><br><span class=\"line\">// 先执行一遍&#123;&#125;中内容，再判断&apos;条件&apos;是否成立，成立继续执行，不成立，不执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>for</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">执行循序：</span><br><span class=\"line\">1.初始化表达式（只在开始的时候执行一次）</span><br><span class=\"line\">2.循环条件表达式（返回值只有两种，真 或 假）</span><br><span class=\"line\">3.2返回为真时，执行&#123;&#125;中内容。为假时，退出循环</span><br><span class=\"line\">4.执行一次&#123;&#125;后，执行“循环后的操作表达式”</span><br><span class=\"line\">5.再执行第2步，循环下去。</span><br><span class=\"line\">*/</span><br><span class=\"line\">for(初始化表达式；循环条件表达式；循环后的操作表达式)&#123;</span><br><span class=\"line\">    执行语句；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>break和continue<br>  break常使用与switch和循环结构中，用于跳出switch或循环<br>  continue常用于循环结构中，用于跳出本次循环</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h1><h2 id=\"printf和scanf的使用\"><a href=\"#printf和scanf的使用\" class=\"headerlink\" title=\"printf和scanf的使用\"></a>printf和scanf的使用</h2><h3 id=\"printf和scanf输出输入格式\"><a href=\"#printf和scanf输出输入格式\" class=\"headerlink\" title=\"printf和scanf输出输入格式\"></a>printf和scanf输出输入格式</h3><table>\n<thead>\n<tr>\n<th align=\"center\">Type</th>\n<th align=\"center\">Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char</td>\n<td align=\"center\">%c</td>\n</tr>\n<tr>\n<td align=\"center\">short int</td>\n<td align=\"center\">%hd</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">%d</td>\n</tr>\n<tr>\n<td align=\"center\">long int</td>\n<td align=\"center\">%ld</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">%f</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">%f</td>\n</tr>\n</tbody></table>\n<h1 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h1><h2 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h2><h3 id=\"常见运算符\"><a href=\"#常见运算符\" class=\"headerlink\" title=\"常见运算符\"></a>常见运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th align=\"left\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td align=\"left\">加法运算符</td>\n</tr>\n<tr>\n<td>-</td>\n<td align=\"left\">减法运算符，或者负数云算法</td>\n</tr>\n<tr>\n<td>*</td>\n<td align=\"left\">乘法运算符</td>\n</tr>\n<tr>\n<td>/</td>\n<td align=\"left\">除法运算符（整数相除，省略小数）</td>\n</tr>\n<tr>\n<td>%</td>\n<td align=\"left\">模运算符，取余运算符（%两侧均为整数）</td>\n</tr>\n<tr>\n<td>### 运算循序</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>1&gt; 算术表达式:用算术运算符将数据连接起来的式子，例如 2 + 4，3 <code>*</code> 5等。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>表达式的运算顺序是按照运算符的<code>结合方向</code>和<code>优先级</code>进行的。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>2&gt; 结合方向</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>算术运算符的结合方向从左到右。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>3&gt; 优先级</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>优先级越高，就越先计算，当优先级相同时，参考结合方向。下面是优先级的排序</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>负值运算符(-) &gt; 乘(*)、除(/)、模(%) &gt; 加(+)、减(-)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>4&gt; 小括号</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>如果被()括起来，那么优先级是最高。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>### 注意点</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>1. 自动类型转换， 自动将大类型转换称小类型，会丢失精度</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>2. 强制类型转换</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><ol>\n<li>简单赋值运算符<br> 赋值运算符的结合方向：从右到左，而且优先级低于算数运算符</li>\n<li>复合赋值运算符<br> += : 如 a+=2等价于，a = a+2;<br> -= : 如 a-=2等价于，a = a-2;<br><code>*</code>= : 如 a<code>*</code>=2等价于，a = a<code>*</code>2;<br> /= : 如 a+=2等价于，a = a+2;<br> %= : 如 a+=2等价于，a = a+2;</li>\n</ol>\n<h2 id=\"自增和自减\"><a href=\"#自增和自减\" class=\"headerlink\" title=\"自增和自减\"></a>自增和自减</h2><ol>\n<li>++<ul>\n<li>先加，后用 <code>++a</code></li>\n<li>先用，后加 <code>a++</code></li>\n</ul>\n</li>\n<li>–<ul>\n<li>先减，后用 <code>--a</code></li>\n<li>先用，后减 <code>a--</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"sizeof\"><a href=\"#sizeof\" class=\"headerlink\" title=\"sizeof\"></a>sizeof</h2><blockquote>\n<p>用来计算一个变量或者一个常量、一种数据类型所占的内存字节数</p>\n</blockquote>\n<h2 id=\"逗号运算符\"><a href=\"#逗号运算符\" class=\"headerlink\" title=\"逗号运算符\"></a>逗号运算符</h2><ul>\n<li>主要用于连接表达式</li>\n<li>从左到右依次计算</li>\n<li>整个都好运算符，是最后一个表达式的值</li>\n</ul>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><ul>\n<li>C语言中条件成立成为“真”，条件不成立成为“假”</li>\n<li>C语言中规定，任何数值都有真假性，任何非0的值都为“真”，只有0才为“假”<h3 id=\"关系运算符-1\"><a href=\"#关系运算符-1\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>！=</td>\n<td>不等于</td>\n</tr>\n</tbody></table>\n<p>关系运算符的结果只有两种，条件成立结果是“1”，不成立为“0”；</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><ol>\n<li>&lt;、&lt;=、&gt;、&gt;=优先级大于 ==、!=优先级</li>\n<li>结合方向，“从左到右”</li>\n<li>优先级低于算术运算符</li>\n</ol>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>意义</th>\n<th>计算规则</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>与</td>\n<td>两个为真才为真</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>或</td>\n<td>一个为真就为真</td>\n</tr>\n<tr>\n<td>！</td>\n<td>非</td>\n<td>！真为假，！假为真</td>\n</tr>\n</tbody></table>\n<h2 id=\"三目运算符\"><a href=\"#三目运算符\" class=\"headerlink\" title=\"三目运算符\"></a>三目运算符</h2><ul>\n<li>条件运算符<blockquote>\n<p>表达式1？表达式2：表达式3;<br>  表达式1为真，执行表达式2，反之执行表达式3</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h1><h2 id=\"3种流程控制结构\"><a href=\"#3种流程控制结构\" class=\"headerlink\" title=\"3种流程控制结构\"></a>3种流程控制结构</h2><ul>\n<li>顺序结构：默认的流程结构。</li>\n<li>选择结构：对给定的条件进行判断，再根据判断来决定执行哪一段代码。</li>\n<li>循环结构：在给定条件成立的情况下，反复执行莫一段代码。</li>\n</ul>\n<h3 id=\"选择结构\"><a href=\"#选择结构\" class=\"headerlink\" title=\"选择结构\"></a>选择结构</h3><ol>\n<li>if(){}else{}</li>\n<li>switch(){case :}</li>\n</ol>\n<h3 id=\"循环结构\"><a href=\"#循环结构\" class=\"headerlink\" title=\"循环结构\"></a>循环结构</h3><ol>\n<li><p>while</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(条件）｛</span><br><span class=\"line\">    语句1；</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//条件成立（为真），就执行&#123;&#125;中内容，条件不成立，就不执行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>do-while</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do&#123;</span><br><span class=\"line\">    语句1；</span><br><span class=\"line\">&#125;while(条件);</span><br><span class=\"line\">// 先执行一遍&#123;&#125;中内容，再判断&apos;条件&apos;是否成立，成立继续执行，不成立，不执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>for</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">执行循序：</span><br><span class=\"line\">1.初始化表达式（只在开始的时候执行一次）</span><br><span class=\"line\">2.循环条件表达式（返回值只有两种，真 或 假）</span><br><span class=\"line\">3.2返回为真时，执行&#123;&#125;中内容。为假时，退出循环</span><br><span class=\"line\">4.执行一次&#123;&#125;后，执行“循环后的操作表达式”</span><br><span class=\"line\">5.再执行第2步，循环下去。</span><br><span class=\"line\">*/</span><br><span class=\"line\">for(初始化表达式；循环条件表达式；循环后的操作表达式)&#123;</span><br><span class=\"line\">    执行语句；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>break和continue<br>  break常使用与switch和循环结构中，用于跳出switch或循环<br>  continue常用于循环结构中，用于跳出本次循环</li>\n</ul>\n"},{"title":"利用Hexo+GitHub搭建个人博客(二)","author":"JsonYe","date":"2019-09-30T06:55:00.000Z","_content":"> 安装好hexo后，可进行各项配置\n\n### 关于页面\n使用：`hexo new page “about” `新建一个 关于我 页面。 \n主题的` _config.yml `文件中的 `menu` 中进行匹配 \n不同主题 `_config. yml`文件有区别\n```\nmenu:\n  home: /      //主页\n  categories: /categories //分类\n  archives: /archives   //归档\n  tags: /tags   //标签\n  about: /about   //关于                  （添加此行即可）\n或    \nmenu:\n  - page: home\n    directory: .      //主页\n    icon: fa-home\n  - page: archive\n    directory: archives/    //归档\n    icon: fa-archive\n  - page: about\n    directory: about/    //关于\n    icon: fa-user\n  - page: rss\n    directory: atom.xml    //rss订阅\n    icon: fa-rss\n```\n编辑 about 关于页面 md文件 部署就能看到\n\n### 添加分类\n使用： `hexo new page categories` 新建一个 分类 页面。  \n主题的 `_config.yml` 文件中的 `menu` 中进行匹配\n```\nmenu:\n  home: /      //主页\n  categories: /categories //分类   \n  archives: /archives   //归档\n  tags: /tags   //标签                  \n  about: /about   //关于\n```\n底下代码是一篇包含 分类 文章的例子：\n```\ntitle: 分类测试\ncategories:\n- hexo                       （这个就是文章的分类了）\n```\n\n\n### 添加RSS\n#### 安装\nhexo博客有一个专门生成RSS xml文件的插件`hexo-generator-feed`\n我们来安装它\n```\nnpm install hexo-generator-feed\n```\n\n看到`added 3 packages`说明安装成功了。\n\n#### 启用\n在博客工程文件根目录下`_config.yml`文件中添加如下内容\n```\n# Extensions\nplugins:\n    hexo-generator-feed\n#Feed Atom\nfeed:\n    type: atom\n    path: atom.xml\n    limit: 20\n```\n\n#### 生成RSS\n```\n$ hexo g\n(node:6520) [DEP0061] DeprecationWarning: fs.SyncWriteStream is depre                                                                                                                           cated.\nINFO  Start processing\nINFO  Files loaded in 6.33 s\nINFO  Generated: atom.xml <----------成功生成atom.xml文件\nINFO  Generated: sitemap.xml\nINFO  Generated: baidusitemap.xml\nINFO  Generated: about/index.html\n......\n......\n......\n```","source":"_posts/hexo/hexo配置.md","raw":"title: 利用Hexo+GitHub搭建个人博客(二)\ncategories:\n  - hexo\ntags:\n  - hexo\nauthor: JsonYe\ndate: 2019-09-30 14:55:00\n---\n> 安装好hexo后，可进行各项配置\n\n### 关于页面\n使用：`hexo new page “about” `新建一个 关于我 页面。 \n主题的` _config.yml `文件中的 `menu` 中进行匹配 \n不同主题 `_config. yml`文件有区别\n```\nmenu:\n  home: /      //主页\n  categories: /categories //分类\n  archives: /archives   //归档\n  tags: /tags   //标签\n  about: /about   //关于                  （添加此行即可）\n或    \nmenu:\n  - page: home\n    directory: .      //主页\n    icon: fa-home\n  - page: archive\n    directory: archives/    //归档\n    icon: fa-archive\n  - page: about\n    directory: about/    //关于\n    icon: fa-user\n  - page: rss\n    directory: atom.xml    //rss订阅\n    icon: fa-rss\n```\n编辑 about 关于页面 md文件 部署就能看到\n\n### 添加分类\n使用： `hexo new page categories` 新建一个 分类 页面。  \n主题的 `_config.yml` 文件中的 `menu` 中进行匹配\n```\nmenu:\n  home: /      //主页\n  categories: /categories //分类   \n  archives: /archives   //归档\n  tags: /tags   //标签                  \n  about: /about   //关于\n```\n底下代码是一篇包含 分类 文章的例子：\n```\ntitle: 分类测试\ncategories:\n- hexo                       （这个就是文章的分类了）\n```\n\n\n### 添加RSS\n#### 安装\nhexo博客有一个专门生成RSS xml文件的插件`hexo-generator-feed`\n我们来安装它\n```\nnpm install hexo-generator-feed\n```\n\n看到`added 3 packages`说明安装成功了。\n\n#### 启用\n在博客工程文件根目录下`_config.yml`文件中添加如下内容\n```\n# Extensions\nplugins:\n    hexo-generator-feed\n#Feed Atom\nfeed:\n    type: atom\n    path: atom.xml\n    limit: 20\n```\n\n#### 生成RSS\n```\n$ hexo g\n(node:6520) [DEP0061] DeprecationWarning: fs.SyncWriteStream is depre                                                                                                                           cated.\nINFO  Start processing\nINFO  Files loaded in 6.33 s\nINFO  Generated: atom.xml <----------成功生成atom.xml文件\nINFO  Generated: sitemap.xml\nINFO  Generated: baidusitemap.xml\nINFO  Generated: about/index.html\n......\n......\n......\n```","slug":"hexo/hexo配置","published":1,"updated":"2019-10-02T08:41:26.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck191nw750007b0wkwspqk4am","content":"<blockquote>\n<p>安装好hexo后，可进行各项配置</p>\n</blockquote>\n<h3 id=\"关于页面\"><a href=\"#关于页面\" class=\"headerlink\" title=\"关于页面\"></a>关于页面</h3><p>使用：<code>hexo new page “about”</code>新建一个 关于我 页面。<br>主题的<code>_config.yml</code>文件中的 <code>menu</code> 中进行匹配<br>不同主题 <code>_config. yml</code>文件有区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /      //主页</span><br><span class=\"line\">  categories: /categories //分类</span><br><span class=\"line\">  archives: /archives   //归档</span><br><span class=\"line\">  tags: /tags   //标签</span><br><span class=\"line\">  about: /about   //关于                  （添加此行即可）</span><br><span class=\"line\">或    </span><br><span class=\"line\">menu:</span><br><span class=\"line\">  - page: home</span><br><span class=\"line\">    directory: .      //主页</span><br><span class=\"line\">    icon: fa-home</span><br><span class=\"line\">  - page: archive</span><br><span class=\"line\">    directory: archives/    //归档</span><br><span class=\"line\">    icon: fa-archive</span><br><span class=\"line\">  - page: about</span><br><span class=\"line\">    directory: about/    //关于</span><br><span class=\"line\">    icon: fa-user</span><br><span class=\"line\">  - page: rss</span><br><span class=\"line\">    directory: atom.xml    //rss订阅</span><br><span class=\"line\">    icon: fa-rss</span><br></pre></td></tr></table></figure>\n\n<p>编辑 about 关于页面 md文件 部署就能看到</p>\n<h3 id=\"添加分类\"><a href=\"#添加分类\" class=\"headerlink\" title=\"添加分类\"></a>添加分类</h3><p>使用： <code>hexo new page categories</code> 新建一个 分类 页面。<br>主题的 <code>_config.yml</code> 文件中的 <code>menu</code> 中进行匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /      //主页</span><br><span class=\"line\">  categories: /categories //分类   </span><br><span class=\"line\">  archives: /archives   //归档</span><br><span class=\"line\">  tags: /tags   //标签                  </span><br><span class=\"line\">  about: /about   //关于</span><br></pre></td></tr></table></figure>\n\n<p>底下代码是一篇包含 分类 文章的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 分类测试</span><br><span class=\"line\">categories:</span><br><span class=\"line\">- hexo                       （这个就是文章的分类了）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加RSS\"><a href=\"#添加RSS\" class=\"headerlink\" title=\"添加RSS\"></a>添加RSS</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>hexo博客有一个专门生成RSS xml文件的插件<code>hexo-generator-feed</code><br>我们来安装它</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure>\n\n<p>看到<code>added 3 packages</code>说明安装成功了。</p>\n<h4 id=\"启用\"><a href=\"#启用\" class=\"headerlink\" title=\"启用\"></a>启用</h4><p>在博客工程文件根目录下<code>_config.yml</code>文件中添加如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">    hexo-generator-feed</span><br><span class=\"line\">#Feed Atom</span><br><span class=\"line\">feed:</span><br><span class=\"line\">    type: atom</span><br><span class=\"line\">    path: atom.xml</span><br><span class=\"line\">    limit: 20</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成RSS\"><a href=\"#生成RSS\" class=\"headerlink\" title=\"生成RSS\"></a>生成RSS</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">(node:6520) [DEP0061] DeprecationWarning: fs.SyncWriteStream is depre                                                                                                                           cated.</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Files loaded in 6.33 s</span><br><span class=\"line\">INFO  Generated: atom.xml &lt;----------成功生成atom.xml文件</span><br><span class=\"line\">INFO  Generated: sitemap.xml</span><br><span class=\"line\">INFO  Generated: baidusitemap.xml</span><br><span class=\"line\">INFO  Generated: about/index.html</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>安装好hexo后，可进行各项配置</p>\n</blockquote>\n<h3 id=\"关于页面\"><a href=\"#关于页面\" class=\"headerlink\" title=\"关于页面\"></a>关于页面</h3><p>使用：<code>hexo new page “about”</code>新建一个 关于我 页面。<br>主题的<code>_config.yml</code>文件中的 <code>menu</code> 中进行匹配<br>不同主题 <code>_config. yml</code>文件有区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /      //主页</span><br><span class=\"line\">  categories: /categories //分类</span><br><span class=\"line\">  archives: /archives   //归档</span><br><span class=\"line\">  tags: /tags   //标签</span><br><span class=\"line\">  about: /about   //关于                  （添加此行即可）</span><br><span class=\"line\">或    </span><br><span class=\"line\">menu:</span><br><span class=\"line\">  - page: home</span><br><span class=\"line\">    directory: .      //主页</span><br><span class=\"line\">    icon: fa-home</span><br><span class=\"line\">  - page: archive</span><br><span class=\"line\">    directory: archives/    //归档</span><br><span class=\"line\">    icon: fa-archive</span><br><span class=\"line\">  - page: about</span><br><span class=\"line\">    directory: about/    //关于</span><br><span class=\"line\">    icon: fa-user</span><br><span class=\"line\">  - page: rss</span><br><span class=\"line\">    directory: atom.xml    //rss订阅</span><br><span class=\"line\">    icon: fa-rss</span><br></pre></td></tr></table></figure>\n\n<p>编辑 about 关于页面 md文件 部署就能看到</p>\n<h3 id=\"添加分类\"><a href=\"#添加分类\" class=\"headerlink\" title=\"添加分类\"></a>添加分类</h3><p>使用： <code>hexo new page categories</code> 新建一个 分类 页面。<br>主题的 <code>_config.yml</code> 文件中的 <code>menu</code> 中进行匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /      //主页</span><br><span class=\"line\">  categories: /categories //分类   </span><br><span class=\"line\">  archives: /archives   //归档</span><br><span class=\"line\">  tags: /tags   //标签                  </span><br><span class=\"line\">  about: /about   //关于</span><br></pre></td></tr></table></figure>\n\n<p>底下代码是一篇包含 分类 文章的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 分类测试</span><br><span class=\"line\">categories:</span><br><span class=\"line\">- hexo                       （这个就是文章的分类了）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加RSS\"><a href=\"#添加RSS\" class=\"headerlink\" title=\"添加RSS\"></a>添加RSS</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>hexo博客有一个专门生成RSS xml文件的插件<code>hexo-generator-feed</code><br>我们来安装它</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure>\n\n<p>看到<code>added 3 packages</code>说明安装成功了。</p>\n<h4 id=\"启用\"><a href=\"#启用\" class=\"headerlink\" title=\"启用\"></a>启用</h4><p>在博客工程文件根目录下<code>_config.yml</code>文件中添加如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">    hexo-generator-feed</span><br><span class=\"line\">#Feed Atom</span><br><span class=\"line\">feed:</span><br><span class=\"line\">    type: atom</span><br><span class=\"line\">    path: atom.xml</span><br><span class=\"line\">    limit: 20</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成RSS\"><a href=\"#生成RSS\" class=\"headerlink\" title=\"生成RSS\"></a>生成RSS</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">(node:6520) [DEP0061] DeprecationWarning: fs.SyncWriteStream is depre                                                                                                                           cated.</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Files loaded in 6.33 s</span><br><span class=\"line\">INFO  Generated: atom.xml &lt;----------成功生成atom.xml文件</span><br><span class=\"line\">INFO  Generated: sitemap.xml</span><br><span class=\"line\">INFO  Generated: baidusitemap.xml</span><br><span class=\"line\">INFO  Generated: about/index.html</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>"},{"title":"利用Hexo+GitHub搭建个人博客(一)","author":"JsonYe","date":"2019-09-30T05:55:00.000Z","_content":"\n## 前言\n很久以前的一个想法，就是搭建一个个人博客，把个人在学习、生活中的故事记录下来。`hexo`让我的想法变成了现实。\n下面就简单说一下整体打搭建流程。\n\n## 搭建步骤：\n> 最开始以为要把hexo安装到服务器上，后来了解后恍然大悟，他是在本地安装的，然后将我们写的markdown文件转换为静态网站文件，放到github上，利用github来作为服务器的。\n\n 1. 安装git bash。\n 2. 安装npm。\n 3. 安装NodeJs\n 4. 申请github账户，并创建一个仓库，命名规范为  \"账户名\".github.io。\n 5. 创建SSH并添加到github上。\n 6. 安装hexo。\n 7. 部署项目，本地测试。\n 8. 上传到github上。\n \n到这一步，博客就搭建好了，域名可选择性进行关联。后续可以设置主题、添加RSS、设置评论、以及写文章。具体可参考[官方文档](https://hexo.io/zh-cn/docs/writing.html)","source":"_posts/hexo/利用Hexo+GitHub搭建个人博客.md","raw":"title: 利用Hexo+GitHub搭建个人博客(一)\ncategories:\n  - hexo\ntags:\n  - hexo\nauthor: JsonYe\ndate: 2019-09-30 13:55:00\n---\n\n## 前言\n很久以前的一个想法，就是搭建一个个人博客，把个人在学习、生活中的故事记录下来。`hexo`让我的想法变成了现实。\n下面就简单说一下整体打搭建流程。\n\n## 搭建步骤：\n> 最开始以为要把hexo安装到服务器上，后来了解后恍然大悟，他是在本地安装的，然后将我们写的markdown文件转换为静态网站文件，放到github上，利用github来作为服务器的。\n\n 1. 安装git bash。\n 2. 安装npm。\n 3. 安装NodeJs\n 4. 申请github账户，并创建一个仓库，命名规范为  \"账户名\".github.io。\n 5. 创建SSH并添加到github上。\n 6. 安装hexo。\n 7. 部署项目，本地测试。\n 8. 上传到github上。\n \n到这一步，博客就搭建好了，域名可选择性进行关联。后续可以设置主题、添加RSS、设置评论、以及写文章。具体可参考[官方文档](https://hexo.io/zh-cn/docs/writing.html)","slug":"hexo/利用Hexo+GitHub搭建个人博客","published":1,"updated":"2019-10-02T08:41:54.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck191nw7d000bb0wky7s2sm1e","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>很久以前的一个想法，就是搭建一个个人博客，把个人在学习、生活中的故事记录下来。<code>hexo</code>让我的想法变成了现实。<br>下面就简单说一下整体打搭建流程。</p>\n<h2 id=\"搭建步骤：\"><a href=\"#搭建步骤：\" class=\"headerlink\" title=\"搭建步骤：\"></a>搭建步骤：</h2><blockquote>\n<p>最开始以为要把hexo安装到服务器上，后来了解后恍然大悟，他是在本地安装的，然后将我们写的markdown文件转换为静态网站文件，放到github上，利用github来作为服务器的。</p>\n</blockquote>\n<ol>\n<li>安装git bash。</li>\n<li>安装npm。</li>\n<li>安装NodeJs</li>\n<li>申请github账户，并创建一个仓库，命名规范为  “账户名”.github.io。</li>\n<li>创建SSH并添加到github上。</li>\n<li>安装hexo。</li>\n<li>部署项目，本地测试。</li>\n<li>上传到github上。</li>\n</ol>\n<p>到这一步，博客就搭建好了，域名可选择性进行关联。后续可以设置主题、添加RSS、设置评论、以及写文章。具体可参考<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>很久以前的一个想法，就是搭建一个个人博客，把个人在学习、生活中的故事记录下来。<code>hexo</code>让我的想法变成了现实。<br>下面就简单说一下整体打搭建流程。</p>\n<h2 id=\"搭建步骤：\"><a href=\"#搭建步骤：\" class=\"headerlink\" title=\"搭建步骤：\"></a>搭建步骤：</h2><blockquote>\n<p>最开始以为要把hexo安装到服务器上，后来了解后恍然大悟，他是在本地安装的，然后将我们写的markdown文件转换为静态网站文件，放到github上，利用github来作为服务器的。</p>\n</blockquote>\n<ol>\n<li>安装git bash。</li>\n<li>安装npm。</li>\n<li>安装NodeJs</li>\n<li>申请github账户，并创建一个仓库，命名规范为  “账户名”.github.io。</li>\n<li>创建SSH并添加到github上。</li>\n<li>安装hexo。</li>\n<li>部署项目，本地测试。</li>\n<li>上传到github上。</li>\n</ol>\n<p>到这一步，博客就搭建好了，域名可选择性进行关联。后续可以设置主题、添加RSS、设置评论、以及写文章。具体可参考<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n"},{"title":"PHP开发工具ZendStudio10","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-04-17T08:59:00.000Z","_content":"## 一、zend studio 10破解/汉化，参考文档\n\n[http://blog.csdn.net/qq1355541448/article/details/16807429](http://blog.csdn.net/qq1355541448/article/details/16807429)\n\n## 二、安装Composer\n\n去到官网下载[https://getcomposer.org/download/](https://getcomposer.org/download/)\n\n[![image](http://static.oschina.net/uploads/img/201504/17120800_gpew.png \"image\")](http://static.oschina.net/uploads/img/201504/17120759_Znd7.png)\n\n## 常见问题\n### windows下Composer因php_openssl扩展缺失而安装失败。\n\nComposer( https://getcomposer.org/ )是PHP下的一个依赖管理工具。你可以在你的项目中声明你所需要用到的类库，然后Composer会在项目中为你安装它们。如果你了解Node的 npm 或者Ruby的 Bundler ，就理解它是做什么的了，但是，它不是包管理器。\n\n在Windows的Wamp环境下安装Composer(注：Composer要求PHP版本在5.3.2+)，你可能会遇到这种安装失败的情况：出错信息是\n\n\n```\n \"The openssl extension is missing, which will reduce the security and stability of Composer. If possible you should enable it or recompile php with --with-openssl\" ，大意就是你的PHP缺少openssl扩展。\n\n你可能会去屏幕右下角的Wamp的控制台，去加载php的openssl扩展，或者在php.ini中去掉 extension=php_openssl.dll 这一行开头的注释，然后重启server，结果发现还是不行。\n\n正确的做法是在php的安装目录比如说C:\\wamp\\bin\\php\\php5.3.3\\中，找到找个目录下的php.ini文件，然后去掉 extension=php_openssl.dll 这一行开头的注释，之后就可以顺利安装Composer了。\n\n你可以发现上面出现了两个php.ini，是的Wamp在Apache和在CLI(命令行)模式下使用了不同的php.ini文件，当你在WAMP的控制台去启用php_openssl这个扩展，是启用的Apache的，而非CLI。而修改php安装目录中的php.ini配置文件，则可以启用CLI模式下的openssl。\n```\n\n### Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！[http://my.oschina.net/yearnfar/blog/346727](http://my.oschina.net/yearnfar/blog/346727)\n\nCA证书下载地址：http://curl.haxx.se/docs/caextract.html\n\n然后修改php.ini文件\n\n```\nopenssl.cafile= D:/wamp/php/verify/cacert.pem\n```","source":"_posts/ide/PHP开发工具ZendStudio10.md","raw":"---\ntitle: PHP开发工具ZendStudio10\nauthor: JsonYe\ntags:\n  - php\ncategories:\n  - IDE \ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-04-17 16:59:00\n---\n## 一、zend studio 10破解/汉化，参考文档\n\n[http://blog.csdn.net/qq1355541448/article/details/16807429](http://blog.csdn.net/qq1355541448/article/details/16807429)\n\n## 二、安装Composer\n\n去到官网下载[https://getcomposer.org/download/](https://getcomposer.org/download/)\n\n[![image](http://static.oschina.net/uploads/img/201504/17120800_gpew.png \"image\")](http://static.oschina.net/uploads/img/201504/17120759_Znd7.png)\n\n## 常见问题\n### windows下Composer因php_openssl扩展缺失而安装失败。\n\nComposer( https://getcomposer.org/ )是PHP下的一个依赖管理工具。你可以在你的项目中声明你所需要用到的类库，然后Composer会在项目中为你安装它们。如果你了解Node的 npm 或者Ruby的 Bundler ，就理解它是做什么的了，但是，它不是包管理器。\n\n在Windows的Wamp环境下安装Composer(注：Composer要求PHP版本在5.3.2+)，你可能会遇到这种安装失败的情况：出错信息是\n\n\n```\n \"The openssl extension is missing, which will reduce the security and stability of Composer. If possible you should enable it or recompile php with --with-openssl\" ，大意就是你的PHP缺少openssl扩展。\n\n你可能会去屏幕右下角的Wamp的控制台，去加载php的openssl扩展，或者在php.ini中去掉 extension=php_openssl.dll 这一行开头的注释，然后重启server，结果发现还是不行。\n\n正确的做法是在php的安装目录比如说C:\\wamp\\bin\\php\\php5.3.3\\中，找到找个目录下的php.ini文件，然后去掉 extension=php_openssl.dll 这一行开头的注释，之后就可以顺利安装Composer了。\n\n你可以发现上面出现了两个php.ini，是的Wamp在Apache和在CLI(命令行)模式下使用了不同的php.ini文件，当你在WAMP的控制台去启用php_openssl这个扩展，是启用的Apache的，而非CLI。而修改php安装目录中的php.ini配置文件，则可以启用CLI模式下的openssl。\n```\n\n### Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！[http://my.oschina.net/yearnfar/blog/346727](http://my.oschina.net/yearnfar/blog/346727)\n\nCA证书下载地址：http://curl.haxx.se/docs/caextract.html\n\n然后修改php.ini文件\n\n```\nopenssl.cafile= D:/wamp/php/verify/cacert.pem\n```","slug":"ide/PHP开发工具ZendStudio10","published":1,"updated":"2019-10-02T08:42:31.101Z","layout":"post","photos":[],"link":"","_id":"ck191nw7h000db0wknkuq2s52","content":"<h2 id=\"一、zend-studio-10破解-汉化，参考文档\"><a href=\"#一、zend-studio-10破解-汉化，参考文档\" class=\"headerlink\" title=\"一、zend studio 10破解/汉化，参考文档\"></a>一、zend studio 10破解/汉化，参考文档</h2><p><a href=\"http://blog.csdn.net/qq1355541448/article/details/16807429\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq1355541448/article/details/16807429</a></p>\n<h2 id=\"二、安装Composer\"><a href=\"#二、安装Composer\" class=\"headerlink\" title=\"二、安装Composer\"></a>二、安装Composer</h2><p>去到官网下载<a href=\"https://getcomposer.org/download/\" target=\"_blank\" rel=\"noopener\">https://getcomposer.org/download/</a></p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/17120759_Znd7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/17120800_gpew.png\" alt=\"image\" title=\"image\"></a></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"windows下Composer因php-openssl扩展缺失而安装失败。\"><a href=\"#windows下Composer因php-openssl扩展缺失而安装失败。\" class=\"headerlink\" title=\"windows下Composer因php_openssl扩展缺失而安装失败。\"></a>windows下Composer因php_openssl扩展缺失而安装失败。</h3><p>Composer( <a href=\"https://getcomposer.org/\" target=\"_blank\" rel=\"noopener\">https://getcomposer.org/</a> )是PHP下的一个依赖管理工具。你可以在你的项目中声明你所需要用到的类库，然后Composer会在项目中为你安装它们。如果你了解Node的 npm 或者Ruby的 Bundler ，就理解它是做什么的了，但是，它不是包管理器。</p>\n<p>在Windows的Wamp环境下安装Composer(注：Composer要求PHP版本在5.3.2+)，你可能会遇到这种安装失败的情况：出错信息是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;The openssl extension is missing, which will reduce the security and stability of Composer. If possible you should enable it or recompile php with --with-openssl&quot; ，大意就是你的PHP缺少openssl扩展。</span><br><span class=\"line\"></span><br><span class=\"line\">你可能会去屏幕右下角的Wamp的控制台，去加载php的openssl扩展，或者在php.ini中去掉 extension=php_openssl.dll 这一行开头的注释，然后重启server，结果发现还是不行。</span><br><span class=\"line\"></span><br><span class=\"line\">正确的做法是在php的安装目录比如说C:\\wamp\\bin\\php\\php5.3.3\\中，找到找个目录下的php.ini文件，然后去掉 extension=php_openssl.dll 这一行开头的注释，之后就可以顺利安装Composer了。</span><br><span class=\"line\"></span><br><span class=\"line\">你可以发现上面出现了两个php.ini，是的Wamp在Apache和在CLI(命令行)模式下使用了不同的php.ini文件，当你在WAMP的控制台去启用php_openssl这个扩展，是启用的Apache的，而非CLI。而修改php安装目录中的php.ini配置文件，则可以启用CLI模式下的openssl。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Win7下运行php-Composer出现SSL报错的问题没有安装CA证书导致的！！！http-my-oschina-net-yearnfar-blog-346727\"><a href=\"#Win7下运行php-Composer出现SSL报错的问题没有安装CA证书导致的！！！http-my-oschina-net-yearnfar-blog-346727\" class=\"headerlink\" title=\"Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！http://my.oschina.net/yearnfar/blog/346727\"></a>Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！<a href=\"http://my.oschina.net/yearnfar/blog/346727\" target=\"_blank\" rel=\"noopener\">http://my.oschina.net/yearnfar/blog/346727</a></h3><p>CA证书下载地址：<a href=\"http://curl.haxx.se/docs/caextract.html\" target=\"_blank\" rel=\"noopener\">http://curl.haxx.se/docs/caextract.html</a></p>\n<p>然后修改php.ini文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl.cafile= D:/wamp/php/verify/cacert.pem</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、zend-studio-10破解-汉化，参考文档\"><a href=\"#一、zend-studio-10破解-汉化，参考文档\" class=\"headerlink\" title=\"一、zend studio 10破解/汉化，参考文档\"></a>一、zend studio 10破解/汉化，参考文档</h2><p><a href=\"http://blog.csdn.net/qq1355541448/article/details/16807429\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq1355541448/article/details/16807429</a></p>\n<h2 id=\"二、安装Composer\"><a href=\"#二、安装Composer\" class=\"headerlink\" title=\"二、安装Composer\"></a>二、安装Composer</h2><p>去到官网下载<a href=\"https://getcomposer.org/download/\" target=\"_blank\" rel=\"noopener\">https://getcomposer.org/download/</a></p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/17120759_Znd7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/17120800_gpew.png\" alt=\"image\" title=\"image\"></a></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"windows下Composer因php-openssl扩展缺失而安装失败。\"><a href=\"#windows下Composer因php-openssl扩展缺失而安装失败。\" class=\"headerlink\" title=\"windows下Composer因php_openssl扩展缺失而安装失败。\"></a>windows下Composer因php_openssl扩展缺失而安装失败。</h3><p>Composer( <a href=\"https://getcomposer.org/\" target=\"_blank\" rel=\"noopener\">https://getcomposer.org/</a> )是PHP下的一个依赖管理工具。你可以在你的项目中声明你所需要用到的类库，然后Composer会在项目中为你安装它们。如果你了解Node的 npm 或者Ruby的 Bundler ，就理解它是做什么的了，但是，它不是包管理器。</p>\n<p>在Windows的Wamp环境下安装Composer(注：Composer要求PHP版本在5.3.2+)，你可能会遇到这种安装失败的情况：出错信息是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;The openssl extension is missing, which will reduce the security and stability of Composer. If possible you should enable it or recompile php with --with-openssl&quot; ，大意就是你的PHP缺少openssl扩展。</span><br><span class=\"line\"></span><br><span class=\"line\">你可能会去屏幕右下角的Wamp的控制台，去加载php的openssl扩展，或者在php.ini中去掉 extension=php_openssl.dll 这一行开头的注释，然后重启server，结果发现还是不行。</span><br><span class=\"line\"></span><br><span class=\"line\">正确的做法是在php的安装目录比如说C:\\wamp\\bin\\php\\php5.3.3\\中，找到找个目录下的php.ini文件，然后去掉 extension=php_openssl.dll 这一行开头的注释，之后就可以顺利安装Composer了。</span><br><span class=\"line\"></span><br><span class=\"line\">你可以发现上面出现了两个php.ini，是的Wamp在Apache和在CLI(命令行)模式下使用了不同的php.ini文件，当你在WAMP的控制台去启用php_openssl这个扩展，是启用的Apache的，而非CLI。而修改php安装目录中的php.ini配置文件，则可以启用CLI模式下的openssl。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Win7下运行php-Composer出现SSL报错的问题没有安装CA证书导致的！！！http-my-oschina-net-yearnfar-blog-346727\"><a href=\"#Win7下运行php-Composer出现SSL报错的问题没有安装CA证书导致的！！！http-my-oschina-net-yearnfar-blog-346727\" class=\"headerlink\" title=\"Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！http://my.oschina.net/yearnfar/blog/346727\"></a>Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！<a href=\"http://my.oschina.net/yearnfar/blog/346727\" target=\"_blank\" rel=\"noopener\">http://my.oschina.net/yearnfar/blog/346727</a></h3><p>CA证书下载地址：<a href=\"http://curl.haxx.se/docs/caextract.html\" target=\"_blank\" rel=\"noopener\">http://curl.haxx.se/docs/caextract.html</a></p>\n<p>然后修改php.ini文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl.cafile= D:/wamp/php/verify/cacert.pem</span><br></pre></td></tr></table></figure>"},{"title":"Win8(X64)下MySQL5.6版本安装及配置","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-04-16T08:59:00.000Z","_content":"\n### 步骤1：双击MySQL安装程序\n\n官方网站http://dev.mysql.com/downloads/下载该软件\n\n### 步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:\n\n> Developer Default 默认安装类型\n> \n> Server only 仅作为服务器\n> \n> Client only 仅作为客户端\n> \n> Full 完全安装类型\n> \n> Custom 用户自定义安装类型\n> \n> 根据自己的情况选择安装，我们这里以自定义安装为例：\n> \n> [![image](http://static.oschina.net/uploads/img/201504/16165918_xBtP.png \"image\")](http://static.oschina.net/uploads/img/201504/16165918_FGf6.png)\n\n### 步骤3：选择安装内容及安装目录：\n\n> [![image](http://static.oschina.net/uploads/img/201504/16165918_xZtq.png \"image\")](http://static.oschina.net/uploads/img/201504/16165918_0GLM.png) [![image](http://static.oschina.net/uploads/img/201504/16165919_WpTX.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_YIKU.png) [![image](http://static.oschina.net/uploads/img/201504/16165919_0DmF.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_vrIa.png)\n\n### 步骤4：选择类型\n\n> Developer Machine(开发机器)，个人用桌面工作站，占用最少的系统资源\n> \n> Server Machine（服务器），MySQL服务器可以同其它应用程序一起运行，例如FTP、email和web服务器。MySQL服务器配置成使用适当比例的系统资源。\n> \n> Dedicated MySQL Server Machine（专用MySQL服务器）：该选项代表只运行MySQL服务的服务器。假定运行没有运行其它应用程序。MySQL服务器配置成使用所有可用系统资源。\n\n根据自己情况选择即可，一般WEB服务器选择第二个，Server Machine即可！个人电脑安装选择第一个，Developer Machine比较好。\n\n[![image](http://static.oschina.net/uploads/img/201504/16165920_8GEz.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_d9x7.png)\n\n### 步骤5：配置密码\n\n[![image](http://static.oschina.net/uploads/img/201504/16165920_c01w.png \"image\")](http://static.oschina.net/uploads/img/201504/16165920_a2cR.png)\n\n对应的界面中，我们需要设置root用户的密码，在“MySQL Root password”(输入新密码)和“Repeat Password”（确认）两个编辑框内输入期望的密码。也可以单击下面的【Add User】按钮另行添加新的用户。(**注:Current Root Password:为空；如果输入密码了在后面安装会报错**)\n\n### 步骤6：**设置Windows Service Name<可默认>，此名为启动数据库服务名，要记住。**\n\n[![image](http://static.oschina.net/uploads/img/201504/16165921_A9pr.png \"image\")](http://static.oschina.net/uploads/img/201504/16165921_kz1L.png)\n\n### 步骤7：验证服务：\n\n在开始菜单栏->**附件->**右键命令提示符->以管理员身份运行:\n\n```\nnet start MySQL56 为启动数据库服务命令；\n```\n\n```\nnet stop MySQL56  为停止数据库服务命令。\n```\n\n[![image](http://static.oschina.net/uploads/img/201504/16165921_qsYm.png \"image\")](http://static.oschina.net/uploads/img/201504/16165921_IAgd.png)\n\n### 步骤8：连接测试：\n\n进入bin目录，执行mysql -u root -p 回车输入密码\n\n```\nD:\\>cd D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin\nD:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin>mysql -u root -p\nEnter password: ****** Welcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 1 Server version: 5.6.24-log MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n```","source":"_posts/mysql/Win8(X64)下MySQL5.6版本安装及配置.md","raw":"title: Win8(X64)下MySQL5.6版本安装及配置\nauthor: JsonYe\ntags:\n  - mysql\n  - 数据库\ncategories:\n  - IDE \ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-04-16 16:59:00\n---\n\n### 步骤1：双击MySQL安装程序\n\n官方网站http://dev.mysql.com/downloads/下载该软件\n\n### 步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:\n\n> Developer Default 默认安装类型\n> \n> Server only 仅作为服务器\n> \n> Client only 仅作为客户端\n> \n> Full 完全安装类型\n> \n> Custom 用户自定义安装类型\n> \n> 根据自己的情况选择安装，我们这里以自定义安装为例：\n> \n> [![image](http://static.oschina.net/uploads/img/201504/16165918_xBtP.png \"image\")](http://static.oschina.net/uploads/img/201504/16165918_FGf6.png)\n\n### 步骤3：选择安装内容及安装目录：\n\n> [![image](http://static.oschina.net/uploads/img/201504/16165918_xZtq.png \"image\")](http://static.oschina.net/uploads/img/201504/16165918_0GLM.png) [![image](http://static.oschina.net/uploads/img/201504/16165919_WpTX.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_YIKU.png) [![image](http://static.oschina.net/uploads/img/201504/16165919_0DmF.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_vrIa.png)\n\n### 步骤4：选择类型\n\n> Developer Machine(开发机器)，个人用桌面工作站，占用最少的系统资源\n> \n> Server Machine（服务器），MySQL服务器可以同其它应用程序一起运行，例如FTP、email和web服务器。MySQL服务器配置成使用适当比例的系统资源。\n> \n> Dedicated MySQL Server Machine（专用MySQL服务器）：该选项代表只运行MySQL服务的服务器。假定运行没有运行其它应用程序。MySQL服务器配置成使用所有可用系统资源。\n\n根据自己情况选择即可，一般WEB服务器选择第二个，Server Machine即可！个人电脑安装选择第一个，Developer Machine比较好。\n\n[![image](http://static.oschina.net/uploads/img/201504/16165920_8GEz.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_d9x7.png)\n\n### 步骤5：配置密码\n\n[![image](http://static.oschina.net/uploads/img/201504/16165920_c01w.png \"image\")](http://static.oschina.net/uploads/img/201504/16165920_a2cR.png)\n\n对应的界面中，我们需要设置root用户的密码，在“MySQL Root password”(输入新密码)和“Repeat Password”（确认）两个编辑框内输入期望的密码。也可以单击下面的【Add User】按钮另行添加新的用户。(**注:Current Root Password:为空；如果输入密码了在后面安装会报错**)\n\n### 步骤6：**设置Windows Service Name<可默认>，此名为启动数据库服务名，要记住。**\n\n[![image](http://static.oschina.net/uploads/img/201504/16165921_A9pr.png \"image\")](http://static.oschina.net/uploads/img/201504/16165921_kz1L.png)\n\n### 步骤7：验证服务：\n\n在开始菜单栏->**附件->**右键命令提示符->以管理员身份运行:\n\n```\nnet start MySQL56 为启动数据库服务命令；\n```\n\n```\nnet stop MySQL56  为停止数据库服务命令。\n```\n\n[![image](http://static.oschina.net/uploads/img/201504/16165921_qsYm.png \"image\")](http://static.oschina.net/uploads/img/201504/16165921_IAgd.png)\n\n### 步骤8：连接测试：\n\n进入bin目录，执行mysql -u root -p 回车输入密码\n\n```\nD:\\>cd D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin\nD:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin>mysql -u root -p\nEnter password: ****** Welcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 1 Server version: 5.6.24-log MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n```","slug":"mysql/Win8(X64)下MySQL5.6版本安装及配置","published":1,"updated":"2019-10-02T08:40:35.546Z","layout":"post","photos":[],"link":"","_id":"ck191nw7o000ib0wk3fg5peou","content":"<h3 id=\"步骤1：双击MySQL安装程序\"><a href=\"#步骤1：双击MySQL安装程序\" class=\"headerlink\" title=\"步骤1：双击MySQL安装程序\"></a>步骤1：双击MySQL安装程序</h3><p>官方网站<a href=\"http://dev.mysql.com/downloads/下载该软件\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/下载该软件</a></p>\n<h3 id=\"步骤2：“Install-MySQL-Products”-文字，会弹出的用户许可证协议窗口，安装类型设置窗口-安装类型界面各设置项含义\"><a href=\"#步骤2：“Install-MySQL-Products”-文字，会弹出的用户许可证协议窗口，安装类型设置窗口-安装类型界面各设置项含义\" class=\"headerlink\" title=\"步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:\"></a>步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:</h3><blockquote>\n<p>Developer Default 默认安装类型</p>\n<p>Server only 仅作为服务器</p>\n<p>Client only 仅作为客户端</p>\n<p>Full 完全安装类型</p>\n<p>Custom 用户自定义安装类型</p>\n<p>根据自己的情况选择安装，我们这里以自定义安装为例：</p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165918_FGf6.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165918_xBtP.png\" alt=\"image\" title=\"image\"></a></p>\n</blockquote>\n<h3 id=\"步骤3：选择安装内容及安装目录：\"><a href=\"#步骤3：选择安装内容及安装目录：\" class=\"headerlink\" title=\"步骤3：选择安装内容及安装目录：\"></a>步骤3：选择安装内容及安装目录：</h3><blockquote>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165918_0GLM.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165918_xZtq.png\" alt=\"image\" title=\"image\"></a> <a href=\"http://static.oschina.net/uploads/img/201504/16165919_YIKU.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165919_WpTX.png\" alt=\"image\" title=\"image\"></a> <a href=\"http://static.oschina.net/uploads/img/201504/16165919_vrIa.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165919_0DmF.png\" alt=\"image\" title=\"image\"></a></p>\n</blockquote>\n<h3 id=\"步骤4：选择类型\"><a href=\"#步骤4：选择类型\" class=\"headerlink\" title=\"步骤4：选择类型\"></a>步骤4：选择类型</h3><blockquote>\n<p>Developer Machine(开发机器)，个人用桌面工作站，占用最少的系统资源</p>\n<p>Server Machine（服务器），MySQL服务器可以同其它应用程序一起运行，例如FTP、email和web服务器。MySQL服务器配置成使用适当比例的系统资源。</p>\n<p>Dedicated MySQL Server Machine（专用MySQL服务器）：该选项代表只运行MySQL服务的服务器。假定运行没有运行其它应用程序。MySQL服务器配置成使用所有可用系统资源。</p>\n</blockquote>\n<p>根据自己情况选择即可，一般WEB服务器选择第二个，Server Machine即可！个人电脑安装选择第一个，Developer Machine比较好。</p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165919_d9x7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165920_8GEz.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤5：配置密码\"><a href=\"#步骤5：配置密码\" class=\"headerlink\" title=\"步骤5：配置密码\"></a>步骤5：配置密码</h3><p><a href=\"http://static.oschina.net/uploads/img/201504/16165920_a2cR.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165920_c01w.png\" alt=\"image\" title=\"image\"></a></p>\n<p>对应的界面中，我们需要设置root用户的密码，在“MySQL Root password”(输入新密码)和“Repeat Password”（确认）两个编辑框内输入期望的密码。也可以单击下面的【Add User】按钮另行添加新的用户。(<strong>注:Current Root Password:为空；如果输入密码了在后面安装会报错</strong>)</p>\n<h3 id=\"步骤6：设置Windows-Service-Name-lt-可默认-gt-，此名为启动数据库服务名，要记住。\"><a href=\"#步骤6：设置Windows-Service-Name-lt-可默认-gt-，此名为启动数据库服务名，要记住。\" class=\"headerlink\" title=\"步骤6：设置Windows Service Name&lt;可默认&gt;，此名为启动数据库服务名，要记住。\"></a>步骤6：<strong>设置Windows Service Name&lt;可默认&gt;，此名为启动数据库服务名，要记住。</strong></h3><p><a href=\"http://static.oschina.net/uploads/img/201504/16165921_kz1L.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165921_A9pr.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤7：验证服务：\"><a href=\"#步骤7：验证服务：\" class=\"headerlink\" title=\"步骤7：验证服务：\"></a>步骤7：验证服务：</h3><p>在开始菜单栏-&gt;<strong>附件-&gt;</strong>右键命令提示符-&gt;以管理员身份运行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net start MySQL56 为启动数据库服务命令；</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net stop MySQL56  为停止数据库服务命令。</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165921_IAgd.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165921_qsYm.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤8：连接测试：\"><a href=\"#步骤8：连接测试：\" class=\"headerlink\" title=\"步骤8：连接测试：\"></a>步骤8：连接测试：</h3><p>进入bin目录，执行mysql -u root -p 回车输入密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\&gt;cd D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin</span><br><span class=\"line\">D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password: ****** Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1 Server version: 5.6.24-log MySQL Community Server (GPL)</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\"></span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"步骤1：双击MySQL安装程序\"><a href=\"#步骤1：双击MySQL安装程序\" class=\"headerlink\" title=\"步骤1：双击MySQL安装程序\"></a>步骤1：双击MySQL安装程序</h3><p>官方网站<a href=\"http://dev.mysql.com/downloads/下载该软件\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/下载该软件</a></p>\n<h3 id=\"步骤2：“Install-MySQL-Products”-文字，会弹出的用户许可证协议窗口，安装类型设置窗口-安装类型界面各设置项含义\"><a href=\"#步骤2：“Install-MySQL-Products”-文字，会弹出的用户许可证协议窗口，安装类型设置窗口-安装类型界面各设置项含义\" class=\"headerlink\" title=\"步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:\"></a>步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:</h3><blockquote>\n<p>Developer Default 默认安装类型</p>\n<p>Server only 仅作为服务器</p>\n<p>Client only 仅作为客户端</p>\n<p>Full 完全安装类型</p>\n<p>Custom 用户自定义安装类型</p>\n<p>根据自己的情况选择安装，我们这里以自定义安装为例：</p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165918_FGf6.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165918_xBtP.png\" alt=\"image\" title=\"image\"></a></p>\n</blockquote>\n<h3 id=\"步骤3：选择安装内容及安装目录：\"><a href=\"#步骤3：选择安装内容及安装目录：\" class=\"headerlink\" title=\"步骤3：选择安装内容及安装目录：\"></a>步骤3：选择安装内容及安装目录：</h3><blockquote>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165918_0GLM.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165918_xZtq.png\" alt=\"image\" title=\"image\"></a> <a href=\"http://static.oschina.net/uploads/img/201504/16165919_YIKU.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165919_WpTX.png\" alt=\"image\" title=\"image\"></a> <a href=\"http://static.oschina.net/uploads/img/201504/16165919_vrIa.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165919_0DmF.png\" alt=\"image\" title=\"image\"></a></p>\n</blockquote>\n<h3 id=\"步骤4：选择类型\"><a href=\"#步骤4：选择类型\" class=\"headerlink\" title=\"步骤4：选择类型\"></a>步骤4：选择类型</h3><blockquote>\n<p>Developer Machine(开发机器)，个人用桌面工作站，占用最少的系统资源</p>\n<p>Server Machine（服务器），MySQL服务器可以同其它应用程序一起运行，例如FTP、email和web服务器。MySQL服务器配置成使用适当比例的系统资源。</p>\n<p>Dedicated MySQL Server Machine（专用MySQL服务器）：该选项代表只运行MySQL服务的服务器。假定运行没有运行其它应用程序。MySQL服务器配置成使用所有可用系统资源。</p>\n</blockquote>\n<p>根据自己情况选择即可，一般WEB服务器选择第二个，Server Machine即可！个人电脑安装选择第一个，Developer Machine比较好。</p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165919_d9x7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165920_8GEz.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤5：配置密码\"><a href=\"#步骤5：配置密码\" class=\"headerlink\" title=\"步骤5：配置密码\"></a>步骤5：配置密码</h3><p><a href=\"http://static.oschina.net/uploads/img/201504/16165920_a2cR.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165920_c01w.png\" alt=\"image\" title=\"image\"></a></p>\n<p>对应的界面中，我们需要设置root用户的密码，在“MySQL Root password”(输入新密码)和“Repeat Password”（确认）两个编辑框内输入期望的密码。也可以单击下面的【Add User】按钮另行添加新的用户。(<strong>注:Current Root Password:为空；如果输入密码了在后面安装会报错</strong>)</p>\n<h3 id=\"步骤6：设置Windows-Service-Name-lt-可默认-gt-，此名为启动数据库服务名，要记住。\"><a href=\"#步骤6：设置Windows-Service-Name-lt-可默认-gt-，此名为启动数据库服务名，要记住。\" class=\"headerlink\" title=\"步骤6：设置Windows Service Name&lt;可默认&gt;，此名为启动数据库服务名，要记住。\"></a>步骤6：<strong>设置Windows Service Name&lt;可默认&gt;，此名为启动数据库服务名，要记住。</strong></h3><p><a href=\"http://static.oschina.net/uploads/img/201504/16165921_kz1L.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165921_A9pr.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤7：验证服务：\"><a href=\"#步骤7：验证服务：\" class=\"headerlink\" title=\"步骤7：验证服务：\"></a>步骤7：验证服务：</h3><p>在开始菜单栏-&gt;<strong>附件-&gt;</strong>右键命令提示符-&gt;以管理员身份运行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net start MySQL56 为启动数据库服务命令；</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net stop MySQL56  为停止数据库服务命令。</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165921_IAgd.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165921_qsYm.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤8：连接测试：\"><a href=\"#步骤8：连接测试：\" class=\"headerlink\" title=\"步骤8：连接测试：\"></a>步骤8：连接测试：</h3><p>进入bin目录，执行mysql -u root -p 回车输入密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\&gt;cd D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin</span><br><span class=\"line\">D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password: ****** Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1 Server version: 5.6.24-log MySQL Community Server (GPL)</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\"></span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure>"},{"title":"Eclipse.ini参数设置","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-04-16T06:03:00.000Z","_content":"### vmargs下常见参数的意思：\n```\n-vmargs  \n-Xms40m  \n-Xmx256m  \n-XX:PermSize=64M  \n-XX:MaxPermSize=128M\n```\n\n- -vmargs: 说明后面是VM的参数  \n- -Xms40m: 虚拟机占用系统的最小内存,初始分配  \n- -Xmx256m: 虚拟机占用系统的最大内存,按需分配  \n- -XX:PermSize: 最小堆大小。一般报内存不足时,都是说这个太小, 堆空间剩余小于5%就会警告,建议把这个稍微设大一点,不过要视自己机器内存大小来设置，但不能超过MaxPermSize  \n- -XX:MaxPermSize: 最大堆大小。这个也适当大些所以若出现问题，首先请调整 `-Xms40m：`将其设置的小一些，就可以解决问题`PermSize`和`MaxPermSize`指虚拟机为java永久生成对象（Permanate generation）等这些可反射对象分配内 存的限制，这些内存不包括在Heap（堆内存）区之中.\n\n### 解决Failed to creat java virtual machine问题:  \n打开eclipse安装目录下的eclipse.ini文件，修改：  \n```\n--launcher.XXMaxPermSize  \n128M;  \n```\n为：\n```  \n--launcher.XXMaxPermSize  \n256m\n```\n设置Eclipse使用的JRE为本机安装的JDK目录：  \n在eclipse.ini中添加两行  \n```\n -vm  \nC:\\\\Program Files\\\\Java\\\\jdk1.6.0_10\\\\bin\\\\javaw.exe   \n```\n* 注意: 要写在两行，写在一行不能生效；这两行要定在-vmargs之前，不然也不能生效。\n\n### 我的eclipes.ini文件配置如下：\n\n```\n-startup\nplugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar\n--launcher.library\nplugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.200.v20140603-1326\n-product\norg.eclipse.epp.package.java.product\n-showsplash\norg.eclipse.platform\n--launcher.defaultAction\nopenFile\n--launcher.XXMaxPermSize\n384M\n-vm\nC:\\Program Files\\Java\\jre7\\bin\\javaw.exe\n-vmargs\n-Dcom.sun.management.jmxremote \n-Dosgi.requiredJavaVersion=1.6\n-Xverify:none\n-Xmn128m\n-Xms256m\n-Xmx768m\n-Xss1m\n-XX:PermSize=128M\n-XX:MaxPermSize=512M\n```","source":"_posts/ide/Eclipse.ini参数设置.md","raw":"title: Eclipse.ini参数设置\nauthor: JsonYe\ntags:\n  - eclipse\ncategories:\n  - IDE  \ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-04-16 14:03:00\n---\n### vmargs下常见参数的意思：\n```\n-vmargs  \n-Xms40m  \n-Xmx256m  \n-XX:PermSize=64M  \n-XX:MaxPermSize=128M\n```\n\n- -vmargs: 说明后面是VM的参数  \n- -Xms40m: 虚拟机占用系统的最小内存,初始分配  \n- -Xmx256m: 虚拟机占用系统的最大内存,按需分配  \n- -XX:PermSize: 最小堆大小。一般报内存不足时,都是说这个太小, 堆空间剩余小于5%就会警告,建议把这个稍微设大一点,不过要视自己机器内存大小来设置，但不能超过MaxPermSize  \n- -XX:MaxPermSize: 最大堆大小。这个也适当大些所以若出现问题，首先请调整 `-Xms40m：`将其设置的小一些，就可以解决问题`PermSize`和`MaxPermSize`指虚拟机为java永久生成对象（Permanate generation）等这些可反射对象分配内 存的限制，这些内存不包括在Heap（堆内存）区之中.\n\n### 解决Failed to creat java virtual machine问题:  \n打开eclipse安装目录下的eclipse.ini文件，修改：  \n```\n--launcher.XXMaxPermSize  \n128M;  \n```\n为：\n```  \n--launcher.XXMaxPermSize  \n256m\n```\n设置Eclipse使用的JRE为本机安装的JDK目录：  \n在eclipse.ini中添加两行  \n```\n -vm  \nC:\\\\Program Files\\\\Java\\\\jdk1.6.0_10\\\\bin\\\\javaw.exe   \n```\n* 注意: 要写在两行，写在一行不能生效；这两行要定在-vmargs之前，不然也不能生效。\n\n### 我的eclipes.ini文件配置如下：\n\n```\n-startup\nplugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar\n--launcher.library\nplugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.200.v20140603-1326\n-product\norg.eclipse.epp.package.java.product\n-showsplash\norg.eclipse.platform\n--launcher.defaultAction\nopenFile\n--launcher.XXMaxPermSize\n384M\n-vm\nC:\\Program Files\\Java\\jre7\\bin\\javaw.exe\n-vmargs\n-Dcom.sun.management.jmxremote \n-Dosgi.requiredJavaVersion=1.6\n-Xverify:none\n-Xmn128m\n-Xms256m\n-Xmx768m\n-Xss1m\n-XX:PermSize=128M\n-XX:MaxPermSize=512M\n```","slug":"ide/Eclipse.ini参数设置","published":1,"updated":"2019-10-02T08:42:28.543Z","layout":"post","photos":[],"link":"","_id":"ck191nw7u000kb0wk2nghig66","content":"<h3 id=\"vmargs下常见参数的意思：\"><a href=\"#vmargs下常见参数的意思：\" class=\"headerlink\" title=\"vmargs下常见参数的意思：\"></a>vmargs下常见参数的意思：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-vmargs  </span><br><span class=\"line\">-Xms40m  </span><br><span class=\"line\">-Xmx256m  </span><br><span class=\"line\">-XX:PermSize=64M  </span><br><span class=\"line\">-XX:MaxPermSize=128M</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-vmargs: 说明后面是VM的参数  </li>\n<li>-Xms40m: 虚拟机占用系统的最小内存,初始分配  </li>\n<li>-Xmx256m: 虚拟机占用系统的最大内存,按需分配  </li>\n<li>-XX:PermSize: 最小堆大小。一般报内存不足时,都是说这个太小, 堆空间剩余小于5%就会警告,建议把这个稍微设大一点,不过要视自己机器内存大小来设置，但不能超过MaxPermSize  </li>\n<li>-XX:MaxPermSize: 最大堆大小。这个也适当大些所以若出现问题，首先请调整 <code>-Xms40m：</code>将其设置的小一些，就可以解决问题<code>PermSize</code>和<code>MaxPermSize</code>指虚拟机为java永久生成对象（Permanate generation）等这些可反射对象分配内 存的限制，这些内存不包括在Heap（堆内存）区之中.</li>\n</ul>\n<h3 id=\"解决Failed-to-creat-java-virtual-machine问题\"><a href=\"#解决Failed-to-creat-java-virtual-machine问题\" class=\"headerlink\" title=\"解决Failed to creat java virtual machine问题:\"></a>解决Failed to creat java virtual machine问题:</h3><p>打开eclipse安装目录下的eclipse.ini文件，修改：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--launcher.XXMaxPermSize  </span><br><span class=\"line\">128M;</span><br></pre></td></tr></table></figure>\n\n<p>为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--launcher.XXMaxPermSize  </span><br><span class=\"line\">256m</span><br></pre></td></tr></table></figure>\n\n<p>设置Eclipse使用的JRE为本机安装的JDK目录：<br>在eclipse.ini中添加两行  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> -vm  </span><br><span class=\"line\">C:\\\\Program Files\\\\Java\\\\jdk1.6.0_10\\\\bin\\\\javaw.exe</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意: 要写在两行，写在一行不能生效；这两行要定在-vmargs之前，不然也不能生效。</li>\n</ul>\n<h3 id=\"我的eclipes-ini文件配置如下：\"><a href=\"#我的eclipes-ini文件配置如下：\" class=\"headerlink\" title=\"我的eclipes.ini文件配置如下：\"></a>我的eclipes.ini文件配置如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-startup</span><br><span class=\"line\">plugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar</span><br><span class=\"line\">--launcher.library</span><br><span class=\"line\">plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.200.v20140603-1326</span><br><span class=\"line\">-product</span><br><span class=\"line\">org.eclipse.epp.package.java.product</span><br><span class=\"line\">-showsplash</span><br><span class=\"line\">org.eclipse.platform</span><br><span class=\"line\">--launcher.defaultAction</span><br><span class=\"line\">openFile</span><br><span class=\"line\">--launcher.XXMaxPermSize</span><br><span class=\"line\">384M</span><br><span class=\"line\">-vm</span><br><span class=\"line\">C:\\Program Files\\Java\\jre7\\bin\\javaw.exe</span><br><span class=\"line\">-vmargs</span><br><span class=\"line\">-Dcom.sun.management.jmxremote </span><br><span class=\"line\">-Dosgi.requiredJavaVersion=1.6</span><br><span class=\"line\">-Xverify:none</span><br><span class=\"line\">-Xmn128m</span><br><span class=\"line\">-Xms256m</span><br><span class=\"line\">-Xmx768m</span><br><span class=\"line\">-Xss1m</span><br><span class=\"line\">-XX:PermSize=128M</span><br><span class=\"line\">-XX:MaxPermSize=512M</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vmargs下常见参数的意思：\"><a href=\"#vmargs下常见参数的意思：\" class=\"headerlink\" title=\"vmargs下常见参数的意思：\"></a>vmargs下常见参数的意思：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-vmargs  </span><br><span class=\"line\">-Xms40m  </span><br><span class=\"line\">-Xmx256m  </span><br><span class=\"line\">-XX:PermSize=64M  </span><br><span class=\"line\">-XX:MaxPermSize=128M</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-vmargs: 说明后面是VM的参数  </li>\n<li>-Xms40m: 虚拟机占用系统的最小内存,初始分配  </li>\n<li>-Xmx256m: 虚拟机占用系统的最大内存,按需分配  </li>\n<li>-XX:PermSize: 最小堆大小。一般报内存不足时,都是说这个太小, 堆空间剩余小于5%就会警告,建议把这个稍微设大一点,不过要视自己机器内存大小来设置，但不能超过MaxPermSize  </li>\n<li>-XX:MaxPermSize: 最大堆大小。这个也适当大些所以若出现问题，首先请调整 <code>-Xms40m：</code>将其设置的小一些，就可以解决问题<code>PermSize</code>和<code>MaxPermSize</code>指虚拟机为java永久生成对象（Permanate generation）等这些可反射对象分配内 存的限制，这些内存不包括在Heap（堆内存）区之中.</li>\n</ul>\n<h3 id=\"解决Failed-to-creat-java-virtual-machine问题\"><a href=\"#解决Failed-to-creat-java-virtual-machine问题\" class=\"headerlink\" title=\"解决Failed to creat java virtual machine问题:\"></a>解决Failed to creat java virtual machine问题:</h3><p>打开eclipse安装目录下的eclipse.ini文件，修改：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--launcher.XXMaxPermSize  </span><br><span class=\"line\">128M;</span><br></pre></td></tr></table></figure>\n\n<p>为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--launcher.XXMaxPermSize  </span><br><span class=\"line\">256m</span><br></pre></td></tr></table></figure>\n\n<p>设置Eclipse使用的JRE为本机安装的JDK目录：<br>在eclipse.ini中添加两行  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> -vm  </span><br><span class=\"line\">C:\\\\Program Files\\\\Java\\\\jdk1.6.0_10\\\\bin\\\\javaw.exe</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意: 要写在两行，写在一行不能生效；这两行要定在-vmargs之前，不然也不能生效。</li>\n</ul>\n<h3 id=\"我的eclipes-ini文件配置如下：\"><a href=\"#我的eclipes-ini文件配置如下：\" class=\"headerlink\" title=\"我的eclipes.ini文件配置如下：\"></a>我的eclipes.ini文件配置如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-startup</span><br><span class=\"line\">plugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar</span><br><span class=\"line\">--launcher.library</span><br><span class=\"line\">plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.200.v20140603-1326</span><br><span class=\"line\">-product</span><br><span class=\"line\">org.eclipse.epp.package.java.product</span><br><span class=\"line\">-showsplash</span><br><span class=\"line\">org.eclipse.platform</span><br><span class=\"line\">--launcher.defaultAction</span><br><span class=\"line\">openFile</span><br><span class=\"line\">--launcher.XXMaxPermSize</span><br><span class=\"line\">384M</span><br><span class=\"line\">-vm</span><br><span class=\"line\">C:\\Program Files\\Java\\jre7\\bin\\javaw.exe</span><br><span class=\"line\">-vmargs</span><br><span class=\"line\">-Dcom.sun.management.jmxremote </span><br><span class=\"line\">-Dosgi.requiredJavaVersion=1.6</span><br><span class=\"line\">-Xverify:none</span><br><span class=\"line\">-Xmn128m</span><br><span class=\"line\">-Xms256m</span><br><span class=\"line\">-Xmx768m</span><br><span class=\"line\">-Xss1m</span><br><span class=\"line\">-XX:PermSize=128M</span><br><span class=\"line\">-XX:MaxPermSize=512M</span><br></pre></td></tr></table></figure>"},{"title":"数据库表命令","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2017-01-12T10:59:00.000Z","_content":"## 数据表操作\n```\n-- 创建数据库\nCREATE DATABASE mydb\n\n-- 使用数据库\nUSE mydb\n\n-- 查看数据表\nSHOW TABLES\n\n-- 创建表\nCREATE TABLE pet (\n\tNAME VARCHAR(20),\n\townerr\tVARCHAR(20),\n\tspecies VARCHAR(20),\n\tsex CHAR(1),\n\tbirth DATE,\n\tdeath DATE);\n\n-- 显示表结构\nDESCRIBE pet;\n-- 改表的名字 \nALTER TABLE pet RENAME TO pet2; \nALTER TABLE pet2 RENAME TO pet; \n\n-- 约束：约束（主键Primary key、唯一性Unique、非空Not Null）\n-- 自动增张 auto_increment \n-- 外键Foreign key-----与reference table_name(col_name列名)配合使用，建表时单独使用 \n-- 删除多个表中有关联的数据----设置foreign key 为set null\n\n-- 删除表\nDROP TABLE IF EXISTS pet;\n\n-- 增加一个字段： \nALTER TABLE pet ADD COLUMN (phone VARCHAR(11)); \n\n-- 删除一个字段\nALTER TABLE pet DROP phone; \n\n-- 修改字段名称/类型\nALTER TABLE pet CHANGE phone tel VARCHAR(11)\nALTER TABLE pet CHANGE tel phone VARCHAR(11)\n\n-- 插入数据\nINSERT INTO pet VALUES\n\t('Fluffy','Harold','cat','f','1993-02-04',NULL),\n\t('Claws','Gwen','cat','m','1994-03-17',NULL),\n\t('Buffy','Harold','dog','f','1989-05-13',NULL),\n\t('Fang','Benny','dog','m','1990-08-27',NULL),\n\t('Bowser','Diane','dog','m','1979-08-31','1995-07-29'),\n\t('Chirpy','Gwen','bird','f','1998-09-11',NULL),\n\t('Whistler','Gwen','bird',' ','1997-12-09',NULL),\n\t('Puffball','Diane','hamster','f','1999-03-30',NULL),\n\t('Slim','Benny','snake','m','1996-04-29',NULL);\n-- 查询表数据\nSELECT * FROM pet\n-- 清空表数据\nDELETE FROM pet\n-- 此方法也会使表中的取号器(ID)从1开始\nTRUNCATE TABLE pet; \n\n-- 修改字段值\nUPDATE pet SET birth = '1989-08-31' WHERE NAME = 'Bowser'\nSELECT * FROM pet WHERE NAME = 'Bowser'\n```\n## 数据表查询\n### 基本查询\n```\n-- DISTINCT 检索出每个唯一的输出记录\nSELECT DISTINCT ownerr FROM pet\n\n-- 排序 order by，对于等同但大小写不同的列，并未定义其顺序，某一列，可以使用BINARY强制执行区分大小写的分类功能，如：ORDER BY BINARY col_name. \nSELECT NAME,ownerr,birth FROM pet ORDER BY birth\n-- 默认排序是升序，可以利用关键字进行控制。DESC(降序)、ASC(升序)\nSELECT NAME,ownerr,birth FROM pet ORDER BY birth ASC\n\n-- 多列进行排序\nSELECT NAME,ownerr,birth FROM pet ORDER BY ownerr,birth DESC\n```\n### 日期计算\n```\n-- YEAR()-提取日期的年部分，MONTH()-提取月份，DAYOFMONTH()-提取所在月份中的日\nSELECT birth, YEAR(birth),MONTH(birth),DAYOFMONTH(birth) FROM pet\n\n-- RIGHT(birth,5)-提取birth的右边5个字符,LEFT - 从左边开始取，MID - 从指定位置(包括)开始取指定长度\nSELECT RIGHT('1234567890',5),LEFT('1234567890',5),MID('1234567890',2,4)\n-- 提出已近死亡的\n-- 出生月份大于当前月份，年龄-1。\nSELECT \n  NAME,\n  birth,\n  CURDATE(),\n  (YEAR(CURDATE()) - YEAR(birth)) - (RIGHT(CURDATE(), 5) < RIGHT(birth, 5)) AS age \nFROM\n  pet WHERE death IS NULL  ORDER BY age\n  \n -- 查询已死亡的年龄\n SELECT \n  NAME,\n  birth,\n  death,\n  (YEAR(death) - YEAR(birth)) - (RIGHT(death, 5) < RIGHT(birth, 5)) AS age \nFROM\n  pet WHERE death IS NOT NULL ORDER BY age\n\n-- 查询下一个月谁过生日\nSELECT * FROM pet ORDER BY MONTH(birth)\nSELECT * FROM pet WHERE MONTH(birth) = MONTH(CURDATE()) + 1\nSELECT * FROM pet WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH))\n```\n### NULL值\n```\n-- NULL 值的判断，不能使用比较运算符，只能用 is null 或 is not null\nSELECT  1 = NULL, 1 > NULL, 1 < NULL,  1 IS NULL,  1 IS NOT NULL \n\n-- 0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1。\nSELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;\n```\n### 模糊匹配\n```\n-- MySQL提供标准的SQL模式匹配，以及一种基于象Unix实用程序如vi、grep和sed的扩展正则表达式模式匹配的格式。\n-- \"_\" 匹配任何单个字符；\"%\" 匹配任意数目字符(包括零字符)，SQL的模式默认是忽略大小写。关键字 LIKE 或 NOT LINK\n\n-- 查找以b开头的name\nSELECT * FROM pet WHERE NAME LIKE 'b%'\n-- 查找以'fy'结尾的名字\nSELECT * FROM pet WHERE NAME LIKE '%fy'\n-- 查找包含w的名字\nSELECT * FROM pet WHERE NAME LIKE '%w%'\n-- 查找正好是5个字符的名字\nSELECT * FROM pet WHERE NAME LIKE '_____'\nSELECT * FROM pet WHERE LENGTH(NAME) = 5\n\n-- MySQL提供的模式匹配的其它类型是使用扩展正则表达式。当你对这类模式进行匹配测试时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，它们是同义词)。 \n-- \".\" 匹配任何单个字符；\n-- \"[...]\" 匹配在方括号内的任何字符，为了命名字符的范围，使用一个“-”。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。\n-- \"*\" 匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的“x”字符，“[0-9]*”匹配任何数量的数字，而“.*”匹配任何数量的任何字符。\n-- 如果REGEXP模式与被测试值的任何地方匹配，模式就匹配(这不同于LIKE模式匹配，只有与整个值匹配，模式才匹配)。 \n-- 为了定位一个模式以便它必须匹配被测试值的开始或结尾，在模式开始处使用“^”或在模式的结尾用“$”。\n\n-- 查找以b开头的name\nSELECT * FROM pet WHERE NAME REGEXP '^b'\n-- 查找以'fy'结尾的名字\nSELECT * FROM pet WHERE NAME REGEXP 'fy$'\n-- 查找包含w的名字\nSELECT * FROM pet WHERE NAME REGEXP 'w'\n-- 查找正好是5个字符的名字\nSELECT * FROM pet WHERE NAME REGEXP '^.....$'\nSELECT * FROM pet WHERE NAME REGEXP '^.{5}$'\n```\n[正则表达式在线参考](http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/regexp.html)","source":"_posts/mysql/数据表命令.md","raw":"---\ntitle: 数据库表命令\nauthor: JsonYe\ntags:\n  - mysql\n  - 数据库\ncategories:\n  - MySql \ncopyright: true\ncomments: true\ntoc: true\ndate: 2017-01-12 18:59:00\n---\n## 数据表操作\n```\n-- 创建数据库\nCREATE DATABASE mydb\n\n-- 使用数据库\nUSE mydb\n\n-- 查看数据表\nSHOW TABLES\n\n-- 创建表\nCREATE TABLE pet (\n\tNAME VARCHAR(20),\n\townerr\tVARCHAR(20),\n\tspecies VARCHAR(20),\n\tsex CHAR(1),\n\tbirth DATE,\n\tdeath DATE);\n\n-- 显示表结构\nDESCRIBE pet;\n-- 改表的名字 \nALTER TABLE pet RENAME TO pet2; \nALTER TABLE pet2 RENAME TO pet; \n\n-- 约束：约束（主键Primary key、唯一性Unique、非空Not Null）\n-- 自动增张 auto_increment \n-- 外键Foreign key-----与reference table_name(col_name列名)配合使用，建表时单独使用 \n-- 删除多个表中有关联的数据----设置foreign key 为set null\n\n-- 删除表\nDROP TABLE IF EXISTS pet;\n\n-- 增加一个字段： \nALTER TABLE pet ADD COLUMN (phone VARCHAR(11)); \n\n-- 删除一个字段\nALTER TABLE pet DROP phone; \n\n-- 修改字段名称/类型\nALTER TABLE pet CHANGE phone tel VARCHAR(11)\nALTER TABLE pet CHANGE tel phone VARCHAR(11)\n\n-- 插入数据\nINSERT INTO pet VALUES\n\t('Fluffy','Harold','cat','f','1993-02-04',NULL),\n\t('Claws','Gwen','cat','m','1994-03-17',NULL),\n\t('Buffy','Harold','dog','f','1989-05-13',NULL),\n\t('Fang','Benny','dog','m','1990-08-27',NULL),\n\t('Bowser','Diane','dog','m','1979-08-31','1995-07-29'),\n\t('Chirpy','Gwen','bird','f','1998-09-11',NULL),\n\t('Whistler','Gwen','bird',' ','1997-12-09',NULL),\n\t('Puffball','Diane','hamster','f','1999-03-30',NULL),\n\t('Slim','Benny','snake','m','1996-04-29',NULL);\n-- 查询表数据\nSELECT * FROM pet\n-- 清空表数据\nDELETE FROM pet\n-- 此方法也会使表中的取号器(ID)从1开始\nTRUNCATE TABLE pet; \n\n-- 修改字段值\nUPDATE pet SET birth = '1989-08-31' WHERE NAME = 'Bowser'\nSELECT * FROM pet WHERE NAME = 'Bowser'\n```\n## 数据表查询\n### 基本查询\n```\n-- DISTINCT 检索出每个唯一的输出记录\nSELECT DISTINCT ownerr FROM pet\n\n-- 排序 order by，对于等同但大小写不同的列，并未定义其顺序，某一列，可以使用BINARY强制执行区分大小写的分类功能，如：ORDER BY BINARY col_name. \nSELECT NAME,ownerr,birth FROM pet ORDER BY birth\n-- 默认排序是升序，可以利用关键字进行控制。DESC(降序)、ASC(升序)\nSELECT NAME,ownerr,birth FROM pet ORDER BY birth ASC\n\n-- 多列进行排序\nSELECT NAME,ownerr,birth FROM pet ORDER BY ownerr,birth DESC\n```\n### 日期计算\n```\n-- YEAR()-提取日期的年部分，MONTH()-提取月份，DAYOFMONTH()-提取所在月份中的日\nSELECT birth, YEAR(birth),MONTH(birth),DAYOFMONTH(birth) FROM pet\n\n-- RIGHT(birth,5)-提取birth的右边5个字符,LEFT - 从左边开始取，MID - 从指定位置(包括)开始取指定长度\nSELECT RIGHT('1234567890',5),LEFT('1234567890',5),MID('1234567890',2,4)\n-- 提出已近死亡的\n-- 出生月份大于当前月份，年龄-1。\nSELECT \n  NAME,\n  birth,\n  CURDATE(),\n  (YEAR(CURDATE()) - YEAR(birth)) - (RIGHT(CURDATE(), 5) < RIGHT(birth, 5)) AS age \nFROM\n  pet WHERE death IS NULL  ORDER BY age\n  \n -- 查询已死亡的年龄\n SELECT \n  NAME,\n  birth,\n  death,\n  (YEAR(death) - YEAR(birth)) - (RIGHT(death, 5) < RIGHT(birth, 5)) AS age \nFROM\n  pet WHERE death IS NOT NULL ORDER BY age\n\n-- 查询下一个月谁过生日\nSELECT * FROM pet ORDER BY MONTH(birth)\nSELECT * FROM pet WHERE MONTH(birth) = MONTH(CURDATE()) + 1\nSELECT * FROM pet WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH))\n```\n### NULL值\n```\n-- NULL 值的判断，不能使用比较运算符，只能用 is null 或 is not null\nSELECT  1 = NULL, 1 > NULL, 1 < NULL,  1 IS NULL,  1 IS NOT NULL \n\n-- 0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1。\nSELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;\n```\n### 模糊匹配\n```\n-- MySQL提供标准的SQL模式匹配，以及一种基于象Unix实用程序如vi、grep和sed的扩展正则表达式模式匹配的格式。\n-- \"_\" 匹配任何单个字符；\"%\" 匹配任意数目字符(包括零字符)，SQL的模式默认是忽略大小写。关键字 LIKE 或 NOT LINK\n\n-- 查找以b开头的name\nSELECT * FROM pet WHERE NAME LIKE 'b%'\n-- 查找以'fy'结尾的名字\nSELECT * FROM pet WHERE NAME LIKE '%fy'\n-- 查找包含w的名字\nSELECT * FROM pet WHERE NAME LIKE '%w%'\n-- 查找正好是5个字符的名字\nSELECT * FROM pet WHERE NAME LIKE '_____'\nSELECT * FROM pet WHERE LENGTH(NAME) = 5\n\n-- MySQL提供的模式匹配的其它类型是使用扩展正则表达式。当你对这类模式进行匹配测试时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，它们是同义词)。 \n-- \".\" 匹配任何单个字符；\n-- \"[...]\" 匹配在方括号内的任何字符，为了命名字符的范围，使用一个“-”。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。\n-- \"*\" 匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的“x”字符，“[0-9]*”匹配任何数量的数字，而“.*”匹配任何数量的任何字符。\n-- 如果REGEXP模式与被测试值的任何地方匹配，模式就匹配(这不同于LIKE模式匹配，只有与整个值匹配，模式才匹配)。 \n-- 为了定位一个模式以便它必须匹配被测试值的开始或结尾，在模式开始处使用“^”或在模式的结尾用“$”。\n\n-- 查找以b开头的name\nSELECT * FROM pet WHERE NAME REGEXP '^b'\n-- 查找以'fy'结尾的名字\nSELECT * FROM pet WHERE NAME REGEXP 'fy$'\n-- 查找包含w的名字\nSELECT * FROM pet WHERE NAME REGEXP 'w'\n-- 查找正好是5个字符的名字\nSELECT * FROM pet WHERE NAME REGEXP '^.....$'\nSELECT * FROM pet WHERE NAME REGEXP '^.{5}$'\n```\n[正则表达式在线参考](http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/regexp.html)","slug":"mysql/数据表命令","published":1,"updated":"2019-10-02T08:46:10.954Z","layout":"post","photos":[],"link":"","_id":"ck191nwf8001ab0wkbwfpor85","content":"<h2 id=\"数据表操作\"><a href=\"#数据表操作\" class=\"headerlink\" title=\"数据表操作\"></a>数据表操作</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 创建数据库</span><br><span class=\"line\">CREATE DATABASE mydb</span><br><span class=\"line\"></span><br><span class=\"line\">-- 使用数据库</span><br><span class=\"line\">USE mydb</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查看数据表</span><br><span class=\"line\">SHOW TABLES</span><br><span class=\"line\"></span><br><span class=\"line\">-- 创建表</span><br><span class=\"line\">CREATE TABLE pet (</span><br><span class=\"line\">\tNAME VARCHAR(20),</span><br><span class=\"line\">\townerr\tVARCHAR(20),</span><br><span class=\"line\">\tspecies VARCHAR(20),</span><br><span class=\"line\">\tsex CHAR(1),</span><br><span class=\"line\">\tbirth DATE,</span><br><span class=\"line\">\tdeath DATE);</span><br><span class=\"line\"></span><br><span class=\"line\">-- 显示表结构</span><br><span class=\"line\">DESCRIBE pet;</span><br><span class=\"line\">-- 改表的名字 </span><br><span class=\"line\">ALTER TABLE pet RENAME TO pet2; </span><br><span class=\"line\">ALTER TABLE pet2 RENAME TO pet; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 约束：约束（主键Primary key、唯一性Unique、非空Not Null）</span><br><span class=\"line\">-- 自动增张 auto_increment </span><br><span class=\"line\">-- 外键Foreign key-----与reference table_name(col_name列名)配合使用，建表时单独使用 </span><br><span class=\"line\">-- 删除多个表中有关联的数据----设置foreign key 为set null</span><br><span class=\"line\"></span><br><span class=\"line\">-- 删除表</span><br><span class=\"line\">DROP TABLE IF EXISTS pet;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 增加一个字段： </span><br><span class=\"line\">ALTER TABLE pet ADD COLUMN (phone VARCHAR(11)); </span><br><span class=\"line\"></span><br><span class=\"line\">-- 删除一个字段</span><br><span class=\"line\">ALTER TABLE pet DROP phone; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 修改字段名称/类型</span><br><span class=\"line\">ALTER TABLE pet CHANGE phone tel VARCHAR(11)</span><br><span class=\"line\">ALTER TABLE pet CHANGE tel phone VARCHAR(11)</span><br><span class=\"line\"></span><br><span class=\"line\">-- 插入数据</span><br><span class=\"line\">INSERT INTO pet VALUES</span><br><span class=\"line\">\t(&apos;Fluffy&apos;,&apos;Harold&apos;,&apos;cat&apos;,&apos;f&apos;,&apos;1993-02-04&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Claws&apos;,&apos;Gwen&apos;,&apos;cat&apos;,&apos;m&apos;,&apos;1994-03-17&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Buffy&apos;,&apos;Harold&apos;,&apos;dog&apos;,&apos;f&apos;,&apos;1989-05-13&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Fang&apos;,&apos;Benny&apos;,&apos;dog&apos;,&apos;m&apos;,&apos;1990-08-27&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Bowser&apos;,&apos;Diane&apos;,&apos;dog&apos;,&apos;m&apos;,&apos;1979-08-31&apos;,&apos;1995-07-29&apos;),</span><br><span class=\"line\">\t(&apos;Chirpy&apos;,&apos;Gwen&apos;,&apos;bird&apos;,&apos;f&apos;,&apos;1998-09-11&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Whistler&apos;,&apos;Gwen&apos;,&apos;bird&apos;,&apos; &apos;,&apos;1997-12-09&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Puffball&apos;,&apos;Diane&apos;,&apos;hamster&apos;,&apos;f&apos;,&apos;1999-03-30&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Slim&apos;,&apos;Benny&apos;,&apos;snake&apos;,&apos;m&apos;,&apos;1996-04-29&apos;,NULL);</span><br><span class=\"line\">-- 查询表数据</span><br><span class=\"line\">SELECT * FROM pet</span><br><span class=\"line\">-- 清空表数据</span><br><span class=\"line\">DELETE FROM pet</span><br><span class=\"line\">-- 此方法也会使表中的取号器(ID)从1开始</span><br><span class=\"line\">TRUNCATE TABLE pet; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 修改字段值</span><br><span class=\"line\">UPDATE pet SET birth = &apos;1989-08-31&apos; WHERE NAME = &apos;Bowser&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME = &apos;Bowser&apos;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据表查询\"><a href=\"#数据表查询\" class=\"headerlink\" title=\"数据表查询\"></a>数据表查询</h2><h3 id=\"基本查询\"><a href=\"#基本查询\" class=\"headerlink\" title=\"基本查询\"></a>基本查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- DISTINCT 检索出每个唯一的输出记录</span><br><span class=\"line\">SELECT DISTINCT ownerr FROM pet</span><br><span class=\"line\"></span><br><span class=\"line\">-- 排序 order by，对于等同但大小写不同的列，并未定义其顺序，某一列，可以使用BINARY强制执行区分大小写的分类功能，如：ORDER BY BINARY col_name. </span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY birth</span><br><span class=\"line\">-- 默认排序是升序，可以利用关键字进行控制。DESC(降序)、ASC(升序)</span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY birth ASC</span><br><span class=\"line\"></span><br><span class=\"line\">-- 多列进行排序</span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY ownerr,birth DESC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日期计算\"><a href=\"#日期计算\" class=\"headerlink\" title=\"日期计算\"></a>日期计算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- YEAR()-提取日期的年部分，MONTH()-提取月份，DAYOFMONTH()-提取所在月份中的日</span><br><span class=\"line\">SELECT birth, YEAR(birth),MONTH(birth),DAYOFMONTH(birth) FROM pet</span><br><span class=\"line\"></span><br><span class=\"line\">-- RIGHT(birth,5)-提取birth的右边5个字符,LEFT - 从左边开始取，MID - 从指定位置(包括)开始取指定长度</span><br><span class=\"line\">SELECT RIGHT(&apos;1234567890&apos;,5),LEFT(&apos;1234567890&apos;,5),MID(&apos;1234567890&apos;,2,4)</span><br><span class=\"line\">-- 提出已近死亡的</span><br><span class=\"line\">-- 出生月份大于当前月份，年龄-1。</span><br><span class=\"line\">SELECT </span><br><span class=\"line\">  NAME,</span><br><span class=\"line\">  birth,</span><br><span class=\"line\">  CURDATE(),</span><br><span class=\"line\">  (YEAR(CURDATE()) - YEAR(birth)) - (RIGHT(CURDATE(), 5) &lt; RIGHT(birth, 5)) AS age </span><br><span class=\"line\">FROM</span><br><span class=\"line\">  pet WHERE death IS NULL  ORDER BY age</span><br><span class=\"line\">  </span><br><span class=\"line\"> -- 查询已死亡的年龄</span><br><span class=\"line\"> SELECT </span><br><span class=\"line\">  NAME,</span><br><span class=\"line\">  birth,</span><br><span class=\"line\">  death,</span><br><span class=\"line\">  (YEAR(death) - YEAR(birth)) - (RIGHT(death, 5) &lt; RIGHT(birth, 5)) AS age </span><br><span class=\"line\">FROM</span><br><span class=\"line\">  pet WHERE death IS NOT NULL ORDER BY age</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查询下一个月谁过生日</span><br><span class=\"line\">SELECT * FROM pet ORDER BY MONTH(birth)</span><br><span class=\"line\">SELECT * FROM pet WHERE MONTH(birth) = MONTH(CURDATE()) + 1</span><br><span class=\"line\">SELECT * FROM pet WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NULL值\"><a href=\"#NULL值\" class=\"headerlink\" title=\"NULL值\"></a>NULL值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- NULL 值的判断，不能使用比较运算符，只能用 is null 或 is not null</span><br><span class=\"line\">SELECT  1 = NULL, 1 &gt; NULL, 1 &lt; NULL,  1 IS NULL,  1 IS NOT NULL </span><br><span class=\"line\"></span><br><span class=\"line\">-- 0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1。</span><br><span class=\"line\">SELECT 0 IS NULL, 0 IS NOT NULL, &apos;&apos; IS NULL, &apos;&apos; IS NOT NULL;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模糊匹配\"><a href=\"#模糊匹配\" class=\"headerlink\" title=\"模糊匹配\"></a>模糊匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- MySQL提供标准的SQL模式匹配，以及一种基于象Unix实用程序如vi、grep和sed的扩展正则表达式模式匹配的格式。</span><br><span class=\"line\">-- &quot;_&quot; 匹配任何单个字符；&quot;%&quot; 匹配任意数目字符(包括零字符)，SQL的模式默认是忽略大小写。关键字 LIKE 或 NOT LINK</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找以b开头的name</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;b%&apos;</span><br><span class=\"line\">-- 查找以&apos;fy&apos;结尾的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;%fy&apos;</span><br><span class=\"line\">-- 查找包含w的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;%w%&apos;</span><br><span class=\"line\">-- 查找正好是5个字符的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;_____&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE LENGTH(NAME) = 5</span><br><span class=\"line\"></span><br><span class=\"line\">-- MySQL提供的模式匹配的其它类型是使用扩展正则表达式。当你对这类模式进行匹配测试时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，它们是同义词)。 </span><br><span class=\"line\">-- &quot;.&quot; 匹配任何单个字符；</span><br><span class=\"line\">-- &quot;[...]&quot; 匹配在方括号内的任何字符，为了命名字符的范围，使用一个“-”。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</span><br><span class=\"line\">-- &quot;*&quot; 匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的“x”字符，“[0-9]*”匹配任何数量的数字，而“.*”匹配任何数量的任何字符。</span><br><span class=\"line\">-- 如果REGEXP模式与被测试值的任何地方匹配，模式就匹配(这不同于LIKE模式匹配，只有与整个值匹配，模式才匹配)。 </span><br><span class=\"line\">-- 为了定位一个模式以便它必须匹配被测试值的开始或结尾，在模式开始处使用“^”或在模式的结尾用“$”。</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找以b开头的name</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^b&apos;</span><br><span class=\"line\">-- 查找以&apos;fy&apos;结尾的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;fy$&apos;</span><br><span class=\"line\">-- 查找包含w的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;w&apos;</span><br><span class=\"line\">-- 查找正好是5个字符的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^.....$&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^.&#123;5&#125;$&apos;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/regexp.html\" target=\"_blank\" rel=\"noopener\">正则表达式在线参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据表操作\"><a href=\"#数据表操作\" class=\"headerlink\" title=\"数据表操作\"></a>数据表操作</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 创建数据库</span><br><span class=\"line\">CREATE DATABASE mydb</span><br><span class=\"line\"></span><br><span class=\"line\">-- 使用数据库</span><br><span class=\"line\">USE mydb</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查看数据表</span><br><span class=\"line\">SHOW TABLES</span><br><span class=\"line\"></span><br><span class=\"line\">-- 创建表</span><br><span class=\"line\">CREATE TABLE pet (</span><br><span class=\"line\">\tNAME VARCHAR(20),</span><br><span class=\"line\">\townerr\tVARCHAR(20),</span><br><span class=\"line\">\tspecies VARCHAR(20),</span><br><span class=\"line\">\tsex CHAR(1),</span><br><span class=\"line\">\tbirth DATE,</span><br><span class=\"line\">\tdeath DATE);</span><br><span class=\"line\"></span><br><span class=\"line\">-- 显示表结构</span><br><span class=\"line\">DESCRIBE pet;</span><br><span class=\"line\">-- 改表的名字 </span><br><span class=\"line\">ALTER TABLE pet RENAME TO pet2; </span><br><span class=\"line\">ALTER TABLE pet2 RENAME TO pet; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 约束：约束（主键Primary key、唯一性Unique、非空Not Null）</span><br><span class=\"line\">-- 自动增张 auto_increment </span><br><span class=\"line\">-- 外键Foreign key-----与reference table_name(col_name列名)配合使用，建表时单独使用 </span><br><span class=\"line\">-- 删除多个表中有关联的数据----设置foreign key 为set null</span><br><span class=\"line\"></span><br><span class=\"line\">-- 删除表</span><br><span class=\"line\">DROP TABLE IF EXISTS pet;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 增加一个字段： </span><br><span class=\"line\">ALTER TABLE pet ADD COLUMN (phone VARCHAR(11)); </span><br><span class=\"line\"></span><br><span class=\"line\">-- 删除一个字段</span><br><span class=\"line\">ALTER TABLE pet DROP phone; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 修改字段名称/类型</span><br><span class=\"line\">ALTER TABLE pet CHANGE phone tel VARCHAR(11)</span><br><span class=\"line\">ALTER TABLE pet CHANGE tel phone VARCHAR(11)</span><br><span class=\"line\"></span><br><span class=\"line\">-- 插入数据</span><br><span class=\"line\">INSERT INTO pet VALUES</span><br><span class=\"line\">\t(&apos;Fluffy&apos;,&apos;Harold&apos;,&apos;cat&apos;,&apos;f&apos;,&apos;1993-02-04&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Claws&apos;,&apos;Gwen&apos;,&apos;cat&apos;,&apos;m&apos;,&apos;1994-03-17&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Buffy&apos;,&apos;Harold&apos;,&apos;dog&apos;,&apos;f&apos;,&apos;1989-05-13&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Fang&apos;,&apos;Benny&apos;,&apos;dog&apos;,&apos;m&apos;,&apos;1990-08-27&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Bowser&apos;,&apos;Diane&apos;,&apos;dog&apos;,&apos;m&apos;,&apos;1979-08-31&apos;,&apos;1995-07-29&apos;),</span><br><span class=\"line\">\t(&apos;Chirpy&apos;,&apos;Gwen&apos;,&apos;bird&apos;,&apos;f&apos;,&apos;1998-09-11&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Whistler&apos;,&apos;Gwen&apos;,&apos;bird&apos;,&apos; &apos;,&apos;1997-12-09&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Puffball&apos;,&apos;Diane&apos;,&apos;hamster&apos;,&apos;f&apos;,&apos;1999-03-30&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Slim&apos;,&apos;Benny&apos;,&apos;snake&apos;,&apos;m&apos;,&apos;1996-04-29&apos;,NULL);</span><br><span class=\"line\">-- 查询表数据</span><br><span class=\"line\">SELECT * FROM pet</span><br><span class=\"line\">-- 清空表数据</span><br><span class=\"line\">DELETE FROM pet</span><br><span class=\"line\">-- 此方法也会使表中的取号器(ID)从1开始</span><br><span class=\"line\">TRUNCATE TABLE pet; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 修改字段值</span><br><span class=\"line\">UPDATE pet SET birth = &apos;1989-08-31&apos; WHERE NAME = &apos;Bowser&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME = &apos;Bowser&apos;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据表查询\"><a href=\"#数据表查询\" class=\"headerlink\" title=\"数据表查询\"></a>数据表查询</h2><h3 id=\"基本查询\"><a href=\"#基本查询\" class=\"headerlink\" title=\"基本查询\"></a>基本查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- DISTINCT 检索出每个唯一的输出记录</span><br><span class=\"line\">SELECT DISTINCT ownerr FROM pet</span><br><span class=\"line\"></span><br><span class=\"line\">-- 排序 order by，对于等同但大小写不同的列，并未定义其顺序，某一列，可以使用BINARY强制执行区分大小写的分类功能，如：ORDER BY BINARY col_name. </span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY birth</span><br><span class=\"line\">-- 默认排序是升序，可以利用关键字进行控制。DESC(降序)、ASC(升序)</span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY birth ASC</span><br><span class=\"line\"></span><br><span class=\"line\">-- 多列进行排序</span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY ownerr,birth DESC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日期计算\"><a href=\"#日期计算\" class=\"headerlink\" title=\"日期计算\"></a>日期计算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- YEAR()-提取日期的年部分，MONTH()-提取月份，DAYOFMONTH()-提取所在月份中的日</span><br><span class=\"line\">SELECT birth, YEAR(birth),MONTH(birth),DAYOFMONTH(birth) FROM pet</span><br><span class=\"line\"></span><br><span class=\"line\">-- RIGHT(birth,5)-提取birth的右边5个字符,LEFT - 从左边开始取，MID - 从指定位置(包括)开始取指定长度</span><br><span class=\"line\">SELECT RIGHT(&apos;1234567890&apos;,5),LEFT(&apos;1234567890&apos;,5),MID(&apos;1234567890&apos;,2,4)</span><br><span class=\"line\">-- 提出已近死亡的</span><br><span class=\"line\">-- 出生月份大于当前月份，年龄-1。</span><br><span class=\"line\">SELECT </span><br><span class=\"line\">  NAME,</span><br><span class=\"line\">  birth,</span><br><span class=\"line\">  CURDATE(),</span><br><span class=\"line\">  (YEAR(CURDATE()) - YEAR(birth)) - (RIGHT(CURDATE(), 5) &lt; RIGHT(birth, 5)) AS age </span><br><span class=\"line\">FROM</span><br><span class=\"line\">  pet WHERE death IS NULL  ORDER BY age</span><br><span class=\"line\">  </span><br><span class=\"line\"> -- 查询已死亡的年龄</span><br><span class=\"line\"> SELECT </span><br><span class=\"line\">  NAME,</span><br><span class=\"line\">  birth,</span><br><span class=\"line\">  death,</span><br><span class=\"line\">  (YEAR(death) - YEAR(birth)) - (RIGHT(death, 5) &lt; RIGHT(birth, 5)) AS age </span><br><span class=\"line\">FROM</span><br><span class=\"line\">  pet WHERE death IS NOT NULL ORDER BY age</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查询下一个月谁过生日</span><br><span class=\"line\">SELECT * FROM pet ORDER BY MONTH(birth)</span><br><span class=\"line\">SELECT * FROM pet WHERE MONTH(birth) = MONTH(CURDATE()) + 1</span><br><span class=\"line\">SELECT * FROM pet WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NULL值\"><a href=\"#NULL值\" class=\"headerlink\" title=\"NULL值\"></a>NULL值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- NULL 值的判断，不能使用比较运算符，只能用 is null 或 is not null</span><br><span class=\"line\">SELECT  1 = NULL, 1 &gt; NULL, 1 &lt; NULL,  1 IS NULL,  1 IS NOT NULL </span><br><span class=\"line\"></span><br><span class=\"line\">-- 0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1。</span><br><span class=\"line\">SELECT 0 IS NULL, 0 IS NOT NULL, &apos;&apos; IS NULL, &apos;&apos; IS NOT NULL;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模糊匹配\"><a href=\"#模糊匹配\" class=\"headerlink\" title=\"模糊匹配\"></a>模糊匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- MySQL提供标准的SQL模式匹配，以及一种基于象Unix实用程序如vi、grep和sed的扩展正则表达式模式匹配的格式。</span><br><span class=\"line\">-- &quot;_&quot; 匹配任何单个字符；&quot;%&quot; 匹配任意数目字符(包括零字符)，SQL的模式默认是忽略大小写。关键字 LIKE 或 NOT LINK</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找以b开头的name</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;b%&apos;</span><br><span class=\"line\">-- 查找以&apos;fy&apos;结尾的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;%fy&apos;</span><br><span class=\"line\">-- 查找包含w的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;%w%&apos;</span><br><span class=\"line\">-- 查找正好是5个字符的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;_____&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE LENGTH(NAME) = 5</span><br><span class=\"line\"></span><br><span class=\"line\">-- MySQL提供的模式匹配的其它类型是使用扩展正则表达式。当你对这类模式进行匹配测试时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，它们是同义词)。 </span><br><span class=\"line\">-- &quot;.&quot; 匹配任何单个字符；</span><br><span class=\"line\">-- &quot;[...]&quot; 匹配在方括号内的任何字符，为了命名字符的范围，使用一个“-”。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</span><br><span class=\"line\">-- &quot;*&quot; 匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的“x”字符，“[0-9]*”匹配任何数量的数字，而“.*”匹配任何数量的任何字符。</span><br><span class=\"line\">-- 如果REGEXP模式与被测试值的任何地方匹配，模式就匹配(这不同于LIKE模式匹配，只有与整个值匹配，模式才匹配)。 </span><br><span class=\"line\">-- 为了定位一个模式以便它必须匹配被测试值的开始或结尾，在模式开始处使用“^”或在模式的结尾用“$”。</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找以b开头的name</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^b&apos;</span><br><span class=\"line\">-- 查找以&apos;fy&apos;结尾的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;fy$&apos;</span><br><span class=\"line\">-- 查找包含w的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;w&apos;</span><br><span class=\"line\">-- 查找正好是5个字符的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^.....$&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^.&#123;5&#125;$&apos;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/regexp.html\" target=\"_blank\" rel=\"noopener\">正则表达式在线参考</a></p>\n"},{"title":"MySql常用信息函数","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2017-01-12T08:59:00.000Z","_content":"## 基本命令\n```sql\n-- 管理员登录\nmysql -uroot\n-- 查看当前服务器版本\nselect version();\n-- 查看当前使用的数据库\nselect database();\n-- 当前用户\nselect current_user();\nselect user();\n\n-- 查询当前日期、时间、日期+时间\nselect curdate(),curtime(),now();\nselect current_date(),current_time(),current_timestamp();\n\n-- 显示所有表\nshow tables;\n-- 显示所有库\nshow databases;\n-- 查看标准建库语句\nshow create database db_name;\n-- 查看标准建表语句\nshow create table tb_name;\n-- 查看表字段信息\nshow full columns from tname;\n-- 显示当前数据库服务器支持的存储引擎\nshow engines;\n-- 查询当前服务器所支持的字符集。\nshow charset;\n\n```\n\n## 存储引擎\n- MyISAM 不支持事务，速度快，引用最多的引擎\n- InnoDB 支持事务\n\n## 常见支持简体中文的字符集\n我国定制，支持中文简体、繁体 日文。\ngb2312 简体中文，只支持6763简体汉字\ngbk 简繁体支持\ngb18030 \n\nutf-8 美国制定，支持所有国家语言","source":"_posts/mysql/mysql常用信息函数.md","raw":"---\ntitle: MySql常用信息函数\nauthor: JsonYe\ntags:\n  - mysql\n  - 数据库\ncategories:\n  - MySql \ncopyright: true\ncomments: true\ntoc: true\ndate: 2017-01-12 16:59:00\n---\n## 基本命令\n```sql\n-- 管理员登录\nmysql -uroot\n-- 查看当前服务器版本\nselect version();\n-- 查看当前使用的数据库\nselect database();\n-- 当前用户\nselect current_user();\nselect user();\n\n-- 查询当前日期、时间、日期+时间\nselect curdate(),curtime(),now();\nselect current_date(),current_time(),current_timestamp();\n\n-- 显示所有表\nshow tables;\n-- 显示所有库\nshow databases;\n-- 查看标准建库语句\nshow create database db_name;\n-- 查看标准建表语句\nshow create table tb_name;\n-- 查看表字段信息\nshow full columns from tname;\n-- 显示当前数据库服务器支持的存储引擎\nshow engines;\n-- 查询当前服务器所支持的字符集。\nshow charset;\n\n```\n\n## 存储引擎\n- MyISAM 不支持事务，速度快，引用最多的引擎\n- InnoDB 支持事务\n\n## 常见支持简体中文的字符集\n我国定制，支持中文简体、繁体 日文。\ngb2312 简体中文，只支持6763简体汉字\ngbk 简繁体支持\ngb18030 \n\nutf-8 美国制定，支持所有国家语言","slug":"mysql/mysql常用信息函数","published":1,"updated":"2019-10-02T08:40:22.980Z","layout":"post","photos":[],"link":"","_id":"ck191nwfc001bb0wkud0wfmu0","content":"<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 管理员登录</span></span><br><span class=\"line\">mysql -uroot</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前服务器版本</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">version</span>();</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前使用的数据库</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">database</span>();</span><br><span class=\"line\"><span class=\"comment\">-- 当前用户</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">current_user</span>();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">user</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询当前日期、时间、日期+时间</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">curdate</span>(),<span class=\"keyword\">curtime</span>(),<span class=\"keyword\">now</span>();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">current_date</span>(),<span class=\"keyword\">current_time</span>(),<span class=\"keyword\">current_timestamp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 显示所有表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 显示所有库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">databases</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 查看标准建库语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">database</span> db_name;</span><br><span class=\"line\"><span class=\"comment\">-- 查看标准建表语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> tb_name;</span><br><span class=\"line\"><span class=\"comment\">-- 查看表字段信息</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">full</span> <span class=\"keyword\">columns</span> <span class=\"keyword\">from</span> tname;</span><br><span class=\"line\"><span class=\"comment\">-- 显示当前数据库服务器支持的存储引擎</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 查询当前服务器所支持的字符集。</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">charset</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><ul>\n<li>MyISAM 不支持事务，速度快，引用最多的引擎</li>\n<li>InnoDB 支持事务</li>\n</ul>\n<h2 id=\"常见支持简体中文的字符集\"><a href=\"#常见支持简体中文的字符集\" class=\"headerlink\" title=\"常见支持简体中文的字符集\"></a>常见支持简体中文的字符集</h2><p>我国定制，支持中文简体、繁体 日文。<br>gb2312 简体中文，只支持6763简体汉字<br>gbk 简繁体支持<br>gb18030 </p>\n<p>utf-8 美国制定，支持所有国家语言</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 管理员登录</span></span><br><span class=\"line\">mysql -uroot</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前服务器版本</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">version</span>();</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前使用的数据库</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">database</span>();</span><br><span class=\"line\"><span class=\"comment\">-- 当前用户</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">current_user</span>();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">user</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询当前日期、时间、日期+时间</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">curdate</span>(),<span class=\"keyword\">curtime</span>(),<span class=\"keyword\">now</span>();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">current_date</span>(),<span class=\"keyword\">current_time</span>(),<span class=\"keyword\">current_timestamp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 显示所有表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 显示所有库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">databases</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 查看标准建库语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">database</span> db_name;</span><br><span class=\"line\"><span class=\"comment\">-- 查看标准建表语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> tb_name;</span><br><span class=\"line\"><span class=\"comment\">-- 查看表字段信息</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">full</span> <span class=\"keyword\">columns</span> <span class=\"keyword\">from</span> tname;</span><br><span class=\"line\"><span class=\"comment\">-- 显示当前数据库服务器支持的存储引擎</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 查询当前服务器所支持的字符集。</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">charset</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><ul>\n<li>MyISAM 不支持事务，速度快，引用最多的引擎</li>\n<li>InnoDB 支持事务</li>\n</ul>\n<h2 id=\"常见支持简体中文的字符集\"><a href=\"#常见支持简体中文的字符集\" class=\"headerlink\" title=\"常见支持简体中文的字符集\"></a>常见支持简体中文的字符集</h2><p>我国定制，支持中文简体、繁体 日文。<br>gb2312 简体中文，只支持6763简体汉字<br>gbk 简繁体支持<br>gb18030 </p>\n<p>utf-8 美国制定，支持所有国家语言</p>\n"},{"title":"Git远程操作详解","author":"JsonYe","comments":1,"toc":true,"date":"2016-01-11T08:22:00.000Z","_content":"Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。\n```\ngit clone\n\ngit remote\n\ngit fetch\n\ngit pull\n\ngit push\n```\n本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。\n\n## 一、git clone\n\n远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。\n\n```\n git clone <版本库的网址>\n```\n\n比如，克隆jQuery的版本库。\n\n```\ngit clone https://github.com/jquery/jquery.git\n```\n\n该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。\n\n```\ngit clone <版本库的网址> <本地目录名>\n```\n\ngit clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。\n\n```\n git clone http[s]://example.com/path/to/repo.git/\n git clone ssh://example.com/path/to/repo.git/\n git clone git://example.com/path/to/repo.git/\n git clone /opt/git/project.git \n git clone file:///opt/git/project.git\n git clone ftp[s]://example.com/path/to/repo.git/\n git clone rsync://example.com/path/to/repo.git/\n```\n\nSSH协议还有另一种写法。\n\n```\n git clone [user@]example.com:path/to/repo.git/\n```\n\n通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。\n\n## 二、git remote\n\n为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。\n\n不带选项的时候，git remote命令列出所有远程主机。\n\n```\ngit remote\norigin\n```\n\n使用-v选项，可以参看远程主机的网址。\n\n```\n git remote -v\norigin  git@github.com:jquery/jquery.git (fetch)\norigin  git@github.com:jquery/jquery.git (push)\n```\n\n上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。\n\n克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。\n\n```\n git clone -o jQuery https://github.com/jquery/jquery.git\n git remote\njQuery\n```\n\n上面命令表示，克隆的时候，指定远程主机叫做jQuery。\n\n```\ngit remote show命令加上主机名，可以查看该主机的详细信息。\n git remote show <主机名>\ngit remote add命令用于添加远程主机。\n git remote add <主机名> <网址>\ngit remote rm命令用于删除远程主机。\n git remote rm <主机名>\ngit remote rename命令用于远程主机的改名。\n git remote rename <原主机名> <新主机名>\n```\n\n## 三、git fetch\n\n一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。\n\n```\n git fetch <远程主机名>\n```\n\n上面命令将某个远程主机的更新，全部取回本地。\n\ngit fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。\n\n默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。\n\n```\n git fetch <远程主机名> <分支名>\n```\n\n比如，取回origin主机的master分支。\n\n```\n git fetch origin master\n```\n\n所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如origin主机的master，就要用origin/master读取。\n\ngit branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。\n\n```\n git branch -r\norigin/master\n git branch -a\n* master\n  remotes/origin/master\n```\n\n上面命令表示，本地主机的当前分支是master，远程分支是origin/master。\n\n取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。\n\n```\n git checkout -b newBrach origin/master\n```\n\n上面命令表示，在origin/master的基础上，创建一个新分支。\n\n此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。\n\n```\n git merge origin/master\n```\n\n\\# 或者\n\n```\n git rebase origin/master\n```\n\n上面命令表示在当前分支上，合并origin/master。\n\n## 四、git pull\n\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。\n\n```\n git pull <远程主机名> <远程分支名>:<本地分支名>\n```\n\n比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。\n\n```\n git pull origin next:master\n```\n\n如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\n\n```\n git pull origin next\n```\n\n上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。\n\n```\n git fetch origin\n git merge origin/next\n```\n\n在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动\"追踪\"origin/master分支。\n\nGit也允许手动建立追踪关系。\n\n```\ngit branch --set-upstream master origin/next\n```\n\n上面命令指定master分支追踪origin/next分支。\n\n如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。\n\n```\n git pull origin\n```\n\n上面命令表示，本地的当前分支自动与对应的origin主机\"追踪分支\"（remote-tracking branch）进行合并。\n\n如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n\n```\n git pull\n```\n\n上面命令表示，当前分支自动与唯一一个追踪分支进行合并。\n\n如果合并需要采用rebase模式，可以使用--rebase选项。\n\n```\n git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n```\n\n如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。\n\n但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。\n\n```\n git pull -p\n# 等同于下面的命令\n git fetch --prune origin \n git fetch -p\n```\n\n## 五、git push\n\ngit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。\n\n```\n git push <远程主机名> <本地分支名>:<远程分支名>\n```\n\n注意，分支推送顺序的写法是<来源地>:<目的地>，所以git pull是<远程分支>:<本地分支>，而git push是<本地分支>:<远程分支>。\n\n如果省略远程分支名，则表示将本地分支推送与之存在\"追踪关系\"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。\n\n```\n git push origin master\n```\n\n上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。\n\n如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\n\n```\n git push origin :master\n```\n\n\\# 等同于\n\n```\n git push origin --delete master\n```\n\n上面命令表示删除origin主机的master分支。\n\n如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n\n```\n git push origin\n```\n\n上面命令表示，将当前分支推送到origin主机的对应分支。\n\n如果当前分支只有一个追踪分支，那么主机名都可以省略。\n\n```\n git push\n```\n\n如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。\n\n```\n git push -u origin master\n```\n\n上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。\n\n不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。\n\n```\n git config --global push.default matching\n```\n\n或者\n\n```\n git config --global push.default simple\n```\n\n还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。\n\n```\n git push --all origin\n```\n\n上面命令表示，将所有本地分支都推送到origin主机。\n\n如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。\n\n```\n git push --force origin\n```\n\n上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。\n\n最后，git push不会推送标签（tag），除非使用--tags选项。\n\n```\n git push origin --tags\n```\n\n（完）","source":"_posts/git/Git远程操作详解.md","raw":"---\ntitle: 'Git远程操作详解'\nauthor: JsonYe\ntags:\n  - git\ncategories:\n  - IDE \ncomments: true\ntoc: true\ndate:  2016-01-11 16:22:00\n---\nGit有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。\n```\ngit clone\n\ngit remote\n\ngit fetch\n\ngit pull\n\ngit push\n```\n本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。\n\n## 一、git clone\n\n远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。\n\n```\n git clone <版本库的网址>\n```\n\n比如，克隆jQuery的版本库。\n\n```\ngit clone https://github.com/jquery/jquery.git\n```\n\n该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。\n\n```\ngit clone <版本库的网址> <本地目录名>\n```\n\ngit clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。\n\n```\n git clone http[s]://example.com/path/to/repo.git/\n git clone ssh://example.com/path/to/repo.git/\n git clone git://example.com/path/to/repo.git/\n git clone /opt/git/project.git \n git clone file:///opt/git/project.git\n git clone ftp[s]://example.com/path/to/repo.git/\n git clone rsync://example.com/path/to/repo.git/\n```\n\nSSH协议还有另一种写法。\n\n```\n git clone [user@]example.com:path/to/repo.git/\n```\n\n通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。\n\n## 二、git remote\n\n为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。\n\n不带选项的时候，git remote命令列出所有远程主机。\n\n```\ngit remote\norigin\n```\n\n使用-v选项，可以参看远程主机的网址。\n\n```\n git remote -v\norigin  git@github.com:jquery/jquery.git (fetch)\norigin  git@github.com:jquery/jquery.git (push)\n```\n\n上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。\n\n克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。\n\n```\n git clone -o jQuery https://github.com/jquery/jquery.git\n git remote\njQuery\n```\n\n上面命令表示，克隆的时候，指定远程主机叫做jQuery。\n\n```\ngit remote show命令加上主机名，可以查看该主机的详细信息。\n git remote show <主机名>\ngit remote add命令用于添加远程主机。\n git remote add <主机名> <网址>\ngit remote rm命令用于删除远程主机。\n git remote rm <主机名>\ngit remote rename命令用于远程主机的改名。\n git remote rename <原主机名> <新主机名>\n```\n\n## 三、git fetch\n\n一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。\n\n```\n git fetch <远程主机名>\n```\n\n上面命令将某个远程主机的更新，全部取回本地。\n\ngit fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。\n\n默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。\n\n```\n git fetch <远程主机名> <分支名>\n```\n\n比如，取回origin主机的master分支。\n\n```\n git fetch origin master\n```\n\n所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如origin主机的master，就要用origin/master读取。\n\ngit branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。\n\n```\n git branch -r\norigin/master\n git branch -a\n* master\n  remotes/origin/master\n```\n\n上面命令表示，本地主机的当前分支是master，远程分支是origin/master。\n\n取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。\n\n```\n git checkout -b newBrach origin/master\n```\n\n上面命令表示，在origin/master的基础上，创建一个新分支。\n\n此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。\n\n```\n git merge origin/master\n```\n\n\\# 或者\n\n```\n git rebase origin/master\n```\n\n上面命令表示在当前分支上，合并origin/master。\n\n## 四、git pull\n\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。\n\n```\n git pull <远程主机名> <远程分支名>:<本地分支名>\n```\n\n比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。\n\n```\n git pull origin next:master\n```\n\n如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\n\n```\n git pull origin next\n```\n\n上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。\n\n```\n git fetch origin\n git merge origin/next\n```\n\n在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动\"追踪\"origin/master分支。\n\nGit也允许手动建立追踪关系。\n\n```\ngit branch --set-upstream master origin/next\n```\n\n上面命令指定master分支追踪origin/next分支。\n\n如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。\n\n```\n git pull origin\n```\n\n上面命令表示，本地的当前分支自动与对应的origin主机\"追踪分支\"（remote-tracking branch）进行合并。\n\n如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n\n```\n git pull\n```\n\n上面命令表示，当前分支自动与唯一一个追踪分支进行合并。\n\n如果合并需要采用rebase模式，可以使用--rebase选项。\n\n```\n git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n```\n\n如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。\n\n但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。\n\n```\n git pull -p\n# 等同于下面的命令\n git fetch --prune origin \n git fetch -p\n```\n\n## 五、git push\n\ngit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。\n\n```\n git push <远程主机名> <本地分支名>:<远程分支名>\n```\n\n注意，分支推送顺序的写法是<来源地>:<目的地>，所以git pull是<远程分支>:<本地分支>，而git push是<本地分支>:<远程分支>。\n\n如果省略远程分支名，则表示将本地分支推送与之存在\"追踪关系\"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。\n\n```\n git push origin master\n```\n\n上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。\n\n如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\n\n```\n git push origin :master\n```\n\n\\# 等同于\n\n```\n git push origin --delete master\n```\n\n上面命令表示删除origin主机的master分支。\n\n如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n\n```\n git push origin\n```\n\n上面命令表示，将当前分支推送到origin主机的对应分支。\n\n如果当前分支只有一个追踪分支，那么主机名都可以省略。\n\n```\n git push\n```\n\n如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。\n\n```\n git push -u origin master\n```\n\n上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。\n\n不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。\n\n```\n git config --global push.default matching\n```\n\n或者\n\n```\n git config --global push.default simple\n```\n\n还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。\n\n```\n git push --all origin\n```\n\n上面命令表示，将所有本地分支都推送到origin主机。\n\n如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。\n\n```\n git push --force origin\n```\n\n上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。\n\n最后，git push不会推送标签（tag），除非使用--tags选项。\n\n```\n git push origin --tags\n```\n\n（完）","slug":"git/Git远程操作详解","published":1,"updated":"2019-10-02T08:42:18.966Z","layout":"post","photos":[],"link":"","_id":"ck191nwfh001eb0wkriifrsdr","content":"<p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone</span><br><span class=\"line\"></span><br><span class=\"line\">git remote</span><br><span class=\"line\"></span><br><span class=\"line\">git fetch</span><br><span class=\"line\"></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p>\n<h2 id=\"一、git-clone\"><a href=\"#一、git-clone\" class=\"headerlink\" title=\"一、git clone\"></a>一、git clone</h2><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，克隆jQuery的版本库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>\n\n<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone http[s]://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone ssh://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone git://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone /opt/git/project.git </span><br><span class=\"line\"> git clone file:///opt/git/project.git</span><br><span class=\"line\"> git clone ftp[s]://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone rsync://example.com/path/to/repo.git/</span><br></pre></td></tr></table></figure>\n\n<p>SSH协议还有另一种写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone [user@]example.com:path/to/repo.git/</span><br></pre></td></tr></table></figure>\n\n<p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p>\n<h2 id=\"二、git-remote\"><a href=\"#二、git-remote\" class=\"headerlink\" title=\"二、git remote\"></a>二、git remote</h2><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。</p>\n<p>不带选项的时候，git remote命令列出所有远程主机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote</span><br><span class=\"line\">origin</span><br></pre></td></tr></table></figure>\n\n<p>使用-v选项，可以参看远程主机的网址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git remote -v</span><br><span class=\"line\">origin  git@github.com:jquery/jquery.git (fetch)</span><br><span class=\"line\">origin  git@github.com:jquery/jquery.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>\n<p>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone -o jQuery https://github.com/jquery/jquery.git</span><br><span class=\"line\"> git remote</span><br><span class=\"line\">jQuery</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show命令加上主机名，可以查看该主机的详细信息。</span><br><span class=\"line\"> git remote show &lt;主机名&gt;</span><br><span class=\"line\">git remote add命令用于添加远程主机。</span><br><span class=\"line\"> git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class=\"line\">git remote rm命令用于删除远程主机。</span><br><span class=\"line\"> git remote rm &lt;主机名&gt;</span><br><span class=\"line\">git remote rename命令用于远程主机的改名。</span><br><span class=\"line\"> git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、git-fetch\"><a href=\"#三、git-fetch\" class=\"headerlink\" title=\"三、git fetch\"></a>三、git fetch</h2><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面命令将某个远程主机的更新，全部取回本地。</p>\n<p>git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>\n<p>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，取回origin主机的master分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch origin master</span><br></pre></td></tr></table></figure>\n\n<p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。</p>\n<p>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git branch -r</span><br><span class=\"line\">origin/master</span><br><span class=\"line\"> git branch -a</span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，本地主机的当前分支是master，远程分支是origin/master。</p>\n<p>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，在origin/master的基础上，创建一个新分支。</p>\n<p>此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git merge origin/master</span><br></pre></td></tr></table></figure>\n\n<p># 或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git rebase origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示在当前分支上，合并origin/master。</p>\n<h2 id=\"四、git-pull\"><a href=\"#四、git-pull\" class=\"headerlink\" title=\"四、git pull\"></a>四、git pull</h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin next:master</span><br></pre></td></tr></table></figure>\n\n<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin next</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch origin</span><br><span class=\"line\"> git merge origin/next</span><br></pre></td></tr></table></figure>\n\n<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。</p>\n<p>Git也允许手动建立追踪关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream master origin/next</span><br></pre></td></tr></table></figure>\n\n<p>上面命令指定master分支追踪origin/next分支。</p>\n<p>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。</p>\n<p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>\n<p>如果合并需要采用rebase模式，可以使用–rebase选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。</p>\n<p>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull -p</span><br><span class=\"line\"># 等同于下面的命令</span><br><span class=\"line\"> git fetch --prune origin </span><br><span class=\"line\"> git fetch -p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、git-push\"><a href=\"#五、git-push\" class=\"headerlink\" title=\"五、git push\"></a>五、git push</h2><p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>\n<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p>\n<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin :master</span><br></pre></td></tr></table></figure>\n\n<p># 等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin --delete master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示删除origin主机的master分支。</p>\n<p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将当前分支推送到origin主机的对应分支。</p>\n<p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push</span><br></pre></td></tr></table></figure>\n\n<p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p>\n<p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global push.default matching</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global push.default simple</span><br></pre></td></tr></table></figure>\n\n<p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push --all origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将所有本地分支都推送到origin主机。</p>\n<p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push --force origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。</p>\n<p>最后，git push不会推送标签（tag），除非使用–tags选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<p>（完）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone</span><br><span class=\"line\"></span><br><span class=\"line\">git remote</span><br><span class=\"line\"></span><br><span class=\"line\">git fetch</span><br><span class=\"line\"></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p>\n<h2 id=\"一、git-clone\"><a href=\"#一、git-clone\" class=\"headerlink\" title=\"一、git clone\"></a>一、git clone</h2><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，克隆jQuery的版本库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>\n\n<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone http[s]://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone ssh://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone git://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone /opt/git/project.git </span><br><span class=\"line\"> git clone file:///opt/git/project.git</span><br><span class=\"line\"> git clone ftp[s]://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone rsync://example.com/path/to/repo.git/</span><br></pre></td></tr></table></figure>\n\n<p>SSH协议还有另一种写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone [user@]example.com:path/to/repo.git/</span><br></pre></td></tr></table></figure>\n\n<p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p>\n<h2 id=\"二、git-remote\"><a href=\"#二、git-remote\" class=\"headerlink\" title=\"二、git remote\"></a>二、git remote</h2><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。</p>\n<p>不带选项的时候，git remote命令列出所有远程主机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote</span><br><span class=\"line\">origin</span><br></pre></td></tr></table></figure>\n\n<p>使用-v选项，可以参看远程主机的网址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git remote -v</span><br><span class=\"line\">origin  git@github.com:jquery/jquery.git (fetch)</span><br><span class=\"line\">origin  git@github.com:jquery/jquery.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>\n<p>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone -o jQuery https://github.com/jquery/jquery.git</span><br><span class=\"line\"> git remote</span><br><span class=\"line\">jQuery</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show命令加上主机名，可以查看该主机的详细信息。</span><br><span class=\"line\"> git remote show &lt;主机名&gt;</span><br><span class=\"line\">git remote add命令用于添加远程主机。</span><br><span class=\"line\"> git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class=\"line\">git remote rm命令用于删除远程主机。</span><br><span class=\"line\"> git remote rm &lt;主机名&gt;</span><br><span class=\"line\">git remote rename命令用于远程主机的改名。</span><br><span class=\"line\"> git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、git-fetch\"><a href=\"#三、git-fetch\" class=\"headerlink\" title=\"三、git fetch\"></a>三、git fetch</h2><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面命令将某个远程主机的更新，全部取回本地。</p>\n<p>git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>\n<p>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，取回origin主机的master分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch origin master</span><br></pre></td></tr></table></figure>\n\n<p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。</p>\n<p>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git branch -r</span><br><span class=\"line\">origin/master</span><br><span class=\"line\"> git branch -a</span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，本地主机的当前分支是master，远程分支是origin/master。</p>\n<p>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，在origin/master的基础上，创建一个新分支。</p>\n<p>此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git merge origin/master</span><br></pre></td></tr></table></figure>\n\n<p># 或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git rebase origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示在当前分支上，合并origin/master。</p>\n<h2 id=\"四、git-pull\"><a href=\"#四、git-pull\" class=\"headerlink\" title=\"四、git pull\"></a>四、git pull</h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin next:master</span><br></pre></td></tr></table></figure>\n\n<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin next</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch origin</span><br><span class=\"line\"> git merge origin/next</span><br></pre></td></tr></table></figure>\n\n<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。</p>\n<p>Git也允许手动建立追踪关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream master origin/next</span><br></pre></td></tr></table></figure>\n\n<p>上面命令指定master分支追踪origin/next分支。</p>\n<p>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。</p>\n<p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>\n<p>如果合并需要采用rebase模式，可以使用–rebase选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。</p>\n<p>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull -p</span><br><span class=\"line\"># 等同于下面的命令</span><br><span class=\"line\"> git fetch --prune origin </span><br><span class=\"line\"> git fetch -p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、git-push\"><a href=\"#五、git-push\" class=\"headerlink\" title=\"五、git push\"></a>五、git push</h2><p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>\n<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p>\n<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin :master</span><br></pre></td></tr></table></figure>\n\n<p># 等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin --delete master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示删除origin主机的master分支。</p>\n<p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将当前分支推送到origin主机的对应分支。</p>\n<p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push</span><br></pre></td></tr></table></figure>\n\n<p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p>\n<p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global push.default matching</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global push.default simple</span><br></pre></td></tr></table></figure>\n\n<p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push --all origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将所有本地分支都推送到origin主机。</p>\n<p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push --force origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。</p>\n<p>最后，git push不会推送标签（tag），除非使用–tags选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<p>（完）</p>\n"},{"title":"C语言指正|结构体|枚举","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-19T09:33:00.000Z","_content":"# 指针\n## 概述\n指针就是用来保存变量的地址的变量\n\n- 访问\n    1. 我们通过`&`来获取变量的地址。\n    2. `&`这个操作符只能指向变量或者是数组。\n    3. `&`是获取地址的操作符。\n    4. 使用`%p`来打印地址。\n\n- 本质\n    指针是一个4字节（或是8字节）的一个int的整数。换句话说也就一个int 型的变量\n- 指针变量\n    1. 指针变量是用来保存地址的。\n    2. 指针变量里保存的地址可以修改。\n    3. 指针变量可以指向特殊的数据类型。\n    4. 可以有多个指针变量里的值是相同的。\n\n- 一级指针的简单使用\n    指针访问内存可以通过`*`这个操作符去访问所指向的内存空间。\n\n## 指针的定义和初始化\n- type * identifier\n    1. 没有初始化的指针，称之为野指针。\n    2. 指针里面是一个随机的值。\n    3. 野指针有很大的风险。\n    4. 指针可以作为函数的参数和返回值。\n-   \n```\n// 声明一个int指针\nint *ptr;\n// 声明一个int值\nint val = 1;\n// 为指针分配一个int值的引用\nptr = &val;\n// 对指针进行取值，打印存储在指针地址中的内容\nint deref = *ptr;\nprintf(\"%d\\n\", deref);\n```\n第2行，我们通过`*`操作符声明了一个int指针。接着我们声明了一个int变量并赋值为1。然后我们用int变量的地址初始化我们的int指针。接下来对int指针取值，用变量的内存地址初始化int指针。最终，我们打印输出变量值，内容为1。\n\n第6行的`&val`是一个引用。在val变量声明并初始化内存之后，通过在变量名之前使用地址操作符`&`我们可以直接引用变量的内存地址。\n第8行，我们再一次使用`*`操作符来对该指针取值，可直接获得指针指向的内存地址中的数据。由于指针声明的类型是int，所以取到的值是指针指向的内存地址存储的int值。\n\n- void指针、NULL指针和未初始化指针\n一个指针可以被声明为void类型，比如void *x。一个指针可以被赋值为NULL。一个指针变量声明之后但没有被赋值，叫做未初始化指针。\n\n```\nint *uninit; \n// int指针未初始化\nint *nullptr = NULL; \n// 初始化为NULL\nvoid *vptr; \n// void指针未初始化\nint val = 1;\nint *iptr;\nint *castptr;\n \n// void类型可以存储任意类型的指针或引用\niptr = &val;\nvptr = iptr;\nprintf(\"iptr=%p, vptr=%p\\n\", iptr, vptr);\n \n// 通过显示转换，我们可以把一个void指针转成\n// int指针并进行取值\ncastptr = (int *)vptr;\nprintf(\"*castptr=%d\\n\", *castptr);\n \n// 打印null和未初始化指针\nprintf(\"uninit=%p, nullptr=%p\\n\", uninit, nullptr);\n// 不知道你会得到怎样的返回值，会是随机的垃圾地址吗？\n// printf(\"*nullptr=%d\\n\", nullptr);\n// 这里会产生一个段错误\n// printf(\"*nullptr=%d\\n\", nullptr);\n执行上面的代码，你会得到类似下面对应不同内存地址的输出。\n\niptr=0x7fff94b89c6c, vptr=0x7fff94b89c6c\n*castptr=1\nuninit=0x7fff94b89d50, nullptr=(nil)\n```\n\n第1行我们声明了一个未初始化int指针。所有的指针在赋值为NULL、一个引用（地址）或者另一个指针之前都是未被初始化的。第2行我们声明了一个NULL指针。第3行声明了一个void指针。第4行到第6行声明了一个int值和几个int指针。\n\n第9行到11行，我们为int指针赋值为一个引用并把int指针赋值为void指针。void指针可以保存各种其它指针类型。大多数时候它们被用来存储数据结构。可以注意到，第11行我们打印了int和void指针的地址。它们现在指向了同样的内存地址。所有的指针都存储了内存地址。它们的类型只在取值时起作用。\n\n第15到16行，我们把void指针转换为int指针castptr。请注意这里需要显示转换。虽然C语言并不要求显示地转换，但这样会增加代码的可读性。接着我们对castptr指针取值，值为1。\n\n第19行非常有意思，在这里打印未初始化指针和NULL指针。值得注意的是，未初始化指针是有内存地址的，而且是一个垃圾地址。不知道这个内存地址指向的值是什么。这就是为什么不要对未初始化指针取值的原因。最好的情况是你取到的是垃圾地址接下来你需要对程序进行调试，最坏的情况则会导致程序崩溃。\n>NULL指针被初始化为o。NULL是一个特殊的地址，用NULL赋值的指针指向的地址为0而不是随机的地址。只有当你准备使用这个地址时有效。不要对NULL地址取值，否则会产生段错误。\n\n- 指针和数组\n    - C语言的数组表示一段连续的内存空间，用来存储多个特定类型的对象。与之相反，指针用来存储单个内存地址。数组和指针不是同一种结构因此不可以互相转换。而数组变量指向了数组的第一个元素的内存地址。\n    - 一个数组变量是一个常量。即使指针变量指向同样的地址或者一个不同的数组，也不能把指针赋值给数组变量。也不可以将一个数组变量赋值给另一个数组。然而，可以把一个数组变量赋值给指针，这一点似乎让人感到费解。把数组变量赋值给指针时，实际上是把指向数组第一个元素的地址赋给指针。\n\n```\nint myarray[4] = {1,2,3,0};\nint *ptr = myarray;\nprintf(\"*ptr=%d\\n\", *ptr);\n \n// 数组变量是常量，不能做下面的赋值\n// myarray = ptr\n// myarray = myarray2\n// myarray = &myarray2[0]\n```\n第1行初始化了一个int数组，第2行用数组变量初始化了一个int指针。由于数组变量实际上是第一个元素的地址，因此我们可以把这个地址赋值给指针。这个赋值与int *ptr = &myarray[0]效果相同，显示地把数组的第一个元素地址赋值到了ptr引用。这里需要注意的是，这里指针需要和数组的元素类型保持一致，除非指针类型为void。\n\n- 指针与`结构体`\n就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。\n\n```\nstruct person {\n  int age;\n  char *name;\n};\nstruct person first;\nstruct person *ptr;\n \nfirst.age = 21;\nchar *fullname = \"full name\";\nfirst.name = fullname;\nptr = &first;\n \nprintf(\"age=%d, name=%s\\n\", first.age, ptr->name);\n```\n\n第1至6行声明了一个person结构体，一个变量指向了一个person结构体和指向person结构体的指针。第8行为age成员赋了一个int值。第9至10行我们声明了一个char指针并赋值给一个char数组并赋值给结构体name成员。第11行我们把一个person结构体引用赋值给结构体变量。\n\n第13行我们打印了结构体实例的age和name。这里需要注意两个不同的符号，’.’ 和 ‘->’ 。结构体实例可以通过使用 ‘.’ 符号访问age变量。对于结构体实例的指针，我们可以通过 ‘->’ 符号访问name变量。也可以同样通过(*ptr).name来访问name变量。\n\n# 结构体\n## 概述\n### 什么事结构体\n1. C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。\n2. 在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。\n3. 为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。\n\n### 结构体的定义\n1. 定义形式：结构体内部的元素，也就是组成成分，我们一般称为\"成员\"。\n结构体的一般定义形式为：\n```\nstruct　结构体名{     \n     类型名1　成员名1;     \n     类型名2　成员名2;     \n     ……     \n     类型名n　成员名n;     \n };\n```\n2. 先定义结构体类型，再定义变量。\n```\nstruct Student {\n     char *name;\n     int age;\n }; \n struct Student stu;\n```\n3. 定义和变量同时进行\n```\nstruct Student {\n    char *name;\n    int age;\n} stu;\n// 结构体变量名为stu\n```\n4. 直接定义结构体类型变量，省略类型名\n```\nstruct {\n    char *name;\n    int age;\n} stu;\n// 结构体变量名为stu\n```\n\n### 注意事项\n- 不可以在结构体本身进行递归定义\n- 可以包含别的结构体\n\n### 内存分配\n- 定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量。\n```\nstruct Student {\n     char *name;\n     int age;\n };\nstruct Student stu;\n// 第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。\n ```\n- 结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列。\n```\nstruct Student {\n     char *name; // 姓名\n     int age; // 年龄\n     float height; // 身高\n };\n// 在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。\n```\n\n### 结构体初始化\n- 将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。\n比如初始化Student结构体变量stu\n```\n struct Student {\n     char *name;\n     int age;\n }; \nstruct Student stu = {“NJ\", 27};\n```\n- 只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是错误的\n```\nstruct Student stu;\nstu = {“NJ\", 27};\n```\n\n### 操作结构体\n1. 一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名\n```\nstruct Student {\n     char *name;\n     int age;\n };\n struct Student stu;\n // 访问stu的age成员\n stu.age = 27;\n// 第9行对结构体的age成员进行了赋值。\".\"称为成员运算符，它在所有运算符中优先级最高\n```\n\n2. 如果某个成员也是结构体变量，可以连续使用成员运算符\".\"访问最低一级成员\n```\nstruct Date {\n       int year;\n       int month;\n       int day;\n  };\n  \n  struct Student {\n      char *name;\n      struct Date birthday;\n };\n \n struct Student stu;\n stu.birthday.year = 1986;\n stu.birthday.month = 9;\n stu.birthday.day = 10;\n```\n\n3. 相同类型的结构体变量之间可以进行整体赋值\n```\nstruct Student {\n      char *name;\n      int age;\n};  \nstruct Student stu1 = {“NJ”, 27};  \n// 将stu1直接赋值给stu2\nstruct Student stu2 = stu1; \nprintf(\"age is %d\", stu2.age);\n```\n\n4. 将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。\n\n5. 指向结构体的指针\n    每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量\n    - 结构体指针变量的定义形式：struct 结构体名称 *指针变量名\n    - 有了指向结构体的指针，那么就有3种访问结构体成员的方式\n    - 结构体变量名.成员名\n    - (*指针变量名).成员名\n    - 指针变量名->成员名\n\n# 枚举\n## 基本概念\n>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。\n\n### 定义\n1. 一般形式为：enum　枚举名　{枚举元素1,枚举元素2,……};\n```\nenum Season {\n\tspring, \n\tsummer, \n\tautumn, \n\tWinter\n}; \n```\n2. 先定义枚举类型，再定义枚举变量\n```\nenum Season {\n\tspring, \n\tsummer, \n\tautumn, \n\tWinter\n}; \n2.enum Season s;\n```\n3. 定义枚举类型的同时定义枚举变量\n```\nenum Season {\n\tspring, \n\tsummer,\n\tautumn,\n \twinter\n} s;\n```\n4. 省略枚举名称，直接定义枚举变量\n```\nenum{\n  spring,\n     summer,\n     autumn, \n     winter\n} s;\n```\n\n### 枚举使用的注意\n1. C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。\n2. 枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。\n```\nenum Season {spring, summer, autumn, winter};\n// 也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3\n```\n3. 也可以在定义枚举类型时改变枚举元素的值\n```\nenum season {spring, summer=3, autumn, winter};\n// 没有指定值的枚举元素，其值为前一元素加1。也就说spring的值为0，summer的值为3，autumn的值为4，winter的值为5\n```\n\n### 赋值\n- 可以给枚举变量赋枚举常量或者整型值\n```\nenum Season {spring, summer, autumn, winter} s;\ns = spring; // 等价于 s = 0;\ns = 3; // 等价于 s = winter;\n```\n\n### 遍历枚举元素\n```\nenum Season {spring, summer, autumn, winter} s;\n// 遍历枚举元素\nfor (s = spring; s <= winter; s++) {\n    printf(\"枚举元素：%d \\n\", s);\n}\n```\n","source":"_posts/c/C语言指针、结构体、枚举.md","raw":"---\ntitle: C语言指正|结构体|枚举\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-19 17:33:00   \n---\n# 指针\n## 概述\n指针就是用来保存变量的地址的变量\n\n- 访问\n    1. 我们通过`&`来获取变量的地址。\n    2. `&`这个操作符只能指向变量或者是数组。\n    3. `&`是获取地址的操作符。\n    4. 使用`%p`来打印地址。\n\n- 本质\n    指针是一个4字节（或是8字节）的一个int的整数。换句话说也就一个int 型的变量\n- 指针变量\n    1. 指针变量是用来保存地址的。\n    2. 指针变量里保存的地址可以修改。\n    3. 指针变量可以指向特殊的数据类型。\n    4. 可以有多个指针变量里的值是相同的。\n\n- 一级指针的简单使用\n    指针访问内存可以通过`*`这个操作符去访问所指向的内存空间。\n\n## 指针的定义和初始化\n- type * identifier\n    1. 没有初始化的指针，称之为野指针。\n    2. 指针里面是一个随机的值。\n    3. 野指针有很大的风险。\n    4. 指针可以作为函数的参数和返回值。\n-   \n```\n// 声明一个int指针\nint *ptr;\n// 声明一个int值\nint val = 1;\n// 为指针分配一个int值的引用\nptr = &val;\n// 对指针进行取值，打印存储在指针地址中的内容\nint deref = *ptr;\nprintf(\"%d\\n\", deref);\n```\n第2行，我们通过`*`操作符声明了一个int指针。接着我们声明了一个int变量并赋值为1。然后我们用int变量的地址初始化我们的int指针。接下来对int指针取值，用变量的内存地址初始化int指针。最终，我们打印输出变量值，内容为1。\n\n第6行的`&val`是一个引用。在val变量声明并初始化内存之后，通过在变量名之前使用地址操作符`&`我们可以直接引用变量的内存地址。\n第8行，我们再一次使用`*`操作符来对该指针取值，可直接获得指针指向的内存地址中的数据。由于指针声明的类型是int，所以取到的值是指针指向的内存地址存储的int值。\n\n- void指针、NULL指针和未初始化指针\n一个指针可以被声明为void类型，比如void *x。一个指针可以被赋值为NULL。一个指针变量声明之后但没有被赋值，叫做未初始化指针。\n\n```\nint *uninit; \n// int指针未初始化\nint *nullptr = NULL; \n// 初始化为NULL\nvoid *vptr; \n// void指针未初始化\nint val = 1;\nint *iptr;\nint *castptr;\n \n// void类型可以存储任意类型的指针或引用\niptr = &val;\nvptr = iptr;\nprintf(\"iptr=%p, vptr=%p\\n\", iptr, vptr);\n \n// 通过显示转换，我们可以把一个void指针转成\n// int指针并进行取值\ncastptr = (int *)vptr;\nprintf(\"*castptr=%d\\n\", *castptr);\n \n// 打印null和未初始化指针\nprintf(\"uninit=%p, nullptr=%p\\n\", uninit, nullptr);\n// 不知道你会得到怎样的返回值，会是随机的垃圾地址吗？\n// printf(\"*nullptr=%d\\n\", nullptr);\n// 这里会产生一个段错误\n// printf(\"*nullptr=%d\\n\", nullptr);\n执行上面的代码，你会得到类似下面对应不同内存地址的输出。\n\niptr=0x7fff94b89c6c, vptr=0x7fff94b89c6c\n*castptr=1\nuninit=0x7fff94b89d50, nullptr=(nil)\n```\n\n第1行我们声明了一个未初始化int指针。所有的指针在赋值为NULL、一个引用（地址）或者另一个指针之前都是未被初始化的。第2行我们声明了一个NULL指针。第3行声明了一个void指针。第4行到第6行声明了一个int值和几个int指针。\n\n第9行到11行，我们为int指针赋值为一个引用并把int指针赋值为void指针。void指针可以保存各种其它指针类型。大多数时候它们被用来存储数据结构。可以注意到，第11行我们打印了int和void指针的地址。它们现在指向了同样的内存地址。所有的指针都存储了内存地址。它们的类型只在取值时起作用。\n\n第15到16行，我们把void指针转换为int指针castptr。请注意这里需要显示转换。虽然C语言并不要求显示地转换，但这样会增加代码的可读性。接着我们对castptr指针取值，值为1。\n\n第19行非常有意思，在这里打印未初始化指针和NULL指针。值得注意的是，未初始化指针是有内存地址的，而且是一个垃圾地址。不知道这个内存地址指向的值是什么。这就是为什么不要对未初始化指针取值的原因。最好的情况是你取到的是垃圾地址接下来你需要对程序进行调试，最坏的情况则会导致程序崩溃。\n>NULL指针被初始化为o。NULL是一个特殊的地址，用NULL赋值的指针指向的地址为0而不是随机的地址。只有当你准备使用这个地址时有效。不要对NULL地址取值，否则会产生段错误。\n\n- 指针和数组\n    - C语言的数组表示一段连续的内存空间，用来存储多个特定类型的对象。与之相反，指针用来存储单个内存地址。数组和指针不是同一种结构因此不可以互相转换。而数组变量指向了数组的第一个元素的内存地址。\n    - 一个数组变量是一个常量。即使指针变量指向同样的地址或者一个不同的数组，也不能把指针赋值给数组变量。也不可以将一个数组变量赋值给另一个数组。然而，可以把一个数组变量赋值给指针，这一点似乎让人感到费解。把数组变量赋值给指针时，实际上是把指向数组第一个元素的地址赋给指针。\n\n```\nint myarray[4] = {1,2,3,0};\nint *ptr = myarray;\nprintf(\"*ptr=%d\\n\", *ptr);\n \n// 数组变量是常量，不能做下面的赋值\n// myarray = ptr\n// myarray = myarray2\n// myarray = &myarray2[0]\n```\n第1行初始化了一个int数组，第2行用数组变量初始化了一个int指针。由于数组变量实际上是第一个元素的地址，因此我们可以把这个地址赋值给指针。这个赋值与int *ptr = &myarray[0]效果相同，显示地把数组的第一个元素地址赋值到了ptr引用。这里需要注意的是，这里指针需要和数组的元素类型保持一致，除非指针类型为void。\n\n- 指针与`结构体`\n就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。\n\n```\nstruct person {\n  int age;\n  char *name;\n};\nstruct person first;\nstruct person *ptr;\n \nfirst.age = 21;\nchar *fullname = \"full name\";\nfirst.name = fullname;\nptr = &first;\n \nprintf(\"age=%d, name=%s\\n\", first.age, ptr->name);\n```\n\n第1至6行声明了一个person结构体，一个变量指向了一个person结构体和指向person结构体的指针。第8行为age成员赋了一个int值。第9至10行我们声明了一个char指针并赋值给一个char数组并赋值给结构体name成员。第11行我们把一个person结构体引用赋值给结构体变量。\n\n第13行我们打印了结构体实例的age和name。这里需要注意两个不同的符号，’.’ 和 ‘->’ 。结构体实例可以通过使用 ‘.’ 符号访问age变量。对于结构体实例的指针，我们可以通过 ‘->’ 符号访问name变量。也可以同样通过(*ptr).name来访问name变量。\n\n# 结构体\n## 概述\n### 什么事结构体\n1. C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。\n2. 在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。\n3. 为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。\n\n### 结构体的定义\n1. 定义形式：结构体内部的元素，也就是组成成分，我们一般称为\"成员\"。\n结构体的一般定义形式为：\n```\nstruct　结构体名{     \n     类型名1　成员名1;     \n     类型名2　成员名2;     \n     ……     \n     类型名n　成员名n;     \n };\n```\n2. 先定义结构体类型，再定义变量。\n```\nstruct Student {\n     char *name;\n     int age;\n }; \n struct Student stu;\n```\n3. 定义和变量同时进行\n```\nstruct Student {\n    char *name;\n    int age;\n} stu;\n// 结构体变量名为stu\n```\n4. 直接定义结构体类型变量，省略类型名\n```\nstruct {\n    char *name;\n    int age;\n} stu;\n// 结构体变量名为stu\n```\n\n### 注意事项\n- 不可以在结构体本身进行递归定义\n- 可以包含别的结构体\n\n### 内存分配\n- 定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量。\n```\nstruct Student {\n     char *name;\n     int age;\n };\nstruct Student stu;\n// 第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。\n ```\n- 结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列。\n```\nstruct Student {\n     char *name; // 姓名\n     int age; // 年龄\n     float height; // 身高\n };\n// 在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。\n```\n\n### 结构体初始化\n- 将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。\n比如初始化Student结构体变量stu\n```\n struct Student {\n     char *name;\n     int age;\n }; \nstruct Student stu = {“NJ\", 27};\n```\n- 只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是错误的\n```\nstruct Student stu;\nstu = {“NJ\", 27};\n```\n\n### 操作结构体\n1. 一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名\n```\nstruct Student {\n     char *name;\n     int age;\n };\n struct Student stu;\n // 访问stu的age成员\n stu.age = 27;\n// 第9行对结构体的age成员进行了赋值。\".\"称为成员运算符，它在所有运算符中优先级最高\n```\n\n2. 如果某个成员也是结构体变量，可以连续使用成员运算符\".\"访问最低一级成员\n```\nstruct Date {\n       int year;\n       int month;\n       int day;\n  };\n  \n  struct Student {\n      char *name;\n      struct Date birthday;\n };\n \n struct Student stu;\n stu.birthday.year = 1986;\n stu.birthday.month = 9;\n stu.birthday.day = 10;\n```\n\n3. 相同类型的结构体变量之间可以进行整体赋值\n```\nstruct Student {\n      char *name;\n      int age;\n};  \nstruct Student stu1 = {“NJ”, 27};  \n// 将stu1直接赋值给stu2\nstruct Student stu2 = stu1; \nprintf(\"age is %d\", stu2.age);\n```\n\n4. 将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。\n\n5. 指向结构体的指针\n    每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量\n    - 结构体指针变量的定义形式：struct 结构体名称 *指针变量名\n    - 有了指向结构体的指针，那么就有3种访问结构体成员的方式\n    - 结构体变量名.成员名\n    - (*指针变量名).成员名\n    - 指针变量名->成员名\n\n# 枚举\n## 基本概念\n>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。\n\n### 定义\n1. 一般形式为：enum　枚举名　{枚举元素1,枚举元素2,……};\n```\nenum Season {\n\tspring, \n\tsummer, \n\tautumn, \n\tWinter\n}; \n```\n2. 先定义枚举类型，再定义枚举变量\n```\nenum Season {\n\tspring, \n\tsummer, \n\tautumn, \n\tWinter\n}; \n2.enum Season s;\n```\n3. 定义枚举类型的同时定义枚举变量\n```\nenum Season {\n\tspring, \n\tsummer,\n\tautumn,\n \twinter\n} s;\n```\n4. 省略枚举名称，直接定义枚举变量\n```\nenum{\n  spring,\n     summer,\n     autumn, \n     winter\n} s;\n```\n\n### 枚举使用的注意\n1. C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。\n2. 枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。\n```\nenum Season {spring, summer, autumn, winter};\n// 也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3\n```\n3. 也可以在定义枚举类型时改变枚举元素的值\n```\nenum season {spring, summer=3, autumn, winter};\n// 没有指定值的枚举元素，其值为前一元素加1。也就说spring的值为0，summer的值为3，autumn的值为4，winter的值为5\n```\n\n### 赋值\n- 可以给枚举变量赋枚举常量或者整型值\n```\nenum Season {spring, summer, autumn, winter} s;\ns = spring; // 等价于 s = 0;\ns = 3; // 等价于 s = winter;\n```\n\n### 遍历枚举元素\n```\nenum Season {spring, summer, autumn, winter} s;\n// 遍历枚举元素\nfor (s = spring; s <= winter; s++) {\n    printf(\"枚举元素：%d \\n\", s);\n}\n```\n","slug":"c/C语言指针、结构体、枚举","published":1,"updated":"2019-10-02T09:00:32.102Z","layout":"post","photos":[],"link":"","_id":"ck191nwfk001gb0wkht5caffj","content":"<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>指针就是用来保存变量的地址的变量</p>\n<ul>\n<li><p>访问</p>\n<ol>\n<li>我们通过<code>&amp;</code>来获取变量的地址。</li>\n<li><code>&amp;</code>这个操作符只能指向变量或者是数组。</li>\n<li><code>&amp;</code>是获取地址的操作符。</li>\n<li>使用<code>%p</code>来打印地址。</li>\n</ol>\n</li>\n<li><p>本质<br>  指针是一个4字节（或是8字节）的一个int的整数。换句话说也就一个int 型的变量</p>\n</li>\n<li><p>指针变量</p>\n<ol>\n<li>指针变量是用来保存地址的。</li>\n<li>指针变量里保存的地址可以修改。</li>\n<li>指针变量可以指向特殊的数据类型。</li>\n<li>可以有多个指针变量里的值是相同的。</li>\n</ol>\n</li>\n<li><p>一级指针的简单使用<br>  指针访问内存可以通过<code>*</code>这个操作符去访问所指向的内存空间。</p>\n</li>\n</ul>\n<h2 id=\"指针的定义和初始化\"><a href=\"#指针的定义和初始化\" class=\"headerlink\" title=\"指针的定义和初始化\"></a>指针的定义和初始化</h2><ul>\n<li>type * identifier<ol>\n<li>没有初始化的指针，称之为野指针。</li>\n<li>指针里面是一个随机的值。</li>\n<li>野指针有很大的风险。</li>\n<li>指针可以作为函数的参数和返回值。</li>\n</ol>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明一个int指针</span><br><span class=\"line\">int *ptr;</span><br><span class=\"line\">// 声明一个int值</span><br><span class=\"line\">int val = 1;</span><br><span class=\"line\">// 为指针分配一个int值的引用</span><br><span class=\"line\">ptr = &amp;val;</span><br><span class=\"line\">// 对指针进行取值，打印存储在指针地址中的内容</span><br><span class=\"line\">int deref = *ptr;</span><br><span class=\"line\">printf(&quot;%d\\n&quot;, deref);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>第2行，我们通过<code>*</code>操作符声明了一个int指针。接着我们声明了一个int变量并赋值为1。然后我们用int变量的地址初始化我们的int指针。接下来对int指针取值，用变量的内存地址初始化int指针。最终，我们打印输出变量值，内容为1。</p>\n<p>第6行的<code>&amp;val</code>是一个引用。在val变量声明并初始化内存之后，通过在变量名之前使用地址操作符<code>&amp;</code>我们可以直接引用变量的内存地址。<br>第8行，我们再一次使用<code>*</code>操作符来对该指针取值，可直接获得指针指向的内存地址中的数据。由于指针声明的类型是int，所以取到的值是指针指向的内存地址存储的int值。</p>\n<ul>\n<li>void指针、NULL指针和未初始化指针<br>一个指针可以被声明为void类型，比如void *x。一个指针可以被赋值为NULL。一个指针变量声明之后但没有被赋值，叫做未初始化指针。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int *uninit; </span><br><span class=\"line\">// int指针未初始化</span><br><span class=\"line\">int *nullptr = NULL; </span><br><span class=\"line\">// 初始化为NULL</span><br><span class=\"line\">void *vptr; </span><br><span class=\"line\">// void指针未初始化</span><br><span class=\"line\">int val = 1;</span><br><span class=\"line\">int *iptr;</span><br><span class=\"line\">int *castptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">// void类型可以存储任意类型的指针或引用</span><br><span class=\"line\">iptr = &amp;val;</span><br><span class=\"line\">vptr = iptr;</span><br><span class=\"line\">printf(&quot;iptr=%p, vptr=%p\\n&quot;, iptr, vptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 通过显示转换，我们可以把一个void指针转成</span><br><span class=\"line\">// int指针并进行取值</span><br><span class=\"line\">castptr = (int *)vptr;</span><br><span class=\"line\">printf(&quot;*castptr=%d\\n&quot;, *castptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 打印null和未初始化指针</span><br><span class=\"line\">printf(&quot;uninit=%p, nullptr=%p\\n&quot;, uninit, nullptr);</span><br><span class=\"line\">// 不知道你会得到怎样的返回值，会是随机的垃圾地址吗？</span><br><span class=\"line\">// printf(&quot;*nullptr=%d\\n&quot;, nullptr);</span><br><span class=\"line\">// 这里会产生一个段错误</span><br><span class=\"line\">// printf(&quot;*nullptr=%d\\n&quot;, nullptr);</span><br><span class=\"line\">执行上面的代码，你会得到类似下面对应不同内存地址的输出。</span><br><span class=\"line\"></span><br><span class=\"line\">iptr=0x7fff94b89c6c, vptr=0x7fff94b89c6c</span><br><span class=\"line\">*castptr=1</span><br><span class=\"line\">uninit=0x7fff94b89d50, nullptr=(nil)</span><br></pre></td></tr></table></figure>\n\n<p>第1行我们声明了一个未初始化int指针。所有的指针在赋值为NULL、一个引用（地址）或者另一个指针之前都是未被初始化的。第2行我们声明了一个NULL指针。第3行声明了一个void指针。第4行到第6行声明了一个int值和几个int指针。</p>\n<p>第9行到11行，我们为int指针赋值为一个引用并把int指针赋值为void指针。void指针可以保存各种其它指针类型。大多数时候它们被用来存储数据结构。可以注意到，第11行我们打印了int和void指针的地址。它们现在指向了同样的内存地址。所有的指针都存储了内存地址。它们的类型只在取值时起作用。</p>\n<p>第15到16行，我们把void指针转换为int指针castptr。请注意这里需要显示转换。虽然C语言并不要求显示地转换，但这样会增加代码的可读性。接着我们对castptr指针取值，值为1。</p>\n<p>第19行非常有意思，在这里打印未初始化指针和NULL指针。值得注意的是，未初始化指针是有内存地址的，而且是一个垃圾地址。不知道这个内存地址指向的值是什么。这就是为什么不要对未初始化指针取值的原因。最好的情况是你取到的是垃圾地址接下来你需要对程序进行调试，最坏的情况则会导致程序崩溃。</p>\n<blockquote>\n<p>NULL指针被初始化为o。NULL是一个特殊的地址，用NULL赋值的指针指向的地址为0而不是随机的地址。只有当你准备使用这个地址时有效。不要对NULL地址取值，否则会产生段错误。</p>\n</blockquote>\n<ul>\n<li>指针和数组<ul>\n<li>C语言的数组表示一段连续的内存空间，用来存储多个特定类型的对象。与之相反，指针用来存储单个内存地址。数组和指针不是同一种结构因此不可以互相转换。而数组变量指向了数组的第一个元素的内存地址。</li>\n<li>一个数组变量是一个常量。即使指针变量指向同样的地址或者一个不同的数组，也不能把指针赋值给数组变量。也不可以将一个数组变量赋值给另一个数组。然而，可以把一个数组变量赋值给指针，这一点似乎让人感到费解。把数组变量赋值给指针时，实际上是把指向数组第一个元素的地址赋给指针。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int myarray[4] = &#123;1,2,3,0&#125;;</span><br><span class=\"line\">int *ptr = myarray;</span><br><span class=\"line\">printf(&quot;*ptr=%d\\n&quot;, *ptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 数组变量是常量，不能做下面的赋值</span><br><span class=\"line\">// myarray = ptr</span><br><span class=\"line\">// myarray = myarray2</span><br><span class=\"line\">// myarray = &amp;myarray2[0]</span><br></pre></td></tr></table></figure>\n\n<p>第1行初始化了一个int数组，第2行用数组变量初始化了一个int指针。由于数组变量实际上是第一个元素的地址，因此我们可以把这个地址赋值给指针。这个赋值与int *ptr = &amp;myarray[0]效果相同，显示地把数组的第一个元素地址赋值到了ptr引用。这里需要注意的是，这里指针需要和数组的元素类型保持一致，除非指针类型为void。</p>\n<ul>\n<li>指针与<code>结构体</code><br>就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct person &#123;</span><br><span class=\"line\">  int age;</span><br><span class=\"line\">  char *name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">struct person first;</span><br><span class=\"line\">struct person *ptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">first.age = 21;</span><br><span class=\"line\">char *fullname = &quot;full name&quot;;</span><br><span class=\"line\">first.name = fullname;</span><br><span class=\"line\">ptr = &amp;first;</span><br><span class=\"line\"> </span><br><span class=\"line\">printf(&quot;age=%d, name=%s\\n&quot;, first.age, ptr-&gt;name);</span><br></pre></td></tr></table></figure>\n\n<p>第1至6行声明了一个person结构体，一个变量指向了一个person结构体和指向person结构体的指针。第8行为age成员赋了一个int值。第9至10行我们声明了一个char指针并赋值给一个char数组并赋值给结构体name成员。第11行我们把一个person结构体引用赋值给结构体变量。</p>\n<p>第13行我们打印了结构体实例的age和name。这里需要注意两个不同的符号，’.’ 和 ‘-&gt;’ 。结构体实例可以通过使用 ‘.’ 符号访问age变量。对于结构体实例的指针，我们可以通过 ‘-&gt;’ 符号访问name变量。也可以同样通过(*ptr).name来访问name变量。</p>\n<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"什么事结构体\"><a href=\"#什么事结构体\" class=\"headerlink\" title=\"什么事结构体\"></a>什么事结构体</h3><ol>\n<li>C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。</li>\n<li>在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。</li>\n<li>为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。</li>\n</ol>\n<h3 id=\"结构体的定义\"><a href=\"#结构体的定义\" class=\"headerlink\" title=\"结构体的定义\"></a>结构体的定义</h3><ol>\n<li><p>定义形式：结构体内部的元素，也就是组成成分，我们一般称为”成员”。<br>结构体的一般定义形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct　结构体名&#123;     </span><br><span class=\"line\">     类型名1　成员名1;     </span><br><span class=\"line\">     类型名2　成员名2;     </span><br><span class=\"line\">     ……     </span><br><span class=\"line\">     类型名n　成员名n;     </span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先定义结构体类型，再定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> struct Student stu;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义和变量同时进行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">    char *name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125; stu;</span><br><span class=\"line\">// 结构体变量名为stu</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接定义结构体类型变量，省略类型名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123;</span><br><span class=\"line\">    char *name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125; stu;</span><br><span class=\"line\">// 结构体变量名为stu</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不可以在结构体本身进行递归定义</li>\n<li>可以包含别的结构体</li>\n</ul>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><ul>\n<li><p>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">struct Student stu;</span><br><span class=\"line\">// 第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name; // 姓名</span><br><span class=\"line\">     int age; // 年龄</span><br><span class=\"line\">     float height; // 身高</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">// 在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"结构体初始化\"><a href=\"#结构体初始化\" class=\"headerlink\" title=\"结构体初始化\"></a>结构体初始化</h3><ul>\n<li><p>将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。<br>比如初始化Student结构体变量stu</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\">struct Student stu = &#123;“NJ&quot;, 27&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是错误的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student stu;</span><br><span class=\"line\">stu = &#123;“NJ&quot;, 27&#125;;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"操作结构体\"><a href=\"#操作结构体\" class=\"headerlink\" title=\"操作结构体\"></a>操作结构体</h3><ol>\n<li><p>一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> struct Student stu;</span><br><span class=\"line\"> // 访问stu的age成员</span><br><span class=\"line\"> stu.age = 27;</span><br><span class=\"line\">// 第9行对结构体的age成员进行了赋值。&quot;.&quot;称为成员运算符，它在所有运算符中优先级最高</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Date &#123;</span><br><span class=\"line\">       int year;</span><br><span class=\"line\">       int month;</span><br><span class=\"line\">       int day;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  struct Student &#123;</span><br><span class=\"line\">      char *name;</span><br><span class=\"line\">      struct Date birthday;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"> struct Student stu;</span><br><span class=\"line\"> stu.birthday.year = 1986;</span><br><span class=\"line\"> stu.birthday.month = 9;</span><br><span class=\"line\"> stu.birthday.day = 10;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相同类型的结构体变量之间可以进行整体赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">      char *name;</span><br><span class=\"line\">      int age;</span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">struct Student stu1 = &#123;“NJ”, 27&#125;;  </span><br><span class=\"line\">// 将stu1直接赋值给stu2</span><br><span class=\"line\">struct Student stu2 = stu1; </span><br><span class=\"line\">printf(&quot;age is %d&quot;, stu2.age);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。</p>\n</li>\n<li><p>指向结构体的指针<br> 每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量</p>\n<ul>\n<li>结构体指针变量的定义形式：struct 结构体名称 *指针变量名</li>\n<li>有了指向结构体的指针，那么就有3种访问结构体成员的方式</li>\n<li>结构体变量名.成员名</li>\n<li>(*指针变量名).成员名</li>\n<li>指针变量名-&gt;成员名</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><blockquote>\n<p>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。</p>\n</blockquote>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ol>\n<li><p>一般形式为：enum　枚举名　{枚举元素1,枚举元素2,……};</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer, </span><br><span class=\"line\">\tautumn, </span><br><span class=\"line\">\tWinter</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先定义枚举类型，再定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer, </span><br><span class=\"line\">\tautumn, </span><br><span class=\"line\">\tWinter</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">2.enum Season s;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义枚举类型的同时定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer,</span><br><span class=\"line\">\tautumn,</span><br><span class=\"line\"> \twinter</span><br><span class=\"line\">&#125; s;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>省略枚举名称，直接定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum&#123;</span><br><span class=\"line\">  spring,</span><br><span class=\"line\">     summer,</span><br><span class=\"line\">     autumn, </span><br><span class=\"line\">     winter</span><br><span class=\"line\">&#125; s;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"枚举使用的注意\"><a href=\"#枚举使用的注意\" class=\"headerlink\" title=\"枚举使用的注意\"></a>枚举使用的注意</h3><ol>\n<li><p>C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。</p>\n</li>\n<li><p>枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125;;</span><br><span class=\"line\">// 也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>也可以在定义枚举类型时改变枚举元素的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum season &#123;spring, summer=3, autumn, winter&#125;;</span><br><span class=\"line\">// 没有指定值的枚举元素，其值为前一元素加1。也就说spring的值为0，summer的值为3，autumn的值为4，winter的值为5</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><ul>\n<li>可以给枚举变量赋枚举常量或者整型值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class=\"line\">s = spring; // 等价于 s = 0;</span><br><span class=\"line\">s = 3; // 等价于 s = winter;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍历枚举元素\"><a href=\"#遍历枚举元素\" class=\"headerlink\" title=\"遍历枚举元素\"></a>遍历枚举元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class=\"line\">// 遍历枚举元素</span><br><span class=\"line\">for (s = spring; s &lt;= winter; s++) &#123;</span><br><span class=\"line\">    printf(&quot;枚举元素：%d \\n&quot;, s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>指针就是用来保存变量的地址的变量</p>\n<ul>\n<li><p>访问</p>\n<ol>\n<li>我们通过<code>&amp;</code>来获取变量的地址。</li>\n<li><code>&amp;</code>这个操作符只能指向变量或者是数组。</li>\n<li><code>&amp;</code>是获取地址的操作符。</li>\n<li>使用<code>%p</code>来打印地址。</li>\n</ol>\n</li>\n<li><p>本质<br>  指针是一个4字节（或是8字节）的一个int的整数。换句话说也就一个int 型的变量</p>\n</li>\n<li><p>指针变量</p>\n<ol>\n<li>指针变量是用来保存地址的。</li>\n<li>指针变量里保存的地址可以修改。</li>\n<li>指针变量可以指向特殊的数据类型。</li>\n<li>可以有多个指针变量里的值是相同的。</li>\n</ol>\n</li>\n<li><p>一级指针的简单使用<br>  指针访问内存可以通过<code>*</code>这个操作符去访问所指向的内存空间。</p>\n</li>\n</ul>\n<h2 id=\"指针的定义和初始化\"><a href=\"#指针的定义和初始化\" class=\"headerlink\" title=\"指针的定义和初始化\"></a>指针的定义和初始化</h2><ul>\n<li>type * identifier<ol>\n<li>没有初始化的指针，称之为野指针。</li>\n<li>指针里面是一个随机的值。</li>\n<li>野指针有很大的风险。</li>\n<li>指针可以作为函数的参数和返回值。</li>\n</ol>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明一个int指针</span><br><span class=\"line\">int *ptr;</span><br><span class=\"line\">// 声明一个int值</span><br><span class=\"line\">int val = 1;</span><br><span class=\"line\">// 为指针分配一个int值的引用</span><br><span class=\"line\">ptr = &amp;val;</span><br><span class=\"line\">// 对指针进行取值，打印存储在指针地址中的内容</span><br><span class=\"line\">int deref = *ptr;</span><br><span class=\"line\">printf(&quot;%d\\n&quot;, deref);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>第2行，我们通过<code>*</code>操作符声明了一个int指针。接着我们声明了一个int变量并赋值为1。然后我们用int变量的地址初始化我们的int指针。接下来对int指针取值，用变量的内存地址初始化int指针。最终，我们打印输出变量值，内容为1。</p>\n<p>第6行的<code>&amp;val</code>是一个引用。在val变量声明并初始化内存之后，通过在变量名之前使用地址操作符<code>&amp;</code>我们可以直接引用变量的内存地址。<br>第8行，我们再一次使用<code>*</code>操作符来对该指针取值，可直接获得指针指向的内存地址中的数据。由于指针声明的类型是int，所以取到的值是指针指向的内存地址存储的int值。</p>\n<ul>\n<li>void指针、NULL指针和未初始化指针<br>一个指针可以被声明为void类型，比如void *x。一个指针可以被赋值为NULL。一个指针变量声明之后但没有被赋值，叫做未初始化指针。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int *uninit; </span><br><span class=\"line\">// int指针未初始化</span><br><span class=\"line\">int *nullptr = NULL; </span><br><span class=\"line\">// 初始化为NULL</span><br><span class=\"line\">void *vptr; </span><br><span class=\"line\">// void指针未初始化</span><br><span class=\"line\">int val = 1;</span><br><span class=\"line\">int *iptr;</span><br><span class=\"line\">int *castptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">// void类型可以存储任意类型的指针或引用</span><br><span class=\"line\">iptr = &amp;val;</span><br><span class=\"line\">vptr = iptr;</span><br><span class=\"line\">printf(&quot;iptr=%p, vptr=%p\\n&quot;, iptr, vptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 通过显示转换，我们可以把一个void指针转成</span><br><span class=\"line\">// int指针并进行取值</span><br><span class=\"line\">castptr = (int *)vptr;</span><br><span class=\"line\">printf(&quot;*castptr=%d\\n&quot;, *castptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 打印null和未初始化指针</span><br><span class=\"line\">printf(&quot;uninit=%p, nullptr=%p\\n&quot;, uninit, nullptr);</span><br><span class=\"line\">// 不知道你会得到怎样的返回值，会是随机的垃圾地址吗？</span><br><span class=\"line\">// printf(&quot;*nullptr=%d\\n&quot;, nullptr);</span><br><span class=\"line\">// 这里会产生一个段错误</span><br><span class=\"line\">// printf(&quot;*nullptr=%d\\n&quot;, nullptr);</span><br><span class=\"line\">执行上面的代码，你会得到类似下面对应不同内存地址的输出。</span><br><span class=\"line\"></span><br><span class=\"line\">iptr=0x7fff94b89c6c, vptr=0x7fff94b89c6c</span><br><span class=\"line\">*castptr=1</span><br><span class=\"line\">uninit=0x7fff94b89d50, nullptr=(nil)</span><br></pre></td></tr></table></figure>\n\n<p>第1行我们声明了一个未初始化int指针。所有的指针在赋值为NULL、一个引用（地址）或者另一个指针之前都是未被初始化的。第2行我们声明了一个NULL指针。第3行声明了一个void指针。第4行到第6行声明了一个int值和几个int指针。</p>\n<p>第9行到11行，我们为int指针赋值为一个引用并把int指针赋值为void指针。void指针可以保存各种其它指针类型。大多数时候它们被用来存储数据结构。可以注意到，第11行我们打印了int和void指针的地址。它们现在指向了同样的内存地址。所有的指针都存储了内存地址。它们的类型只在取值时起作用。</p>\n<p>第15到16行，我们把void指针转换为int指针castptr。请注意这里需要显示转换。虽然C语言并不要求显示地转换，但这样会增加代码的可读性。接着我们对castptr指针取值，值为1。</p>\n<p>第19行非常有意思，在这里打印未初始化指针和NULL指针。值得注意的是，未初始化指针是有内存地址的，而且是一个垃圾地址。不知道这个内存地址指向的值是什么。这就是为什么不要对未初始化指针取值的原因。最好的情况是你取到的是垃圾地址接下来你需要对程序进行调试，最坏的情况则会导致程序崩溃。</p>\n<blockquote>\n<p>NULL指针被初始化为o。NULL是一个特殊的地址，用NULL赋值的指针指向的地址为0而不是随机的地址。只有当你准备使用这个地址时有效。不要对NULL地址取值，否则会产生段错误。</p>\n</blockquote>\n<ul>\n<li>指针和数组<ul>\n<li>C语言的数组表示一段连续的内存空间，用来存储多个特定类型的对象。与之相反，指针用来存储单个内存地址。数组和指针不是同一种结构因此不可以互相转换。而数组变量指向了数组的第一个元素的内存地址。</li>\n<li>一个数组变量是一个常量。即使指针变量指向同样的地址或者一个不同的数组，也不能把指针赋值给数组变量。也不可以将一个数组变量赋值给另一个数组。然而，可以把一个数组变量赋值给指针，这一点似乎让人感到费解。把数组变量赋值给指针时，实际上是把指向数组第一个元素的地址赋给指针。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int myarray[4] = &#123;1,2,3,0&#125;;</span><br><span class=\"line\">int *ptr = myarray;</span><br><span class=\"line\">printf(&quot;*ptr=%d\\n&quot;, *ptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 数组变量是常量，不能做下面的赋值</span><br><span class=\"line\">// myarray = ptr</span><br><span class=\"line\">// myarray = myarray2</span><br><span class=\"line\">// myarray = &amp;myarray2[0]</span><br></pre></td></tr></table></figure>\n\n<p>第1行初始化了一个int数组，第2行用数组变量初始化了一个int指针。由于数组变量实际上是第一个元素的地址，因此我们可以把这个地址赋值给指针。这个赋值与int *ptr = &amp;myarray[0]效果相同，显示地把数组的第一个元素地址赋值到了ptr引用。这里需要注意的是，这里指针需要和数组的元素类型保持一致，除非指针类型为void。</p>\n<ul>\n<li>指针与<code>结构体</code><br>就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct person &#123;</span><br><span class=\"line\">  int age;</span><br><span class=\"line\">  char *name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">struct person first;</span><br><span class=\"line\">struct person *ptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">first.age = 21;</span><br><span class=\"line\">char *fullname = &quot;full name&quot;;</span><br><span class=\"line\">first.name = fullname;</span><br><span class=\"line\">ptr = &amp;first;</span><br><span class=\"line\"> </span><br><span class=\"line\">printf(&quot;age=%d, name=%s\\n&quot;, first.age, ptr-&gt;name);</span><br></pre></td></tr></table></figure>\n\n<p>第1至6行声明了一个person结构体，一个变量指向了一个person结构体和指向person结构体的指针。第8行为age成员赋了一个int值。第9至10行我们声明了一个char指针并赋值给一个char数组并赋值给结构体name成员。第11行我们把一个person结构体引用赋值给结构体变量。</p>\n<p>第13行我们打印了结构体实例的age和name。这里需要注意两个不同的符号，’.’ 和 ‘-&gt;’ 。结构体实例可以通过使用 ‘.’ 符号访问age变量。对于结构体实例的指针，我们可以通过 ‘-&gt;’ 符号访问name变量。也可以同样通过(*ptr).name来访问name变量。</p>\n<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"什么事结构体\"><a href=\"#什么事结构体\" class=\"headerlink\" title=\"什么事结构体\"></a>什么事结构体</h3><ol>\n<li>C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。</li>\n<li>在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。</li>\n<li>为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。</li>\n</ol>\n<h3 id=\"结构体的定义\"><a href=\"#结构体的定义\" class=\"headerlink\" title=\"结构体的定义\"></a>结构体的定义</h3><ol>\n<li><p>定义形式：结构体内部的元素，也就是组成成分，我们一般称为”成员”。<br>结构体的一般定义形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct　结构体名&#123;     </span><br><span class=\"line\">     类型名1　成员名1;     </span><br><span class=\"line\">     类型名2　成员名2;     </span><br><span class=\"line\">     ……     </span><br><span class=\"line\">     类型名n　成员名n;     </span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先定义结构体类型，再定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> struct Student stu;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义和变量同时进行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">    char *name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125; stu;</span><br><span class=\"line\">// 结构体变量名为stu</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接定义结构体类型变量，省略类型名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123;</span><br><span class=\"line\">    char *name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125; stu;</span><br><span class=\"line\">// 结构体变量名为stu</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不可以在结构体本身进行递归定义</li>\n<li>可以包含别的结构体</li>\n</ul>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><ul>\n<li><p>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">struct Student stu;</span><br><span class=\"line\">// 第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name; // 姓名</span><br><span class=\"line\">     int age; // 年龄</span><br><span class=\"line\">     float height; // 身高</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">// 在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"结构体初始化\"><a href=\"#结构体初始化\" class=\"headerlink\" title=\"结构体初始化\"></a>结构体初始化</h3><ul>\n<li><p>将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。<br>比如初始化Student结构体变量stu</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\">struct Student stu = &#123;“NJ&quot;, 27&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是错误的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student stu;</span><br><span class=\"line\">stu = &#123;“NJ&quot;, 27&#125;;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"操作结构体\"><a href=\"#操作结构体\" class=\"headerlink\" title=\"操作结构体\"></a>操作结构体</h3><ol>\n<li><p>一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> struct Student stu;</span><br><span class=\"line\"> // 访问stu的age成员</span><br><span class=\"line\"> stu.age = 27;</span><br><span class=\"line\">// 第9行对结构体的age成员进行了赋值。&quot;.&quot;称为成员运算符，它在所有运算符中优先级最高</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Date &#123;</span><br><span class=\"line\">       int year;</span><br><span class=\"line\">       int month;</span><br><span class=\"line\">       int day;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  struct Student &#123;</span><br><span class=\"line\">      char *name;</span><br><span class=\"line\">      struct Date birthday;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"> struct Student stu;</span><br><span class=\"line\"> stu.birthday.year = 1986;</span><br><span class=\"line\"> stu.birthday.month = 9;</span><br><span class=\"line\"> stu.birthday.day = 10;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相同类型的结构体变量之间可以进行整体赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">      char *name;</span><br><span class=\"line\">      int age;</span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">struct Student stu1 = &#123;“NJ”, 27&#125;;  </span><br><span class=\"line\">// 将stu1直接赋值给stu2</span><br><span class=\"line\">struct Student stu2 = stu1; </span><br><span class=\"line\">printf(&quot;age is %d&quot;, stu2.age);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。</p>\n</li>\n<li><p>指向结构体的指针<br> 每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量</p>\n<ul>\n<li>结构体指针变量的定义形式：struct 结构体名称 *指针变量名</li>\n<li>有了指向结构体的指针，那么就有3种访问结构体成员的方式</li>\n<li>结构体变量名.成员名</li>\n<li>(*指针变量名).成员名</li>\n<li>指针变量名-&gt;成员名</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><blockquote>\n<p>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。</p>\n</blockquote>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ol>\n<li><p>一般形式为：enum　枚举名　{枚举元素1,枚举元素2,……};</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer, </span><br><span class=\"line\">\tautumn, </span><br><span class=\"line\">\tWinter</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先定义枚举类型，再定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer, </span><br><span class=\"line\">\tautumn, </span><br><span class=\"line\">\tWinter</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">2.enum Season s;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义枚举类型的同时定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer,</span><br><span class=\"line\">\tautumn,</span><br><span class=\"line\"> \twinter</span><br><span class=\"line\">&#125; s;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>省略枚举名称，直接定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum&#123;</span><br><span class=\"line\">  spring,</span><br><span class=\"line\">     summer,</span><br><span class=\"line\">     autumn, </span><br><span class=\"line\">     winter</span><br><span class=\"line\">&#125; s;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"枚举使用的注意\"><a href=\"#枚举使用的注意\" class=\"headerlink\" title=\"枚举使用的注意\"></a>枚举使用的注意</h3><ol>\n<li><p>C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。</p>\n</li>\n<li><p>枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125;;</span><br><span class=\"line\">// 也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>也可以在定义枚举类型时改变枚举元素的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum season &#123;spring, summer=3, autumn, winter&#125;;</span><br><span class=\"line\">// 没有指定值的枚举元素，其值为前一元素加1。也就说spring的值为0，summer的值为3，autumn的值为4，winter的值为5</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><ul>\n<li>可以给枚举变量赋枚举常量或者整型值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class=\"line\">s = spring; // 等价于 s = 0;</span><br><span class=\"line\">s = 3; // 等价于 s = winter;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍历枚举元素\"><a href=\"#遍历枚举元素\" class=\"headerlink\" title=\"遍历枚举元素\"></a>遍历枚举元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class=\"line\">// 遍历枚举元素</span><br><span class=\"line\">for (s = spring; s &lt;= winter; s++) &#123;</span><br><span class=\"line\">    printf(&quot;枚举元素：%d \\n&quot;, s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"C语言的预处理指令和关键字","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-20T13:24:00.000Z","_content":"## 预处理指令\n- C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译\n- 为了区分预处理指令和一般的C语句，所有预处理指令都以符号“#”开头，并且结尾不用分号\n- 预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件\n- C语言提供的预处理指令主要有：宏定义、文件包含、条件编译\n\n### 定义\n宏定义可以分为2种：\n\n1. 不带参数的宏定义 \n    - 定义格式：\n    ```\n    #define 宏名 字符串\n    // 比如  #define ABC 10\n    ```\n    - 作用：是在编译预处理时，将源程序中所有\"宏名\"替换成右边的\"字符串\"，常用来定义常量。\n    - 使用习惯与注意\n        1. 宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误\n        2. 对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。\n        3. 在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查\n        4. 宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令\n        5. 定义一个宏时可以引用已经定义的宏名\n    \n2. 带参数的宏定义\n    - 定义格式：\n    ```\n    #define 宏名(参数列表) 字符串\n    ```\n    - 作用：在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换.\n    - 使用注意：\n        1. 宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.\n        2. 带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。\n        3. 参数和计算结果都要用小括号括起来\n    - 与函数的区别：从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：\n        1. 宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题\n        2. 函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率\n        \n### 条件编译\n>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。\n \n- 格式  \n```   \n#if 条件1\n  ...code1...\n#elif 条件2\n  ...code2...\n#else\n  ...code3...\n#endif\n```\n\n- 注意\n>条件编译结束后，要在最后面加一个#endif，不然后果很严重。\n`#if` 和 `#elif`后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义。\n\n- 条件编译其它用法\n```\n#if defined()和#if !defined()的用法\n//#if defined(MAX)\n#if !defined(MAX)\n    ...code...\n#endif\n#ifdef 和 ifndef的用法\n //#ifdef MAX\n #ifndef MAX\n     ...code...\n #endif\n```\n## static/extern\n### static和extern关键字对函数的作用\n- 外部函数和内部函数\n    - 外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。C语言规定，不允许有同名的外部函数。\n    - 内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。C语言规定不同的源文件可以有同名的内部函数，并且互不干扰。\n- `extern`\n    - 在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。\n    - 在一个文件中要调用其他文件中的外部函数，则需要在当前文件中用extern声明该外部函数，然后就可以使用，这里的extern也可以省略。\n- `static`\n    - 在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。\n    - static也可以用来声明一个内部函数\n\n### static和extern关键字对全局变量的作用\n1. extern可以用来声明一个全局变量，但是不能用来定义变量\n2. 默认情况下，一个全局变量是可以供多个源文件共享的，也就说，多个源文件中同名的全局变量都代表着同一个变量\n3. 如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰\n\n### Static对局部变量的作用\n1. 用static修饰局部变量后会延长局部变量的生命周期，当执行到定义变量的那一行的时候分配存储空间，但是直到程序结束变量才会释放\n2. 尽管延长了变量的生命周期，但是没有改变变量的作用域\n    使用场合：当一个变量要被经常重复使用的时候就可以用static来修饰这个变量\n\n## typedef\n>可以使用typedef关键字为各种数据类型定义一个新名字(别名)，可以简化代码和提高阅读性。\n\n### typedef与指针\n```\ntypedef char *String;\nint main(int argc, const char * argv[]) {\n    // 相当于char *str = \"This is a string!\";\n    String str = \"This is a string!\";    \n    printf(\"%s\", str);   \n    return 0;\n }\n```\n\n### typedef与结构体\n```\n// 定义一个结构体\nstruct MyPoint {\n    float x;\n     float y;\n}; \nint main(int argc, const char * argv[]) {\n   // 定义结构体变量\n    struct MyPoint p;\n    p.x = 10.0f;\n    p.y = 20.0f;\n    retuen 0;    \n}\n```\n### 使用typedef给结构体起别名\n```\n// 定义一个结构体\nstruct MyPoint {\n   float x;\n   float y;\n};\n// 起别名\ntypedef struct MyPoint Point; \nint main(int argc, const char * argv[]) {\n  // 定义结构体变量\n  Point p;\n  p.x = 10.0f;\n  p.y = 20.0f;    \n  return 0;\n}\n```\n### typedef与指向结构体的指针\n```\n// 定义一个结构体并起别名\n typedef struct {\n    float x;\n    float y;\n } Point; \n // 起别名\n typedef Point *PP; \n int main(int argc, const char * argv[]) {\n    // 定义结构体变量\n    Point point = {10, 20};    \n    // 定义指针变量\n    PP p = &point;     \n    // 利用指针变量访问结构体成员\n    printf(\"x=%f，y=%f\", p->x, p->y);\n    return 0;\n}\n```\n### typedef与指向函数的指针\n```\n// 定义一个sum函数，计算a跟b的和\n  int sum(int a, int b) {\n      int c = a + b;\n      printf(\"%d + %d = %d\", a, b, c);\n      return c;\n  }  \n typedef int (*MySum)(int, int);\n int main(int argc, const char * argv[]) {\n     // 定义一个指向sum函数的指针变量p\n     // int (*p)(int, int) = sum;  \n     // 定义一个指向sum函数的指针变量p\n     MySum p = sum;   \n     // 利用指针变量p调用sum函数\n     (*p)(4, 5);\n     return 0;\n }\n```\n### typedef与#define\n```\ntypedef char *String1;//其别名\n#define String2 char *//宏定义，在代码中只是将(char *)替换称String\nint main(int argc, const char * argv[]) \n    String1 str1, str2;   // 实际是char *str1,char *str2\n    String2 str3, str4;   // 实际是char *str3,char str4\n    return 0;\n}\n```\n\n### 使用场合：\n - 给基本数据类型起别名\n - 给指针起别名\n - 给结构体起别名\n - 给枚举起别名\n - 给指向函数的指针起别名\n - 给指向结构体的指针起别名","source":"_posts/c/C语言的预处理指令和关键字.md","raw":"---\ntitle: C语言的预处理指令和关键字\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-20 21:24:00   \n---\n## 预处理指令\n- C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译\n- 为了区分预处理指令和一般的C语句，所有预处理指令都以符号“#”开头，并且结尾不用分号\n- 预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件\n- C语言提供的预处理指令主要有：宏定义、文件包含、条件编译\n\n### 定义\n宏定义可以分为2种：\n\n1. 不带参数的宏定义 \n    - 定义格式：\n    ```\n    #define 宏名 字符串\n    // 比如  #define ABC 10\n    ```\n    - 作用：是在编译预处理时，将源程序中所有\"宏名\"替换成右边的\"字符串\"，常用来定义常量。\n    - 使用习惯与注意\n        1. 宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误\n        2. 对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。\n        3. 在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查\n        4. 宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令\n        5. 定义一个宏时可以引用已经定义的宏名\n    \n2. 带参数的宏定义\n    - 定义格式：\n    ```\n    #define 宏名(参数列表) 字符串\n    ```\n    - 作用：在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换.\n    - 使用注意：\n        1. 宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.\n        2. 带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。\n        3. 参数和计算结果都要用小括号括起来\n    - 与函数的区别：从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：\n        1. 宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题\n        2. 函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率\n        \n### 条件编译\n>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。\n \n- 格式  \n```   \n#if 条件1\n  ...code1...\n#elif 条件2\n  ...code2...\n#else\n  ...code3...\n#endif\n```\n\n- 注意\n>条件编译结束后，要在最后面加一个#endif，不然后果很严重。\n`#if` 和 `#elif`后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义。\n\n- 条件编译其它用法\n```\n#if defined()和#if !defined()的用法\n//#if defined(MAX)\n#if !defined(MAX)\n    ...code...\n#endif\n#ifdef 和 ifndef的用法\n //#ifdef MAX\n #ifndef MAX\n     ...code...\n #endif\n```\n## static/extern\n### static和extern关键字对函数的作用\n- 外部函数和内部函数\n    - 外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。C语言规定，不允许有同名的外部函数。\n    - 内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。C语言规定不同的源文件可以有同名的内部函数，并且互不干扰。\n- `extern`\n    - 在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。\n    - 在一个文件中要调用其他文件中的外部函数，则需要在当前文件中用extern声明该外部函数，然后就可以使用，这里的extern也可以省略。\n- `static`\n    - 在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。\n    - static也可以用来声明一个内部函数\n\n### static和extern关键字对全局变量的作用\n1. extern可以用来声明一个全局变量，但是不能用来定义变量\n2. 默认情况下，一个全局变量是可以供多个源文件共享的，也就说，多个源文件中同名的全局变量都代表着同一个变量\n3. 如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰\n\n### Static对局部变量的作用\n1. 用static修饰局部变量后会延长局部变量的生命周期，当执行到定义变量的那一行的时候分配存储空间，但是直到程序结束变量才会释放\n2. 尽管延长了变量的生命周期，但是没有改变变量的作用域\n    使用场合：当一个变量要被经常重复使用的时候就可以用static来修饰这个变量\n\n## typedef\n>可以使用typedef关键字为各种数据类型定义一个新名字(别名)，可以简化代码和提高阅读性。\n\n### typedef与指针\n```\ntypedef char *String;\nint main(int argc, const char * argv[]) {\n    // 相当于char *str = \"This is a string!\";\n    String str = \"This is a string!\";    \n    printf(\"%s\", str);   \n    return 0;\n }\n```\n\n### typedef与结构体\n```\n// 定义一个结构体\nstruct MyPoint {\n    float x;\n     float y;\n}; \nint main(int argc, const char * argv[]) {\n   // 定义结构体变量\n    struct MyPoint p;\n    p.x = 10.0f;\n    p.y = 20.0f;\n    retuen 0;    \n}\n```\n### 使用typedef给结构体起别名\n```\n// 定义一个结构体\nstruct MyPoint {\n   float x;\n   float y;\n};\n// 起别名\ntypedef struct MyPoint Point; \nint main(int argc, const char * argv[]) {\n  // 定义结构体变量\n  Point p;\n  p.x = 10.0f;\n  p.y = 20.0f;    \n  return 0;\n}\n```\n### typedef与指向结构体的指针\n```\n// 定义一个结构体并起别名\n typedef struct {\n    float x;\n    float y;\n } Point; \n // 起别名\n typedef Point *PP; \n int main(int argc, const char * argv[]) {\n    // 定义结构体变量\n    Point point = {10, 20};    \n    // 定义指针变量\n    PP p = &point;     \n    // 利用指针变量访问结构体成员\n    printf(\"x=%f，y=%f\", p->x, p->y);\n    return 0;\n}\n```\n### typedef与指向函数的指针\n```\n// 定义一个sum函数，计算a跟b的和\n  int sum(int a, int b) {\n      int c = a + b;\n      printf(\"%d + %d = %d\", a, b, c);\n      return c;\n  }  \n typedef int (*MySum)(int, int);\n int main(int argc, const char * argv[]) {\n     // 定义一个指向sum函数的指针变量p\n     // int (*p)(int, int) = sum;  \n     // 定义一个指向sum函数的指针变量p\n     MySum p = sum;   \n     // 利用指针变量p调用sum函数\n     (*p)(4, 5);\n     return 0;\n }\n```\n### typedef与#define\n```\ntypedef char *String1;//其别名\n#define String2 char *//宏定义，在代码中只是将(char *)替换称String\nint main(int argc, const char * argv[]) \n    String1 str1, str2;   // 实际是char *str1,char *str2\n    String2 str3, str4;   // 实际是char *str3,char str4\n    return 0;\n}\n```\n\n### 使用场合：\n - 给基本数据类型起别名\n - 给指针起别名\n - 给结构体起别名\n - 给枚举起别名\n - 给指向函数的指针起别名\n - 给指向结构体的指针起别名","slug":"c/C语言的预处理指令和关键字","published":1,"updated":"2019-10-02T09:03:08.980Z","layout":"post","photos":[],"link":"","_id":"ck191nwfo001jb0wke900fnmc","content":"<h2 id=\"预处理指令\"><a href=\"#预处理指令\" class=\"headerlink\" title=\"预处理指令\"></a>预处理指令</h2><ul>\n<li>C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译</li>\n<li>为了区分预处理指令和一般的C语句，所有预处理指令都以符号“#”开头，并且结尾不用分号</li>\n<li>预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件</li>\n<li>C语言提供的预处理指令主要有：宏定义、文件包含、条件编译</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>宏定义可以分为2种：</p>\n<ol>\n<li><p>不带参数的宏定义 </p>\n<ul>\n<li><p>定义格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define 宏名 字符串</span><br><span class=\"line\">// 比如  #define ABC 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：是在编译预处理时，将源程序中所有”宏名”替换成右边的”字符串”，常用来定义常量。</p>\n</li>\n<li><p>使用习惯与注意</p>\n<ol>\n<li>宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误</li>\n<li>对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。</li>\n<li>在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查</li>\n<li>宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令</li>\n<li>定义一个宏时可以引用已经定义的宏名</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>带参数的宏定义</p>\n<ul>\n<li><p>定义格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define 宏名(参数列表) 字符串</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换.</p>\n</li>\n<li><p>使用注意：</p>\n<ol>\n<li>宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.</li>\n<li>带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。</li>\n<li>参数和计算结果都要用小括号括起来</li>\n</ol>\n</li>\n<li><p>与函数的区别：从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：</p>\n<ol>\n<li>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题</li>\n<li>函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h3><blockquote>\n<p>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。</p>\n</blockquote>\n<ul>\n<li><p>格式  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if 条件1</span><br><span class=\"line\">  ...code1...</span><br><span class=\"line\">#elif 条件2</span><br><span class=\"line\">  ...code2...</span><br><span class=\"line\">#else</span><br><span class=\"line\">  ...code3...</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意</p>\n<blockquote>\n<p>条件编译结束后，要在最后面加一个#endif，不然后果很严重。<br><code>#if</code> 和 <code>#elif</code>后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义。</p>\n</blockquote>\n</li>\n<li><p>条件编译其它用法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined()和#if !defined()的用法</span><br><span class=\"line\">//#if defined(MAX)</span><br><span class=\"line\">#if !defined(MAX)</span><br><span class=\"line\">    ...code...</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef 和 ifndef的用法</span><br><span class=\"line\"> //#ifdef MAX</span><br><span class=\"line\"> #ifndef MAX</span><br><span class=\"line\">     ...code...</span><br><span class=\"line\"> #endif</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"static-extern\"><a href=\"#static-extern\" class=\"headerlink\" title=\"static/extern\"></a>static/extern</h2><h3 id=\"static和extern关键字对函数的作用\"><a href=\"#static和extern关键字对函数的作用\" class=\"headerlink\" title=\"static和extern关键字对函数的作用\"></a>static和extern关键字对函数的作用</h3><ul>\n<li>外部函数和内部函数<ul>\n<li>外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。C语言规定，不允许有同名的外部函数。</li>\n<li>内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。C语言规定不同的源文件可以有同名的内部函数，并且互不干扰。</li>\n</ul>\n</li>\n<li><code>extern</code><ul>\n<li>在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。</li>\n<li>在一个文件中要调用其他文件中的外部函数，则需要在当前文件中用extern声明该外部函数，然后就可以使用，这里的extern也可以省略。</li>\n</ul>\n</li>\n<li><code>static</code><ul>\n<li>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。</li>\n<li>static也可以用来声明一个内部函数</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"static和extern关键字对全局变量的作用\"><a href=\"#static和extern关键字对全局变量的作用\" class=\"headerlink\" title=\"static和extern关键字对全局变量的作用\"></a>static和extern关键字对全局变量的作用</h3><ol>\n<li>extern可以用来声明一个全局变量，但是不能用来定义变量</li>\n<li>默认情况下，一个全局变量是可以供多个源文件共享的，也就说，多个源文件中同名的全局变量都代表着同一个变量</li>\n<li>如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</li>\n</ol>\n<h3 id=\"Static对局部变量的作用\"><a href=\"#Static对局部变量的作用\" class=\"headerlink\" title=\"Static对局部变量的作用\"></a>Static对局部变量的作用</h3><ol>\n<li>用static修饰局部变量后会延长局部变量的生命周期，当执行到定义变量的那一行的时候分配存储空间，但是直到程序结束变量才会释放</li>\n<li>尽管延长了变量的生命周期，但是没有改变变量的作用域<br> 使用场合：当一个变量要被经常重复使用的时候就可以用static来修饰这个变量</li>\n</ol>\n<h2 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h2><blockquote>\n<p>可以使用typedef关键字为各种数据类型定义一个新名字(别名)，可以简化代码和提高阅读性。</p>\n</blockquote>\n<h3 id=\"typedef与指针\"><a href=\"#typedef与指针\" class=\"headerlink\" title=\"typedef与指针\"></a>typedef与指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char *String;</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    // 相当于char *str = &quot;This is a string!&quot;;</span><br><span class=\"line\">    String str = &quot;This is a string!&quot;;    </span><br><span class=\"line\">    printf(&quot;%s&quot;, str);   </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与结构体\"><a href=\"#typedef与结构体\" class=\"headerlink\" title=\"typedef与结构体\"></a>typedef与结构体</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体</span><br><span class=\"line\">struct MyPoint &#123;</span><br><span class=\"line\">    float x;</span><br><span class=\"line\">     float y;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">   // 定义结构体变量</span><br><span class=\"line\">    struct MyPoint p;</span><br><span class=\"line\">    p.x = 10.0f;</span><br><span class=\"line\">    p.y = 20.0f;</span><br><span class=\"line\">    retuen 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用typedef给结构体起别名\"><a href=\"#使用typedef给结构体起别名\" class=\"headerlink\" title=\"使用typedef给结构体起别名\"></a>使用typedef给结构体起别名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体</span><br><span class=\"line\">struct MyPoint &#123;</span><br><span class=\"line\">   float x;</span><br><span class=\"line\">   float y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 起别名</span><br><span class=\"line\">typedef struct MyPoint Point; </span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">  // 定义结构体变量</span><br><span class=\"line\">  Point p;</span><br><span class=\"line\">  p.x = 10.0f;</span><br><span class=\"line\">  p.y = 20.0f;    </span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与指向结构体的指针\"><a href=\"#typedef与指向结构体的指针\" class=\"headerlink\" title=\"typedef与指向结构体的指针\"></a>typedef与指向结构体的指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体并起别名</span><br><span class=\"line\"> typedef struct &#123;</span><br><span class=\"line\">    float x;</span><br><span class=\"line\">    float y;</span><br><span class=\"line\"> &#125; Point; </span><br><span class=\"line\"> // 起别名</span><br><span class=\"line\"> typedef Point *PP; </span><br><span class=\"line\"> int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    // 定义结构体变量</span><br><span class=\"line\">    Point point = &#123;10, 20&#125;;    </span><br><span class=\"line\">    // 定义指针变量</span><br><span class=\"line\">    PP p = &amp;point;     </span><br><span class=\"line\">    // 利用指针变量访问结构体成员</span><br><span class=\"line\">    printf(&quot;x=%f，y=%f&quot;, p-&gt;x, p-&gt;y);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与指向函数的指针\"><a href=\"#typedef与指向函数的指针\" class=\"headerlink\" title=\"typedef与指向函数的指针\"></a>typedef与指向函数的指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个sum函数，计算a跟b的和</span><br><span class=\"line\">  int sum(int a, int b) &#123;</span><br><span class=\"line\">      int c = a + b;</span><br><span class=\"line\">      printf(&quot;%d + %d = %d&quot;, a, b, c);</span><br><span class=\"line\">      return c;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"> typedef int (*MySum)(int, int);</span><br><span class=\"line\"> int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">     // 定义一个指向sum函数的指针变量p</span><br><span class=\"line\">     // int (*p)(int, int) = sum;  </span><br><span class=\"line\">     // 定义一个指向sum函数的指针变量p</span><br><span class=\"line\">     MySum p = sum;   </span><br><span class=\"line\">     // 利用指针变量p调用sum函数</span><br><span class=\"line\">     (*p)(4, 5);</span><br><span class=\"line\">     return 0;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与-define\"><a href=\"#typedef与-define\" class=\"headerlink\" title=\"typedef与#define\"></a>typedef与#define</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char *String1;//其别名</span><br><span class=\"line\">#define String2 char *//宏定义，在代码中只是将(char *)替换称String</span><br><span class=\"line\">int main(int argc, const char * argv[]) </span><br><span class=\"line\">    String1 str1, str2;   // 实际是char *str1,char *str2</span><br><span class=\"line\">    String2 str3, str4;   // 实际是char *str3,char str4</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用场合：\"><a href=\"#使用场合：\" class=\"headerlink\" title=\"使用场合：\"></a>使用场合：</h3><ul>\n<li>给基本数据类型起别名</li>\n<li>给指针起别名</li>\n<li>给结构体起别名</li>\n<li>给枚举起别名</li>\n<li>给指向函数的指针起别名</li>\n<li>给指向结构体的指针起别名</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"预处理指令\"><a href=\"#预处理指令\" class=\"headerlink\" title=\"预处理指令\"></a>预处理指令</h2><ul>\n<li>C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译</li>\n<li>为了区分预处理指令和一般的C语句，所有预处理指令都以符号“#”开头，并且结尾不用分号</li>\n<li>预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件</li>\n<li>C语言提供的预处理指令主要有：宏定义、文件包含、条件编译</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>宏定义可以分为2种：</p>\n<ol>\n<li><p>不带参数的宏定义 </p>\n<ul>\n<li><p>定义格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define 宏名 字符串</span><br><span class=\"line\">// 比如  #define ABC 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：是在编译预处理时，将源程序中所有”宏名”替换成右边的”字符串”，常用来定义常量。</p>\n</li>\n<li><p>使用习惯与注意</p>\n<ol>\n<li>宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误</li>\n<li>对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。</li>\n<li>在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查</li>\n<li>宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令</li>\n<li>定义一个宏时可以引用已经定义的宏名</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>带参数的宏定义</p>\n<ul>\n<li><p>定义格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define 宏名(参数列表) 字符串</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换.</p>\n</li>\n<li><p>使用注意：</p>\n<ol>\n<li>宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.</li>\n<li>带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。</li>\n<li>参数和计算结果都要用小括号括起来</li>\n</ol>\n</li>\n<li><p>与函数的区别：从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：</p>\n<ol>\n<li>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题</li>\n<li>函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h3><blockquote>\n<p>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。</p>\n</blockquote>\n<ul>\n<li><p>格式  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if 条件1</span><br><span class=\"line\">  ...code1...</span><br><span class=\"line\">#elif 条件2</span><br><span class=\"line\">  ...code2...</span><br><span class=\"line\">#else</span><br><span class=\"line\">  ...code3...</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意</p>\n<blockquote>\n<p>条件编译结束后，要在最后面加一个#endif，不然后果很严重。<br><code>#if</code> 和 <code>#elif</code>后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义。</p>\n</blockquote>\n</li>\n<li><p>条件编译其它用法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined()和#if !defined()的用法</span><br><span class=\"line\">//#if defined(MAX)</span><br><span class=\"line\">#if !defined(MAX)</span><br><span class=\"line\">    ...code...</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef 和 ifndef的用法</span><br><span class=\"line\"> //#ifdef MAX</span><br><span class=\"line\"> #ifndef MAX</span><br><span class=\"line\">     ...code...</span><br><span class=\"line\"> #endif</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"static-extern\"><a href=\"#static-extern\" class=\"headerlink\" title=\"static/extern\"></a>static/extern</h2><h3 id=\"static和extern关键字对函数的作用\"><a href=\"#static和extern关键字对函数的作用\" class=\"headerlink\" title=\"static和extern关键字对函数的作用\"></a>static和extern关键字对函数的作用</h3><ul>\n<li>外部函数和内部函数<ul>\n<li>外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。C语言规定，不允许有同名的外部函数。</li>\n<li>内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。C语言规定不同的源文件可以有同名的内部函数，并且互不干扰。</li>\n</ul>\n</li>\n<li><code>extern</code><ul>\n<li>在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。</li>\n<li>在一个文件中要调用其他文件中的外部函数，则需要在当前文件中用extern声明该外部函数，然后就可以使用，这里的extern也可以省略。</li>\n</ul>\n</li>\n<li><code>static</code><ul>\n<li>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。</li>\n<li>static也可以用来声明一个内部函数</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"static和extern关键字对全局变量的作用\"><a href=\"#static和extern关键字对全局变量的作用\" class=\"headerlink\" title=\"static和extern关键字对全局变量的作用\"></a>static和extern关键字对全局变量的作用</h3><ol>\n<li>extern可以用来声明一个全局变量，但是不能用来定义变量</li>\n<li>默认情况下，一个全局变量是可以供多个源文件共享的，也就说，多个源文件中同名的全局变量都代表着同一个变量</li>\n<li>如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</li>\n</ol>\n<h3 id=\"Static对局部变量的作用\"><a href=\"#Static对局部变量的作用\" class=\"headerlink\" title=\"Static对局部变量的作用\"></a>Static对局部变量的作用</h3><ol>\n<li>用static修饰局部变量后会延长局部变量的生命周期，当执行到定义变量的那一行的时候分配存储空间，但是直到程序结束变量才会释放</li>\n<li>尽管延长了变量的生命周期，但是没有改变变量的作用域<br> 使用场合：当一个变量要被经常重复使用的时候就可以用static来修饰这个变量</li>\n</ol>\n<h2 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h2><blockquote>\n<p>可以使用typedef关键字为各种数据类型定义一个新名字(别名)，可以简化代码和提高阅读性。</p>\n</blockquote>\n<h3 id=\"typedef与指针\"><a href=\"#typedef与指针\" class=\"headerlink\" title=\"typedef与指针\"></a>typedef与指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char *String;</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    // 相当于char *str = &quot;This is a string!&quot;;</span><br><span class=\"line\">    String str = &quot;This is a string!&quot;;    </span><br><span class=\"line\">    printf(&quot;%s&quot;, str);   </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与结构体\"><a href=\"#typedef与结构体\" class=\"headerlink\" title=\"typedef与结构体\"></a>typedef与结构体</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体</span><br><span class=\"line\">struct MyPoint &#123;</span><br><span class=\"line\">    float x;</span><br><span class=\"line\">     float y;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">   // 定义结构体变量</span><br><span class=\"line\">    struct MyPoint p;</span><br><span class=\"line\">    p.x = 10.0f;</span><br><span class=\"line\">    p.y = 20.0f;</span><br><span class=\"line\">    retuen 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用typedef给结构体起别名\"><a href=\"#使用typedef给结构体起别名\" class=\"headerlink\" title=\"使用typedef给结构体起别名\"></a>使用typedef给结构体起别名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体</span><br><span class=\"line\">struct MyPoint &#123;</span><br><span class=\"line\">   float x;</span><br><span class=\"line\">   float y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 起别名</span><br><span class=\"line\">typedef struct MyPoint Point; </span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">  // 定义结构体变量</span><br><span class=\"line\">  Point p;</span><br><span class=\"line\">  p.x = 10.0f;</span><br><span class=\"line\">  p.y = 20.0f;    </span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与指向结构体的指针\"><a href=\"#typedef与指向结构体的指针\" class=\"headerlink\" title=\"typedef与指向结构体的指针\"></a>typedef与指向结构体的指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体并起别名</span><br><span class=\"line\"> typedef struct &#123;</span><br><span class=\"line\">    float x;</span><br><span class=\"line\">    float y;</span><br><span class=\"line\"> &#125; Point; </span><br><span class=\"line\"> // 起别名</span><br><span class=\"line\"> typedef Point *PP; </span><br><span class=\"line\"> int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    // 定义结构体变量</span><br><span class=\"line\">    Point point = &#123;10, 20&#125;;    </span><br><span class=\"line\">    // 定义指针变量</span><br><span class=\"line\">    PP p = &amp;point;     </span><br><span class=\"line\">    // 利用指针变量访问结构体成员</span><br><span class=\"line\">    printf(&quot;x=%f，y=%f&quot;, p-&gt;x, p-&gt;y);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与指向函数的指针\"><a href=\"#typedef与指向函数的指针\" class=\"headerlink\" title=\"typedef与指向函数的指针\"></a>typedef与指向函数的指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个sum函数，计算a跟b的和</span><br><span class=\"line\">  int sum(int a, int b) &#123;</span><br><span class=\"line\">      int c = a + b;</span><br><span class=\"line\">      printf(&quot;%d + %d = %d&quot;, a, b, c);</span><br><span class=\"line\">      return c;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"> typedef int (*MySum)(int, int);</span><br><span class=\"line\"> int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">     // 定义一个指向sum函数的指针变量p</span><br><span class=\"line\">     // int (*p)(int, int) = sum;  </span><br><span class=\"line\">     // 定义一个指向sum函数的指针变量p</span><br><span class=\"line\">     MySum p = sum;   </span><br><span class=\"line\">     // 利用指针变量p调用sum函数</span><br><span class=\"line\">     (*p)(4, 5);</span><br><span class=\"line\">     return 0;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与-define\"><a href=\"#typedef与-define\" class=\"headerlink\" title=\"typedef与#define\"></a>typedef与#define</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char *String1;//其别名</span><br><span class=\"line\">#define String2 char *//宏定义，在代码中只是将(char *)替换称String</span><br><span class=\"line\">int main(int argc, const char * argv[]) </span><br><span class=\"line\">    String1 str1, str2;   // 实际是char *str1,char *str2</span><br><span class=\"line\">    String2 str3, str4;   // 实际是char *str3,char str4</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用场合：\"><a href=\"#使用场合：\" class=\"headerlink\" title=\"使用场合：\"></a>使用场合：</h3><ul>\n<li>给基本数据类型起别名</li>\n<li>给指针起别名</li>\n<li>给结构体起别名</li>\n<li>给枚举起别名</li>\n<li>给指向函数的指针起别名</li>\n<li>给指向结构体的指针起别名</li>\n</ul>\n"},{"title":"Android应用的基本组件","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-04-29T09:35:00.000Z","_content":"\nAndroid系统中有著名的四大组件：Activity、Service、BroadcastReceiver、ContentProvider。一个商业的Android应用程序，通常由多个基本的组件联合组成。这四大组件，在使用的时候均需要在清单文件AndroidManifest.xml中进行注册，否则不予使用。本小节将对这些组件进行简单的介绍，使读者对Android应用开发的内容有一个大致的认识。\n\n## 活动（Activity）\n\n\nActivity是Android应用中，最直接与用户接触的组件，它负责加载View组件，使其展现给用户，并保持与用户的交互。所有的Activity组件均需要继承Activity类，这是一个Content的间接子类，包装了一些Activity的基本特性。\n\n\nView组件是所有UI组件、容器组件的基类，也就是说，它可以是一个布局容器，也可以是一个布局容器内的基本UI组件。View组件一般通过XML布局资源文件定义，同时Android系统也对这些View组件提供了对应的实现类。如果需要通过某个Activity把指定的View组件显示出来，调用Activity的setContentView()方法即可，它具有多个重载方法，可以传递一个XML资源ID或者View对象。\n\n例如：\n```java\nLinearLayout layout=new LinearLayout(this);\nsetContentView(layout)；\n```\n或者：\n```\nsetContentView(R.layout.main);\n```\n\nActivity为Android应用提供了一个用户界面，当一个Activity被开启之后，它具有自己的生命周期。Activity类也对这些生命周期提供了对应的方法，如果需要对Activity各个不同的生命周期做出响应，可以重写这些生命周期方法实现。对于大多数商业应用而言，整个系统中包含了多个Activity，在应用中逐步导航跳转开启这些Activity之后，会形成Activity的回退栈，当前显示并获得焦点的Activity位于这个回退栈的栈顶。\n\n## 服务（Service）\n\nService主要用于在后台完成一些无需向用户展示界面的功能实现。通常位于系统后台运行，它一般不需要与用户进行交互，因此Service组件没有用户界面展示给用户。Service主要用于完成一些类似于下载文件、播放音乐等无需用户界面与用户进行交互的功能。\n与Activity组件需要继承Activity类相似，Service组件同样需要继承Service类，Service类也是Context的间接子类，其中包装了一些Service的专有特性。一个Service被运行起来之后，它将具有自己独立的生命周期，Service类中对其各个不同的生命周期提供了对应的方法，开发人员可以通过在Service中重写Service类中这些生命周期方法，来响应Service各个生命周期的功能实现。\n\n## 广播接收器（BroadcastReceiver）\n\nBroadcastReceiver同样也是Android系统中的一个重要组件，BroadcastReceiver代表了一个广播接收器，用于接收系统中其它组件发送的广播，并对其进行响应或是拦截广播的继续传播。\n广播是一个系统级的消息，当系统环境发生改变的时候会发送一些广播供对应的程序进行接收响应，例如：接收到一条短信、开机、关机、插上充电器、插上耳机、充电完成等，均会发送一条广播供需要监听此类广播的应用进行响应。除了一些系统事件的广播，开发人员也可以自定义广播内容。但是大部分情况下，开发应用的时候主要用于接受系统广播并对其进行响应，很少需要发送自定义的广播。\n使用BroadcastReceiver组件接收广播非常的简单，只需要实现自己的BroadcastReceiver子类，并重写onReceive()方法，就能完成BroadcastReceiver，而对于这个BroadcastReceiver对什么广播感兴趣，则需要对其进行另行配置。\n\n## 内容提供者（ContentProvider）\nAndroid系统作为一个智能操作系统，它需要系统中运行的应用程序都必须是相互独立的，各自运行在自己的Dalvik VM实例中。在正常情况下，Android应用之间是不能进行实时的数据交换，而考虑到有些应用的数据需要对外进行共享，Android系统提供了一个标准的数据接口ContentProvider，通过应用提供的ContentProvider，可以在其它应用中对这个应用的暴露出来的数据进行增删改查。\n为应用程序暴露数据接口非常的简单，只需要继承ContentProvider类，并且实现insert()、delete()、update()、query()等方法，使外部应用可对本应用的数据进行增删改查。\n\n## 意图（Intent）\n\n虽然Intent并不是Android应用的组件，也无需专门在清单文件中配置，但是它对于Android应用的作用非常的大。除了ContentProvider之外，其它组件的启动，均需要通过Intent进行指定。Intent不仅可以明确指定一个Android组件进行启动，还可以提供一个标准的行为，再由Android系统配合意图过滤器来选定启动指定组件来完成任务。而Intent在开启对组件的过程中，进行各个组件间数据的传递。\n\n## 小结\n\n本章简要介绍了Android系统的发展史及其现状，并且介绍了Android系统的架构与Dalvik VM虚拟机，最后还简单介绍了Android开发中的四大组件。通过阅读本章，对Android的历史与现状、系统架构、基本组件有个大致的了解，这对本书接下来的内容理解非常有帮助。","source":"_posts/android/base/Android应用的基本组件.md","raw":"title: Android应用的基本组件\nauthor: JsonYe\ntags:\n  - Android\ncategories:\n  - Android基础  \ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-04-29 17:35:00\n---\n\nAndroid系统中有著名的四大组件：Activity、Service、BroadcastReceiver、ContentProvider。一个商业的Android应用程序，通常由多个基本的组件联合组成。这四大组件，在使用的时候均需要在清单文件AndroidManifest.xml中进行注册，否则不予使用。本小节将对这些组件进行简单的介绍，使读者对Android应用开发的内容有一个大致的认识。\n\n## 活动（Activity）\n\n\nActivity是Android应用中，最直接与用户接触的组件，它负责加载View组件，使其展现给用户，并保持与用户的交互。所有的Activity组件均需要继承Activity类，这是一个Content的间接子类，包装了一些Activity的基本特性。\n\n\nView组件是所有UI组件、容器组件的基类，也就是说，它可以是一个布局容器，也可以是一个布局容器内的基本UI组件。View组件一般通过XML布局资源文件定义，同时Android系统也对这些View组件提供了对应的实现类。如果需要通过某个Activity把指定的View组件显示出来，调用Activity的setContentView()方法即可，它具有多个重载方法，可以传递一个XML资源ID或者View对象。\n\n例如：\n```java\nLinearLayout layout=new LinearLayout(this);\nsetContentView(layout)；\n```\n或者：\n```\nsetContentView(R.layout.main);\n```\n\nActivity为Android应用提供了一个用户界面，当一个Activity被开启之后，它具有自己的生命周期。Activity类也对这些生命周期提供了对应的方法，如果需要对Activity各个不同的生命周期做出响应，可以重写这些生命周期方法实现。对于大多数商业应用而言，整个系统中包含了多个Activity，在应用中逐步导航跳转开启这些Activity之后，会形成Activity的回退栈，当前显示并获得焦点的Activity位于这个回退栈的栈顶。\n\n## 服务（Service）\n\nService主要用于在后台完成一些无需向用户展示界面的功能实现。通常位于系统后台运行，它一般不需要与用户进行交互，因此Service组件没有用户界面展示给用户。Service主要用于完成一些类似于下载文件、播放音乐等无需用户界面与用户进行交互的功能。\n与Activity组件需要继承Activity类相似，Service组件同样需要继承Service类，Service类也是Context的间接子类，其中包装了一些Service的专有特性。一个Service被运行起来之后，它将具有自己独立的生命周期，Service类中对其各个不同的生命周期提供了对应的方法，开发人员可以通过在Service中重写Service类中这些生命周期方法，来响应Service各个生命周期的功能实现。\n\n## 广播接收器（BroadcastReceiver）\n\nBroadcastReceiver同样也是Android系统中的一个重要组件，BroadcastReceiver代表了一个广播接收器，用于接收系统中其它组件发送的广播，并对其进行响应或是拦截广播的继续传播。\n广播是一个系统级的消息，当系统环境发生改变的时候会发送一些广播供对应的程序进行接收响应，例如：接收到一条短信、开机、关机、插上充电器、插上耳机、充电完成等，均会发送一条广播供需要监听此类广播的应用进行响应。除了一些系统事件的广播，开发人员也可以自定义广播内容。但是大部分情况下，开发应用的时候主要用于接受系统广播并对其进行响应，很少需要发送自定义的广播。\n使用BroadcastReceiver组件接收广播非常的简单，只需要实现自己的BroadcastReceiver子类，并重写onReceive()方法，就能完成BroadcastReceiver，而对于这个BroadcastReceiver对什么广播感兴趣，则需要对其进行另行配置。\n\n## 内容提供者（ContentProvider）\nAndroid系统作为一个智能操作系统，它需要系统中运行的应用程序都必须是相互独立的，各自运行在自己的Dalvik VM实例中。在正常情况下，Android应用之间是不能进行实时的数据交换，而考虑到有些应用的数据需要对外进行共享，Android系统提供了一个标准的数据接口ContentProvider，通过应用提供的ContentProvider，可以在其它应用中对这个应用的暴露出来的数据进行增删改查。\n为应用程序暴露数据接口非常的简单，只需要继承ContentProvider类，并且实现insert()、delete()、update()、query()等方法，使外部应用可对本应用的数据进行增删改查。\n\n## 意图（Intent）\n\n虽然Intent并不是Android应用的组件，也无需专门在清单文件中配置，但是它对于Android应用的作用非常的大。除了ContentProvider之外，其它组件的启动，均需要通过Intent进行指定。Intent不仅可以明确指定一个Android组件进行启动，还可以提供一个标准的行为，再由Android系统配合意图过滤器来选定启动指定组件来完成任务。而Intent在开启对组件的过程中，进行各个组件间数据的传递。\n\n## 小结\n\n本章简要介绍了Android系统的发展史及其现状，并且介绍了Android系统的架构与Dalvik VM虚拟机，最后还简单介绍了Android开发中的四大组件。通过阅读本章，对Android的历史与现状、系统架构、基本组件有个大致的了解，这对本书接下来的内容理解非常有帮助。","slug":"android/base/Android应用的基本组件","published":1,"updated":"2019-10-02T08:41:02.792Z","layout":"post","photos":[],"link":"","_id":"ck191nwg2001ub0wkqut2nc33","content":"<p>Android系统中有著名的四大组件：Activity、Service、BroadcastReceiver、ContentProvider。一个商业的Android应用程序，通常由多个基本的组件联合组成。这四大组件，在使用的时候均需要在清单文件AndroidManifest.xml中进行注册，否则不予使用。本小节将对这些组件进行简单的介绍，使读者对Android应用开发的内容有一个大致的认识。</p>\n<h2 id=\"活动（Activity）\"><a href=\"#活动（Activity）\" class=\"headerlink\" title=\"活动（Activity）\"></a>活动（Activity）</h2><p>Activity是Android应用中，最直接与用户接触的组件，它负责加载View组件，使其展现给用户，并保持与用户的交互。所有的Activity组件均需要继承Activity类，这是一个Content的间接子类，包装了一些Activity的基本特性。</p>\n<p>View组件是所有UI组件、容器组件的基类，也就是说，它可以是一个布局容器，也可以是一个布局容器内的基本UI组件。View组件一般通过XML布局资源文件定义，同时Android系统也对这些View组件提供了对应的实现类。如果需要通过某个Activity把指定的View组件显示出来，调用Activity的setContentView()方法即可，它具有多个重载方法，可以传递一个XML资源ID或者View对象。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinearLayout layout=<span class=\"keyword\">new</span> LinearLayout(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">setContentView(layout)；</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContentView(R.layout.main);</span><br></pre></td></tr></table></figure>\n\n<p>Activity为Android应用提供了一个用户界面，当一个Activity被开启之后，它具有自己的生命周期。Activity类也对这些生命周期提供了对应的方法，如果需要对Activity各个不同的生命周期做出响应，可以重写这些生命周期方法实现。对于大多数商业应用而言，整个系统中包含了多个Activity，在应用中逐步导航跳转开启这些Activity之后，会形成Activity的回退栈，当前显示并获得焦点的Activity位于这个回退栈的栈顶。</p>\n<h2 id=\"服务（Service）\"><a href=\"#服务（Service）\" class=\"headerlink\" title=\"服务（Service）\"></a>服务（Service）</h2><p>Service主要用于在后台完成一些无需向用户展示界面的功能实现。通常位于系统后台运行，它一般不需要与用户进行交互，因此Service组件没有用户界面展示给用户。Service主要用于完成一些类似于下载文件、播放音乐等无需用户界面与用户进行交互的功能。<br>与Activity组件需要继承Activity类相似，Service组件同样需要继承Service类，Service类也是Context的间接子类，其中包装了一些Service的专有特性。一个Service被运行起来之后，它将具有自己独立的生命周期，Service类中对其各个不同的生命周期提供了对应的方法，开发人员可以通过在Service中重写Service类中这些生命周期方法，来响应Service各个生命周期的功能实现。</p>\n<h2 id=\"广播接收器（BroadcastReceiver）\"><a href=\"#广播接收器（BroadcastReceiver）\" class=\"headerlink\" title=\"广播接收器（BroadcastReceiver）\"></a>广播接收器（BroadcastReceiver）</h2><p>BroadcastReceiver同样也是Android系统中的一个重要组件，BroadcastReceiver代表了一个广播接收器，用于接收系统中其它组件发送的广播，并对其进行响应或是拦截广播的继续传播。<br>广播是一个系统级的消息，当系统环境发生改变的时候会发送一些广播供对应的程序进行接收响应，例如：接收到一条短信、开机、关机、插上充电器、插上耳机、充电完成等，均会发送一条广播供需要监听此类广播的应用进行响应。除了一些系统事件的广播，开发人员也可以自定义广播内容。但是大部分情况下，开发应用的时候主要用于接受系统广播并对其进行响应，很少需要发送自定义的广播。<br>使用BroadcastReceiver组件接收广播非常的简单，只需要实现自己的BroadcastReceiver子类，并重写onReceive()方法，就能完成BroadcastReceiver，而对于这个BroadcastReceiver对什么广播感兴趣，则需要对其进行另行配置。</p>\n<h2 id=\"内容提供者（ContentProvider）\"><a href=\"#内容提供者（ContentProvider）\" class=\"headerlink\" title=\"内容提供者（ContentProvider）\"></a>内容提供者（ContentProvider）</h2><p>Android系统作为一个智能操作系统，它需要系统中运行的应用程序都必须是相互独立的，各自运行在自己的Dalvik VM实例中。在正常情况下，Android应用之间是不能进行实时的数据交换，而考虑到有些应用的数据需要对外进行共享，Android系统提供了一个标准的数据接口ContentProvider，通过应用提供的ContentProvider，可以在其它应用中对这个应用的暴露出来的数据进行增删改查。<br>为应用程序暴露数据接口非常的简单，只需要继承ContentProvider类，并且实现insert()、delete()、update()、query()等方法，使外部应用可对本应用的数据进行增删改查。</p>\n<h2 id=\"意图（Intent）\"><a href=\"#意图（Intent）\" class=\"headerlink\" title=\"意图（Intent）\"></a>意图（Intent）</h2><p>虽然Intent并不是Android应用的组件，也无需专门在清单文件中配置，但是它对于Android应用的作用非常的大。除了ContentProvider之外，其它组件的启动，均需要通过Intent进行指定。Intent不仅可以明确指定一个Android组件进行启动，还可以提供一个标准的行为，再由Android系统配合意图过滤器来选定启动指定组件来完成任务。而Intent在开启对组件的过程中，进行各个组件间数据的传递。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本章简要介绍了Android系统的发展史及其现状，并且介绍了Android系统的架构与Dalvik VM虚拟机，最后还简单介绍了Android开发中的四大组件。通过阅读本章，对Android的历史与现状、系统架构、基本组件有个大致的了解，这对本书接下来的内容理解非常有帮助。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Android系统中有著名的四大组件：Activity、Service、BroadcastReceiver、ContentProvider。一个商业的Android应用程序，通常由多个基本的组件联合组成。这四大组件，在使用的时候均需要在清单文件AndroidManifest.xml中进行注册，否则不予使用。本小节将对这些组件进行简单的介绍，使读者对Android应用开发的内容有一个大致的认识。</p>\n<h2 id=\"活动（Activity）\"><a href=\"#活动（Activity）\" class=\"headerlink\" title=\"活动（Activity）\"></a>活动（Activity）</h2><p>Activity是Android应用中，最直接与用户接触的组件，它负责加载View组件，使其展现给用户，并保持与用户的交互。所有的Activity组件均需要继承Activity类，这是一个Content的间接子类，包装了一些Activity的基本特性。</p>\n<p>View组件是所有UI组件、容器组件的基类，也就是说，它可以是一个布局容器，也可以是一个布局容器内的基本UI组件。View组件一般通过XML布局资源文件定义，同时Android系统也对这些View组件提供了对应的实现类。如果需要通过某个Activity把指定的View组件显示出来，调用Activity的setContentView()方法即可，它具有多个重载方法，可以传递一个XML资源ID或者View对象。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinearLayout layout=<span class=\"keyword\">new</span> LinearLayout(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">setContentView(layout)；</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContentView(R.layout.main);</span><br></pre></td></tr></table></figure>\n\n<p>Activity为Android应用提供了一个用户界面，当一个Activity被开启之后，它具有自己的生命周期。Activity类也对这些生命周期提供了对应的方法，如果需要对Activity各个不同的生命周期做出响应，可以重写这些生命周期方法实现。对于大多数商业应用而言，整个系统中包含了多个Activity，在应用中逐步导航跳转开启这些Activity之后，会形成Activity的回退栈，当前显示并获得焦点的Activity位于这个回退栈的栈顶。</p>\n<h2 id=\"服务（Service）\"><a href=\"#服务（Service）\" class=\"headerlink\" title=\"服务（Service）\"></a>服务（Service）</h2><p>Service主要用于在后台完成一些无需向用户展示界面的功能实现。通常位于系统后台运行，它一般不需要与用户进行交互，因此Service组件没有用户界面展示给用户。Service主要用于完成一些类似于下载文件、播放音乐等无需用户界面与用户进行交互的功能。<br>与Activity组件需要继承Activity类相似，Service组件同样需要继承Service类，Service类也是Context的间接子类，其中包装了一些Service的专有特性。一个Service被运行起来之后，它将具有自己独立的生命周期，Service类中对其各个不同的生命周期提供了对应的方法，开发人员可以通过在Service中重写Service类中这些生命周期方法，来响应Service各个生命周期的功能实现。</p>\n<h2 id=\"广播接收器（BroadcastReceiver）\"><a href=\"#广播接收器（BroadcastReceiver）\" class=\"headerlink\" title=\"广播接收器（BroadcastReceiver）\"></a>广播接收器（BroadcastReceiver）</h2><p>BroadcastReceiver同样也是Android系统中的一个重要组件，BroadcastReceiver代表了一个广播接收器，用于接收系统中其它组件发送的广播，并对其进行响应或是拦截广播的继续传播。<br>广播是一个系统级的消息，当系统环境发生改变的时候会发送一些广播供对应的程序进行接收响应，例如：接收到一条短信、开机、关机、插上充电器、插上耳机、充电完成等，均会发送一条广播供需要监听此类广播的应用进行响应。除了一些系统事件的广播，开发人员也可以自定义广播内容。但是大部分情况下，开发应用的时候主要用于接受系统广播并对其进行响应，很少需要发送自定义的广播。<br>使用BroadcastReceiver组件接收广播非常的简单，只需要实现自己的BroadcastReceiver子类，并重写onReceive()方法，就能完成BroadcastReceiver，而对于这个BroadcastReceiver对什么广播感兴趣，则需要对其进行另行配置。</p>\n<h2 id=\"内容提供者（ContentProvider）\"><a href=\"#内容提供者（ContentProvider）\" class=\"headerlink\" title=\"内容提供者（ContentProvider）\"></a>内容提供者（ContentProvider）</h2><p>Android系统作为一个智能操作系统，它需要系统中运行的应用程序都必须是相互独立的，各自运行在自己的Dalvik VM实例中。在正常情况下，Android应用之间是不能进行实时的数据交换，而考虑到有些应用的数据需要对外进行共享，Android系统提供了一个标准的数据接口ContentProvider，通过应用提供的ContentProvider，可以在其它应用中对这个应用的暴露出来的数据进行增删改查。<br>为应用程序暴露数据接口非常的简单，只需要继承ContentProvider类，并且实现insert()、delete()、update()、query()等方法，使外部应用可对本应用的数据进行增删改查。</p>\n<h2 id=\"意图（Intent）\"><a href=\"#意图（Intent）\" class=\"headerlink\" title=\"意图（Intent）\"></a>意图（Intent）</h2><p>虽然Intent并不是Android应用的组件，也无需专门在清单文件中配置，但是它对于Android应用的作用非常的大。除了ContentProvider之外，其它组件的启动，均需要通过Intent进行指定。Intent不仅可以明确指定一个Android组件进行启动，还可以提供一个标准的行为，再由Android系统配合意图过滤器来选定启动指定组件来完成任务。而Intent在开启对组件的过程中，进行各个组件间数据的传递。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本章简要介绍了Android系统的发展史及其现状，并且介绍了Android系统的架构与Dalvik VM虚拟机，最后还简单介绍了Android开发中的四大组件。通过阅读本章，对Android的历史与现状、系统架构、基本组件有个大致的了解，这对本书接下来的内容理解非常有帮助。</p>\n"},{"title":"android发展史及系统架构","author":"JsonYe","copyright":true,"date":"2015-04-29T09:32:00.000Z","_content":"\n## 1.1 Android发展史与现状\n\nAndy Rubin创立22个月后→（2005年）Google收购。\n\n2008 Patrick Brady于Google I/O 演讲“Anatomy & Physiology of an Android”，并提出的 Android HAL 架构图。\n\n### Android版本升级  \nAndroid系统今后将继续每半年一次的升级步伐，分别定在每年的夏天和年终。每代Android系统都将以食物命名，比如1.5版叫做 Cupcake(纸杯蛋糕)，1.6版为Donut(甜甜圈)，然后是Eclair(法式奶油夹心甜点)和Flan(水果馅饼)。Donut将把社交网络功能作为升级重点，在“手机的各种体验中”都增加社交网络元素。  \n#### 1.5 (Cupcake)  \n基于Linux Kernel 2.6.27 2009年4月30日，官方1.5版本(Cupcake)的Android发布。主要的更新如下:  \n● 拍摄/回放视频，并支持上传到youtube  \n● 支持立体声蓝牙耳机，同时改善自动配对性能  \n● 最新的采用WebKit技术的浏览器，支持拷贝/粘帖和页面中搜索  \n● GPS性能大大提高  \n● 屏幕虚拟键盘  \n● 主屏幕增加音乐播放器和相框widgets  \n● 应用程序自动随着手机旋转  \n● 短信，Gmail，日历，浏览器的用户界面大幅改善，比如说Gmail现在可以批量删除邮件了  \n● 相机启动速度加快，拍摄图片可以直接上传到picasa  \n● 来电照片显示  \n#### 1.6 (Donut)  \n基于Linux Kernel 2.6.29 2009年9月15日, 1.6(Donut)版本SDK发布。主要的更新如下:  \n● 完全重新设计的Android Market  \n● 手势支持  \n● 支持CDMA网络  \n● 文字转语音系统(TXT-2-speech)  \n● 快速搜索框  \n● 全新的拍照界面  \n● 应用程序耗电查看  \n● 支持VPN  \n● 支持更多的屏幕分辨率  \n● 支持OpenCore2媒体引擎  \n● 新增面向视觉或听觉困难人群的易用性插件  \n#### 2.0/2.0.1/2.1(Eclair)  \n基于Linux Kernel 2.6.29 2009年10月26日, 2.0(Eclair)版本SDK发布。主要的更新如下:  \n● 优化硬件速度  \n● \"Car Home\"程序  \n● 支持更多的屏幕分辨率  \n● 重整界面  \n● 新的浏览器的用户界面和支持HTML5  \n● 新的联系人名单  \n● 更好的白色/黑色背景比率  \n● 改进Google Maps 3.1.2  \n● 支持Microsoft Exchange  \n● 支持内置相机闪光灯  \n● 数字变焦  \n● 改进的虚拟键盘  \n● 蓝牙2.1  \nAndroid的代号序列会按甜点名字中首个英文字母(C、D、E、F)的排列顺序。  \n下一个版本的Android将会命名为Froyo(冻酸奶,基于Linux Kernel 2.6.32)。Froyo 之后的版本的Android将会命名为Gingerbread(姜饼,基于Linux Kernel 2.6.33/34)。\n\n**Android****版本**\n\n**发布日期**\n\n**代号**\n\n**Android 1.1**\n\n**Android 1.5**\n\n2009年4月30日\n\nCupcake（纸杯蛋糕）\n\n**Android 1.6**\n\n2009年9月15日\n\nDonut（炸面圈）\n\n**Android 2.0/2.1**\n\n2009年10月26日\n\nEclair（长松饼）\n\n**Android 2.2**\n\n2010年5月20日\n\nFroyo（冻酸奶）\n\n**Android 2.3**\n\n2010年12月6日\n\nGingerbread（姜饼）\n\n**Android 3.0/3.1/3.2**\n\n2011年2月22日\n\nHoneycomb（蜂巢）\n\n**Android 4.0**\n\n2011年10月19日\n\nIce Cream Sandwich（冰淇淋三明治）\n\n**Android 4.1**\n\n2012年6月28日\n\nJelly Bean（果冻豆）\n\n**Android 4.2**\n\n2012年10月8日\n\nJelly Bean（果冻豆）\n\n**Android5.0**\n\n待定\n\nLime Pie（酸橙派）\n\n### 1.2 Android系统的架构与特性\n\n#### 1.2.1 Android系统架构\n\nAndroid系统的底层是建立在Linux系统之上的，它采用软件叠层（Software Stack）的方式进行构建。使得层与层之间相互分离，明确各层的分工。这种分工保证了层与层之间的低苟合，当下层发生改变的时候，上层应用程序无需做任何改变。\n\n下图为Android系统的系统架构图：\n\n![](http://s1.51cto.com/wyfs02/M01/25/73/wKioL1NgW-Si7ae7AAEJ_vZkaJ0908.jpg)\n\n如图可知，Android系统分为四个层，从高到底分别是：应用程序层（Application）、应用程序框架层（Application Framework）、系统运行库层（Libraries）和Linux内核层（Linux Kernel）。\n\nAndroid操作系统可以在四个主要层面上分为5个部分：\n\n##### 1\\. 应用程序层（Application）\n\nAndroid系统包含了一系列核心应用程序，包括电子邮件、短信SMS、日历、拨号器、地图、浏览器、联系人等。这些应用程序都是用Java语言编写。本书重点讲解如何编写Android系统上运行的应用程序，在程序分层上，与系统核心应用程序平级。\n\n##### 2\\. 应用程序框架层（Application Framework）\n\nAndroid应用程序框架提供了大量的API供开发人员使用，Android应用程序的开发，就是调用这些API，根据需求实现功能。\n\n应用程序框架是应用程序的基础。为了软件的复用，任何一个应用程序都可以开发Android系统的功能模块，只要发布的时候遵循应用程序框架的规范，其它应用程序也可以使用这个功能模块。\n\n##### 3\\. 系统运行库层（Libraries）**\n\nAndroid系统运行库是用C/C++语言编写的，是一套被不同组件所使用的函数库组成的集合。一般来说，Android应用开发者无法直接调用这套函数库，都是通过它上层的应用程序框架提供的API来对这些函数库进行调用。\n\n下面对一些核心库进行简单的介绍：\n\n> **Libc：**从BSD系统派生出来的标准C系统库，在此基础之上，为了便携式Linux系统专门进行了调整。\n> \n> **Medio Framework：**基于PacketView的OpenCORE，这套媒体库支持播放与录制硬盘及视频格式的文件，并能查看静态图片。\n> \n> **Surface Manager：**在执行多个应用程序的时，负责管理显示与存取操作间的互动，同时负责2D绘图与3D绘图进行显示合成。\n> \n> **WebKit：**Web浏览器引擎，该引擎为Android浏览器提供支持。\n> \n> **SGL：**底层的2D图像引擎。\n> \n> **3D libraries：**基于OpenGL ES 1.0API，提供使用软硬件实现3D加速的功能。\n> \n> **FreeType：**提供位图和向量字体的支持。\n> \n> **SQLite：**轻量级的关系型数据库。\n\n\n##### 4\\. Android运行时**\n\n    Android运行时由两部分完成：Android核心库和Dalvik虚拟机。其中核心库集提供了Java语言核心库所能使用的绝大部分功能，Dalvik虚拟机负责运行Android应用程序。\n\n    虽然Android应用程序通过Java语言编写，而每个Java程序都会在Java虚拟机JVM内运行，但是Android系统毕竟是运行在移动设备上的，由于硬件的限制， Android应用程序并不使用Java的虚拟机JVM来运行程序，而是使用自己独立的虚拟机Dalvik VM，它针对多个同时高效运行的虚拟机进行了优化。每个Android应用程序都运行在单独的一个Dalvik虚拟机内，因此Android系统可以方便对应用程序进行隔离。\n\n##### 5\\. Linux内核\n\nAndroid系统是基于Linux2.6之上建立的操作系统，它的Linux内核为Android系统提供了安全性、内存管理、进程管理、网络协议栈、驱动模型等核心系统服务。Linux内核帮助Android系统实现了底层硬件与上层软件之间的抽象。\n\n#### 1.2.2 Dalvik VM和JVM的区别\n\nJVM（Java虚拟机）是一个虚构出来的运行Java程序的运行时，是通过在实际的计算机上仿真模拟各种计算机功能的实现。它具有完善的硬件架构（如处理器、堆栈、寄存器等），还具有相应的指令系统，使用JVM就是使Java程序支持与操作系统无关。理论上在任何操作系统中，只要有对应的JVM，即可运行Java程序。\n\nDalvik VM是在Android系统上运行Android程序的虚拟机，其指令集是基于寄存器架构的，执行特有的文件格式-dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。\n\n由于Android应用程序的开发编程语言是Java，而Java程序运行在JVM（Java虚拟机）上的，因此有些人会把Android的虚拟机DalvikVM和JVM弄混淆，但是实际上Dalvik并未遵守JVM规范，而且两者也是互不兼容。\n\n从Dalvik VM和JVM的编译过程分析，它们的编译过程如下：\n\n```\nJVM：.java→.class→.jar\nDalvik VM：.java→.class→.dex\n```\n\n从它们的编译过程可以看出，JVM运行的是.class文件的Java字节码，但是Dalvik VM运行的是其转换后的dex（Dalvik Executable）文件。JVM字节从.class文件或者JAR包中加载字节码然后运行，而Dalvik VM无法直接从.class文件或JAR包中加载字节码，它需要通过DX工具将应用程序所有的.class文件编译成一个.dex文件，Dalvik VM则运行这个.dex文件。\n\n下图显示了Dalvik VM与JVM编译过程的区别：\n\n![](http://s4.51cto.com/wyfs02/M01/25/73/wKiom1NgXMOTVyNiAAB-h8_94xE986.jpg)\n\n从图中可以看出，Dalvik VM把.java文件编译成.class后，会对.class进行重构，整合的基本元素（常量池、类定义、数据段）,最后压缩写进一个.dex文件中。其中，常量池描述了所有的常量，包括引用、方法名、数值常量等；类定义包括访问标识、类名等基本信息；数据段中包含各种被VM指定的方法代码以及类和方法的相关信息和实例变量。这种把多个.class文件进行整合的方法，大大提高了Android程序的运行速度，例如：应用程序中多个类定义了字符串常量TAG，而在JVM中，会编译成多个.class文件，每个.class文件的常量池中，均包含这个TAG常量，但是Dalvik VM在编译成.dex文件之后，其常量池里只有一个TAG常量。\n\nJVM和Dalvik VM还有一点非常重要的不同，就是基于的架构不同。JVM是基于栈的架构，而Dalvik VM是基于寄存器的架构。相对于基于栈的JVM而言，基于寄存器的Dalvik VM实现虽然牺牲了一些硬件上的通用性，但是它在代码的执行效率上要更胜一筹。一般来讲，VM中指令的解释执行的时间主要花费在以下三个方面：\n\n> 分发指令；\n> \n> 访问运算数；\n> \n> 执行运算；\n\n\n其中分发指令这个环节对性能的影响最大。在基于寄存器的Dalvik VM中，可以更有效的减少冗余指令的分发，减少内存的读写访问。\n\n从JVM和Dalvik VM的区别上来说，Dalvik VM主要是针对Android这个嵌入式操作系统的特点进行了各种优化，使其更省电、更省内存、运行效率更高，但是牺牲了一些JVM的与平台无关的特性。实际上，Dalvik VM本就是为Android设计的，无需考虑其它平台的问题。这里只是介绍了JVM和Dalvik VM的两个重要的区别，毕竟本书并不是讲解Android内核的，这里只是点明Dalvik VM的特点，读者对这部分的内容了解即可。\n\n### 1.2.3 Android系统平台的优势\n\nAndroid系统相对于其它操作系统，有如下几点优势：\n\n#### 1. 开放性\n\n首先就是Android系统的开放性，其开发平台允许任何移动终端厂商加入到Android联盟中来，降低了开发门槛，使其拥有更多的开发者，随着用户和应用的日益丰富，也将推进Android系统的成熟。同时，开放性有利于Android设备的普及以及市场竞争力，这样有利于消费者买到更低价位的Android设备。\n\n#### 2. 丰富的硬件选择\n\n同样由于Android系统的开放性，众多硬件厂商可以推出各种的搭载Android系统的设备。现如今，Android系统不仅仅只是运行在手机上，越来越多的设备开始支持Android系统，如电视、可佩戴设备、数码相机等。\n\n#### 3. 便于开发\n\nGoogle开放了Android的系统源码，提供了开发者一个自由的开发环境，不必受到各种条条框框的束缚。\n\n#### 4. Google服务的支持\n\nGoogle公司作为一个做服务的公司，它提供了如地图、邮件、搜索等服务，Android系统可以对这些服务进行无缝的结合。","source":"_posts/android/base/android发展史及系统架构.md","raw":"title: android发展史及系统架构\nauthor: JsonYe\ntags:\n  - Android\ncategories:\n  - Android基础\ncopyright: true\ndate: 2015-04-29 17:32:00\n---\n\n## 1.1 Android发展史与现状\n\nAndy Rubin创立22个月后→（2005年）Google收购。\n\n2008 Patrick Brady于Google I/O 演讲“Anatomy & Physiology of an Android”，并提出的 Android HAL 架构图。\n\n### Android版本升级  \nAndroid系统今后将继续每半年一次的升级步伐，分别定在每年的夏天和年终。每代Android系统都将以食物命名，比如1.5版叫做 Cupcake(纸杯蛋糕)，1.6版为Donut(甜甜圈)，然后是Eclair(法式奶油夹心甜点)和Flan(水果馅饼)。Donut将把社交网络功能作为升级重点，在“手机的各种体验中”都增加社交网络元素。  \n#### 1.5 (Cupcake)  \n基于Linux Kernel 2.6.27 2009年4月30日，官方1.5版本(Cupcake)的Android发布。主要的更新如下:  \n● 拍摄/回放视频，并支持上传到youtube  \n● 支持立体声蓝牙耳机，同时改善自动配对性能  \n● 最新的采用WebKit技术的浏览器，支持拷贝/粘帖和页面中搜索  \n● GPS性能大大提高  \n● 屏幕虚拟键盘  \n● 主屏幕增加音乐播放器和相框widgets  \n● 应用程序自动随着手机旋转  \n● 短信，Gmail，日历，浏览器的用户界面大幅改善，比如说Gmail现在可以批量删除邮件了  \n● 相机启动速度加快，拍摄图片可以直接上传到picasa  \n● 来电照片显示  \n#### 1.6 (Donut)  \n基于Linux Kernel 2.6.29 2009年9月15日, 1.6(Donut)版本SDK发布。主要的更新如下:  \n● 完全重新设计的Android Market  \n● 手势支持  \n● 支持CDMA网络  \n● 文字转语音系统(TXT-2-speech)  \n● 快速搜索框  \n● 全新的拍照界面  \n● 应用程序耗电查看  \n● 支持VPN  \n● 支持更多的屏幕分辨率  \n● 支持OpenCore2媒体引擎  \n● 新增面向视觉或听觉困难人群的易用性插件  \n#### 2.0/2.0.1/2.1(Eclair)  \n基于Linux Kernel 2.6.29 2009年10月26日, 2.0(Eclair)版本SDK发布。主要的更新如下:  \n● 优化硬件速度  \n● \"Car Home\"程序  \n● 支持更多的屏幕分辨率  \n● 重整界面  \n● 新的浏览器的用户界面和支持HTML5  \n● 新的联系人名单  \n● 更好的白色/黑色背景比率  \n● 改进Google Maps 3.1.2  \n● 支持Microsoft Exchange  \n● 支持内置相机闪光灯  \n● 数字变焦  \n● 改进的虚拟键盘  \n● 蓝牙2.1  \nAndroid的代号序列会按甜点名字中首个英文字母(C、D、E、F)的排列顺序。  \n下一个版本的Android将会命名为Froyo(冻酸奶,基于Linux Kernel 2.6.32)。Froyo 之后的版本的Android将会命名为Gingerbread(姜饼,基于Linux Kernel 2.6.33/34)。\n\n**Android****版本**\n\n**发布日期**\n\n**代号**\n\n**Android 1.1**\n\n**Android 1.5**\n\n2009年4月30日\n\nCupcake（纸杯蛋糕）\n\n**Android 1.6**\n\n2009年9月15日\n\nDonut（炸面圈）\n\n**Android 2.0/2.1**\n\n2009年10月26日\n\nEclair（长松饼）\n\n**Android 2.2**\n\n2010年5月20日\n\nFroyo（冻酸奶）\n\n**Android 2.3**\n\n2010年12月6日\n\nGingerbread（姜饼）\n\n**Android 3.0/3.1/3.2**\n\n2011年2月22日\n\nHoneycomb（蜂巢）\n\n**Android 4.0**\n\n2011年10月19日\n\nIce Cream Sandwich（冰淇淋三明治）\n\n**Android 4.1**\n\n2012年6月28日\n\nJelly Bean（果冻豆）\n\n**Android 4.2**\n\n2012年10月8日\n\nJelly Bean（果冻豆）\n\n**Android5.0**\n\n待定\n\nLime Pie（酸橙派）\n\n### 1.2 Android系统的架构与特性\n\n#### 1.2.1 Android系统架构\n\nAndroid系统的底层是建立在Linux系统之上的，它采用软件叠层（Software Stack）的方式进行构建。使得层与层之间相互分离，明确各层的分工。这种分工保证了层与层之间的低苟合，当下层发生改变的时候，上层应用程序无需做任何改变。\n\n下图为Android系统的系统架构图：\n\n![](http://s1.51cto.com/wyfs02/M01/25/73/wKioL1NgW-Si7ae7AAEJ_vZkaJ0908.jpg)\n\n如图可知，Android系统分为四个层，从高到底分别是：应用程序层（Application）、应用程序框架层（Application Framework）、系统运行库层（Libraries）和Linux内核层（Linux Kernel）。\n\nAndroid操作系统可以在四个主要层面上分为5个部分：\n\n##### 1\\. 应用程序层（Application）\n\nAndroid系统包含了一系列核心应用程序，包括电子邮件、短信SMS、日历、拨号器、地图、浏览器、联系人等。这些应用程序都是用Java语言编写。本书重点讲解如何编写Android系统上运行的应用程序，在程序分层上，与系统核心应用程序平级。\n\n##### 2\\. 应用程序框架层（Application Framework）\n\nAndroid应用程序框架提供了大量的API供开发人员使用，Android应用程序的开发，就是调用这些API，根据需求实现功能。\n\n应用程序框架是应用程序的基础。为了软件的复用，任何一个应用程序都可以开发Android系统的功能模块，只要发布的时候遵循应用程序框架的规范，其它应用程序也可以使用这个功能模块。\n\n##### 3\\. 系统运行库层（Libraries）**\n\nAndroid系统运行库是用C/C++语言编写的，是一套被不同组件所使用的函数库组成的集合。一般来说，Android应用开发者无法直接调用这套函数库，都是通过它上层的应用程序框架提供的API来对这些函数库进行调用。\n\n下面对一些核心库进行简单的介绍：\n\n> **Libc：**从BSD系统派生出来的标准C系统库，在此基础之上，为了便携式Linux系统专门进行了调整。\n> \n> **Medio Framework：**基于PacketView的OpenCORE，这套媒体库支持播放与录制硬盘及视频格式的文件，并能查看静态图片。\n> \n> **Surface Manager：**在执行多个应用程序的时，负责管理显示与存取操作间的互动，同时负责2D绘图与3D绘图进行显示合成。\n> \n> **WebKit：**Web浏览器引擎，该引擎为Android浏览器提供支持。\n> \n> **SGL：**底层的2D图像引擎。\n> \n> **3D libraries：**基于OpenGL ES 1.0API，提供使用软硬件实现3D加速的功能。\n> \n> **FreeType：**提供位图和向量字体的支持。\n> \n> **SQLite：**轻量级的关系型数据库。\n\n\n##### 4\\. Android运行时**\n\n    Android运行时由两部分完成：Android核心库和Dalvik虚拟机。其中核心库集提供了Java语言核心库所能使用的绝大部分功能，Dalvik虚拟机负责运行Android应用程序。\n\n    虽然Android应用程序通过Java语言编写，而每个Java程序都会在Java虚拟机JVM内运行，但是Android系统毕竟是运行在移动设备上的，由于硬件的限制， Android应用程序并不使用Java的虚拟机JVM来运行程序，而是使用自己独立的虚拟机Dalvik VM，它针对多个同时高效运行的虚拟机进行了优化。每个Android应用程序都运行在单独的一个Dalvik虚拟机内，因此Android系统可以方便对应用程序进行隔离。\n\n##### 5\\. Linux内核\n\nAndroid系统是基于Linux2.6之上建立的操作系统，它的Linux内核为Android系统提供了安全性、内存管理、进程管理、网络协议栈、驱动模型等核心系统服务。Linux内核帮助Android系统实现了底层硬件与上层软件之间的抽象。\n\n#### 1.2.2 Dalvik VM和JVM的区别\n\nJVM（Java虚拟机）是一个虚构出来的运行Java程序的运行时，是通过在实际的计算机上仿真模拟各种计算机功能的实现。它具有完善的硬件架构（如处理器、堆栈、寄存器等），还具有相应的指令系统，使用JVM就是使Java程序支持与操作系统无关。理论上在任何操作系统中，只要有对应的JVM，即可运行Java程序。\n\nDalvik VM是在Android系统上运行Android程序的虚拟机，其指令集是基于寄存器架构的，执行特有的文件格式-dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。\n\n由于Android应用程序的开发编程语言是Java，而Java程序运行在JVM（Java虚拟机）上的，因此有些人会把Android的虚拟机DalvikVM和JVM弄混淆，但是实际上Dalvik并未遵守JVM规范，而且两者也是互不兼容。\n\n从Dalvik VM和JVM的编译过程分析，它们的编译过程如下：\n\n```\nJVM：.java→.class→.jar\nDalvik VM：.java→.class→.dex\n```\n\n从它们的编译过程可以看出，JVM运行的是.class文件的Java字节码，但是Dalvik VM运行的是其转换后的dex（Dalvik Executable）文件。JVM字节从.class文件或者JAR包中加载字节码然后运行，而Dalvik VM无法直接从.class文件或JAR包中加载字节码，它需要通过DX工具将应用程序所有的.class文件编译成一个.dex文件，Dalvik VM则运行这个.dex文件。\n\n下图显示了Dalvik VM与JVM编译过程的区别：\n\n![](http://s4.51cto.com/wyfs02/M01/25/73/wKiom1NgXMOTVyNiAAB-h8_94xE986.jpg)\n\n从图中可以看出，Dalvik VM把.java文件编译成.class后，会对.class进行重构，整合的基本元素（常量池、类定义、数据段）,最后压缩写进一个.dex文件中。其中，常量池描述了所有的常量，包括引用、方法名、数值常量等；类定义包括访问标识、类名等基本信息；数据段中包含各种被VM指定的方法代码以及类和方法的相关信息和实例变量。这种把多个.class文件进行整合的方法，大大提高了Android程序的运行速度，例如：应用程序中多个类定义了字符串常量TAG，而在JVM中，会编译成多个.class文件，每个.class文件的常量池中，均包含这个TAG常量，但是Dalvik VM在编译成.dex文件之后，其常量池里只有一个TAG常量。\n\nJVM和Dalvik VM还有一点非常重要的不同，就是基于的架构不同。JVM是基于栈的架构，而Dalvik VM是基于寄存器的架构。相对于基于栈的JVM而言，基于寄存器的Dalvik VM实现虽然牺牲了一些硬件上的通用性，但是它在代码的执行效率上要更胜一筹。一般来讲，VM中指令的解释执行的时间主要花费在以下三个方面：\n\n> 分发指令；\n> \n> 访问运算数；\n> \n> 执行运算；\n\n\n其中分发指令这个环节对性能的影响最大。在基于寄存器的Dalvik VM中，可以更有效的减少冗余指令的分发，减少内存的读写访问。\n\n从JVM和Dalvik VM的区别上来说，Dalvik VM主要是针对Android这个嵌入式操作系统的特点进行了各种优化，使其更省电、更省内存、运行效率更高，但是牺牲了一些JVM的与平台无关的特性。实际上，Dalvik VM本就是为Android设计的，无需考虑其它平台的问题。这里只是介绍了JVM和Dalvik VM的两个重要的区别，毕竟本书并不是讲解Android内核的，这里只是点明Dalvik VM的特点，读者对这部分的内容了解即可。\n\n### 1.2.3 Android系统平台的优势\n\nAndroid系统相对于其它操作系统，有如下几点优势：\n\n#### 1. 开放性\n\n首先就是Android系统的开放性，其开发平台允许任何移动终端厂商加入到Android联盟中来，降低了开发门槛，使其拥有更多的开发者，随着用户和应用的日益丰富，也将推进Android系统的成熟。同时，开放性有利于Android设备的普及以及市场竞争力，这样有利于消费者买到更低价位的Android设备。\n\n#### 2. 丰富的硬件选择\n\n同样由于Android系统的开放性，众多硬件厂商可以推出各种的搭载Android系统的设备。现如今，Android系统不仅仅只是运行在手机上，越来越多的设备开始支持Android系统，如电视、可佩戴设备、数码相机等。\n\n#### 3. 便于开发\n\nGoogle开放了Android的系统源码，提供了开发者一个自由的开发环境，不必受到各种条条框框的束缚。\n\n#### 4. Google服务的支持\n\nGoogle公司作为一个做服务的公司，它提供了如地图、邮件、搜索等服务，Android系统可以对这些服务进行无缝的结合。","slug":"android/base/android发展史及系统架构","published":1,"updated":"2019-10-02T08:40:59.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck191nwgb001zb0wkk5wiag45","content":"<h2 id=\"1-1-Android发展史与现状\"><a href=\"#1-1-Android发展史与现状\" class=\"headerlink\" title=\"1.1 Android发展史与现状\"></a>1.1 Android发展史与现状</h2><p>Andy Rubin创立22个月后→（2005年）Google收购。</p>\n<p>2008 Patrick Brady于Google I/O 演讲“Anatomy &amp; Physiology of an Android”，并提出的 Android HAL 架构图。</p>\n<h3 id=\"Android版本升级\"><a href=\"#Android版本升级\" class=\"headerlink\" title=\"Android版本升级\"></a>Android版本升级</h3><p>Android系统今后将继续每半年一次的升级步伐，分别定在每年的夏天和年终。每代Android系统都将以食物命名，比如1.5版叫做 Cupcake(纸杯蛋糕)，1.6版为Donut(甜甜圈)，然后是Eclair(法式奶油夹心甜点)和Flan(水果馅饼)。Donut将把社交网络功能作为升级重点，在“手机的各种体验中”都增加社交网络元素。  </p>\n<h4 id=\"1-5-Cupcake\"><a href=\"#1-5-Cupcake\" class=\"headerlink\" title=\"1.5 (Cupcake)\"></a>1.5 (Cupcake)</h4><p>基于Linux Kernel 2.6.27 2009年4月30日，官方1.5版本(Cupcake)的Android发布。主要的更新如下:<br>● 拍摄/回放视频，并支持上传到youtube<br>● 支持立体声蓝牙耳机，同时改善自动配对性能<br>● 最新的采用WebKit技术的浏览器，支持拷贝/粘帖和页面中搜索<br>● GPS性能大大提高<br>● 屏幕虚拟键盘<br>● 主屏幕增加音乐播放器和相框widgets<br>● 应用程序自动随着手机旋转<br>● 短信，Gmail，日历，浏览器的用户界面大幅改善，比如说Gmail现在可以批量删除邮件了<br>● 相机启动速度加快，拍摄图片可以直接上传到picasa<br>● 来电照片显示  </p>\n<h4 id=\"1-6-Donut\"><a href=\"#1-6-Donut\" class=\"headerlink\" title=\"1.6 (Donut)\"></a>1.6 (Donut)</h4><p>基于Linux Kernel 2.6.29 2009年9月15日, 1.6(Donut)版本SDK发布。主要的更新如下:<br>● 完全重新设计的Android Market<br>● 手势支持<br>● 支持CDMA网络<br>● 文字转语音系统(TXT-2-speech)<br>● 快速搜索框<br>● 全新的拍照界面<br>● 应用程序耗电查看<br>● 支持VPN<br>● 支持更多的屏幕分辨率<br>● 支持OpenCore2媒体引擎<br>● 新增面向视觉或听觉困难人群的易用性插件  </p>\n<h4 id=\"2-0-2-0-1-2-1-Eclair\"><a href=\"#2-0-2-0-1-2-1-Eclair\" class=\"headerlink\" title=\"2.0/2.0.1/2.1(Eclair)\"></a>2.0/2.0.1/2.1(Eclair)</h4><p>基于Linux Kernel 2.6.29 2009年10月26日, 2.0(Eclair)版本SDK发布。主要的更新如下:<br>● 优化硬件速度<br>● “Car Home”程序<br>● 支持更多的屏幕分辨率<br>● 重整界面<br>● 新的浏览器的用户界面和支持HTML5<br>● 新的联系人名单<br>● 更好的白色/黑色背景比率<br>● 改进Google Maps 3.1.2<br>● 支持Microsoft Exchange<br>● 支持内置相机闪光灯<br>● 数字变焦<br>● 改进的虚拟键盘<br>● 蓝牙2.1<br>Android的代号序列会按甜点名字中首个英文字母(C、D、E、F)的排列顺序。<br>下一个版本的Android将会命名为Froyo(冻酸奶,基于Linux Kernel 2.6.32)。Froyo 之后的版本的Android将会命名为Gingerbread(姜饼,基于Linux Kernel 2.6.33/34)。</p>\n<p><strong>Android**</strong>版本**</p>\n<p><strong>发布日期</strong></p>\n<p><strong>代号</strong></p>\n<p><strong>Android 1.1</strong></p>\n<p><strong>Android 1.5</strong></p>\n<p>2009年4月30日</p>\n<p>Cupcake（纸杯蛋糕）</p>\n<p><strong>Android 1.6</strong></p>\n<p>2009年9月15日</p>\n<p>Donut（炸面圈）</p>\n<p><strong>Android 2.0/2.1</strong></p>\n<p>2009年10月26日</p>\n<p>Eclair（长松饼）</p>\n<p><strong>Android 2.2</strong></p>\n<p>2010年5月20日</p>\n<p>Froyo（冻酸奶）</p>\n<p><strong>Android 2.3</strong></p>\n<p>2010年12月6日</p>\n<p>Gingerbread（姜饼）</p>\n<p><strong>Android 3.0/3.1/3.2</strong></p>\n<p>2011年2月22日</p>\n<p>Honeycomb（蜂巢）</p>\n<p><strong>Android 4.0</strong></p>\n<p>2011年10月19日</p>\n<p>Ice Cream Sandwich（冰淇淋三明治）</p>\n<p><strong>Android 4.1</strong></p>\n<p>2012年6月28日</p>\n<p>Jelly Bean（果冻豆）</p>\n<p><strong>Android 4.2</strong></p>\n<p>2012年10月8日</p>\n<p>Jelly Bean（果冻豆）</p>\n<p><strong>Android5.0</strong></p>\n<p>待定</p>\n<p>Lime Pie（酸橙派）</p>\n<h3 id=\"1-2-Android系统的架构与特性\"><a href=\"#1-2-Android系统的架构与特性\" class=\"headerlink\" title=\"1.2 Android系统的架构与特性\"></a>1.2 Android系统的架构与特性</h3><h4 id=\"1-2-1-Android系统架构\"><a href=\"#1-2-1-Android系统架构\" class=\"headerlink\" title=\"1.2.1 Android系统架构\"></a>1.2.1 Android系统架构</h4><p>Android系统的底层是建立在Linux系统之上的，它采用软件叠层（Software Stack）的方式进行构建。使得层与层之间相互分离，明确各层的分工。这种分工保证了层与层之间的低苟合，当下层发生改变的时候，上层应用程序无需做任何改变。</p>\n<p>下图为Android系统的系统架构图：</p>\n<p><img src=\"http://s1.51cto.com/wyfs02/M01/25/73/wKioL1NgW-Si7ae7AAEJ_vZkaJ0908.jpg\" alt></p>\n<p>如图可知，Android系统分为四个层，从高到底分别是：应用程序层（Application）、应用程序框架层（Application Framework）、系统运行库层（Libraries）和Linux内核层（Linux Kernel）。</p>\n<p>Android操作系统可以在四个主要层面上分为5个部分：</p>\n<h5 id=\"1-应用程序层（Application）\"><a href=\"#1-应用程序层（Application）\" class=\"headerlink\" title=\"1. 应用程序层（Application）\"></a>1. 应用程序层（Application）</h5><p>Android系统包含了一系列核心应用程序，包括电子邮件、短信SMS、日历、拨号器、地图、浏览器、联系人等。这些应用程序都是用Java语言编写。本书重点讲解如何编写Android系统上运行的应用程序，在程序分层上，与系统核心应用程序平级。</p>\n<h5 id=\"2-应用程序框架层（Application-Framework）\"><a href=\"#2-应用程序框架层（Application-Framework）\" class=\"headerlink\" title=\"2. 应用程序框架层（Application Framework）\"></a>2. 应用程序框架层（Application Framework）</h5><p>Android应用程序框架提供了大量的API供开发人员使用，Android应用程序的开发，就是调用这些API，根据需求实现功能。</p>\n<p>应用程序框架是应用程序的基础。为了软件的复用，任何一个应用程序都可以开发Android系统的功能模块，只要发布的时候遵循应用程序框架的规范，其它应用程序也可以使用这个功能模块。</p>\n<h5 id=\"3-系统运行库层（Libraries）\"><a href=\"#3-系统运行库层（Libraries）\" class=\"headerlink\" title=\"3. 系统运行库层（Libraries）**\"></a>3. 系统运行库层（Libraries）**</h5><p>Android系统运行库是用C/C++语言编写的，是一套被不同组件所使用的函数库组成的集合。一般来说，Android应用开发者无法直接调用这套函数库，都是通过它上层的应用程序框架提供的API来对这些函数库进行调用。</p>\n<p>下面对一些核心库进行简单的介绍：</p>\n<blockquote>\n<p><strong>Libc：</strong>从BSD系统派生出来的标准C系统库，在此基础之上，为了便携式Linux系统专门进行了调整。</p>\n<p><strong>Medio Framework：</strong>基于PacketView的OpenCORE，这套媒体库支持播放与录制硬盘及视频格式的文件，并能查看静态图片。</p>\n<p><strong>Surface Manager：</strong>在执行多个应用程序的时，负责管理显示与存取操作间的互动，同时负责2D绘图与3D绘图进行显示合成。</p>\n<p><strong>WebKit：</strong>Web浏览器引擎，该引擎为Android浏览器提供支持。</p>\n<p><strong>SGL：</strong>底层的2D图像引擎。</p>\n<p><strong>3D libraries：</strong>基于OpenGL ES 1.0API，提供使用软硬件实现3D加速的功能。</p>\n<p><strong>FreeType：</strong>提供位图和向量字体的支持。</p>\n<p><strong>SQLite：</strong>轻量级的关系型数据库。</p>\n</blockquote>\n<h5 id=\"4-Android运行时\"><a href=\"#4-Android运行时\" class=\"headerlink\" title=\"4. Android运行时**\"></a>4. Android运行时**</h5><pre><code>Android运行时由两部分完成：Android核心库和Dalvik虚拟机。其中核心库集提供了Java语言核心库所能使用的绝大部分功能，Dalvik虚拟机负责运行Android应用程序。\n\n虽然Android应用程序通过Java语言编写，而每个Java程序都会在Java虚拟机JVM内运行，但是Android系统毕竟是运行在移动设备上的，由于硬件的限制， Android应用程序并不使用Java的虚拟机JVM来运行程序，而是使用自己独立的虚拟机Dalvik VM，它针对多个同时高效运行的虚拟机进行了优化。每个Android应用程序都运行在单独的一个Dalvik虚拟机内，因此Android系统可以方便对应用程序进行隔离。</code></pre><h5 id=\"5-Linux内核\"><a href=\"#5-Linux内核\" class=\"headerlink\" title=\"5. Linux内核\"></a>5. Linux内核</h5><p>Android系统是基于Linux2.6之上建立的操作系统，它的Linux内核为Android系统提供了安全性、内存管理、进程管理、网络协议栈、驱动模型等核心系统服务。Linux内核帮助Android系统实现了底层硬件与上层软件之间的抽象。</p>\n<h4 id=\"1-2-2-Dalvik-VM和JVM的区别\"><a href=\"#1-2-2-Dalvik-VM和JVM的区别\" class=\"headerlink\" title=\"1.2.2 Dalvik VM和JVM的区别\"></a>1.2.2 Dalvik VM和JVM的区别</h4><p>JVM（Java虚拟机）是一个虚构出来的运行Java程序的运行时，是通过在实际的计算机上仿真模拟各种计算机功能的实现。它具有完善的硬件架构（如处理器、堆栈、寄存器等），还具有相应的指令系统，使用JVM就是使Java程序支持与操作系统无关。理论上在任何操作系统中，只要有对应的JVM，即可运行Java程序。</p>\n<p>Dalvik VM是在Android系统上运行Android程序的虚拟机，其指令集是基于寄存器架构的，执行特有的文件格式-dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。</p>\n<p>由于Android应用程序的开发编程语言是Java，而Java程序运行在JVM（Java虚拟机）上的，因此有些人会把Android的虚拟机DalvikVM和JVM弄混淆，但是实际上Dalvik并未遵守JVM规范，而且两者也是互不兼容。</p>\n<p>从Dalvik VM和JVM的编译过程分析，它们的编译过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JVM：.java→.class→.jar</span><br><span class=\"line\">Dalvik VM：.java→.class→.dex</span><br></pre></td></tr></table></figure>\n\n<p>从它们的编译过程可以看出，JVM运行的是.class文件的Java字节码，但是Dalvik VM运行的是其转换后的dex（Dalvik Executable）文件。JVM字节从.class文件或者JAR包中加载字节码然后运行，而Dalvik VM无法直接从.class文件或JAR包中加载字节码，它需要通过DX工具将应用程序所有的.class文件编译成一个.dex文件，Dalvik VM则运行这个.dex文件。</p>\n<p>下图显示了Dalvik VM与JVM编译过程的区别：</p>\n<p><img src=\"http://s4.51cto.com/wyfs02/M01/25/73/wKiom1NgXMOTVyNiAAB-h8_94xE986.jpg\" alt></p>\n<p>从图中可以看出，Dalvik VM把.java文件编译成.class后，会对.class进行重构，整合的基本元素（常量池、类定义、数据段）,最后压缩写进一个.dex文件中。其中，常量池描述了所有的常量，包括引用、方法名、数值常量等；类定义包括访问标识、类名等基本信息；数据段中包含各种被VM指定的方法代码以及类和方法的相关信息和实例变量。这种把多个.class文件进行整合的方法，大大提高了Android程序的运行速度，例如：应用程序中多个类定义了字符串常量TAG，而在JVM中，会编译成多个.class文件，每个.class文件的常量池中，均包含这个TAG常量，但是Dalvik VM在编译成.dex文件之后，其常量池里只有一个TAG常量。</p>\n<p>JVM和Dalvik VM还有一点非常重要的不同，就是基于的架构不同。JVM是基于栈的架构，而Dalvik VM是基于寄存器的架构。相对于基于栈的JVM而言，基于寄存器的Dalvik VM实现虽然牺牲了一些硬件上的通用性，但是它在代码的执行效率上要更胜一筹。一般来讲，VM中指令的解释执行的时间主要花费在以下三个方面：</p>\n<blockquote>\n<p>分发指令；</p>\n<p>访问运算数；</p>\n<p>执行运算；</p>\n</blockquote>\n<p>其中分发指令这个环节对性能的影响最大。在基于寄存器的Dalvik VM中，可以更有效的减少冗余指令的分发，减少内存的读写访问。</p>\n<p>从JVM和Dalvik VM的区别上来说，Dalvik VM主要是针对Android这个嵌入式操作系统的特点进行了各种优化，使其更省电、更省内存、运行效率更高，但是牺牲了一些JVM的与平台无关的特性。实际上，Dalvik VM本就是为Android设计的，无需考虑其它平台的问题。这里只是介绍了JVM和Dalvik VM的两个重要的区别，毕竟本书并不是讲解Android内核的，这里只是点明Dalvik VM的特点，读者对这部分的内容了解即可。</p>\n<h3 id=\"1-2-3-Android系统平台的优势\"><a href=\"#1-2-3-Android系统平台的优势\" class=\"headerlink\" title=\"1.2.3 Android系统平台的优势\"></a>1.2.3 Android系统平台的优势</h3><p>Android系统相对于其它操作系统，有如下几点优势：</p>\n<h4 id=\"1-开放性\"><a href=\"#1-开放性\" class=\"headerlink\" title=\"1. 开放性\"></a>1. 开放性</h4><p>首先就是Android系统的开放性，其开发平台允许任何移动终端厂商加入到Android联盟中来，降低了开发门槛，使其拥有更多的开发者，随着用户和应用的日益丰富，也将推进Android系统的成熟。同时，开放性有利于Android设备的普及以及市场竞争力，这样有利于消费者买到更低价位的Android设备。</p>\n<h4 id=\"2-丰富的硬件选择\"><a href=\"#2-丰富的硬件选择\" class=\"headerlink\" title=\"2. 丰富的硬件选择\"></a>2. 丰富的硬件选择</h4><p>同样由于Android系统的开放性，众多硬件厂商可以推出各种的搭载Android系统的设备。现如今，Android系统不仅仅只是运行在手机上，越来越多的设备开始支持Android系统，如电视、可佩戴设备、数码相机等。</p>\n<h4 id=\"3-便于开发\"><a href=\"#3-便于开发\" class=\"headerlink\" title=\"3. 便于开发\"></a>3. 便于开发</h4><p>Google开放了Android的系统源码，提供了开发者一个自由的开发环境，不必受到各种条条框框的束缚。</p>\n<h4 id=\"4-Google服务的支持\"><a href=\"#4-Google服务的支持\" class=\"headerlink\" title=\"4. Google服务的支持\"></a>4. Google服务的支持</h4><p>Google公司作为一个做服务的公司，它提供了如地图、邮件、搜索等服务，Android系统可以对这些服务进行无缝的结合。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-1-Android发展史与现状\"><a href=\"#1-1-Android发展史与现状\" class=\"headerlink\" title=\"1.1 Android发展史与现状\"></a>1.1 Android发展史与现状</h2><p>Andy Rubin创立22个月后→（2005年）Google收购。</p>\n<p>2008 Patrick Brady于Google I/O 演讲“Anatomy &amp; Physiology of an Android”，并提出的 Android HAL 架构图。</p>\n<h3 id=\"Android版本升级\"><a href=\"#Android版本升级\" class=\"headerlink\" title=\"Android版本升级\"></a>Android版本升级</h3><p>Android系统今后将继续每半年一次的升级步伐，分别定在每年的夏天和年终。每代Android系统都将以食物命名，比如1.5版叫做 Cupcake(纸杯蛋糕)，1.6版为Donut(甜甜圈)，然后是Eclair(法式奶油夹心甜点)和Flan(水果馅饼)。Donut将把社交网络功能作为升级重点，在“手机的各种体验中”都增加社交网络元素。  </p>\n<h4 id=\"1-5-Cupcake\"><a href=\"#1-5-Cupcake\" class=\"headerlink\" title=\"1.5 (Cupcake)\"></a>1.5 (Cupcake)</h4><p>基于Linux Kernel 2.6.27 2009年4月30日，官方1.5版本(Cupcake)的Android发布。主要的更新如下:<br>● 拍摄/回放视频，并支持上传到youtube<br>● 支持立体声蓝牙耳机，同时改善自动配对性能<br>● 最新的采用WebKit技术的浏览器，支持拷贝/粘帖和页面中搜索<br>● GPS性能大大提高<br>● 屏幕虚拟键盘<br>● 主屏幕增加音乐播放器和相框widgets<br>● 应用程序自动随着手机旋转<br>● 短信，Gmail，日历，浏览器的用户界面大幅改善，比如说Gmail现在可以批量删除邮件了<br>● 相机启动速度加快，拍摄图片可以直接上传到picasa<br>● 来电照片显示  </p>\n<h4 id=\"1-6-Donut\"><a href=\"#1-6-Donut\" class=\"headerlink\" title=\"1.6 (Donut)\"></a>1.6 (Donut)</h4><p>基于Linux Kernel 2.6.29 2009年9月15日, 1.6(Donut)版本SDK发布。主要的更新如下:<br>● 完全重新设计的Android Market<br>● 手势支持<br>● 支持CDMA网络<br>● 文字转语音系统(TXT-2-speech)<br>● 快速搜索框<br>● 全新的拍照界面<br>● 应用程序耗电查看<br>● 支持VPN<br>● 支持更多的屏幕分辨率<br>● 支持OpenCore2媒体引擎<br>● 新增面向视觉或听觉困难人群的易用性插件  </p>\n<h4 id=\"2-0-2-0-1-2-1-Eclair\"><a href=\"#2-0-2-0-1-2-1-Eclair\" class=\"headerlink\" title=\"2.0/2.0.1/2.1(Eclair)\"></a>2.0/2.0.1/2.1(Eclair)</h4><p>基于Linux Kernel 2.6.29 2009年10月26日, 2.0(Eclair)版本SDK发布。主要的更新如下:<br>● 优化硬件速度<br>● “Car Home”程序<br>● 支持更多的屏幕分辨率<br>● 重整界面<br>● 新的浏览器的用户界面和支持HTML5<br>● 新的联系人名单<br>● 更好的白色/黑色背景比率<br>● 改进Google Maps 3.1.2<br>● 支持Microsoft Exchange<br>● 支持内置相机闪光灯<br>● 数字变焦<br>● 改进的虚拟键盘<br>● 蓝牙2.1<br>Android的代号序列会按甜点名字中首个英文字母(C、D、E、F)的排列顺序。<br>下一个版本的Android将会命名为Froyo(冻酸奶,基于Linux Kernel 2.6.32)。Froyo 之后的版本的Android将会命名为Gingerbread(姜饼,基于Linux Kernel 2.6.33/34)。</p>\n<p><strong>Android**</strong>版本**</p>\n<p><strong>发布日期</strong></p>\n<p><strong>代号</strong></p>\n<p><strong>Android 1.1</strong></p>\n<p><strong>Android 1.5</strong></p>\n<p>2009年4月30日</p>\n<p>Cupcake（纸杯蛋糕）</p>\n<p><strong>Android 1.6</strong></p>\n<p>2009年9月15日</p>\n<p>Donut（炸面圈）</p>\n<p><strong>Android 2.0/2.1</strong></p>\n<p>2009年10月26日</p>\n<p>Eclair（长松饼）</p>\n<p><strong>Android 2.2</strong></p>\n<p>2010年5月20日</p>\n<p>Froyo（冻酸奶）</p>\n<p><strong>Android 2.3</strong></p>\n<p>2010年12月6日</p>\n<p>Gingerbread（姜饼）</p>\n<p><strong>Android 3.0/3.1/3.2</strong></p>\n<p>2011年2月22日</p>\n<p>Honeycomb（蜂巢）</p>\n<p><strong>Android 4.0</strong></p>\n<p>2011年10月19日</p>\n<p>Ice Cream Sandwich（冰淇淋三明治）</p>\n<p><strong>Android 4.1</strong></p>\n<p>2012年6月28日</p>\n<p>Jelly Bean（果冻豆）</p>\n<p><strong>Android 4.2</strong></p>\n<p>2012年10月8日</p>\n<p>Jelly Bean（果冻豆）</p>\n<p><strong>Android5.0</strong></p>\n<p>待定</p>\n<p>Lime Pie（酸橙派）</p>\n<h3 id=\"1-2-Android系统的架构与特性\"><a href=\"#1-2-Android系统的架构与特性\" class=\"headerlink\" title=\"1.2 Android系统的架构与特性\"></a>1.2 Android系统的架构与特性</h3><h4 id=\"1-2-1-Android系统架构\"><a href=\"#1-2-1-Android系统架构\" class=\"headerlink\" title=\"1.2.1 Android系统架构\"></a>1.2.1 Android系统架构</h4><p>Android系统的底层是建立在Linux系统之上的，它采用软件叠层（Software Stack）的方式进行构建。使得层与层之间相互分离，明确各层的分工。这种分工保证了层与层之间的低苟合，当下层发生改变的时候，上层应用程序无需做任何改变。</p>\n<p>下图为Android系统的系统架构图：</p>\n<p><img src=\"http://s1.51cto.com/wyfs02/M01/25/73/wKioL1NgW-Si7ae7AAEJ_vZkaJ0908.jpg\" alt></p>\n<p>如图可知，Android系统分为四个层，从高到底分别是：应用程序层（Application）、应用程序框架层（Application Framework）、系统运行库层（Libraries）和Linux内核层（Linux Kernel）。</p>\n<p>Android操作系统可以在四个主要层面上分为5个部分：</p>\n<h5 id=\"1-应用程序层（Application）\"><a href=\"#1-应用程序层（Application）\" class=\"headerlink\" title=\"1. 应用程序层（Application）\"></a>1. 应用程序层（Application）</h5><p>Android系统包含了一系列核心应用程序，包括电子邮件、短信SMS、日历、拨号器、地图、浏览器、联系人等。这些应用程序都是用Java语言编写。本书重点讲解如何编写Android系统上运行的应用程序，在程序分层上，与系统核心应用程序平级。</p>\n<h5 id=\"2-应用程序框架层（Application-Framework）\"><a href=\"#2-应用程序框架层（Application-Framework）\" class=\"headerlink\" title=\"2. 应用程序框架层（Application Framework）\"></a>2. 应用程序框架层（Application Framework）</h5><p>Android应用程序框架提供了大量的API供开发人员使用，Android应用程序的开发，就是调用这些API，根据需求实现功能。</p>\n<p>应用程序框架是应用程序的基础。为了软件的复用，任何一个应用程序都可以开发Android系统的功能模块，只要发布的时候遵循应用程序框架的规范，其它应用程序也可以使用这个功能模块。</p>\n<h5 id=\"3-系统运行库层（Libraries）\"><a href=\"#3-系统运行库层（Libraries）\" class=\"headerlink\" title=\"3. 系统运行库层（Libraries）**\"></a>3. 系统运行库层（Libraries）**</h5><p>Android系统运行库是用C/C++语言编写的，是一套被不同组件所使用的函数库组成的集合。一般来说，Android应用开发者无法直接调用这套函数库，都是通过它上层的应用程序框架提供的API来对这些函数库进行调用。</p>\n<p>下面对一些核心库进行简单的介绍：</p>\n<blockquote>\n<p><strong>Libc：</strong>从BSD系统派生出来的标准C系统库，在此基础之上，为了便携式Linux系统专门进行了调整。</p>\n<p><strong>Medio Framework：</strong>基于PacketView的OpenCORE，这套媒体库支持播放与录制硬盘及视频格式的文件，并能查看静态图片。</p>\n<p><strong>Surface Manager：</strong>在执行多个应用程序的时，负责管理显示与存取操作间的互动，同时负责2D绘图与3D绘图进行显示合成。</p>\n<p><strong>WebKit：</strong>Web浏览器引擎，该引擎为Android浏览器提供支持。</p>\n<p><strong>SGL：</strong>底层的2D图像引擎。</p>\n<p><strong>3D libraries：</strong>基于OpenGL ES 1.0API，提供使用软硬件实现3D加速的功能。</p>\n<p><strong>FreeType：</strong>提供位图和向量字体的支持。</p>\n<p><strong>SQLite：</strong>轻量级的关系型数据库。</p>\n</blockquote>\n<h5 id=\"4-Android运行时\"><a href=\"#4-Android运行时\" class=\"headerlink\" title=\"4. Android运行时**\"></a>4. Android运行时**</h5><pre><code>Android运行时由两部分完成：Android核心库和Dalvik虚拟机。其中核心库集提供了Java语言核心库所能使用的绝大部分功能，Dalvik虚拟机负责运行Android应用程序。\n\n虽然Android应用程序通过Java语言编写，而每个Java程序都会在Java虚拟机JVM内运行，但是Android系统毕竟是运行在移动设备上的，由于硬件的限制， Android应用程序并不使用Java的虚拟机JVM来运行程序，而是使用自己独立的虚拟机Dalvik VM，它针对多个同时高效运行的虚拟机进行了优化。每个Android应用程序都运行在单独的一个Dalvik虚拟机内，因此Android系统可以方便对应用程序进行隔离。</code></pre><h5 id=\"5-Linux内核\"><a href=\"#5-Linux内核\" class=\"headerlink\" title=\"5. Linux内核\"></a>5. Linux内核</h5><p>Android系统是基于Linux2.6之上建立的操作系统，它的Linux内核为Android系统提供了安全性、内存管理、进程管理、网络协议栈、驱动模型等核心系统服务。Linux内核帮助Android系统实现了底层硬件与上层软件之间的抽象。</p>\n<h4 id=\"1-2-2-Dalvik-VM和JVM的区别\"><a href=\"#1-2-2-Dalvik-VM和JVM的区别\" class=\"headerlink\" title=\"1.2.2 Dalvik VM和JVM的区别\"></a>1.2.2 Dalvik VM和JVM的区别</h4><p>JVM（Java虚拟机）是一个虚构出来的运行Java程序的运行时，是通过在实际的计算机上仿真模拟各种计算机功能的实现。它具有完善的硬件架构（如处理器、堆栈、寄存器等），还具有相应的指令系统，使用JVM就是使Java程序支持与操作系统无关。理论上在任何操作系统中，只要有对应的JVM，即可运行Java程序。</p>\n<p>Dalvik VM是在Android系统上运行Android程序的虚拟机，其指令集是基于寄存器架构的，执行特有的文件格式-dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。</p>\n<p>由于Android应用程序的开发编程语言是Java，而Java程序运行在JVM（Java虚拟机）上的，因此有些人会把Android的虚拟机DalvikVM和JVM弄混淆，但是实际上Dalvik并未遵守JVM规范，而且两者也是互不兼容。</p>\n<p>从Dalvik VM和JVM的编译过程分析，它们的编译过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JVM：.java→.class→.jar</span><br><span class=\"line\">Dalvik VM：.java→.class→.dex</span><br></pre></td></tr></table></figure>\n\n<p>从它们的编译过程可以看出，JVM运行的是.class文件的Java字节码，但是Dalvik VM运行的是其转换后的dex（Dalvik Executable）文件。JVM字节从.class文件或者JAR包中加载字节码然后运行，而Dalvik VM无法直接从.class文件或JAR包中加载字节码，它需要通过DX工具将应用程序所有的.class文件编译成一个.dex文件，Dalvik VM则运行这个.dex文件。</p>\n<p>下图显示了Dalvik VM与JVM编译过程的区别：</p>\n<p><img src=\"http://s4.51cto.com/wyfs02/M01/25/73/wKiom1NgXMOTVyNiAAB-h8_94xE986.jpg\" alt></p>\n<p>从图中可以看出，Dalvik VM把.java文件编译成.class后，会对.class进行重构，整合的基本元素（常量池、类定义、数据段）,最后压缩写进一个.dex文件中。其中，常量池描述了所有的常量，包括引用、方法名、数值常量等；类定义包括访问标识、类名等基本信息；数据段中包含各种被VM指定的方法代码以及类和方法的相关信息和实例变量。这种把多个.class文件进行整合的方法，大大提高了Android程序的运行速度，例如：应用程序中多个类定义了字符串常量TAG，而在JVM中，会编译成多个.class文件，每个.class文件的常量池中，均包含这个TAG常量，但是Dalvik VM在编译成.dex文件之后，其常量池里只有一个TAG常量。</p>\n<p>JVM和Dalvik VM还有一点非常重要的不同，就是基于的架构不同。JVM是基于栈的架构，而Dalvik VM是基于寄存器的架构。相对于基于栈的JVM而言，基于寄存器的Dalvik VM实现虽然牺牲了一些硬件上的通用性，但是它在代码的执行效率上要更胜一筹。一般来讲，VM中指令的解释执行的时间主要花费在以下三个方面：</p>\n<blockquote>\n<p>分发指令；</p>\n<p>访问运算数；</p>\n<p>执行运算；</p>\n</blockquote>\n<p>其中分发指令这个环节对性能的影响最大。在基于寄存器的Dalvik VM中，可以更有效的减少冗余指令的分发，减少内存的读写访问。</p>\n<p>从JVM和Dalvik VM的区别上来说，Dalvik VM主要是针对Android这个嵌入式操作系统的特点进行了各种优化，使其更省电、更省内存、运行效率更高，但是牺牲了一些JVM的与平台无关的特性。实际上，Dalvik VM本就是为Android设计的，无需考虑其它平台的问题。这里只是介绍了JVM和Dalvik VM的两个重要的区别，毕竟本书并不是讲解Android内核的，这里只是点明Dalvik VM的特点，读者对这部分的内容了解即可。</p>\n<h3 id=\"1-2-3-Android系统平台的优势\"><a href=\"#1-2-3-Android系统平台的优势\" class=\"headerlink\" title=\"1.2.3 Android系统平台的优势\"></a>1.2.3 Android系统平台的优势</h3><p>Android系统相对于其它操作系统，有如下几点优势：</p>\n<h4 id=\"1-开放性\"><a href=\"#1-开放性\" class=\"headerlink\" title=\"1. 开放性\"></a>1. 开放性</h4><p>首先就是Android系统的开放性，其开发平台允许任何移动终端厂商加入到Android联盟中来，降低了开发门槛，使其拥有更多的开发者，随着用户和应用的日益丰富，也将推进Android系统的成熟。同时，开放性有利于Android设备的普及以及市场竞争力，这样有利于消费者买到更低价位的Android设备。</p>\n<h4 id=\"2-丰富的硬件选择\"><a href=\"#2-丰富的硬件选择\" class=\"headerlink\" title=\"2. 丰富的硬件选择\"></a>2. 丰富的硬件选择</h4><p>同样由于Android系统的开放性，众多硬件厂商可以推出各种的搭载Android系统的设备。现如今，Android系统不仅仅只是运行在手机上，越来越多的设备开始支持Android系统，如电视、可佩戴设备、数码相机等。</p>\n<h4 id=\"3-便于开发\"><a href=\"#3-便于开发\" class=\"headerlink\" title=\"3. 便于开发\"></a>3. 便于开发</h4><p>Google开放了Android的系统源码，提供了开发者一个自由的开发环境，不必受到各种条条框框的束缚。</p>\n<h4 id=\"4-Google服务的支持\"><a href=\"#4-Google服务的支持\" class=\"headerlink\" title=\"4. Google服务的支持\"></a>4. Google服务的支持</h4><p>Google公司作为一个做服务的公司，它提供了如地图、邮件、搜索等服务，Android系统可以对这些服务进行无缝的结合。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck191nw720006b0wkt6goi5dt","category_id":"ck191nw6t0003b0wkoiqtbnh9","_id":"ck191nw7k000eb0wkzgq9c59i"},{"post_id":"ck191nw6b0001b0wk49t69ztu","category_id":"ck191nw6t0003b0wkoiqtbnh9","_id":"ck191nw7s000jb0wk1te7je84"},{"post_id":"ck191nw6o0002b0wkb32180pv","category_id":"ck191nw6t0003b0wkoiqtbnh9","_id":"ck191nw7z000mb0wk0nkj3wne"},{"post_id":"ck191nw6z0005b0wk8oglxoul","category_id":"ck191nw6t0003b0wkoiqtbnh9","_id":"ck191nw83000pb0wk50unvud1"},{"post_id":"ck191nw750007b0wkwspqk4am","category_id":"ck191nw7x000lb0wkrysujmtj","_id":"ck191nw89000ub0wkyuybz11s"},{"post_id":"ck191nw7d000bb0wky7s2sm1e","category_id":"ck191nw7x000lb0wkrysujmtj","_id":"ck191nw8c000xb0wkcf4k8ioa"},{"post_id":"ck191nw7h000db0wknkuq2s52","category_id":"ck191nw88000tb0wk2frb4727","_id":"ck191nw8h0012b0wkh2ndtgjk"},{"post_id":"ck191nw7o000ib0wk3fg5peou","category_id":"ck191nw88000tb0wk2frb4727","_id":"ck191nw8k0014b0wksfbilgvq"},{"post_id":"ck191nw7u000kb0wk2nghig66","category_id":"ck191nw88000tb0wk2frb4727","_id":"ck191nw8m0017b0wkym5du7o1"},{"post_id":"ck191nwfh001eb0wkriifrsdr","category_id":"ck191nw88000tb0wk2frb4727","_id":"ck191nwft001mb0wk810jxeez"},{"post_id":"ck191nwfk001gb0wkht5caffj","category_id":"ck191nw6t0003b0wkoiqtbnh9","_id":"ck191nwfv001ob0wkxskir6pj"},{"post_id":"ck191nwf8001ab0wkbwfpor85","category_id":"ck191nwff001cb0wkx1g12drc","_id":"ck191nwfx001qb0wk4gwmf1vu"},{"post_id":"ck191nwfo001jb0wke900fnmc","category_id":"ck191nw6t0003b0wkoiqtbnh9","_id":"ck191nwfz001sb0wka3kh6wkb"},{"post_id":"ck191nwfc001bb0wkud0wfmu0","category_id":"ck191nwff001cb0wkx1g12drc","_id":"ck191nwg0001tb0wkpuzegzq6"},{"post_id":"ck191nwg2001ub0wkqut2nc33","category_id":"ck191nwg5001vb0wktroumb1z","_id":"ck191nwg9001yb0wk8845zlyn"},{"post_id":"ck191nwgb001zb0wkk5wiag45","category_id":"ck191nwg5001vb0wktroumb1z","_id":"ck191nwgf0021b0wkmqst5fkh"}],"PostTag":[{"post_id":"ck191nw720006b0wkt6goi5dt","tag_id":"ck191nw6w0004b0wkp8kjqu91","_id":"ck191nw7c000ab0wkwdod5m5v"},{"post_id":"ck191nw6b0001b0wk49t69ztu","tag_id":"ck191nw6w0004b0wkp8kjqu91","_id":"ck191nw7g000cb0wktzafkf4c"},{"post_id":"ck191nw6o0002b0wkb32180pv","tag_id":"ck191nw6w0004b0wkp8kjqu91","_id":"ck191nw7o000hb0wk5utercpy"},{"post_id":"ck191nw6z0005b0wk8oglxoul","tag_id":"ck191nw6w0004b0wkp8kjqu91","_id":"ck191nw81000ob0wkr49a3lxj"},{"post_id":"ck191nw750007b0wkwspqk4am","tag_id":"ck191nw7z000nb0wk8v801ldn","_id":"ck191nw87000sb0wkae9e7g4b"},{"post_id":"ck191nw7d000bb0wky7s2sm1e","tag_id":"ck191nw7z000nb0wk8v801ldn","_id":"ck191nw8a000wb0wk4htsvxhy"},{"post_id":"ck191nw7h000db0wknkuq2s52","tag_id":"ck191nw89000vb0wkqiuxcikr","_id":"ck191nw8f0010b0wki0g58j92"},{"post_id":"ck191nw7o000ib0wk3fg5peou","tag_id":"ck191nw8e000zb0wk0qpleh4t","_id":"ck191nw8m0016b0wkzlzkw8lm"},{"post_id":"ck191nw7o000ib0wk3fg5peou","tag_id":"ck191nw8i0013b0wku2kvnqf2","_id":"ck191nw8n0018b0wkgc93srh6"},{"post_id":"ck191nw7u000kb0wk2nghig66","tag_id":"ck191nw8l0015b0wkyobw6btz","_id":"ck191nw8o0019b0wk73g85ujv"},{"post_id":"ck191nwf8001ab0wkbwfpor85","tag_id":"ck191nw8e000zb0wk0qpleh4t","_id":"ck191nwfg001db0wkempb6gj5"},{"post_id":"ck191nwf8001ab0wkbwfpor85","tag_id":"ck191nw8i0013b0wku2kvnqf2","_id":"ck191nwfj001fb0wkbiinc2m3"},{"post_id":"ck191nwfc001bb0wkud0wfmu0","tag_id":"ck191nw8e000zb0wk0qpleh4t","_id":"ck191nwfo001ib0wk6ug68vb1"},{"post_id":"ck191nwfc001bb0wkud0wfmu0","tag_id":"ck191nw8i0013b0wku2kvnqf2","_id":"ck191nwfs001lb0wkqbjdwqoa"},{"post_id":"ck191nwfk001gb0wkht5caffj","tag_id":"ck191nw6w0004b0wkp8kjqu91","_id":"ck191nwfu001nb0wkdjpmnrat"},{"post_id":"ck191nwfo001jb0wke900fnmc","tag_id":"ck191nw6w0004b0wkp8kjqu91","_id":"ck191nwfw001pb0wkb4uvq4tu"},{"post_id":"ck191nwfh001eb0wkriifrsdr","tag_id":"ck191nwfn001hb0wk204lb7cb","_id":"ck191nwfy001rb0wkw2h5irfd"},{"post_id":"ck191nwg2001ub0wkqut2nc33","tag_id":"ck191nwg6001wb0wkduumrbwq","_id":"ck191nwg8001xb0wkdvj00k8n"},{"post_id":"ck191nwgb001zb0wkk5wiag45","tag_id":"ck191nwg6001wb0wkduumrbwq","_id":"ck191nwge0020b0wkk1mn8rlg"}],"Tag":[{"name":"c","_id":"ck191nw6w0004b0wkp8kjqu91"},{"name":"hexo","_id":"ck191nw7z000nb0wk8v801ldn"},{"name":"php","_id":"ck191nw89000vb0wkqiuxcikr"},{"name":"mysql","_id":"ck191nw8e000zb0wk0qpleh4t"},{"name":"数据库","_id":"ck191nw8i0013b0wku2kvnqf2"},{"name":"eclipse","_id":"ck191nw8l0015b0wkyobw6btz"},{"name":"git","_id":"ck191nwfn001hb0wk204lb7cb"},{"name":"Android","_id":"ck191nwg6001wb0wkduumrbwq"}]}}