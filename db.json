{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/maupassant/source/archives/index.md","path":"archives/index.md","modified":1,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/apple-touch-icon.png","hash":"fbd2744aedd23c6addea809a9e5e7cbb3306e7b9","modified":1569822379618},{"_id":"themes/maupassant/README.md","hash":"4e402501b89720f18ffbfce4203663c79b3c0a7f","modified":1569824776815},{"_id":"themes/maupassant/.travis.yml","hash":"f8da426b97088e4caa5226cff219a5d95087961f","modified":1569824776812},{"_id":"source/favicon.ico","hash":"92d61ec769765f2fb7bc1882c2c3b18931ac40f2","modified":1569822262504},{"_id":"themes/maupassant/.gitignore","hash":"d7d27e5a9bcffe7f90dc2f4f0752e19020e40f40","modified":1569824776810},{"_id":"themes/maupassant/package.json","hash":"5328c4c435cd4a5fe47caae31b9975013cdca5bb","modified":1569824776880},{"_id":"themes/maupassant/LICENSE","hash":"0663fd3a7ea9fc4f4c634b4d73e2da426b536f86","modified":1569824776813},{"_id":"source/about/index.md","hash":"fad4e9bc74b8d95b61613524a9cb976f9aaf5c2f","modified":1570024165376},{"_id":"themes/maupassant/_config.yml","hash":"82b200e5f516ba16800daa74bdec1bcd2a24848a","modified":1569990727259},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"25d1d8cd8113045a7603c14af1ea1539fc6456ed","modified":1569824776820},{"_id":"themes/maupassant/languages/en.yml","hash":"518beaa8538a772ca697122264d667059797e458","modified":1569824776822},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"3a50568f200b9c1258415b53727e42c6b6c7ea0b","modified":1569824776825},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"3cc9312fbdba4a8f8e8254804121e4724c719bcc","modified":1569824776824},{"_id":"themes/maupassant/languages/ko.yml","hash":"a454bcec60113507bc1d593a699849822386c196","modified":1569824776827},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"a1a9888b6cd0fd3dc45ffed3490f4ca8ce1abfd7","modified":1569824776831},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"34dba7ac67aeb316f629ca73e546fa143cc362d5","modified":1569824776833},{"_id":"themes/maupassant/languages/ru.yml","hash":"36edc014c6aaef367d58929089bf7915375e71a6","modified":1569824776828},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"b0a0ec63ee0225eaa0996d72164202bc9a28a225","modified":1569824776867},{"_id":"themes/maupassant/layout/index.pug","hash":"d1d56fa62f1293cd0cbefe96dbbde2d35b557a0a","modified":1569824776870},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"4c8923bd7fe2a6d413cde7945ac3c34eeef9942b","modified":1569824776877},{"_id":"themes/maupassant/layout/archive.pug","hash":"05f751cb766616ff96ff22ad0790d9cd28777270","modified":1569824776865},{"_id":"themes/maupassant/layout/base.pug","hash":"7451a590db6943edc099dc0e13b317c38686e8fc","modified":1569824776869},{"_id":"themes/maupassant/layout/single-column.pug","hash":"8b4b731cdf86379d526821a1fa950bf15ed61f15","modified":1569824776875},{"_id":"themes/maupassant/layout/timeline.pug","hash":"04f7efdc45acda1faff409d0f80fa5a0dd2309d0","modified":1569824776878},{"_id":"themes/maupassant/layout/page.pug","hash":"a21e638d5459120d88e45e8f18a23dc072d9ca07","modified":1569824776872},{"_id":"themes/maupassant/layout/post.pug","hash":"faa84d65681da6f4697f2b3aec1e27f615569f7a","modified":1569834254736},{"_id":"source/_posts/c/C语言include和变量.md","hash":"d9468efc9e76317029871f161b7407eafa705d61","modified":1570006557706},{"_id":"source/_posts/c/C语言初识.md","hash":"4567ed9eb582fb5ae8ba844d406060e30155c500","modified":1570006276236},{"_id":"source/_posts/c/C语言指针、结构体、枚举.md","hash":"220dcc60ead453b8eca8ad3c8e73c5401f9d6dc3","modified":1570006832102},{"_id":"source/_posts/c/C语言数组和字符串.md","hash":"5c63a818e2bde1ca772fd84b28b6f164784ec2d3","modified":1570006665541},{"_id":"source/_posts/c/C语言表达式和结构控制.md","hash":"41e795d2afac323c314578ef948c3d36b6eb6d18","modified":1570006420484},{"_id":"source/_posts/c/C语言的预处理指令和关键字.md","hash":"9f983001495b3b7c13fed451a051d6e184ac0e4d","modified":1570006988980},{"_id":"source/_posts/dart/02_Dart初识.md","hash":"b25ecf90d584d65a5d3711a721f81d44d7576de2","modified":1570008184182},{"_id":"source/_posts/dart/05_Dart流程控制.md","hash":"3b65f9b52acfb320967a682fbffbacc5e0196e81","modified":1570008223149},{"_id":"source/_posts/dart/03_Dart函数.md","hash":"673055f88d57c47cbe66bc70a93c68057b7508c8","modified":1570008184183},{"_id":"source/_posts/dart/06_Dart异常处理.md","hash":"703b5fe27e059d9546145cbcca0b9f2b7f0122af","modified":1570008253040},{"_id":"source/_posts/dart/04_Dart运算符.md","hash":"0522f032029d9d80db5c04c76ae4b47188c442c3","modified":1570008182239},{"_id":"source/_posts/dart/10_异步支持.md","hash":"404e1491de736f10558ee614482365b8ea0a87dc","modified":1570008418845},{"_id":"source/_posts/dart/07_Dart类.md","hash":"40f6696729151768e04754bf4a195cdf2dc0f738","modified":1570008287373},{"_id":"source/_posts/dart/11_生成器等.md","hash":"6d067749faf11ca34cd451cb524b52948232458a","modified":1570008449672},{"_id":"source/_posts/dart/09_库和可见性.md","hash":"0bea9717fd9db991c2898a3456d3480180343575","modified":1570008388181},{"_id":"source/_posts/flutter/12_第一个Flutter应用.md","hash":"d11a3bd301e59f84253ef6c2f76938755ca7b590","modified":1570012361812},{"_id":"source/_posts/flutter/01_初识与安装.md","hash":"b836b264191c4c217b7b91eaa700adc166db2fe5","modified":1570012364219},{"_id":"source/_posts/git/Git远程操作详解.md","hash":"b76d1181b8ea588646fc65ba6122fc3d4964088d","modified":1570005738966},{"_id":"source/_posts/hexo/hexo配置.md","hash":"1116a8a4096f128a34c65816ca56aaf37a3f3fc8","modified":1570005686962},{"_id":"source/_posts/ide/Eclipse.ini参数设置.md","hash":"cc883bab830dc8f321a5750de322daaed359c8a4","modified":1570005748543},{"_id":"source/_posts/hexo/利用Hexo+GitHub搭建个人博客.md","hash":"669da26a1627d07f9b13136382b0cb7808150bf2","modified":1570005714758},{"_id":"source/_posts/ide/PHP开发工具ZendStudio10.md","hash":"bc08654f39d3ce648393e37c37fe1352686727bc","modified":1570005751101},{"_id":"source/_posts/uml/01 UML介绍.md","hash":"f138491d253a69f12c8907fe7dfd8c1fb35e5589","modified":1570017908987},{"_id":"source/_posts/uml/03 静态图.md","hash":"ce70d099ebd6f3b0f5335838297781dcbdd37889","modified":1570024112727},{"_id":"source/_posts/uml/02 用例图（Use Case）.md","hash":"0fceb6840742c2d206bf41f3eba49b225b850ea2","modified":1570024101942},{"_id":"source/_posts/uml/06 部署图(Deployment Diagram).md","hash":"779853d30c980fe21284e233260147f526f090f1","modified":1570024139103},{"_id":"source/_posts/uml/05 状态图(Statechart Diagram).md","hash":"8ff47889b4c5330ebd9ce41819e906d42aa3e5b5","modified":1570024131136},{"_id":"source/_posts/uml/04 活动图(Activity Diagram).md","hash":"51a3850b706c50ca5f32dadd69e8e36e8e17e5b5","modified":1570024121137},{"_id":"source/_posts/uml/07 时序图(Sequence Diagram).md","hash":"6899ec80d7bef88cfcdbc77d6d062c8d8a34aba1","modified":1570024146828},{"_id":"source/_posts/mysql/Win8(X64)下MySQL5.6版本安装及配置.md","hash":"0ccdaaed2da693a357670d3728a28aec21f29970","modified":1570005635546},{"_id":"source/_posts/mysql/mysql常用信息函数.md","hash":"c36da120b0b01055d6efe33bba5af2a562513c0c","modified":1570005622980},{"_id":"source/_posts/mysql/数据表命令.md","hash":"6275862d5f3fda2925fad63464be0f2a18c3a4a3","modified":1570005970954},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"92aa15e813bfb411803cc54218feb5410469a9c2","modified":1569824776839},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"78c9a74bc379feca35342e4753a4cc6330a0fe94","modified":1569824776838},{"_id":"source/_posts/dart/08_泛型.md","hash":"62f02d8e339d012a195cdf761b0cc0bd93822056","modified":1570008388196},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"d2ffd7c34c743ec3c01dc1a1ddb8913ffd025f2a","modified":1569824776836},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1569824776843},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"235660024477ba0f68dacbbde12492280f82242a","modified":1569824776841},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1569824776846},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1569824776851},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1569824776844},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1569824776850},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1569824776848},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"6fb1d8ee09cfc4fd31e8ae53736e4f479d45e31e","modified":1569824776854},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7707b4c718a935882ee986d0bb0078e50cdbea64","modified":1569824776857},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"eb91a3baf9411188c7c8130f63a674f541ca9c81","modified":1569824776853},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"7bc7c17cfd498c3e0c3371cef78f08f1dc25db36","modified":1569824776857},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"770b6c41cbf7969ed33adf87eec3be6f50a0911b","modified":1569824776860},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"68bae3eb2f80e6127e03faa7ee1b78fb2e70aafc","modified":1569824776859},{"_id":"themes/maupassant/source/archives/index.md","hash":"f6247f6b31fd4fa7723b05264d3757fbffb70e4f","modified":1569824968622},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"37f236365b153fc40324391e5a602d6d50014e18","modified":1569824776863},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6aa743486f282545f553a4fad6aae037afe26108","modified":1569824776862},{"_id":"themes/maupassant/source/donate/index.html","hash":"72e48cbc939df9e4f963ebf570e0181e129a51c5","modified":1569824776890},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1569824776893},{"_id":"themes/maupassant/source/css/default.css","hash":"b41d95120f9e64fd4530ae00ceaef09c7ea20818","modified":1569824776884},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1569824776897},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1569824776895},{"_id":"themes/maupassant/source/css/donate.css","hash":"ca39d14a598e1de5c51db4170ceb399c6a7131fe","modified":1569824776885},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"292ea040e865c1d0be259703ff850570b3bdfc97","modified":1569824776899},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"30418295bed44bcc4b29076eb7deed49cf4d6c1c","modified":1569824776908},{"_id":"themes/maupassant/source/css/style.scss","hash":"ee0800852fc68c82821b7a7c7a77e933fb00d157","modified":1569824776888},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"eeb2ee8cf44ba5c298baeed84bb90866f4814955","modified":1569824776901},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"c77270e684a60babc1abb7353e700ecdc5a66d30","modified":1569824776911},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1569824776913},{"_id":"themes/maupassant/source/js/search.js","hash":"dbda07a03e6edc73f1dc28a068c24a6037b97b56","modified":1569824776920},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"8a993c1c4ad40789d2960b682cb2130382a0f26a","modified":1569824776914},{"_id":"themes/maupassant/source/js/share.js","hash":"514e726c1efae9f6566600fa0e945b4b9e620f2e","modified":1569824776921},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"150ab1cad40d7ae081b0896b13f7d7cbac4e6338","modified":1569824776924},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1569824776905},{"_id":"themes/maupassant/source/js/totop.js","hash":"15de186b089c245fe60766d509b587919f05ff23","modified":1569824776925},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"e916dea1c1bba1bc935510310f65b2c9328a401a","modified":1569824776907},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1569824776902},{"_id":"source/_posts/android/base/Android应用的基本组件.md","hash":"6571919c912a6b1478d8c93540f5f3ba82803da1","modified":1570005662792},{"_id":"source/_posts/android/base/android发展史及系统架构.md","hash":"dc4df0788593bba9a10994c6706a2d1d5bd9abb9","modified":1570005659303},{"_id":"source/_posts/dart/img/keywords.png","hash":"b5562fccd7e433a946ff746225d071e2a7f533ab","modified":1550388666151},{"_id":"source/_posts/flutter/img/13_1.png","hash":"626dc6c0efc8d6217edecdf9ba187ac6c5b4de57","modified":1550803997899},{"_id":"source/_posts/flutter/img/14_1.png","hash":"4bc3e1811a54b978472951e733d6bda49cc4f2ef","modified":1550808205978},{"_id":"source/_posts/flutter/img/12_3.png","hash":"c3fca20bbf65e9939dc99ee0d9a852cad34b204e","modified":1550549189618},{"_id":"source/_posts/dart/img/dart.jpg","hash":"442773e383e01afde325ad846fd867daf0197666","modified":1550226073218},{"_id":"source/_posts/flutter/img/padding.jpg","hash":"a8ee59062edb95ebccbf49c6bea49f4c4cf9dd00","modified":1551086726768},{"_id":"source/_posts/flutter/img/flutter.jpg","hash":"a3e192485b5dc33522f84007f9b8c0dc3d2049f5","modified":1550421881175},{"_id":"source/_posts/flutter/可滚动Widget/ListView.md","hash":"fabac66138341e48b712e2e7f28045514ba7300d","modified":1570017067230},{"_id":"source/_posts/flutter/可滚动Widget/SingleChildScrollView.md","hash":"d360434456adb8b96bd518c82b807a494bd7b66b","modified":1570017062821},{"_id":"source/_posts/flutter/img/hello_word_ios.png","hash":"32cb1458bdf992ae6795408eb11ef24a7eded4f1","modified":1550541852247},{"_id":"source/_posts/flutter/img/stack_positioned.png","hash":"f77e60853c94f4e1aba6bbfb09d01c6ef000f355","modified":1551169833870},{"_id":"source/_posts/flutter/可滚动Widget/可滚动Widget.md","hash":"2b342ac874e0049e6cb056c6305507cc8e3ac153","modified":1570017057496},{"_id":"source/_posts/flutter/widget/16_Material_Scaffold.md","hash":"6e3899f74c7339ab308653b01b235d660e4f7469","modified":1570017075268},{"_id":"source/_posts/flutter/widget/17_Material_AppBar.md","hash":"76a81ea9c1e9e9d736abdf4734e102fc2843c676","modified":1570017078762},{"_id":"source/_posts/flutter/img/15_1.jpg","hash":"9f92f32f2e8104f437a363e420c90b285e498552","modified":1550812998641},{"_id":"source/_posts/flutter/widget/18_Material_BottomNavigationBar.md","hash":"fbdf69d37eb83eef30d75ffa1ec0894af8884384","modified":1570017082046},{"_id":"source/_posts/flutter/widget/19_Material_PopupMenu.md","hash":"af02b82eac8a653fcca5a67e87d97d006a2b9061","modified":1570017085340},{"_id":"source/_posts/flutter/widget/FlutterWidget.md","hash":"489f847e9e4163dac9a9207b6f3f86bfe79f69a5","modified":1570017096452},{"_id":"source/_posts/flutter/widget/Image&Icon.md","hash":"96e8fb7a4f5d689ef59f7d863b2cb25eda0817df","modified":1570017101152},{"_id":"source/_posts/flutter/widget/Button.md","hash":"a8d8c4d3f80d811212f0a88c183c25e06576928a","modified":1570017089033},{"_id":"source/_posts/flutter/widget/Text.md","hash":"773dd2ec4801030eac0a7e83eaca2bf3f03418dc","modified":1570017105960},{"_id":"source/_posts/flutter/widget/image.md","hash":"70a47a0f9407d1d11d21435ede17aa5675da6470","modified":1570017092518},{"_id":"source/_posts/flutter/容器/Container.md","hash":"16967877b8b42ccf14611008dbdd3392a1d471b3","modified":1570017535234},{"_id":"source/_posts/flutter/容器/变换Transform.md","hash":"92d9e104fb0ceed084096b2d9c71e52891f6b09c","modified":1570017484677},{"_id":"source/_posts/flutter/容器/Padding&Align&Center.md","hash":"cd7324f22e035360407f572a1d6b8c2331d2ce38","modified":1570017570461},{"_id":"source/_posts/flutter/容器/布局限制容器ConstrainedBox和SizedBox.md","hash":"61b2ea6b3c66a854854d8e2252db63a22116c2f2","modified":1570017509247},{"_id":"source/_posts/flutter/布局/Flex&Expand.md","hash":"254cb60bf292728f83b4afd36d022b995bebbdae","modified":1570017231738},{"_id":"source/_posts/flutter/布局/Row&Colum.md","hash":"be9d6594b6ee6d2efd88a8546ea646045765f4ef","modified":1570017279090},{"_id":"source/_posts/flutter/布局/布局类Widget.md","hash":"8c00f08dacdbc367144b393d38fc7771fecc34ff","modified":1570017047283},{"_id":"source/_posts/flutter/布局/Stack&Positioned.md","hash":"3291d617b30e8b854770489359e2710e4024e676","modified":1570017320803},{"_id":"source/_posts/flutter/img/state_life.png","hash":"e0551eae54b6cf7d62c4595dcc2dd4dd44d47303","modified":1551107904751},{"_id":"source/_posts/flutter/布局/Wrap&Flow.md","hash":"2f6a2b5cbe53351553cdd9ae65a65f433937bd02","modified":1570017349109},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"b15998a45d5f386d30905cfbfbb1658336acbb5b","modified":1569824776918},{"_id":"source/_posts/flutter/img/scaffold.jpg","hash":"18e39b829592a72e0a24842bd3efcfc818a71494","modified":1550823470289},{"_id":"source/_posts/uml/image/uml_view.jpg","hash":"fb51b5d9cc8aba9a4a893a22430c3008944bab25","modified":1550458950590},{"_id":"source/_posts/flutter/img/12_1.png","hash":"f3f0b3b19002b341dcce809068f9440bd4fec862","modified":1550548847608},{"_id":"source/_posts/flutter/img/appBarDemo.png","hash":"300cd44aafb5dd046365a6f8babd86eb5a54bbb8","modified":1551065976888},{"_id":"source/_posts/flutter/img/appBar.png","hash":"14ee223e769e1032209d589641b2120661131fe2","modified":1551065564129},{"_id":"source/_posts/uml/image/usecase.png","hash":"baef19bd5c2f6e5fd1f732e813dd11d81aef936e","modified":1550458950591},{"_id":"source/_posts/flutter/img/bottomNavigationBarDemo.png","hash":"f5e2ab4439ea431cc824601de7c9aa3c43ff8f49","modified":1551066687924},{"_id":"source/_posts/uml/image/actor.png","hash":"c2534c1d61e6001965ebab5e6dabe4f3e8904301","modified":1550458950556},{"_id":"source/_posts/uml/image/Deployment/结点.png","hash":"0962b5c79f1725c4e3e97eabac150cbea9f6d5b4","modified":1550458950525},{"_id":"source/_posts/uml/image/activity/分叉和汇合.png","hash":"92a112a4fb9cbfa2c402a8d3932d1b5189dd4ed4","modified":1550458950540},{"_id":"source/_posts/uml/image/Deployment/结点实例.png","hash":"327769d06705aaf40b106eb01437e96e73befa38","modified":1550458950526},{"_id":"source/_posts/uml/image/activity/分支和合并.png","hash":"135a440011c4426abbd213951fe1f4d048889436","modified":1550458950541},{"_id":"source/_posts/uml/image/activity/动作流.png","hash":"8238b7c8b6e7aa1c783cb5ae1cb2b55a8367f99d","modified":1550458950542},{"_id":"source/_posts/uml/image/activity/动作状态约束.png","hash":"f00fd073fc5a15aa00f38afc0a82b461c552e672","modified":1550458950543},{"_id":"source/_posts/uml/image/activity/对象流.png","hash":"c13dba3382179196db54537683c57a7602864460","modified":1550458950544},{"_id":"source/_posts/uml/image/activity/开始节点.png","hash":"d6b26050f53e0a49efff74c5588697bcaf8ebc60","modified":1550458950545},{"_id":"source/_posts/uml/image/activity/活动图样例.jpg","hash":"6b59fe1a2e10ebdbf05050e40b18cbf4f9b9b4ea","modified":1550458950552},{"_id":"source/_posts/uml/image/activity/泳道.png","hash":"bd4ac6afbc363d0211164fb8eced10ef373df592","modified":1550458950549},{"_id":"source/_posts/uml/image/activity/异常处理.png","hash":"6ecb281ad6627d95ed73dfe0ff1dcdcb400c2f27","modified":1550458950546},{"_id":"source/_posts/uml/image/activity/活动终止.png","hash":"3b253ba03ad1a780783a71d8982b314a5f8be615","modified":1550458950553},{"_id":"source/_posts/uml/image/activity/数据存储.png","hash":"b9d8817d2c2bc5bbf48b6cc28bd8934087269a2d","modified":1550458950547},{"_id":"source/_posts/uml/image/activity/活动中断区域.png","hash":"d1c7444a70c80b075b44c367e7f053b3c4c1751c","modified":1550458950551},{"_id":"source/_posts/uml/image/Statechart/历史状态.png","hash":"2e3da5af38117820af432066c05a731f24fb2a30","modified":1550458950533},{"_id":"source/_posts/uml/image/Statechart/并发区域.png","hash":"637f04c3f49fe40b4d84654728e0fbb1967be3ae","modified":1550458950535},{"_id":"source/_posts/uml/image/activity/流程终止.png","hash":"d3a0fb0554dea29c5e977f63582f82ffdb8b78f5","modified":1550458950555},{"_id":"source/_posts/uml/image/Statechart/进入节点.png","hash":"bb91b9e5d2aea7505ff9b24d0630a2069d5e875c","modified":1550458950537},{"_id":"source/_posts/uml/image/uc/Artifact.png","hash":"467539d6c49a8c718d35604b5034a9309be27e6e","modified":1550458950575},{"_id":"source/_posts/uml/image/uc/Association.png","hash":"a35f495f13848aed95076109caa7dededd2da9d7","modified":1550458950576},{"_id":"source/_posts/uml/image/Sequence/控制焦点.png","hash":"323d43b336938b36373a90dcd922bccfb4309392","modified":1550458950528},{"_id":"source/_posts/uml/image/uc/Comment.png","hash":"b3f13fc55b1aefea9b2a74f1f5a4fca8bae89019","modified":1550458950577},{"_id":"source/_posts/uml/image/Sequence/消息.png","hash":"a40138354bea93eba6434fbb348d7e6056206f57","modified":1550458950529},{"_id":"source/_posts/uml/image/uc/Extend.png","hash":"e37f5dd1cabc9ed4ea0a532a4f65020c2d1c926d","modified":1550458950579},{"_id":"source/_posts/uml/image/Sequence/自关联消息.png","hash":"3efa90e904a7f7484ad5325a2f5e842541d746d9","modified":1550458950531},{"_id":"source/_posts/uml/image/uc/Include.png","hash":"cfd680042267b00063610c7619f5ec8f100b610c","modified":1550458950580},{"_id":"source/_posts/uml/image/uc/Dependency.png","hash":"42278f6e1d789236e4e2e7ea6e3d00b4490ca1ce","modified":1550458950578},{"_id":"source/_posts/uml/image/uc/subsystem.png","hash":"d73fa45e90b8c2820b5f3b240dbb10c43b0702b2","modified":1550458950586},{"_id":"source/_posts/uml/image/uc/edit_drow.png","hash":"08b9a89b67d80bd59138cb6c717e1661ab44b64a","modified":1550458950585},{"_id":"source/_posts/uml/image/class_diagram/包图.png","hash":"6a1bdfec8e4c6727b35d2e38c899e55d4ed58163","modified":1550458950560},{"_id":"source/_posts/uml/image/class_diagram/对象图.png","hash":"b5d784840960ccbb504cbe54f64d0ac47c65df35","modified":1550458950564},{"_id":"source/_posts/uml/image/class_diagram/单向关联.png","hash":"e7d99bf55ef22f3403f398311bea18199c11242f","modified":1550458950561},{"_id":"source/_posts/uml/image/class_diagram/依赖.png","hash":"9c4067098ab960aba880ecc9ee88daf73dd14245","modified":1550458950558},{"_id":"source/_posts/uml/image/class_diagram/双向关联.png","hash":"c5a12c63409850c29d2270c1ba8941268e402ae4","modified":1550458950561},{"_id":"source/_posts/uml/image/class_diagram/组合.png","hash":"052071bb07b317c7e58d54593571c3c89d6a80c4","modified":1550458950570},{"_id":"source/_posts/uml/image/class_diagram/多维关联.png","hash":"db5ac964143551da5d1de530906daa3235b887ae","modified":1550458950563},{"_id":"source/_posts/uml/image/class_diagram/泛化.png","hash":"ba1a09c546336ff28d30a386e11a5bf4ca39ce9a","modified":1550458950566},{"_id":"source/_posts/uml/image/class_diagram/继承.png","hash":"966a8d15423cdd7c57780d563261b6c948f43921","modified":1550458950571},{"_id":"source/_posts/uml/image/class_diagram/自身关联.png","hash":"0b3c08ee23a3775206d50b777d73fc82b98051da","modified":1550458950573},{"_id":"source/_posts/uml/image/class_diagram/聚合.png","hash":"5a831c9a9ca84fa5fea9e951dd5dc27b4c45624c","modified":1550458950572},{"_id":"source/_posts/flutter/img/12_2.png","hash":"273ac84928dc757eaa56466fcff2c10b3ab73b9c","modified":1550549016897},{"_id":"source/_posts/uml/image/Statechart/状态图练习.png","hash":"b4eb60a6eefb783234377d28e67b20ca5fdffb02","modified":1550458950536},{"_id":"source/_posts/uml/image/Sequence/生命线.png","hash":"a4fbd9a58c41625c05cd3ad44583b04137b39e48","modified":1550458950530},{"_id":"source/_posts/uml/image/Statechart/退出节点.png","hash":"f26fb6b72961296d347fab5f41fa97222ea21fe4","modified":1550458950538},{"_id":"source/_posts/uml/image/uc/edit_add.png","hash":"e273f3b14b73effab85b95c34c98076045588cca","modified":1550458950583},{"_id":"source/_posts/uml/image/uc/Inheritance.png","hash":"a57d2fa435964c2a1524e236d6c47c7d96899c06","modified":1550458950581},{"_id":"source/_posts/uml/image/class_diagram/startUML连线.png","hash":"81163b57dc769cb9ad6c9d940a6883c688706ff9","modified":1550458950557},{"_id":"source/_posts/flutter/img/hello_word_android.png","hash":"56c86a185bb9cdfd462a30a4c6c1e82e80310c74","modified":1550541756225},{"_id":"source/_posts/uml/image/uc/图书管理系统.jpg","hash":"66b4577a37de6a6f603f55248c197cc4ce32e897","modified":1550458950588},{"_id":"source/_posts/uml/image/class_diagram/类图练习.jpg","hash":"8d4c44cf8b452a923da82d6bc86cc9a698d87640","modified":1550458950568},{"_id":"source/_posts/uml/UML样例.mdj","hash":"d1f2cfa7de7fc39d1958a4b1d727c2be304cc9af","modified":1550458950523},{"_id":"public/atom.xml","hash":"1dfab4ecd9fcdb7436fb78881ca37f14e1b9956f","modified":1570024198332},{"_id":"public/archives/index.html","hash":"305a0deb11fb37407e616921c22f8ee432faf405","modified":1570024198929},{"_id":"public/about/index.html","hash":"30f0ec16323e92578077579b098be1b82b920ae7","modified":1570024198929},{"_id":"public/2019/09/30/hexo/利用Hexo+GitHub搭建个人博客/index.html","hash":"ab3dd7b02db2fa3253e92cbb9158ecdc2e89ae9c","modified":1570024198937},{"_id":"public/2019/09/30/hexo/hexo配置/index.html","hash":"7af344d3b5f7373f91a0b6f958a37799904434a4","modified":1570024198957},{"_id":"public/2019/02/26/flutter/可滚动Widget/可滚动Widget/index.html","hash":"9dfff1f0eb24becce6070f9aa6d7ebb088b1acc2","modified":1570024199674},{"_id":"public/2019/02/26/flutter/可滚动Widget/SingleChildScrollView/index.html","hash":"2455c928d3e6fa4fb80fef6d34bdef3a1d6438d4","modified":1570024199677},{"_id":"public/2019/02/26/flutter/布局/布局类Widget/index.html","hash":"3834d7dba1a2800e9ee4464806cbe70ad3035cec","modified":1570024199709},{"_id":"public/2019/02/26/flutter/容器/Padding&Align&Center/index.html","hash":"aa01d02052a40ebcd31a0db15bfda7df9a34ae3f","modified":1570024199710},{"_id":"public/2019/02/26/flutter/布局/Flex&Expand/index.html","hash":"21762894457358931e82b5223e422994d53ea955","modified":1570024199710},{"_id":"public/2017/01/12/mysql/mysql常用信息函数/index.html","hash":"8a8e0cc1a4caa8ea7c2fbb009440dc312b7da6f5","modified":1570024199710},{"_id":"public/2015/12/20/c/C语言数组和字符串/index.html","hash":"4e98ee53fcf70b9c1b43a932d64ddf081db828b7","modified":1570024199710},{"_id":"public/2015/04/17/ide/PHP开发工具ZendStudio10/index.html","hash":"e4b8e56568abb810df8c3589488ec05d7288978d","modified":1570024199711},{"_id":"public/2015/04/16/ide/Eclipse.ini参数设置/index.html","hash":"2468c6112af5d200b79f8f1df8c830c875c02a93","modified":1570024199711},{"_id":"public/archives/page/2/index.html","hash":"f56970f94a9746f15761fc9ff7fa314662fa01bb","modified":1570024199711},{"_id":"public/archives/2015/index.html","hash":"e86d238c9b5b081627b1b9ce73e623f47c62220b","modified":1570024199711},{"_id":"public/archives/2015/12/index.html","hash":"32a14b0574bcb21ac4e3fed7891f3c9a79b2dfdd","modified":1570024199711},{"_id":"public/archives/2015/page/2/index.html","hash":"920b5102cb857d00bf090c1b6e6fafb54f1c33ef","modified":1570024199711},{"_id":"public/archives/2015/04/index.html","hash":"ac9b7df2fd44b4d506f87eb34e08023f5b9b7b84","modified":1570024199711},{"_id":"public/archives/2016/index.html","hash":"89fc3b85c7e774ee95a750f03c404bec748e63a9","modified":1570024199711},{"_id":"public/archives/2016/01/index.html","hash":"89fc3b85c7e774ee95a750f03c404bec748e63a9","modified":1570024199712},{"_id":"public/archives/2017/index.html","hash":"6186921e51281fbf2c797935e6b0b3f50058cf69","modified":1570024199712},{"_id":"public/archives/2017/01/index.html","hash":"6186921e51281fbf2c797935e6b0b3f50058cf69","modified":1570024199712},{"_id":"public/archives/2019/index.html","hash":"d35d23897d65d72aee8b1d66856a06604e0ed1fa","modified":1570024199712},{"_id":"public/categories/C语言/index.html","hash":"73dcd7002b595c579f1a4523090ccdf40c9dadaf","modified":1570024199712},{"_id":"public/archives/2019/09/index.html","hash":"419c996b20ecd0dc109ed0f1cb5332dfbab0e4d2","modified":1570024199712},{"_id":"public/categories/IDE/index.html","hash":"8acd7c6e9d486eda11fb1579abfb0617c3d4a477","modified":1570024199712},{"_id":"public/categories/hexo/index.html","hash":"ac974f49500030d0afdef36c201ce5137903354d","modified":1570024199712},{"_id":"public/categories/MySql/index.html","hash":"1fff0b027ae684303407efbda6cebf6a1be3697d","modified":1570024199712},{"_id":"public/categories/Android基础/index.html","hash":"f7e510775ae67d58a28b9f795dedfe264f7e7745","modified":1570024199713},{"_id":"public/tags/c/index.html","hash":"0566b15ae29b41e9dbae17790c8bac91a6bb11d2","modified":1570024199713},{"_id":"public/tags/eclipse/index.html","hash":"cc9611b3f05365c19bb9d356bcfb0fd3566eb2e3","modified":1570024199713},{"_id":"public/tags/hexo/index.html","hash":"ac974f49500030d0afdef36c201ce5137903354d","modified":1570024199713},{"_id":"public/tags/php/index.html","hash":"562c18ec92caf340f8da7e4b2e6165adbe28dd30","modified":1570024199713},{"_id":"public/tags/数据库/index.html","hash":"e071ac9d1f2b258e4787b84e7d9ec90aa01f7928","modified":1570024199713},{"_id":"public/tags/mysql/index.html","hash":"b22d4ef7777b204af9ff859db59c44bb2d901fcf","modified":1570024199713},{"_id":"public/tags/git/index.html","hash":"ab7e51a56c5145505e67d261e65cb5d3ed3fd1d6","modified":1570024199714},{"_id":"public/tags/Android/index.html","hash":"007845a6ca28c6c824cedf00ae283578acc18598","modified":1570024199714},{"_id":"public/2019/02/27/flutter/可滚动Widget/ListView/index.html","hash":"bdd4ad0ddf4efe0fe9730a6d7d5cafc3ddd8c85a","modified":1570024199714},{"_id":"public/2019/02/26/flutter/容器/布局限制容器ConstrainedBox和SizedBox/index.html","hash":"7432bc28ebeef7e56206d2eef1d0db3c903ece24","modified":1570024199714},{"_id":"public/2019/02/26/flutter/容器/变换Transform/index.html","hash":"681907641dd0ea23c30021219f1c601e342d6665","modified":1570024199714},{"_id":"public/2019/02/26/flutter/容器/Container/index.html","hash":"2a46cc2e9275432cf2f7489adfd68cad5066c792","modified":1570024199714},{"_id":"public/2019/02/26/flutter/布局/Stack&Positioned/index.html","hash":"24ec2d01ec5e91574eaa9173f33937fe3ae04e9b","modified":1570024199715},{"_id":"public/2019/02/26/flutter/布局/Wrap&Flow/index.html","hash":"331081cd24b239a8a046c692269b5605b79c26af","modified":1570024199715},{"_id":"public/2019/02/26/flutter/widget/Button/index.html","hash":"5fd2ebdad7f3e89da2a357c453d615261edd428a","modified":1570024199715},{"_id":"public/2017/01/12/mysql/数据表命令/index.html","hash":"2a7be5e02ef0919f3ebdd2609bd51756e4054f92","modified":1570024199715},{"_id":"public/2016/01/11/git/Git远程操作详解/index.html","hash":"e56ffa66f234aaa9fe386a1a324b0636dc49633e","modified":1570024199715},{"_id":"public/2015/12/20/c/C语言的预处理指令和关键字/index.html","hash":"b5dcc1afbdd11271950dcc20647d0525ead37a1a","modified":1570024199715},{"_id":"public/2015/12/19/c/C语言include和变量/index.html","hash":"74da8b0972b295bc9e1f00b10a44ae7ad593ab62","modified":1570024199715},{"_id":"public/2015/12/19/c/C语言指针、结构体、枚举/index.html","hash":"e13f5f776b045655b4ba6d184b0ceebe8068d158","modified":1570024199716},{"_id":"public/2015/12/19/c/C语言初识/index.html","hash":"39c40ceda9a5ed03a0e56bb465ef2417520dc1b6","modified":1570024199716},{"_id":"public/2015/04/29/android/base/Android应用的基本组件/index.html","hash":"2cf9f53a2f7ba329526e22f6952f44f968020446","modified":1570024199716},{"_id":"public/2015/12/19/c/C语言表达式和结构控制/index.html","hash":"603c1b1f9da35f8031e5d23eb17a6caa061aa14c","modified":1570024199716},{"_id":"public/2015/04/29/android/base/android发展史及系统架构/index.html","hash":"72ec2ef4315b0c51d19dbd5a3d8370163079e9b1","modified":1570024199716},{"_id":"public/2015/04/16/mysql/Win8(X64)下MySQL5.6版本安装及配置/index.html","hash":"784036682fa879669cb7fcd59695e4fef64fa63e","modified":1570024199716},{"_id":"public/index.html","hash":"6d638f3bac22d12a6510179224131419d3e93799","modified":1570024199716},{"_id":"public/page/2/index.html","hash":"372bdc807a78f5b30394ec80f22071064c61d158","modified":1570024199717},{"_id":"public/2019/02/26/flutter/布局/Row&Colum/index.html","hash":"4c38b988f544d12e440a27eaad81770ccfc1c165","modified":1570024199742},{"_id":"public/2018/05/23/uml/06 部署图(Deployment Diagram)/index.html","hash":"db95e6855ad12facb3de334601fd50d418ef928e","modified":1570024199742},{"_id":"public/archives/page/3/index.html","hash":"a92dd66c5213939b2f5a920ef4641a6a754de09b","modified":1570024199743},{"_id":"public/archives/page/4/index.html","hash":"fc655031c3a5f27ec2e0836702e48727982dd3cc","modified":1570024199743},{"_id":"public/archives/page/5/index.html","hash":"99d63d57aaa8e53b8070b2d0069683cde8fc4819","modified":1570024199743},{"_id":"public/archives/page/6/index.html","hash":"2def3779655c6e01f4827c6ba3797b293abd85fa","modified":1570024199743},{"_id":"public/archives/2018/index.html","hash":"8367cd72914d5f277924113428a24888fa2c4ac5","modified":1570024199743},{"_id":"public/archives/2018/05/index.html","hash":"8367cd72914d5f277924113428a24888fa2c4ac5","modified":1570024199743},{"_id":"public/archives/2019/page/2/index.html","hash":"ba9b381f56a7ea99fdadf7e39dacd7fee0070d26","modified":1570024199743},{"_id":"public/archives/2019/page/3/index.html","hash":"719ee61cbea6f7112acccf4ab368f8e17bea5e5f","modified":1570024199743},{"_id":"public/archives/2019/02/index.html","hash":"b4a067366ab1eb47d2cd6c8d3f1519ff4691ee42","modified":1570024199743},{"_id":"public/archives/2019/page/4/index.html","hash":"919b952ef3e99d026ecaf81940ba4904de05e5c9","modified":1570024199743},{"_id":"public/archives/2019/02/page/2/index.html","hash":"90b64ea9ab800f22f03d57a91a2f7e0c982201d9","modified":1570024199744},{"_id":"public/archives/2019/02/page/3/index.html","hash":"9b235a896440df4b5ebe23afb6e0090ab9b8375b","modified":1570024199744},{"_id":"public/archives/2019/02/page/4/index.html","hash":"242af51aa89ba77ca2b16e1866e8c81dd92ea99c","modified":1570024199744},{"_id":"public/categories/Dart/index.html","hash":"24e0429e9fca3437ce08abe4a4562aec1c8d476f","modified":1570024199744},{"_id":"public/categories/Flutter/page/2/index.html","hash":"28a6bc0709e172c139f8222614b725195284e2c6","modified":1570024199744},{"_id":"public/categories/Flutter/index.html","hash":"fb5903817711c45c5a7fcd52084cea4eac3205b0","modified":1570024199744},{"_id":"public/categories/Flutter/page/3/index.html","hash":"43fd47b63c9402217298a95de88e536ad14fa669","modified":1570024199744},{"_id":"public/categories/UML/index.html","hash":"f8812d25571e356b4f84017c3a36387a8da03d4f","modified":1570024199744},{"_id":"public/categories/Flutter/Widget/index.html","hash":"cc2cb2bec39c64b943fa345be5932073ebb55dc5","modified":1570024199744},{"_id":"public/categories/Flutter/Widget/page/2/index.html","hash":"49e8d65ab19995b59a55c0906f8840c23094d637","modified":1570024199745},{"_id":"public/categories/Flutter/容器/index.html","hash":"406935d8a3ce4c9d602b5b58fd3910241cdb2312","modified":1570024199745},{"_id":"public/categories/Flutter/布局/index.html","hash":"7d2137a31fb9d899538769c279ed17b432e01d29","modified":1570024199745},{"_id":"public/page/3/index.html","hash":"559a3a4e7b955ed9b4e70f8ed6602932d43aa3fe","modified":1570024199745},{"_id":"public/page/4/index.html","hash":"c70175de100022f3b71b47e8c39b5382ba260e99","modified":1570024199746},{"_id":"public/page/6/index.html","hash":"cc58a7d06066bfc43ede3b20b8011052ef6b95e8","modified":1570024199746},{"_id":"public/tags/flutter/index.html","hash":"41d096701276899024619ff0ecc4f79f1ecbb609","modified":1570024199746},{"_id":"public/tags/dart/index.html","hash":"8ec29572cfeae0deec22359d5d60aafaeec5cbd0","modified":1570024199746},{"_id":"public/tags/flutter/page/2/index.html","hash":"f78cba8c4645eca835ec74fd35c80f92b12fdb31","modified":1570024199746},{"_id":"public/tags/flutter/page/3/index.html","hash":"646dd44e843d489353787420d532f76c94f02525","modified":1570024199746},{"_id":"public/tags/uml/index.html","hash":"7cad976fdf4e4e9721750da0c0004890e40fead6","modified":1570024199746},{"_id":"public/tags/用例图/index.html","hash":"4f65b204f0212db81a604c41c32a46961e5169b4","modified":1570024199746},{"_id":"public/tags/状态图/index.html","hash":"6c9a62f3b55ac65d963941961ce4a05ec2d0d6b1","modified":1570024199747},{"_id":"public/tags/部署图/index.html","hash":"a77cba34af5bfa6f41bd4268ac250b38b762c8ff","modified":1570024199747},{"_id":"public/tags/活动图/index.html","hash":"daaae8c8fa432b881bd2d7d11c9521e5277b8cb5","modified":1570024199747},{"_id":"public/tags/时序图/index.html","hash":"3f2409061f7709f262a6de3d9295971a577498ca","modified":1570024199747},{"_id":"public/tags/静态图/index.html","hash":"2d3a52ad10eda3d68e8efd77ef89304b7e1660c6","modified":1570024199747},{"_id":"public/2019/02/26/flutter/widget/Text/index.html","hash":"4d437f6f0d656e88084bbe2ec3d1fcbd480b2cd6","modified":1570024199748},{"_id":"public/2019/02/26/flutter/widget/FlutterWidget/index.html","hash":"e58577b68a15a947ef8e11d313eb51a3c736b499","modified":1570024199748},{"_id":"public/2019/02/26/flutter/widget/Image&Icon/index.html","hash":"29dc079b8e53572688525d3e71c5dcc365ea9d5e","modified":1570024199748},{"_id":"public/2019/02/25/flutter/widget/19_Material_PopupMenu/index.html","hash":"873a91a0969c1a1b477ce571ea85793cef8c7a1a","modified":1570024199748},{"_id":"public/2019/02/25/flutter/widget/18_Material_BottomNavigationBar/index.html","hash":"648f5127cee573446f9b6a84e95eade826ecba1c","modified":1570024199748},{"_id":"public/2019/02/25/flutter/widget/17_Material_AppBar/index.html","hash":"c41adbf6089e79fba38402743d2518503af28d1f","modified":1570024199749},{"_id":"public/2019/02/22/flutter/widget/16_Material_Scaffold/index.html","hash":"c3279e37bd9b3c3857e56763f1d58eacf7a0c6b6","modified":1570024199749},{"_id":"public/2019/02/22/flutter/widget/image/index.html","hash":"3f939a8e1951f8e0c34a7c1fc4454504391a4b7c","modified":1570024199749},{"_id":"public/2019/02/19/flutter/12_第一个Flutter应用/index.html","hash":"4f477ff00a1a4043ee8d35ac35c7ea42e258d596","modified":1570024199749},{"_id":"public/2019/02/19/flutter/01_初识与安装/index.html","hash":"6091facc14cad3ddd367cedc66d57dbfd1b5084c","modified":1570024199749},{"_id":"public/2019/02/18/dart/11_生成器等/index.html","hash":"b429b0b47ecfcc4e8753ab8202f5fdd521b06397","modified":1570024199749},{"_id":"public/2019/02/18/dart/10_异步支持/index.html","hash":"6dc21ca083d0e58fd0a5df129fc50d512f26511e","modified":1570024199750},{"_id":"public/2019/02/18/dart/09_库和可见性/index.html","hash":"26106849d43f6e30048926330f570a44139a6691","modified":1570024199750},{"_id":"public/2019/02/18/dart/08_泛型/index.html","hash":"2d8bb76eb6cfecc29b4be4a09ea2335caeb0c3ec","modified":1570024199750},{"_id":"public/2019/02/18/dart/07_Dart类/index.html","hash":"edb2dc320b42c94567b1e3f402d8f37d40e75ef4","modified":1570024199750},{"_id":"public/2019/02/17/dart/06_Dart异常处理/index.html","hash":"2d1c0e99926fbd5c401ba4b45eb7a872cda6a88c","modified":1570024199750},{"_id":"public/2019/02/17/dart/05_Dart流程控制/index.html","hash":"e846f525b80e7d882e251c314542f148096d9361","modified":1570024199751},{"_id":"public/2018/05/24/uml/07 时序图(Sequence Diagram)/index.html","hash":"b8013711c1a42be8ee9d5b3b96a843d9c0a1e482","modified":1570024199751},{"_id":"public/2018/05/22/uml/05 状态图(Statechart Diagram)/index.html","hash":"b12ad57ac89c878b64f1fdee9e04681452a824bb","modified":1570024199751},{"_id":"public/2018/05/21/uml/04 活动图(Activity Diagram)/index.html","hash":"887063dfd9aaf51f4bbeed631b5ebdf14a62acea","modified":1570024199751},{"_id":"public/2019/02/17/dart/04_Dart运算符/index.html","hash":"890128448b88f51147b36670411c42b09a620260","modified":1570024199751},{"_id":"public/2019/02/15/dart/02_Dart初识/index.html","hash":"6cd0011d5493a35c2df26a0956c496c82afb1b67","modified":1570024199752},{"_id":"public/2019/02/16/dart/03_Dart函数/index.html","hash":"f24f54066c3d5cb279397d6946d26bdbbe31db05","modified":1570024199762},{"_id":"public/2018/05/20/uml/03 静态图/index.html","hash":"45747cbde01dca21c56e070b87e5aa733eefe635","modified":1570024199762},{"_id":"public/2018/05/19/uml/02 用例图（Use Case）/index.html","hash":"01318a179364bdc2f94c09e22eaa41c39aa1f36b","modified":1570024199763},{"_id":"public/2018/05/18/uml/01 UML介绍/index.html","hash":"84d09ec0c92abb6281bd3ed673b1ce714b2a9b85","modified":1570024199763},{"_id":"public/page/5/index.html","hash":"e7734925e5b8e0dbbffa0ef2a4b8c784a9ca09b0","modified":1570024199763},{"_id":"public/favicon.ico","hash":"92d61ec769765f2fb7bc1882c2c3b18931ac40f2","modified":1570024199763},{"_id":"public/apple-touch-icon.png","hash":"fbd2744aedd23c6addea809a9e5e7cbb3306e7b9","modified":1570024199763},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1570024199763},{"_id":"public/img/alipay.svg","hash":"292ea040e865c1d0be259703ff850570b3bdfc97","modified":1570024199763},{"_id":"public/img/wechat.svg","hash":"30418295bed44bcc4b29076eb7deed49cf4d6c1c","modified":1570024199764},{"_id":"public/img/bitcoin.svg","hash":"eeb2ee8cf44ba5c298baeed84bb90866f4814955","modified":1570024199764},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1570024199764},{"_id":"public/img/paypal.svg","hash":"e916dea1c1bba1bc935510310f65b2c9328a401a","modified":1570024199764},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1570024199764},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1570024199776},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1570024199779},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1570024199793},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1570024199794},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1570024199794},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1570024199794},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1570024199794},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1570024199795},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1570024199795},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1570024199795},{"_id":"public/donate/index.html","hash":"7374db74b42ed03f138d25f10f8d47e5aab4efec","modified":1570024199795},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1570024199887},{"_id":"public/css/style.css","hash":"9cffbc12bd2b40733e64d8de9c9e9403cd8fd581","modified":1570024200075},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1570024200294}],"Category":[{"name":"C语言","_id":"ck19bvapi000300wkejexrt20"},{"name":"Dart","_id":"ck19bvaqm000l00wkbn0g6g2l"},{"name":"Flutter","_id":"ck19bvark001c00wk6i6d5m5j"},{"name":"IDE","_id":"ck19bvayu001l00wk9quo0cyq"},{"name":"hexo","_id":"ck19bvaz5001q00wky1hu5fok"},{"name":"UML","_id":"ck19bvazp002200wkuac4zbih"},{"name":"MySql","_id":"ck19bvb17003000wknru5ork7"},{"name":"Android基础","_id":"ck19bvb37004700wk6obmjdmb"},{"name":"Widget","parent":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb3s004j00wkxpjfygdz"},{"name":"容器","parent":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb5g005h00wkg6llnmq6"},{"name":"布局","parent":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb6g006f00wk05b76wqe"}],"Data":[],"Page":[{"title":"一个理想主义者","date":"2019-09-30T07:22:57.000Z","_content":"\n随便写写，后面再补充吧","source":"about/index.md","raw":"---\ntitle: 一个理想主义者\ndate: 2019-09-30 15:22:57\n---\n\n随便写写，后面再补充吧","updated":"2019-10-02T13:49:25.376Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck19bvaoe000000wkohuts83f","content":"<p>随便写写，后面再补充吧</p>\n","site":{"data":{}},"excerpt":"","more":"<p>随便写写，后面再补充吧</p>\n"}],"Post":[{"title":"C语言include和变量","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-19T15:24:00.000Z","_content":"## 常见函数\n\n- main函数\nmain函数时整个C程序的入口，整个C程序中也有且仅有一个main函数\n- printf函数\n在屏幕上输出内容，使用前必须加 `#incluce <stdio.h>`\n\n## `#include`\n- `#include`指令介绍\n    - `#include` 是C语言的`预处理指令`之一。    \n    在编译之前做的处理，预处理指令一般以`#`开头    \n    - `#include`指令后面会跟着一个文件名，此时，会将该文件内容包含到当前文件中。\n    - 如果本包含的文件拓展名为 `.h` 则称为头文件(Header File)。\n    - `#include`指令不仅限于 `.h` 头文件，可以包含任何白安逸器能识别的C/C++代码文件 \n- `#include <>`和`#include \"\"`区别（主要是检索顺序不同）\n    - `#include <>` 检索顺序：\n    父文件所在文件夹 → 父文件的父文件所在文件夹 → 编译器设置的include路径 → 系统INCLUDE环境变量\n    - `#include \" \"` 检索顺序：\n    编译器设置的include路径 → 系统INCLUDE环境变量\n- `stdio.h`\n    - 是C语言函数库中的一个头文件\n\n## 多源文件开发\n\n1. 在编写第一个C程序的时候已经提到：我们编写的所有C语言代码都保存在拓展名为.c的源文件中，编写完毕后就进行编译、链接，最后运行程序。\n2. 在实际开发过程中，项目做大了，源代码肯定非常多，很容易就上万行 代码了，甚至上十万、百万都有可能。这个时候如果把所有的代码都写到一个.c源文件中，那么这个文件将会非常庞大，也非常恶心，你可以想象一下，一个文件 有十几万行文字，不要说调试程序了，连阅读代码都非常困难。\n3. 公司里面都是以团队开发为主，如果多个开发人员同时修改一个源文件，那就会带来很多麻烦的问题，比如张三修改的代码很有可能会抹掉李四之前添加的代码。\n4. 因此，为了模块化开发，一般会将不同的功能写到不同的.c源文件中，这样的话，每个开发人员都负责修改不同的源文件，达到分工合作的目的，能够大大提高开发效率。也就是说，一个正常的C语言项目是由多个.c源文件构成。\n\n----\n\n## 常用UNIX指令\n| 指令 | 作用|\n| :--- | :----|\n| ls | 列出当前目录下的所有内容（文件\\文件夹）|\n| pwd | 显示出当前目录的名称|\n| cd | 改变当前操作的目录|\n| who | 显示当前用户名|\n| clear | 清除所有内容|\n| mkdir | 创建一个新目录|\n\n## 编译C程序\n- 编译one.c，生成one.o文件\n```cc -c one.c```\n\n- 链接one.o，生成a.out文件\n```cc one.o```\n\n- 运行a.out\n```./a.out```\n\n## 进制\n    进制：一种计数方式\n- 十进制\n由0、1、2….9十个基本数字组成；运算规则是“逢十进一”\n- 二进制\n特点：由0、1两个基本数字组成；运算规则是“逢二进一”\n书写形式：需要以0b或者0B开头，比如0b101\n- 八进制\n特点：由0~7八个基本数字组成；运算规则是“逢八进一”\n书写形式：在前面加个0，比如045\n- 十六进制\n特点：由0~9和A~F组成，A~F分别表示10~15；运算规则是“逢十六进一”\n书写形式：在前面加个0x或者0X，比如0x45\n\n## 位运算符\n运算符 | 作用  | 说明 |举例\n -----|-------|----|---\n&| 按位与|只有对应的两个二进位均为1时，结果位才为1，否则为0|1001 & 0101 = 0001\n&#x7c;| 按位或|只要对应的二个二进位有一个为1时，结果位就为1，否则为0|1001 &#x7c; 0101 = 1101\n^ |按位异或|当对应的二进位相异（不相同）时，结果为1，否则为0|1001 ^ 101 = 1100\n~ |取反|各二进位进行取反（0变1，1变0）|~1001 = 0110\n<< |左移|各二进位全部左移n位，高位丢弃，低位补0|乘以2的n次方\n&#x3e;&#x3e; |右移|各二进位全部右移n位，保持符号位不变|是除以2的n次方    \n```\n//使用位运算实现交换两个数的值\na = a^b;\nb = b^a;\na = a^b;\n```\n## 变量的内存分析\n### 字节和地址\n- 内存以“字节为单位”，不同类型的变量在不同编译器环境下所占的空间也不同\n\n变量类型 | 16位编译器  | 32位编译器  | 64位编译器\n--|--|--|--\nchar |1|1|1\nint |2|4|4\nfloat|4|4|4\ndouble|8|8|8\n- 变量存储单元的第一个字节的地址就是该变量的地址\n- 负数的二进制形式，就是对它的正数的二进制取反后加1\n\n## 类型说明符\n类型|说明|64位编译器\n--|--|--\nshort|短型|2字节（16位）\nlong|长型|8字节（64位）\nsigned|有符号型\nunsigned|无符号型\n>一般就是用来修饰int类型的，所以在使用时省略int。\nshort int等价于short，long int等价于long，long long int等价于long long\n\n- signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。\n- signed：表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是<img src=\"http://www.forkosh.com/mathtex.cgi? -2^{31}\"> ~ <img src=\"http://www.forkosh.com/mathtex.cgi? 2^{31}-1\">\n- unsigned：表示无符号，也就是说最高位并不当做符号位，所 以不包括负数。在64bit编译器环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0~<img src=\"http://www.forkosh.com/mathtex.cgi? 2{32}-1\">\n\n## char类型（字符型）\n- 一个字符型变量占用1个字节，共8位。范围是<img src=\"http://www.forkosh.com/mathtex.cgi? -2^7\">~<img src=\"http://www.forkosh.com/mathtex.cgi? 2^7-1\">。\n- 不能用来存储汉字\n- 前面加\"\\\"形成的字符，称为“转义字符”  \n\n转义字符|意义|ASCII码值\n--|--|--\n\\n|回车|10\n\\t|退格|9\n\\\\|\\|92\n\\'|'|39\n\\\"|\"|34\n\\0|空字符|0\n\n\n\n","source":"_posts/c/C语言include和变量.md","raw":"---\ntitle: C语言include和变量\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-19 23:24:00   \n---\n## 常见函数\n\n- main函数\nmain函数时整个C程序的入口，整个C程序中也有且仅有一个main函数\n- printf函数\n在屏幕上输出内容，使用前必须加 `#incluce <stdio.h>`\n\n## `#include`\n- `#include`指令介绍\n    - `#include` 是C语言的`预处理指令`之一。    \n    在编译之前做的处理，预处理指令一般以`#`开头    \n    - `#include`指令后面会跟着一个文件名，此时，会将该文件内容包含到当前文件中。\n    - 如果本包含的文件拓展名为 `.h` 则称为头文件(Header File)。\n    - `#include`指令不仅限于 `.h` 头文件，可以包含任何白安逸器能识别的C/C++代码文件 \n- `#include <>`和`#include \"\"`区别（主要是检索顺序不同）\n    - `#include <>` 检索顺序：\n    父文件所在文件夹 → 父文件的父文件所在文件夹 → 编译器设置的include路径 → 系统INCLUDE环境变量\n    - `#include \" \"` 检索顺序：\n    编译器设置的include路径 → 系统INCLUDE环境变量\n- `stdio.h`\n    - 是C语言函数库中的一个头文件\n\n## 多源文件开发\n\n1. 在编写第一个C程序的时候已经提到：我们编写的所有C语言代码都保存在拓展名为.c的源文件中，编写完毕后就进行编译、链接，最后运行程序。\n2. 在实际开发过程中，项目做大了，源代码肯定非常多，很容易就上万行 代码了，甚至上十万、百万都有可能。这个时候如果把所有的代码都写到一个.c源文件中，那么这个文件将会非常庞大，也非常恶心，你可以想象一下，一个文件 有十几万行文字，不要说调试程序了，连阅读代码都非常困难。\n3. 公司里面都是以团队开发为主，如果多个开发人员同时修改一个源文件，那就会带来很多麻烦的问题，比如张三修改的代码很有可能会抹掉李四之前添加的代码。\n4. 因此，为了模块化开发，一般会将不同的功能写到不同的.c源文件中，这样的话，每个开发人员都负责修改不同的源文件，达到分工合作的目的，能够大大提高开发效率。也就是说，一个正常的C语言项目是由多个.c源文件构成。\n\n----\n\n## 常用UNIX指令\n| 指令 | 作用|\n| :--- | :----|\n| ls | 列出当前目录下的所有内容（文件\\文件夹）|\n| pwd | 显示出当前目录的名称|\n| cd | 改变当前操作的目录|\n| who | 显示当前用户名|\n| clear | 清除所有内容|\n| mkdir | 创建一个新目录|\n\n## 编译C程序\n- 编译one.c，生成one.o文件\n```cc -c one.c```\n\n- 链接one.o，生成a.out文件\n```cc one.o```\n\n- 运行a.out\n```./a.out```\n\n## 进制\n    进制：一种计数方式\n- 十进制\n由0、1、2….9十个基本数字组成；运算规则是“逢十进一”\n- 二进制\n特点：由0、1两个基本数字组成；运算规则是“逢二进一”\n书写形式：需要以0b或者0B开头，比如0b101\n- 八进制\n特点：由0~7八个基本数字组成；运算规则是“逢八进一”\n书写形式：在前面加个0，比如045\n- 十六进制\n特点：由0~9和A~F组成，A~F分别表示10~15；运算规则是“逢十六进一”\n书写形式：在前面加个0x或者0X，比如0x45\n\n## 位运算符\n运算符 | 作用  | 说明 |举例\n -----|-------|----|---\n&| 按位与|只有对应的两个二进位均为1时，结果位才为1，否则为0|1001 & 0101 = 0001\n&#x7c;| 按位或|只要对应的二个二进位有一个为1时，结果位就为1，否则为0|1001 &#x7c; 0101 = 1101\n^ |按位异或|当对应的二进位相异（不相同）时，结果为1，否则为0|1001 ^ 101 = 1100\n~ |取反|各二进位进行取反（0变1，1变0）|~1001 = 0110\n<< |左移|各二进位全部左移n位，高位丢弃，低位补0|乘以2的n次方\n&#x3e;&#x3e; |右移|各二进位全部右移n位，保持符号位不变|是除以2的n次方    \n```\n//使用位运算实现交换两个数的值\na = a^b;\nb = b^a;\na = a^b;\n```\n## 变量的内存分析\n### 字节和地址\n- 内存以“字节为单位”，不同类型的变量在不同编译器环境下所占的空间也不同\n\n变量类型 | 16位编译器  | 32位编译器  | 64位编译器\n--|--|--|--\nchar |1|1|1\nint |2|4|4\nfloat|4|4|4\ndouble|8|8|8\n- 变量存储单元的第一个字节的地址就是该变量的地址\n- 负数的二进制形式，就是对它的正数的二进制取反后加1\n\n## 类型说明符\n类型|说明|64位编译器\n--|--|--\nshort|短型|2字节（16位）\nlong|长型|8字节（64位）\nsigned|有符号型\nunsigned|无符号型\n>一般就是用来修饰int类型的，所以在使用时省略int。\nshort int等价于short，long int等价于long，long long int等价于long long\n\n- signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。\n- signed：表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是<img src=\"http://www.forkosh.com/mathtex.cgi? -2^{31}\"> ~ <img src=\"http://www.forkosh.com/mathtex.cgi? 2^{31}-1\">\n- unsigned：表示无符号，也就是说最高位并不当做符号位，所 以不包括负数。在64bit编译器环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0~<img src=\"http://www.forkosh.com/mathtex.cgi? 2{32}-1\">\n\n## char类型（字符型）\n- 一个字符型变量占用1个字节，共8位。范围是<img src=\"http://www.forkosh.com/mathtex.cgi? -2^7\">~<img src=\"http://www.forkosh.com/mathtex.cgi? 2^7-1\">。\n- 不能用来存储汉字\n- 前面加\"\\\"形成的字符，称为“转义字符”  \n\n转义字符|意义|ASCII码值\n--|--|--\n\\n|回车|10\n\\t|退格|9\n\\\\|\\|92\n\\'|'|39\n\\\"|\"|34\n\\0|空字符|0\n\n\n\n","slug":"c/C语言include和变量","published":1,"updated":"2019-10-02T08:55:57.706Z","layout":"post","photos":[],"link":"","_id":"ck19bvap3000100wkep5jefqx","content":"<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><ul>\n<li>main函数<br>main函数时整个C程序的入口，整个C程序中也有且仅有一个main函数</li>\n<li>printf函数<br>在屏幕上输出内容，使用前必须加 <code>#incluce &lt;stdio.h&gt;</code></li>\n</ul>\n<h2 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"#include\"></a><code>#include</code></h2><ul>\n<li><code>#include</code>指令介绍<ul>\n<li><code>#include</code> 是C语言的<code>预处理指令</code>之一。<br>在编译之前做的处理，预处理指令一般以<code>#</code>开头    </li>\n<li><code>#include</code>指令后面会跟着一个文件名，此时，会将该文件内容包含到当前文件中。</li>\n<li>如果本包含的文件拓展名为 <code>.h</code> 则称为头文件(Header File)。</li>\n<li><code>#include</code>指令不仅限于 <code>.h</code> 头文件，可以包含任何白安逸器能识别的C/C++代码文件 </li>\n</ul>\n</li>\n<li><code>#include &lt;&gt;</code>和<code>#include &quot;&quot;</code>区别（主要是检索顺序不同）<ul>\n<li><code>#include &lt;&gt;</code> 检索顺序：<br>父文件所在文件夹 → 父文件的父文件所在文件夹 → 编译器设置的include路径 → 系统INCLUDE环境变量</li>\n<li><code>#include &quot; &quot;</code> 检索顺序：<br>编译器设置的include路径 → 系统INCLUDE环境变量</li>\n</ul>\n</li>\n<li><code>stdio.h</code><ul>\n<li>是C语言函数库中的一个头文件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多源文件开发\"><a href=\"#多源文件开发\" class=\"headerlink\" title=\"多源文件开发\"></a>多源文件开发</h2><ol>\n<li>在编写第一个C程序的时候已经提到：我们编写的所有C语言代码都保存在拓展名为.c的源文件中，编写完毕后就进行编译、链接，最后运行程序。</li>\n<li>在实际开发过程中，项目做大了，源代码肯定非常多，很容易就上万行 代码了，甚至上十万、百万都有可能。这个时候如果把所有的代码都写到一个.c源文件中，那么这个文件将会非常庞大，也非常恶心，你可以想象一下，一个文件 有十几万行文字，不要说调试程序了，连阅读代码都非常困难。</li>\n<li>公司里面都是以团队开发为主，如果多个开发人员同时修改一个源文件，那就会带来很多麻烦的问题，比如张三修改的代码很有可能会抹掉李四之前添加的代码。</li>\n<li>因此，为了模块化开发，一般会将不同的功能写到不同的.c源文件中，这样的话，每个开发人员都负责修改不同的源文件，达到分工合作的目的，能够大大提高开发效率。也就是说，一个正常的C语言项目是由多个.c源文件构成。</li>\n</ol>\n<hr>\n<h2 id=\"常用UNIX指令\"><a href=\"#常用UNIX指令\" class=\"headerlink\" title=\"常用UNIX指令\"></a>常用UNIX指令</h2><table>\n<thead>\n<tr>\n<th align=\"left\">指令</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ls</td>\n<td align=\"left\">列出当前目录下的所有内容（文件\\文件夹）</td>\n</tr>\n<tr>\n<td align=\"left\">pwd</td>\n<td align=\"left\">显示出当前目录的名称</td>\n</tr>\n<tr>\n<td align=\"left\">cd</td>\n<td align=\"left\">改变当前操作的目录</td>\n</tr>\n<tr>\n<td align=\"left\">who</td>\n<td align=\"left\">显示当前用户名</td>\n</tr>\n<tr>\n<td align=\"left\">clear</td>\n<td align=\"left\">清除所有内容</td>\n</tr>\n<tr>\n<td align=\"left\">mkdir</td>\n<td align=\"left\">创建一个新目录</td>\n</tr>\n</tbody></table>\n<h2 id=\"编译C程序\"><a href=\"#编译C程序\" class=\"headerlink\" title=\"编译C程序\"></a>编译C程序</h2><ul>\n<li><p>编译one.c，生成one.o文件</p>\n<figure class=\"highlight cc\"><figcaption><span>-c one.c```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 链接one.o，生成a.out文件</span><br><span class=\"line\">```cc one.o</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行a.out</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 进制</span><br><span class=\"line\">    进制：一种计数方式</span><br><span class=\"line\">- 十进制</span><br><span class=\"line\">由0、1、2….9十个基本数字组成；运算规则是“逢十进一”</span><br><span class=\"line\">- 二进制</span><br><span class=\"line\">特点：由0、1两个基本数字组成；运算规则是“逢二进一”</span><br><span class=\"line\">书写形式：需要以0b或者0B开头，比如0b101</span><br><span class=\"line\">- 八进制</span><br><span class=\"line\">特点：由0~7八个基本数字组成；运算规则是“逢八进一”</span><br><span class=\"line\">书写形式：在前面加个0，比如045</span><br><span class=\"line\">- 十六进制</span><br><span class=\"line\">特点：由0~9和A~F组成，A~F分别表示10~15；运算规则是“逢十六进一”</span><br><span class=\"line\">书写形式：在前面加个0x或者0X，比如0x45</span><br><span class=\"line\"></span><br><span class=\"line\">## 位运算符</span><br><span class=\"line\">运算符 | 作用  | 说明 |举例</span><br><span class=\"line\"> -----|-------|----|---</span><br><span class=\"line\">&amp;| 按位与|只有对应的两个二进位均为1时，结果位才为1，否则为0|1001 &amp; 0101 = 0001</span><br><span class=\"line\">&amp;#x7c;| 按位或|只要对应的二个二进位有一个为1时，结果位就为1，否则为0|1001 &amp;#x7c; 0101 = 1101</span><br><span class=\"line\">^ |按位异或|当对应的二进位相异（不相同）时，结果为1，否则为0|1001 ^ 101 = 1100</span><br><span class=\"line\">~ |取反|各二进位进行取反（0变1，1变0）|~1001 = 0110</span><br><span class=\"line\">&lt;&lt; |左移|各二进位全部左移n位，高位丢弃，低位补0|乘以2的n次方</span><br><span class=\"line\">&amp;#x3e;&amp;#x3e; |右移|各二进位全部右移n位，保持符号位不变|是除以2的n次方</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>//使用位运算实现交换两个数的值<br>a = a^b;<br>b = b^a;<br>a = a^b;</p>\n<pre><code>## 变量的内存分析\n### 字节和地址\n- 内存以“字节为单位”，不同类型的变量在不同编译器环境下所占的空间也不同\n\n变量类型 | 16位编译器  | 32位编译器  | 64位编译器\n--|--|--|--\nchar |1|1|1\nint |2|4|4\nfloat|4|4|4\ndouble|8|8|8\n- 变量存储单元的第一个字节的地址就是该变量的地址\n- 负数的二进制形式，就是对它的正数的二进制取反后加1\n\n## 类型说明符\n类型|说明|64位编译器\n--|--|--\nshort|短型|2字节（16位）\nlong|长型|8字节（64位）\nsigned|有符号型\nunsigned|无符号型\n&gt;一般就是用来修饰int类型的，所以在使用时省略int。\nshort int等价于short，long int等价于long，long long int等价于long long\n\n- signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。\n- signed：表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? -2^{31}&quot;&gt; ~ &lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2^{31}-1&quot;&gt;\n- unsigned：表示无符号，也就是说最高位并不当做符号位，所 以不包括负数。在64bit编译器环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0~&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2{32}-1&quot;&gt;\n\n## char类型（字符型）\n- 一个字符型变量占用1个字节，共8位。范围是&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? -2^7&quot;&gt;~&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2^7-1&quot;&gt;。\n- 不能用来存储汉字\n- 前面加&quot;\\&quot;形成的字符，称为“转义字符”  \n\n转义字符|意义|ASCII码值\n--|--|--\n\\n|回车|10\n\\t|退格|9\n\\\\|\\|92\n\\&apos;|&apos;|39\n\\&quot;|&quot;|34\n\\0|空字符|0\n\n\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常见函数\"><a href=\"#常见函数\" class=\"headerlink\" title=\"常见函数\"></a>常见函数</h2><ul>\n<li>main函数<br>main函数时整个C程序的入口，整个C程序中也有且仅有一个main函数</li>\n<li>printf函数<br>在屏幕上输出内容，使用前必须加 <code>#incluce &lt;stdio.h&gt;</code></li>\n</ul>\n<h2 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"#include\"></a><code>#include</code></h2><ul>\n<li><code>#include</code>指令介绍<ul>\n<li><code>#include</code> 是C语言的<code>预处理指令</code>之一。<br>在编译之前做的处理，预处理指令一般以<code>#</code>开头    </li>\n<li><code>#include</code>指令后面会跟着一个文件名，此时，会将该文件内容包含到当前文件中。</li>\n<li>如果本包含的文件拓展名为 <code>.h</code> 则称为头文件(Header File)。</li>\n<li><code>#include</code>指令不仅限于 <code>.h</code> 头文件，可以包含任何白安逸器能识别的C/C++代码文件 </li>\n</ul>\n</li>\n<li><code>#include &lt;&gt;</code>和<code>#include &quot;&quot;</code>区别（主要是检索顺序不同）<ul>\n<li><code>#include &lt;&gt;</code> 检索顺序：<br>父文件所在文件夹 → 父文件的父文件所在文件夹 → 编译器设置的include路径 → 系统INCLUDE环境变量</li>\n<li><code>#include &quot; &quot;</code> 检索顺序：<br>编译器设置的include路径 → 系统INCLUDE环境变量</li>\n</ul>\n</li>\n<li><code>stdio.h</code><ul>\n<li>是C语言函数库中的一个头文件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多源文件开发\"><a href=\"#多源文件开发\" class=\"headerlink\" title=\"多源文件开发\"></a>多源文件开发</h2><ol>\n<li>在编写第一个C程序的时候已经提到：我们编写的所有C语言代码都保存在拓展名为.c的源文件中，编写完毕后就进行编译、链接，最后运行程序。</li>\n<li>在实际开发过程中，项目做大了，源代码肯定非常多，很容易就上万行 代码了，甚至上十万、百万都有可能。这个时候如果把所有的代码都写到一个.c源文件中，那么这个文件将会非常庞大，也非常恶心，你可以想象一下，一个文件 有十几万行文字，不要说调试程序了，连阅读代码都非常困难。</li>\n<li>公司里面都是以团队开发为主，如果多个开发人员同时修改一个源文件，那就会带来很多麻烦的问题，比如张三修改的代码很有可能会抹掉李四之前添加的代码。</li>\n<li>因此，为了模块化开发，一般会将不同的功能写到不同的.c源文件中，这样的话，每个开发人员都负责修改不同的源文件，达到分工合作的目的，能够大大提高开发效率。也就是说，一个正常的C语言项目是由多个.c源文件构成。</li>\n</ol>\n<hr>\n<h2 id=\"常用UNIX指令\"><a href=\"#常用UNIX指令\" class=\"headerlink\" title=\"常用UNIX指令\"></a>常用UNIX指令</h2><table>\n<thead>\n<tr>\n<th align=\"left\">指令</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ls</td>\n<td align=\"left\">列出当前目录下的所有内容（文件\\文件夹）</td>\n</tr>\n<tr>\n<td align=\"left\">pwd</td>\n<td align=\"left\">显示出当前目录的名称</td>\n</tr>\n<tr>\n<td align=\"left\">cd</td>\n<td align=\"left\">改变当前操作的目录</td>\n</tr>\n<tr>\n<td align=\"left\">who</td>\n<td align=\"left\">显示当前用户名</td>\n</tr>\n<tr>\n<td align=\"left\">clear</td>\n<td align=\"left\">清除所有内容</td>\n</tr>\n<tr>\n<td align=\"left\">mkdir</td>\n<td align=\"left\">创建一个新目录</td>\n</tr>\n</tbody></table>\n<h2 id=\"编译C程序\"><a href=\"#编译C程序\" class=\"headerlink\" title=\"编译C程序\"></a>编译C程序</h2><ul>\n<li><p>编译one.c，生成one.o文件</p>\n<figure class=\"highlight cc\"><figcaption><span>-c one.c```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- 链接one.o，生成a.out文件</span><br><span class=\"line\">```cc one.o</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行a.out</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 进制</span><br><span class=\"line\">    进制：一种计数方式</span><br><span class=\"line\">- 十进制</span><br><span class=\"line\">由0、1、2….9十个基本数字组成；运算规则是“逢十进一”</span><br><span class=\"line\">- 二进制</span><br><span class=\"line\">特点：由0、1两个基本数字组成；运算规则是“逢二进一”</span><br><span class=\"line\">书写形式：需要以0b或者0B开头，比如0b101</span><br><span class=\"line\">- 八进制</span><br><span class=\"line\">特点：由0~7八个基本数字组成；运算规则是“逢八进一”</span><br><span class=\"line\">书写形式：在前面加个0，比如045</span><br><span class=\"line\">- 十六进制</span><br><span class=\"line\">特点：由0~9和A~F组成，A~F分别表示10~15；运算规则是“逢十六进一”</span><br><span class=\"line\">书写形式：在前面加个0x或者0X，比如0x45</span><br><span class=\"line\"></span><br><span class=\"line\">## 位运算符</span><br><span class=\"line\">运算符 | 作用  | 说明 |举例</span><br><span class=\"line\"> -----|-------|----|---</span><br><span class=\"line\">&amp;| 按位与|只有对应的两个二进位均为1时，结果位才为1，否则为0|1001 &amp; 0101 = 0001</span><br><span class=\"line\">&amp;#x7c;| 按位或|只要对应的二个二进位有一个为1时，结果位就为1，否则为0|1001 &amp;#x7c; 0101 = 1101</span><br><span class=\"line\">^ |按位异或|当对应的二进位相异（不相同）时，结果为1，否则为0|1001 ^ 101 = 1100</span><br><span class=\"line\">~ |取反|各二进位进行取反（0变1，1变0）|~1001 = 0110</span><br><span class=\"line\">&lt;&lt; |左移|各二进位全部左移n位，高位丢弃，低位补0|乘以2的n次方</span><br><span class=\"line\">&amp;#x3e;&amp;#x3e; |右移|各二进位全部右移n位，保持符号位不变|是除以2的n次方</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>//使用位运算实现交换两个数的值<br>a = a^b;<br>b = b^a;<br>a = a^b;</p>\n<pre><code>## 变量的内存分析\n### 字节和地址\n- 内存以“字节为单位”，不同类型的变量在不同编译器环境下所占的空间也不同\n\n变量类型 | 16位编译器  | 32位编译器  | 64位编译器\n--|--|--|--\nchar |1|1|1\nint |2|4|4\nfloat|4|4|4\ndouble|8|8|8\n- 变量存储单元的第一个字节的地址就是该变量的地址\n- 负数的二进制形式，就是对它的正数的二进制取反后加1\n\n## 类型说明符\n类型|说明|64位编译器\n--|--|--\nshort|短型|2字节（16位）\nlong|长型|8字节（64位）\nsigned|有符号型\nunsigned|无符号型\n&gt;一般就是用来修饰int类型的，所以在使用时省略int。\nshort int等价于short，long int等价于long，long long int等价于long long\n\n- signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。\n- signed：表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? -2^{31}&quot;&gt; ~ &lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2^{31}-1&quot;&gt;\n- unsigned：表示无符号，也就是说最高位并不当做符号位，所 以不包括负数。在64bit编译器环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0~&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2{32}-1&quot;&gt;\n\n## char类型（字符型）\n- 一个字符型变量占用1个字节，共8位。范围是&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? -2^7&quot;&gt;~&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 2^7-1&quot;&gt;。\n- 不能用来存储汉字\n- 前面加&quot;\\&quot;形成的字符，称为“转义字符”  \n\n转义字符|意义|ASCII码值\n--|--|--\n\\n|回车|10\n\\t|退格|9\n\\\\|\\|92\n\\&apos;|&apos;|39\n\\&quot;|&quot;|34\n\\0|空字符|0\n\n\n</code></pre>"},{"title":"C语言初识","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-19T07:24:00.000Z","_content":"## 计算机发展史\n* 机器语言\n* 所有的代码里面只有0和1\n* 优点：直接对硬件产生作用，程序的执行效率非常高\n* 缺点：指令又多又难记、可读性差、无可移植性\n\n* 汇编语言\n* 符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令\n* 优点：直接对硬件产生作用，程序的执行效率非常高、可读性好\n* 缺点：符号非常多和难记、无可移植性\n\n* 高级语言\n* 非常接近自然语言的高级语言，语法和结构类似于普通英文\n* 优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性\n* 缺点：有些高级语言写出的程序执行效率并不高\n\n# C语言\n## 什么是C语言\n- C语言就是一门计算机编程语言，属于高级语言，可以用来编写程序、开发软件。\n- ios程序的额主要开发语言就是C语言和Object-c，而Object-c是在C语言的基础上衍生出来的。\n- C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，比如C++，C#，Object-c等\n\n## C语言简史\n- 1972年发明，首次使用是用于重写UINX操作系统\n- 它是一门面向过程的语言\n\n## C语言的特点\n- 丰富的运算符\n- 丰富的数据类型\n- 可以直接操作硬件\n- 高效的目标代码\n- 可移植性好\n\n## C语言的用途\n- 编写系统软件、图像处理、单片机程序、嵌入式系统开发等\n- 便携游戏外挂\n- 编写Android程序\n- 编写iOS程序\n\n## C语言的版本问题\n- 1983年美国国家标准（ANSI)成立一个委员，开始定制C语言标准的工作\n- 1989年C语言标准被批准，这个版本的C语言标准成为ANSI C\n- 1999年，国际标准化组织ISO对C语言标准进行修订，命名为C99\n- 2011年12与8日，ISO发布新的标准草案：C11\n\n## C语言的开发过程\n`编写程序`→`编译`→`链接`→`运行`\n\n## C语言程序\n- 构成\n>任何一个C语言的程序都是有一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以说，C语言程序是由函数构成的。\n- 程序入口\n```\n#incluce <stdio.h>\nint main()\n{\nprintf(\"程序入口\");\nreturn 0;\n}\n```\n- c程序源文件的拓展名为.c\n- 常见错误\n- 语法错误：编译器会直接报错\n- 逻辑错误：没有语法错误，只是运行结果不正确\n\n## 关键字\n>被C语言赋予了特殊含义的单词，这些单词是系统自己用的，叫做系统保留字，这些保留字称为关键字\n```c\n // 32个关键字\n auto double int struct break else long switch\n case enum register typedef char extern return\n union const float short unsigned continue for\n signed void default goto sizeof volatile do if\n while static \n```\n\n## 标示符\n标示符就是程序员在程序中起的一些名字，变量名、函数名等\n\n- 命名规范\n    1. 只能有26个英文字母的大小写、10个阿拉伯数字0~9、下划线_组成\n    2. 不能以数字开头\n    3. 不可以和关键字重名\n    4. 严格区分大小写 \n\n- 行业约束\n    1. 尽量取有意义的名称\n    2. 如果标示符包含多个单词，可以用驼峰标识（除第一个单词外，后面每个单词首字母大写 或者 用下划线连接）\n\n## 注释\n在所有计算机语言中都非常重要，用来解释一段程序或者一行代码是什么意思，可以是任何语言，不参与编译\n- 单行注释 `//`\n- 多行注释 `/*  要注释的内容 */` \n","source":"_posts/c/C语言初识.md","raw":"---\ntitle: C语言初识\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-19 15:24:00   \n---\n## 计算机发展史\n* 机器语言\n* 所有的代码里面只有0和1\n* 优点：直接对硬件产生作用，程序的执行效率非常高\n* 缺点：指令又多又难记、可读性差、无可移植性\n\n* 汇编语言\n* 符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令\n* 优点：直接对硬件产生作用，程序的执行效率非常高、可读性好\n* 缺点：符号非常多和难记、无可移植性\n\n* 高级语言\n* 非常接近自然语言的高级语言，语法和结构类似于普通英文\n* 优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性\n* 缺点：有些高级语言写出的程序执行效率并不高\n\n# C语言\n## 什么是C语言\n- C语言就是一门计算机编程语言，属于高级语言，可以用来编写程序、开发软件。\n- ios程序的额主要开发语言就是C语言和Object-c，而Object-c是在C语言的基础上衍生出来的。\n- C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，比如C++，C#，Object-c等\n\n## C语言简史\n- 1972年发明，首次使用是用于重写UINX操作系统\n- 它是一门面向过程的语言\n\n## C语言的特点\n- 丰富的运算符\n- 丰富的数据类型\n- 可以直接操作硬件\n- 高效的目标代码\n- 可移植性好\n\n## C语言的用途\n- 编写系统软件、图像处理、单片机程序、嵌入式系统开发等\n- 便携游戏外挂\n- 编写Android程序\n- 编写iOS程序\n\n## C语言的版本问题\n- 1983年美国国家标准（ANSI)成立一个委员，开始定制C语言标准的工作\n- 1989年C语言标准被批准，这个版本的C语言标准成为ANSI C\n- 1999年，国际标准化组织ISO对C语言标准进行修订，命名为C99\n- 2011年12与8日，ISO发布新的标准草案：C11\n\n## C语言的开发过程\n`编写程序`→`编译`→`链接`→`运行`\n\n## C语言程序\n- 构成\n>任何一个C语言的程序都是有一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以说，C语言程序是由函数构成的。\n- 程序入口\n```\n#incluce <stdio.h>\nint main()\n{\nprintf(\"程序入口\");\nreturn 0;\n}\n```\n- c程序源文件的拓展名为.c\n- 常见错误\n- 语法错误：编译器会直接报错\n- 逻辑错误：没有语法错误，只是运行结果不正确\n\n## 关键字\n>被C语言赋予了特殊含义的单词，这些单词是系统自己用的，叫做系统保留字，这些保留字称为关键字\n```c\n // 32个关键字\n auto double int struct break else long switch\n case enum register typedef char extern return\n union const float short unsigned continue for\n signed void default goto sizeof volatile do if\n while static \n```\n\n## 标示符\n标示符就是程序员在程序中起的一些名字，变量名、函数名等\n\n- 命名规范\n    1. 只能有26个英文字母的大小写、10个阿拉伯数字0~9、下划线_组成\n    2. 不能以数字开头\n    3. 不可以和关键字重名\n    4. 严格区分大小写 \n\n- 行业约束\n    1. 尽量取有意义的名称\n    2. 如果标示符包含多个单词，可以用驼峰标识（除第一个单词外，后面每个单词首字母大写 或者 用下划线连接）\n\n## 注释\n在所有计算机语言中都非常重要，用来解释一段程序或者一行代码是什么意思，可以是任何语言，不参与编译\n- 单行注释 `//`\n- 多行注释 `/*  要注释的内容 */` \n","slug":"c/C语言初识","published":1,"updated":"2019-10-02T08:51:16.236Z","layout":"post","photos":[],"link":"","_id":"ck19bvape000200wk2jhsrdwj","content":"<h2 id=\"计算机发展史\"><a href=\"#计算机发展史\" class=\"headerlink\" title=\"计算机发展史\"></a>计算机发展史</h2><ul>\n<li><p>机器语言</p>\n</li>\n<li><p>所有的代码里面只有0和1</p>\n</li>\n<li><p>优点：直接对硬件产生作用，程序的执行效率非常高</p>\n</li>\n<li><p>缺点：指令又多又难记、可读性差、无可移植性</p>\n</li>\n<li><p>汇编语言</p>\n</li>\n<li><p>符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令</p>\n</li>\n<li><p>优点：直接对硬件产生作用，程序的执行效率非常高、可读性好</p>\n</li>\n<li><p>缺点：符号非常多和难记、无可移植性</p>\n</li>\n<li><p>高级语言</p>\n</li>\n<li><p>非常接近自然语言的高级语言，语法和结构类似于普通英文</p>\n</li>\n<li><p>优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性</p>\n</li>\n<li><p>缺点：有些高级语言写出的程序执行效率并不高</p>\n</li>\n</ul>\n<h1 id=\"C语言\"><a href=\"#C语言\" class=\"headerlink\" title=\"C语言\"></a>C语言</h1><h2 id=\"什么是C语言\"><a href=\"#什么是C语言\" class=\"headerlink\" title=\"什么是C语言\"></a>什么是C语言</h2><ul>\n<li>C语言就是一门计算机编程语言，属于高级语言，可以用来编写程序、开发软件。</li>\n<li>ios程序的额主要开发语言就是C语言和Object-c，而Object-c是在C语言的基础上衍生出来的。</li>\n<li>C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，比如C++，C#，Object-c等</li>\n</ul>\n<h2 id=\"C语言简史\"><a href=\"#C语言简史\" class=\"headerlink\" title=\"C语言简史\"></a>C语言简史</h2><ul>\n<li>1972年发明，首次使用是用于重写UINX操作系统</li>\n<li>它是一门面向过程的语言</li>\n</ul>\n<h2 id=\"C语言的特点\"><a href=\"#C语言的特点\" class=\"headerlink\" title=\"C语言的特点\"></a>C语言的特点</h2><ul>\n<li>丰富的运算符</li>\n<li>丰富的数据类型</li>\n<li>可以直接操作硬件</li>\n<li>高效的目标代码</li>\n<li>可移植性好</li>\n</ul>\n<h2 id=\"C语言的用途\"><a href=\"#C语言的用途\" class=\"headerlink\" title=\"C语言的用途\"></a>C语言的用途</h2><ul>\n<li>编写系统软件、图像处理、单片机程序、嵌入式系统开发等</li>\n<li>便携游戏外挂</li>\n<li>编写Android程序</li>\n<li>编写iOS程序</li>\n</ul>\n<h2 id=\"C语言的版本问题\"><a href=\"#C语言的版本问题\" class=\"headerlink\" title=\"C语言的版本问题\"></a>C语言的版本问题</h2><ul>\n<li>1983年美国国家标准（ANSI)成立一个委员，开始定制C语言标准的工作</li>\n<li>1989年C语言标准被批准，这个版本的C语言标准成为ANSI C</li>\n<li>1999年，国际标准化组织ISO对C语言标准进行修订，命名为C99</li>\n<li>2011年12与8日，ISO发布新的标准草案：C11</li>\n</ul>\n<h2 id=\"C语言的开发过程\"><a href=\"#C语言的开发过程\" class=\"headerlink\" title=\"C语言的开发过程\"></a>C语言的开发过程</h2><p><code>编写程序</code>→<code>编译</code>→<code>链接</code>→<code>运行</code></p>\n<h2 id=\"C语言程序\"><a href=\"#C语言程序\" class=\"headerlink\" title=\"C语言程序\"></a>C语言程序</h2><ul>\n<li><p>构成</p>\n<blockquote>\n<p>任何一个C语言的程序都是有一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以说，C语言程序是由函数构成的。</p>\n</blockquote>\n</li>\n<li><p>程序入口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#incluce &lt;stdio.h&gt;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">printf(&quot;程序入口&quot;);</span><br><span class=\"line\">return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>c程序源文件的拓展名为.c</p>\n</li>\n<li><p>常见错误</p>\n</li>\n<li><p>语法错误：编译器会直接报错</p>\n</li>\n<li><p>逻辑错误：没有语法错误，只是运行结果不正确</p>\n</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><blockquote>\n<p>被C语言赋予了特殊含义的单词，这些单词是系统自己用的，叫做系统保留字，这些保留字称为关键字</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 32个关键字</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">double</span> <span class=\"keyword\">int</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">break</span> <span class=\"title\">else</span> <span class=\"title\">long</span> <span class=\"title\">switch</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">case</span> <span class=\"title\">enum</span> <span class=\"title\">register</span> <span class=\"title\">typedef</span> <span class=\"title\">char</span> <span class=\"title\">extern</span> <span class=\"title\">return</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">union</span> <span class=\"title\">const</span> <span class=\"title\">float</span> <span class=\"title\">short</span> <span class=\"title\">unsigned</span> <span class=\"title\">continue</span> <span class=\"title\">for</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">signed</span> <span class=\"title\">void</span> <span class=\"title\">default</span> <span class=\"title\">goto</span> <span class=\"title\">sizeof</span> <span class=\"title\">volatile</span> <span class=\"title\">do</span> <span class=\"title\">if</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">while</span> <span class=\"title\">static</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标示符\"><a href=\"#标示符\" class=\"headerlink\" title=\"标示符\"></a>标示符</h2><p>标示符就是程序员在程序中起的一些名字，变量名、函数名等</p>\n<ul>\n<li><p>命名规范</p>\n<ol>\n<li>只能有26个英文字母的大小写、10个阿拉伯数字0~9、下划线_组成</li>\n<li>不能以数字开头</li>\n<li>不可以和关键字重名</li>\n<li>严格区分大小写 </li>\n</ol>\n</li>\n<li><p>行业约束</p>\n<ol>\n<li>尽量取有意义的名称</li>\n<li>如果标示符包含多个单词，可以用驼峰标识（除第一个单词外，后面每个单词首字母大写 或者 用下划线连接）</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>在所有计算机语言中都非常重要，用来解释一段程序或者一行代码是什么意思，可以是任何语言，不参与编译</p>\n<ul>\n<li>单行注释 <code>//</code></li>\n<li>多行注释 <code>/*  要注释的内容 */</code> </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"计算机发展史\"><a href=\"#计算机发展史\" class=\"headerlink\" title=\"计算机发展史\"></a>计算机发展史</h2><ul>\n<li><p>机器语言</p>\n</li>\n<li><p>所有的代码里面只有0和1</p>\n</li>\n<li><p>优点：直接对硬件产生作用，程序的执行效率非常高</p>\n</li>\n<li><p>缺点：指令又多又难记、可读性差、无可移植性</p>\n</li>\n<li><p>汇编语言</p>\n</li>\n<li><p>符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令</p>\n</li>\n<li><p>优点：直接对硬件产生作用，程序的执行效率非常高、可读性好</p>\n</li>\n<li><p>缺点：符号非常多和难记、无可移植性</p>\n</li>\n<li><p>高级语言</p>\n</li>\n<li><p>非常接近自然语言的高级语言，语法和结构类似于普通英文</p>\n</li>\n<li><p>优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性</p>\n</li>\n<li><p>缺点：有些高级语言写出的程序执行效率并不高</p>\n</li>\n</ul>\n<h1 id=\"C语言\"><a href=\"#C语言\" class=\"headerlink\" title=\"C语言\"></a>C语言</h1><h2 id=\"什么是C语言\"><a href=\"#什么是C语言\" class=\"headerlink\" title=\"什么是C语言\"></a>什么是C语言</h2><ul>\n<li>C语言就是一门计算机编程语言，属于高级语言，可以用来编写程序、开发软件。</li>\n<li>ios程序的额主要开发语言就是C语言和Object-c，而Object-c是在C语言的基础上衍生出来的。</li>\n<li>C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，比如C++，C#，Object-c等</li>\n</ul>\n<h2 id=\"C语言简史\"><a href=\"#C语言简史\" class=\"headerlink\" title=\"C语言简史\"></a>C语言简史</h2><ul>\n<li>1972年发明，首次使用是用于重写UINX操作系统</li>\n<li>它是一门面向过程的语言</li>\n</ul>\n<h2 id=\"C语言的特点\"><a href=\"#C语言的特点\" class=\"headerlink\" title=\"C语言的特点\"></a>C语言的特点</h2><ul>\n<li>丰富的运算符</li>\n<li>丰富的数据类型</li>\n<li>可以直接操作硬件</li>\n<li>高效的目标代码</li>\n<li>可移植性好</li>\n</ul>\n<h2 id=\"C语言的用途\"><a href=\"#C语言的用途\" class=\"headerlink\" title=\"C语言的用途\"></a>C语言的用途</h2><ul>\n<li>编写系统软件、图像处理、单片机程序、嵌入式系统开发等</li>\n<li>便携游戏外挂</li>\n<li>编写Android程序</li>\n<li>编写iOS程序</li>\n</ul>\n<h2 id=\"C语言的版本问题\"><a href=\"#C语言的版本问题\" class=\"headerlink\" title=\"C语言的版本问题\"></a>C语言的版本问题</h2><ul>\n<li>1983年美国国家标准（ANSI)成立一个委员，开始定制C语言标准的工作</li>\n<li>1989年C语言标准被批准，这个版本的C语言标准成为ANSI C</li>\n<li>1999年，国际标准化组织ISO对C语言标准进行修订，命名为C99</li>\n<li>2011年12与8日，ISO发布新的标准草案：C11</li>\n</ul>\n<h2 id=\"C语言的开发过程\"><a href=\"#C语言的开发过程\" class=\"headerlink\" title=\"C语言的开发过程\"></a>C语言的开发过程</h2><p><code>编写程序</code>→<code>编译</code>→<code>链接</code>→<code>运行</code></p>\n<h2 id=\"C语言程序\"><a href=\"#C语言程序\" class=\"headerlink\" title=\"C语言程序\"></a>C语言程序</h2><ul>\n<li><p>构成</p>\n<blockquote>\n<p>任何一个C语言的程序都是有一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以说，C语言程序是由函数构成的。</p>\n</blockquote>\n</li>\n<li><p>程序入口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#incluce &lt;stdio.h&gt;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">printf(&quot;程序入口&quot;);</span><br><span class=\"line\">return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>c程序源文件的拓展名为.c</p>\n</li>\n<li><p>常见错误</p>\n</li>\n<li><p>语法错误：编译器会直接报错</p>\n</li>\n<li><p>逻辑错误：没有语法错误，只是运行结果不正确</p>\n</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><blockquote>\n<p>被C语言赋予了特殊含义的单词，这些单词是系统自己用的，叫做系统保留字，这些保留字称为关键字</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 32个关键字</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">double</span> <span class=\"keyword\">int</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">break</span> <span class=\"title\">else</span> <span class=\"title\">long</span> <span class=\"title\">switch</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">case</span> <span class=\"title\">enum</span> <span class=\"title\">register</span> <span class=\"title\">typedef</span> <span class=\"title\">char</span> <span class=\"title\">extern</span> <span class=\"title\">return</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">union</span> <span class=\"title\">const</span> <span class=\"title\">float</span> <span class=\"title\">short</span> <span class=\"title\">unsigned</span> <span class=\"title\">continue</span> <span class=\"title\">for</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">signed</span> <span class=\"title\">void</span> <span class=\"title\">default</span> <span class=\"title\">goto</span> <span class=\"title\">sizeof</span> <span class=\"title\">volatile</span> <span class=\"title\">do</span> <span class=\"title\">if</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">while</span> <span class=\"title\">static</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"标示符\"><a href=\"#标示符\" class=\"headerlink\" title=\"标示符\"></a>标示符</h2><p>标示符就是程序员在程序中起的一些名字，变量名、函数名等</p>\n<ul>\n<li><p>命名规范</p>\n<ol>\n<li>只能有26个英文字母的大小写、10个阿拉伯数字0~9、下划线_组成</li>\n<li>不能以数字开头</li>\n<li>不可以和关键字重名</li>\n<li>严格区分大小写 </li>\n</ol>\n</li>\n<li><p>行业约束</p>\n<ol>\n<li>尽量取有意义的名称</li>\n<li>如果标示符包含多个单词，可以用驼峰标识（除第一个单词外，后面每个单词首字母大写 或者 用下划线连接）</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>在所有计算机语言中都非常重要，用来解释一段程序或者一行代码是什么意思，可以是任何语言，不参与编译</p>\n<ul>\n<li>单行注释 <code>//</code></li>\n<li>多行注释 <code>/*  要注释的内容 */</code> </li>\n</ul>\n"},{"title":"C语言数组和字符串","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-20T07:24:00.000Z","_content":"## C程序内存分配\n1. `栈区(stack)` - 由编译器自动分配释放，存放函数的参数名，局部变量名等。\n2. `堆区(heap)` - 有程序员分配和释放，它与数据结构中的`堆`是两回事。\n3. `全局区(静态区)(static)` - 全局变量和静态变量存储位置\n4. `文字常量区` - 常量字符串存放位置\n5. `程序代码区` - 存放函数体的二进制代码\n\n## 数组\n### 说明\n    存储一组数据的容器\n### 特点\n- 只能存储一种类型的数据\n- 有顺序之分，索引从0开始。\n\n### 定义\n元素类型  数组名[元素个数]\nint nums[3];\n### 初始化\n一般会在数组定义的同时进行初始化\nint nums[3] = {2,5,3};\n### 访问\n通用下标（索引)访问：nums[1];\n\n## 二维数组\n### 定义\n### 初始化\n* 按行进行初始化\nint a[2][3] = { {2, 2, 3}, {3, 4, 5} }; \n* 按存储顺序进行初始化(先存放第1行，再存放第2行)\nint a[2][3] = {2, 2, 3, 3, 4, 5}; \n* 对部分元素进行初始化\nint a[2][3] = { {2}, {3, 4} };  \n* 如果只初始化了部分元素，可以省略行数，但是不可以省略列数\nint a[][3] = {1, 2, 3, 4, 5, 6};\n\n## 字符串\n- char a[] = “123”;  和 char a [] = {‘1’,’2’,’3’};的区别，可以比较大小\n- “123”其实是由’1’、’2’、’3’、’\\0’组成\n- 字符串的输出”%s”，’\\0’是不会输出的\n\n## 字符串数组\n1. char names[2][10] = { {'J','a','y','\\0'}, {'J','i','m','\\0'} };  \n2. char names2[2][10] = { {\"Jay\"}, {\"Jim\"} };  \n3. char names3[2][10] = { \"Jay\", \"Jim\" };\n\n## 常用字符串函数\n- strlen(字符数组名或字符指针变量);字符串测长函数\n- strcat(字符串1的地址，字符串2的地址)；将字符串2的内容连接到字符串1的尾部。\n- strcmp(字符串1的地址，字符串2的地址)；比较串1和串2哪个比较大。比较大小的依据是，两个字符串从左往右相应位置上第一个不相等的字符ASCII码值之差\n- strcpy(字符串1的地址，字符串2的地址)；将字符串2的内容复制到字符串1内。","source":"_posts/c/C语言数组和字符串.md","raw":"---\ntitle: C语言数组和字符串\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-20 15:24:00   \n---\n## C程序内存分配\n1. `栈区(stack)` - 由编译器自动分配释放，存放函数的参数名，局部变量名等。\n2. `堆区(heap)` - 有程序员分配和释放，它与数据结构中的`堆`是两回事。\n3. `全局区(静态区)(static)` - 全局变量和静态变量存储位置\n4. `文字常量区` - 常量字符串存放位置\n5. `程序代码区` - 存放函数体的二进制代码\n\n## 数组\n### 说明\n    存储一组数据的容器\n### 特点\n- 只能存储一种类型的数据\n- 有顺序之分，索引从0开始。\n\n### 定义\n元素类型  数组名[元素个数]\nint nums[3];\n### 初始化\n一般会在数组定义的同时进行初始化\nint nums[3] = {2,5,3};\n### 访问\n通用下标（索引)访问：nums[1];\n\n## 二维数组\n### 定义\n### 初始化\n* 按行进行初始化\nint a[2][3] = { {2, 2, 3}, {3, 4, 5} }; \n* 按存储顺序进行初始化(先存放第1行，再存放第2行)\nint a[2][3] = {2, 2, 3, 3, 4, 5}; \n* 对部分元素进行初始化\nint a[2][3] = { {2}, {3, 4} };  \n* 如果只初始化了部分元素，可以省略行数，但是不可以省略列数\nint a[][3] = {1, 2, 3, 4, 5, 6};\n\n## 字符串\n- char a[] = “123”;  和 char a [] = {‘1’,’2’,’3’};的区别，可以比较大小\n- “123”其实是由’1’、’2’、’3’、’\\0’组成\n- 字符串的输出”%s”，’\\0’是不会输出的\n\n## 字符串数组\n1. char names[2][10] = { {'J','a','y','\\0'}, {'J','i','m','\\0'} };  \n2. char names2[2][10] = { {\"Jay\"}, {\"Jim\"} };  \n3. char names3[2][10] = { \"Jay\", \"Jim\" };\n\n## 常用字符串函数\n- strlen(字符数组名或字符指针变量);字符串测长函数\n- strcat(字符串1的地址，字符串2的地址)；将字符串2的内容连接到字符串1的尾部。\n- strcmp(字符串1的地址，字符串2的地址)；比较串1和串2哪个比较大。比较大小的依据是，两个字符串从左往右相应位置上第一个不相等的字符ASCII码值之差\n- strcpy(字符串1的地址，字符串2的地址)；将字符串2的内容复制到字符串1内。","slug":"c/C语言数组和字符串","published":1,"updated":"2019-10-02T08:57:45.541Z","layout":"post","photos":[],"link":"","_id":"ck19bvapo000500wk1pkj13kz","content":"<h2 id=\"C程序内存分配\"><a href=\"#C程序内存分配\" class=\"headerlink\" title=\"C程序内存分配\"></a>C程序内存分配</h2><ol>\n<li><code>栈区(stack)</code> - 由编译器自动分配释放，存放函数的参数名，局部变量名等。</li>\n<li><code>堆区(heap)</code> - 有程序员分配和释放，它与数据结构中的<code>堆</code>是两回事。</li>\n<li><code>全局区(静态区)(static)</code> - 全局变量和静态变量存储位置</li>\n<li><code>文字常量区</code> - 常量字符串存放位置</li>\n<li><code>程序代码区</code> - 存放函数体的二进制代码</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><pre><code>存储一组数据的容器</code></pre><h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>只能存储一种类型的数据</li>\n<li>有顺序之分，索引从0开始。</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>元素类型  数组名[元素个数]<br>int nums[3];</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>一般会在数组定义的同时进行初始化<br>int nums[3] = {2,5,3};</p>\n<h3 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h3><p>通用下标（索引)访问：nums[1];</p>\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>按行进行初始化<br>int a[2][3] = { {2, 2, 3}, {3, 4, 5} }; </li>\n<li>按存储顺序进行初始化(先存放第1行，再存放第2行)<br>int a[2][3] = {2, 2, 3, 3, 4, 5}; </li>\n<li>对部分元素进行初始化<br>int a[2][3] = { {2}, {3, 4} };  </li>\n<li>如果只初始化了部分元素，可以省略行数，但是不可以省略列数<br>int a[][3] = {1, 2, 3, 4, 5, 6};</li>\n</ul>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><ul>\n<li>char a[] = “123”;  和 char a [] = {‘1’,’2’,’3’};的区别，可以比较大小</li>\n<li>“123”其实是由’1’、’2’、’3’、’\\0’组成</li>\n<li>字符串的输出”%s”，’\\0’是不会输出的</li>\n</ul>\n<h2 id=\"字符串数组\"><a href=\"#字符串数组\" class=\"headerlink\" title=\"字符串数组\"></a>字符串数组</h2><ol>\n<li>char names[2][10] = { {‘J’,’a’,’y’,’\\0’}, {‘J’,’i’,’m’,’\\0’} };  </li>\n<li>char names2[2][10] = { {“Jay”}, {“Jim”} };  </li>\n<li>char names3[2][10] = { “Jay”, “Jim” };</li>\n</ol>\n<h2 id=\"常用字符串函数\"><a href=\"#常用字符串函数\" class=\"headerlink\" title=\"常用字符串函数\"></a>常用字符串函数</h2><ul>\n<li>strlen(字符数组名或字符指针变量);字符串测长函数</li>\n<li>strcat(字符串1的地址，字符串2的地址)；将字符串2的内容连接到字符串1的尾部。</li>\n<li>strcmp(字符串1的地址，字符串2的地址)；比较串1和串2哪个比较大。比较大小的依据是，两个字符串从左往右相应位置上第一个不相等的字符ASCII码值之差</li>\n<li>strcpy(字符串1的地址，字符串2的地址)；将字符串2的内容复制到字符串1内。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C程序内存分配\"><a href=\"#C程序内存分配\" class=\"headerlink\" title=\"C程序内存分配\"></a>C程序内存分配</h2><ol>\n<li><code>栈区(stack)</code> - 由编译器自动分配释放，存放函数的参数名，局部变量名等。</li>\n<li><code>堆区(heap)</code> - 有程序员分配和释放，它与数据结构中的<code>堆</code>是两回事。</li>\n<li><code>全局区(静态区)(static)</code> - 全局变量和静态变量存储位置</li>\n<li><code>文字常量区</code> - 常量字符串存放位置</li>\n<li><code>程序代码区</code> - 存放函数体的二进制代码</li>\n</ol>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><pre><code>存储一组数据的容器</code></pre><h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>只能存储一种类型的数据</li>\n<li>有顺序之分，索引从0开始。</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>元素类型  数组名[元素个数]<br>int nums[3];</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>一般会在数组定义的同时进行初始化<br>int nums[3] = {2,5,3};</p>\n<h3 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h3><p>通用下标（索引)访问：nums[1];</p>\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>按行进行初始化<br>int a[2][3] = { {2, 2, 3}, {3, 4, 5} }; </li>\n<li>按存储顺序进行初始化(先存放第1行，再存放第2行)<br>int a[2][3] = {2, 2, 3, 3, 4, 5}; </li>\n<li>对部分元素进行初始化<br>int a[2][3] = { {2}, {3, 4} };  </li>\n<li>如果只初始化了部分元素，可以省略行数，但是不可以省略列数<br>int a[][3] = {1, 2, 3, 4, 5, 6};</li>\n</ul>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><ul>\n<li>char a[] = “123”;  和 char a [] = {‘1’,’2’,’3’};的区别，可以比较大小</li>\n<li>“123”其实是由’1’、’2’、’3’、’\\0’组成</li>\n<li>字符串的输出”%s”，’\\0’是不会输出的</li>\n</ul>\n<h2 id=\"字符串数组\"><a href=\"#字符串数组\" class=\"headerlink\" title=\"字符串数组\"></a>字符串数组</h2><ol>\n<li>char names[2][10] = { {‘J’,’a’,’y’,’\\0’}, {‘J’,’i’,’m’,’\\0’} };  </li>\n<li>char names2[2][10] = { {“Jay”}, {“Jim”} };  </li>\n<li>char names3[2][10] = { “Jay”, “Jim” };</li>\n</ol>\n<h2 id=\"常用字符串函数\"><a href=\"#常用字符串函数\" class=\"headerlink\" title=\"常用字符串函数\"></a>常用字符串函数</h2><ul>\n<li>strlen(字符数组名或字符指针变量);字符串测长函数</li>\n<li>strcat(字符串1的地址，字符串2的地址)；将字符串2的内容连接到字符串1的尾部。</li>\n<li>strcmp(字符串1的地址，字符串2的地址)；比较串1和串2哪个比较大。比较大小的依据是，两个字符串从左往右相应位置上第一个不相等的字符ASCII码值之差</li>\n<li>strcpy(字符串1的地址，字符串2的地址)；将字符串2的内容复制到字符串1内。</li>\n</ul>\n"},{"title":"C语言表达式和结构控制","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-19T09:24:00.000Z","_content":"# 输入输出\n## printf和scanf的使用\n### printf和scanf输出输入格式\n| Type      | Example \n| :--:      | :-----: \n| char      | %c\n| short int | %hd\n| int       | %d\n| long int  | %ld\n| float     | %f\n| double    | %f\n\n# 表达式\n## 算数运算符\n### 常见运算符\n运算符 | 意义\n-|:--\n+|加法运算符\n-|减法运算符，或者负数云算法\n*|乘法运算符\n/|除法运算符（整数相除，省略小数）\n%|模运算符，取余运算符（%两侧均为整数）\n### 运算循序\n1> 算术表达式:用算术运算符将数据连接起来的式子，例如 2 + 4，3 `*` 5等。\n    表达式的运算顺序是按照运算符的`结合方向`和`优先级`进行的。\n2> 结合方向\n    算术运算符的结合方向从左到右。\n3> 优先级\n    优先级越高，就越先计算，当优先级相同时，参考结合方向。下面是优先级的排序\n    负值运算符(-) > 乘(*)、除(/)、模(%) > 加(+)、减(-)\n4> 小括号\n    如果被()括起来，那么优先级是最高。\n### 注意点\n1. 自动类型转换， 自动将大类型转换称小类型，会丢失精度    \n2. 强制类型转换\n\n## 赋值运算符\n1. 简单赋值运算符\n    赋值运算符的结合方向：从右到左，而且优先级低于算数运算符\n2. 复合赋值运算符\n    += : 如 a+=2等价于，a = a+2;\n    -= : 如 a-=2等价于，a = a-2;\n   `*`= : 如 a`*`=2等价于，a = a`*`2;\n    /= : 如 a+=2等价于，a = a+2;\n    %= : 如 a+=2等价于，a = a+2;\n\n## 自增和自减\n1. ++\n    - 先加，后用 `++a`\n    - 先用，后加 `a++`\n2. --\n    - 先减，后用 `--a`\n    - 先用，后减 `a--`\n    \n## sizeof\n>用来计算一个变量或者一个常量、一种数据类型所占的内存字节数\n\n## 逗号运算符\n- 主要用于连接表达式\n- 从左到右依次计算\n- 整个都好运算符，是最后一个表达式的值\n\n## 关系运算符\n- C语言中条件成立成为“真”，条件不成立成为“假”\n- C语言中规定，任何数值都有真假性，任何非0的值都为“真”，只有0才为“假”\n### 关系运算符\n\n运算符 | 意义\n-|-\n<|小于\n<=|小于等于\n>|大于\n>=|大于等于\n==|等于\n！=|不等于\n\n关系运算符的结果只有两种，条件成立结果是“1”，不成立为“0”；\n### 优先级\n1. <、<=、>、>=优先级大于 ==、!=优先级\n2. 结合方向，“从左到右”\n3. 优先级低于算术运算符\n\n## 逻辑运算符\n\n运算符|意义|计算规则\n-|- | -\n&&|与|两个为真才为真\n&#124;&#124; | 或|一个为真就为真\n！ | 非|！真为假，！假为真\n\n## 三目运算符\n- 条件运算符\n> 表达式1？表达式2：表达式3;\n    表达式1为真，执行表达式2，反之执行表达式3\n\n# 控制结构\n## 3种流程控制结构\n- 顺序结构：默认的流程结构。\n- 选择结构：对给定的条件进行判断，再根据判断来决定执行哪一段代码。\n- 循环结构：在给定条件成立的情况下，反复执行莫一段代码。\n\n### 选择结构\n1. if(){}else{}\n2. switch(){case :}\n\n### 循环结构\n1. while\n```\nwhile(条件）｛\n    语句1；\n    ……\n}\n//条件成立（为真），就执行{}中内容，条件不成立，就不执行\n```\n\n2. do-while\n```\ndo{\n    语句1；\n}while(条件);\n// 先执行一遍{}中内容，再判断'条件'是否成立，成立继续执行，不成立，不执行。\n```\n\n3. for\n```\n/*\n执行循序：\n1.初始化表达式（只在开始的时候执行一次）\n2.循环条件表达式（返回值只有两种，真 或 假）\n3.2返回为真时，执行{}中内容。为假时，退出循环\n4.执行一次{}后，执行“循环后的操作表达式”\n5.再执行第2步，循环下去。\n*/\nfor(初始化表达式；循环条件表达式；循环后的操作表达式){\n    执行语句；\n}\n```\n- break和continue\n    break常使用与switch和循环结构中，用于跳出switch或循环\n    continue常用于循环结构中，用于跳出本次循环","source":"_posts/c/C语言表达式和结构控制.md","raw":"---\ntitle: C语言表达式和结构控制\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-19 17:24:00   \n---\n# 输入输出\n## printf和scanf的使用\n### printf和scanf输出输入格式\n| Type      | Example \n| :--:      | :-----: \n| char      | %c\n| short int | %hd\n| int       | %d\n| long int  | %ld\n| float     | %f\n| double    | %f\n\n# 表达式\n## 算数运算符\n### 常见运算符\n运算符 | 意义\n-|:--\n+|加法运算符\n-|减法运算符，或者负数云算法\n*|乘法运算符\n/|除法运算符（整数相除，省略小数）\n%|模运算符，取余运算符（%两侧均为整数）\n### 运算循序\n1> 算术表达式:用算术运算符将数据连接起来的式子，例如 2 + 4，3 `*` 5等。\n    表达式的运算顺序是按照运算符的`结合方向`和`优先级`进行的。\n2> 结合方向\n    算术运算符的结合方向从左到右。\n3> 优先级\n    优先级越高，就越先计算，当优先级相同时，参考结合方向。下面是优先级的排序\n    负值运算符(-) > 乘(*)、除(/)、模(%) > 加(+)、减(-)\n4> 小括号\n    如果被()括起来，那么优先级是最高。\n### 注意点\n1. 自动类型转换， 自动将大类型转换称小类型，会丢失精度    \n2. 强制类型转换\n\n## 赋值运算符\n1. 简单赋值运算符\n    赋值运算符的结合方向：从右到左，而且优先级低于算数运算符\n2. 复合赋值运算符\n    += : 如 a+=2等价于，a = a+2;\n    -= : 如 a-=2等价于，a = a-2;\n   `*`= : 如 a`*`=2等价于，a = a`*`2;\n    /= : 如 a+=2等价于，a = a+2;\n    %= : 如 a+=2等价于，a = a+2;\n\n## 自增和自减\n1. ++\n    - 先加，后用 `++a`\n    - 先用，后加 `a++`\n2. --\n    - 先减，后用 `--a`\n    - 先用，后减 `a--`\n    \n## sizeof\n>用来计算一个变量或者一个常量、一种数据类型所占的内存字节数\n\n## 逗号运算符\n- 主要用于连接表达式\n- 从左到右依次计算\n- 整个都好运算符，是最后一个表达式的值\n\n## 关系运算符\n- C语言中条件成立成为“真”，条件不成立成为“假”\n- C语言中规定，任何数值都有真假性，任何非0的值都为“真”，只有0才为“假”\n### 关系运算符\n\n运算符 | 意义\n-|-\n<|小于\n<=|小于等于\n>|大于\n>=|大于等于\n==|等于\n！=|不等于\n\n关系运算符的结果只有两种，条件成立结果是“1”，不成立为“0”；\n### 优先级\n1. <、<=、>、>=优先级大于 ==、!=优先级\n2. 结合方向，“从左到右”\n3. 优先级低于算术运算符\n\n## 逻辑运算符\n\n运算符|意义|计算规则\n-|- | -\n&&|与|两个为真才为真\n&#124;&#124; | 或|一个为真就为真\n！ | 非|！真为假，！假为真\n\n## 三目运算符\n- 条件运算符\n> 表达式1？表达式2：表达式3;\n    表达式1为真，执行表达式2，反之执行表达式3\n\n# 控制结构\n## 3种流程控制结构\n- 顺序结构：默认的流程结构。\n- 选择结构：对给定的条件进行判断，再根据判断来决定执行哪一段代码。\n- 循环结构：在给定条件成立的情况下，反复执行莫一段代码。\n\n### 选择结构\n1. if(){}else{}\n2. switch(){case :}\n\n### 循环结构\n1. while\n```\nwhile(条件）｛\n    语句1；\n    ……\n}\n//条件成立（为真），就执行{}中内容，条件不成立，就不执行\n```\n\n2. do-while\n```\ndo{\n    语句1；\n}while(条件);\n// 先执行一遍{}中内容，再判断'条件'是否成立，成立继续执行，不成立，不执行。\n```\n\n3. for\n```\n/*\n执行循序：\n1.初始化表达式（只在开始的时候执行一次）\n2.循环条件表达式（返回值只有两种，真 或 假）\n3.2返回为真时，执行{}中内容。为假时，退出循环\n4.执行一次{}后，执行“循环后的操作表达式”\n5.再执行第2步，循环下去。\n*/\nfor(初始化表达式；循环条件表达式；循环后的操作表达式){\n    执行语句；\n}\n```\n- break和continue\n    break常使用与switch和循环结构中，用于跳出switch或循环\n    continue常用于循环结构中，用于跳出本次循环","slug":"c/C语言表达式和结构控制","published":1,"updated":"2019-10-02T08:53:40.484Z","layout":"post","photos":[],"link":"","_id":"ck19bvapr000600wk2z55r2rn","content":"<h1 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h1><h2 id=\"printf和scanf的使用\"><a href=\"#printf和scanf的使用\" class=\"headerlink\" title=\"printf和scanf的使用\"></a>printf和scanf的使用</h2><h3 id=\"printf和scanf输出输入格式\"><a href=\"#printf和scanf输出输入格式\" class=\"headerlink\" title=\"printf和scanf输出输入格式\"></a>printf和scanf输出输入格式</h3><table>\n<thead>\n<tr>\n<th align=\"center\">Type</th>\n<th align=\"center\">Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char</td>\n<td align=\"center\">%c</td>\n</tr>\n<tr>\n<td align=\"center\">short int</td>\n<td align=\"center\">%hd</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">%d</td>\n</tr>\n<tr>\n<td align=\"center\">long int</td>\n<td align=\"center\">%ld</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">%f</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">%f</td>\n</tr>\n</tbody></table>\n<h1 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h1><h2 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h2><h3 id=\"常见运算符\"><a href=\"#常见运算符\" class=\"headerlink\" title=\"常见运算符\"></a>常见运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th align=\"left\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td align=\"left\">加法运算符</td>\n</tr>\n<tr>\n<td>-</td>\n<td align=\"left\">减法运算符，或者负数云算法</td>\n</tr>\n<tr>\n<td>*</td>\n<td align=\"left\">乘法运算符</td>\n</tr>\n<tr>\n<td>/</td>\n<td align=\"left\">除法运算符（整数相除，省略小数）</td>\n</tr>\n<tr>\n<td>%</td>\n<td align=\"left\">模运算符，取余运算符（%两侧均为整数）</td>\n</tr>\n<tr>\n<td>### 运算循序</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>1&gt; 算术表达式:用算术运算符将数据连接起来的式子，例如 2 + 4，3 <code>*</code> 5等。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>表达式的运算顺序是按照运算符的<code>结合方向</code>和<code>优先级</code>进行的。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>2&gt; 结合方向</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>算术运算符的结合方向从左到右。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>3&gt; 优先级</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>优先级越高，就越先计算，当优先级相同时，参考结合方向。下面是优先级的排序</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>负值运算符(-) &gt; 乘(*)、除(/)、模(%) &gt; 加(+)、减(-)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>4&gt; 小括号</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>如果被()括起来，那么优先级是最高。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>### 注意点</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>1. 自动类型转换， 自动将大类型转换称小类型，会丢失精度</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>2. 强制类型转换</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><ol>\n<li>简单赋值运算符<br> 赋值运算符的结合方向：从右到左，而且优先级低于算数运算符</li>\n<li>复合赋值运算符<br> += : 如 a+=2等价于，a = a+2;<br> -= : 如 a-=2等价于，a = a-2;<br><code>*</code>= : 如 a<code>*</code>=2等价于，a = a<code>*</code>2;<br> /= : 如 a+=2等价于，a = a+2;<br> %= : 如 a+=2等价于，a = a+2;</li>\n</ol>\n<h2 id=\"自增和自减\"><a href=\"#自增和自减\" class=\"headerlink\" title=\"自增和自减\"></a>自增和自减</h2><ol>\n<li>++<ul>\n<li>先加，后用 <code>++a</code></li>\n<li>先用，后加 <code>a++</code></li>\n</ul>\n</li>\n<li>–<ul>\n<li>先减，后用 <code>--a</code></li>\n<li>先用，后减 <code>a--</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"sizeof\"><a href=\"#sizeof\" class=\"headerlink\" title=\"sizeof\"></a>sizeof</h2><blockquote>\n<p>用来计算一个变量或者一个常量、一种数据类型所占的内存字节数</p>\n</blockquote>\n<h2 id=\"逗号运算符\"><a href=\"#逗号运算符\" class=\"headerlink\" title=\"逗号运算符\"></a>逗号运算符</h2><ul>\n<li>主要用于连接表达式</li>\n<li>从左到右依次计算</li>\n<li>整个都好运算符，是最后一个表达式的值</li>\n</ul>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><ul>\n<li>C语言中条件成立成为“真”，条件不成立成为“假”</li>\n<li>C语言中规定，任何数值都有真假性，任何非0的值都为“真”，只有0才为“假”<h3 id=\"关系运算符-1\"><a href=\"#关系运算符-1\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>！=</td>\n<td>不等于</td>\n</tr>\n</tbody></table>\n<p>关系运算符的结果只有两种，条件成立结果是“1”，不成立为“0”；</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><ol>\n<li>&lt;、&lt;=、&gt;、&gt;=优先级大于 ==、!=优先级</li>\n<li>结合方向，“从左到右”</li>\n<li>优先级低于算术运算符</li>\n</ol>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>意义</th>\n<th>计算规则</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>与</td>\n<td>两个为真才为真</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>或</td>\n<td>一个为真就为真</td>\n</tr>\n<tr>\n<td>！</td>\n<td>非</td>\n<td>！真为假，！假为真</td>\n</tr>\n</tbody></table>\n<h2 id=\"三目运算符\"><a href=\"#三目运算符\" class=\"headerlink\" title=\"三目运算符\"></a>三目运算符</h2><ul>\n<li>条件运算符<blockquote>\n<p>表达式1？表达式2：表达式3;<br>  表达式1为真，执行表达式2，反之执行表达式3</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h1><h2 id=\"3种流程控制结构\"><a href=\"#3种流程控制结构\" class=\"headerlink\" title=\"3种流程控制结构\"></a>3种流程控制结构</h2><ul>\n<li>顺序结构：默认的流程结构。</li>\n<li>选择结构：对给定的条件进行判断，再根据判断来决定执行哪一段代码。</li>\n<li>循环结构：在给定条件成立的情况下，反复执行莫一段代码。</li>\n</ul>\n<h3 id=\"选择结构\"><a href=\"#选择结构\" class=\"headerlink\" title=\"选择结构\"></a>选择结构</h3><ol>\n<li>if(){}else{}</li>\n<li>switch(){case :}</li>\n</ol>\n<h3 id=\"循环结构\"><a href=\"#循环结构\" class=\"headerlink\" title=\"循环结构\"></a>循环结构</h3><ol>\n<li><p>while</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(条件）｛</span><br><span class=\"line\">    语句1；</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//条件成立（为真），就执行&#123;&#125;中内容，条件不成立，就不执行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>do-while</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do&#123;</span><br><span class=\"line\">    语句1；</span><br><span class=\"line\">&#125;while(条件);</span><br><span class=\"line\">// 先执行一遍&#123;&#125;中内容，再判断&apos;条件&apos;是否成立，成立继续执行，不成立，不执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>for</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">执行循序：</span><br><span class=\"line\">1.初始化表达式（只在开始的时候执行一次）</span><br><span class=\"line\">2.循环条件表达式（返回值只有两种，真 或 假）</span><br><span class=\"line\">3.2返回为真时，执行&#123;&#125;中内容。为假时，退出循环</span><br><span class=\"line\">4.执行一次&#123;&#125;后，执行“循环后的操作表达式”</span><br><span class=\"line\">5.再执行第2步，循环下去。</span><br><span class=\"line\">*/</span><br><span class=\"line\">for(初始化表达式；循环条件表达式；循环后的操作表达式)&#123;</span><br><span class=\"line\">    执行语句；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>break和continue<br>  break常使用与switch和循环结构中，用于跳出switch或循环<br>  continue常用于循环结构中，用于跳出本次循环</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h1><h2 id=\"printf和scanf的使用\"><a href=\"#printf和scanf的使用\" class=\"headerlink\" title=\"printf和scanf的使用\"></a>printf和scanf的使用</h2><h3 id=\"printf和scanf输出输入格式\"><a href=\"#printf和scanf输出输入格式\" class=\"headerlink\" title=\"printf和scanf输出输入格式\"></a>printf和scanf输出输入格式</h3><table>\n<thead>\n<tr>\n<th align=\"center\">Type</th>\n<th align=\"center\">Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char</td>\n<td align=\"center\">%c</td>\n</tr>\n<tr>\n<td align=\"center\">short int</td>\n<td align=\"center\">%hd</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">%d</td>\n</tr>\n<tr>\n<td align=\"center\">long int</td>\n<td align=\"center\">%ld</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">%f</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">%f</td>\n</tr>\n</tbody></table>\n<h1 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h1><h2 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h2><h3 id=\"常见运算符\"><a href=\"#常见运算符\" class=\"headerlink\" title=\"常见运算符\"></a>常见运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th align=\"left\">意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td align=\"left\">加法运算符</td>\n</tr>\n<tr>\n<td>-</td>\n<td align=\"left\">减法运算符，或者负数云算法</td>\n</tr>\n<tr>\n<td>*</td>\n<td align=\"left\">乘法运算符</td>\n</tr>\n<tr>\n<td>/</td>\n<td align=\"left\">除法运算符（整数相除，省略小数）</td>\n</tr>\n<tr>\n<td>%</td>\n<td align=\"left\">模运算符，取余运算符（%两侧均为整数）</td>\n</tr>\n<tr>\n<td>### 运算循序</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>1&gt; 算术表达式:用算术运算符将数据连接起来的式子，例如 2 + 4，3 <code>*</code> 5等。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>表达式的运算顺序是按照运算符的<code>结合方向</code>和<code>优先级</code>进行的。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>2&gt; 结合方向</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>算术运算符的结合方向从左到右。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>3&gt; 优先级</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>优先级越高，就越先计算，当优先级相同时，参考结合方向。下面是优先级的排序</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>负值运算符(-) &gt; 乘(*)、除(/)、模(%) &gt; 加(+)、减(-)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>4&gt; 小括号</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>如果被()括起来，那么优先级是最高。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>### 注意点</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>1. 自动类型转换， 自动将大类型转换称小类型，会丢失精度</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td>2. 强制类型转换</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><ol>\n<li>简单赋值运算符<br> 赋值运算符的结合方向：从右到左，而且优先级低于算数运算符</li>\n<li>复合赋值运算符<br> += : 如 a+=2等价于，a = a+2;<br> -= : 如 a-=2等价于，a = a-2;<br><code>*</code>= : 如 a<code>*</code>=2等价于，a = a<code>*</code>2;<br> /= : 如 a+=2等价于，a = a+2;<br> %= : 如 a+=2等价于，a = a+2;</li>\n</ol>\n<h2 id=\"自增和自减\"><a href=\"#自增和自减\" class=\"headerlink\" title=\"自增和自减\"></a>自增和自减</h2><ol>\n<li>++<ul>\n<li>先加，后用 <code>++a</code></li>\n<li>先用，后加 <code>a++</code></li>\n</ul>\n</li>\n<li>–<ul>\n<li>先减，后用 <code>--a</code></li>\n<li>先用，后减 <code>a--</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"sizeof\"><a href=\"#sizeof\" class=\"headerlink\" title=\"sizeof\"></a>sizeof</h2><blockquote>\n<p>用来计算一个变量或者一个常量、一种数据类型所占的内存字节数</p>\n</blockquote>\n<h2 id=\"逗号运算符\"><a href=\"#逗号运算符\" class=\"headerlink\" title=\"逗号运算符\"></a>逗号运算符</h2><ul>\n<li>主要用于连接表达式</li>\n<li>从左到右依次计算</li>\n<li>整个都好运算符，是最后一个表达式的值</li>\n</ul>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><ul>\n<li>C语言中条件成立成为“真”，条件不成立成为“假”</li>\n<li>C语言中规定，任何数值都有真假性，任何非0的值都为“真”，只有0才为“假”<h3 id=\"关系运算符-1\"><a href=\"#关系运算符-1\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>！=</td>\n<td>不等于</td>\n</tr>\n</tbody></table>\n<p>关系运算符的结果只有两种，条件成立结果是“1”，不成立为“0”；</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><ol>\n<li>&lt;、&lt;=、&gt;、&gt;=优先级大于 ==、!=优先级</li>\n<li>结合方向，“从左到右”</li>\n<li>优先级低于算术运算符</li>\n</ol>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>意义</th>\n<th>计算规则</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>与</td>\n<td>两个为真才为真</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>或</td>\n<td>一个为真就为真</td>\n</tr>\n<tr>\n<td>！</td>\n<td>非</td>\n<td>！真为假，！假为真</td>\n</tr>\n</tbody></table>\n<h2 id=\"三目运算符\"><a href=\"#三目运算符\" class=\"headerlink\" title=\"三目运算符\"></a>三目运算符</h2><ul>\n<li>条件运算符<blockquote>\n<p>表达式1？表达式2：表达式3;<br>  表达式1为真，执行表达式2，反之执行表达式3</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"控制结构\"><a href=\"#控制结构\" class=\"headerlink\" title=\"控制结构\"></a>控制结构</h1><h2 id=\"3种流程控制结构\"><a href=\"#3种流程控制结构\" class=\"headerlink\" title=\"3种流程控制结构\"></a>3种流程控制结构</h2><ul>\n<li>顺序结构：默认的流程结构。</li>\n<li>选择结构：对给定的条件进行判断，再根据判断来决定执行哪一段代码。</li>\n<li>循环结构：在给定条件成立的情况下，反复执行莫一段代码。</li>\n</ul>\n<h3 id=\"选择结构\"><a href=\"#选择结构\" class=\"headerlink\" title=\"选择结构\"></a>选择结构</h3><ol>\n<li>if(){}else{}</li>\n<li>switch(){case :}</li>\n</ol>\n<h3 id=\"循环结构\"><a href=\"#循环结构\" class=\"headerlink\" title=\"循环结构\"></a>循环结构</h3><ol>\n<li><p>while</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while(条件）｛</span><br><span class=\"line\">    语句1；</span><br><span class=\"line\">    ……</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//条件成立（为真），就执行&#123;&#125;中内容，条件不成立，就不执行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>do-while</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do&#123;</span><br><span class=\"line\">    语句1；</span><br><span class=\"line\">&#125;while(条件);</span><br><span class=\"line\">// 先执行一遍&#123;&#125;中内容，再判断&apos;条件&apos;是否成立，成立继续执行，不成立，不执行。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>for</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">执行循序：</span><br><span class=\"line\">1.初始化表达式（只在开始的时候执行一次）</span><br><span class=\"line\">2.循环条件表达式（返回值只有两种，真 或 假）</span><br><span class=\"line\">3.2返回为真时，执行&#123;&#125;中内容。为假时，退出循环</span><br><span class=\"line\">4.执行一次&#123;&#125;后，执行“循环后的操作表达式”</span><br><span class=\"line\">5.再执行第2步，循环下去。</span><br><span class=\"line\">*/</span><br><span class=\"line\">for(初始化表达式；循环条件表达式；循环后的操作表达式)&#123;</span><br><span class=\"line\">    执行语句；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>break和continue<br>  break常使用与switch和循环结构中，用于跳出switch或循环<br>  continue常用于循环结构中，用于跳出本次循环</li>\n</ul>\n"},{"title":"Dart函数","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-16T09:24:00.000Z","_content":"## 定义函数\n函数也是对象，当没有指定返回值的时候，函数返回null。函数定义方法如下：\n```Dart\nString sayHello(String name)\n{\n  return 'Hello $name!';\n}\n\n//is  is!操作符判断对象是否为指定类型，如num、String等\nassert(sayHello is Function);\n```\n由于类型可选，所以也可以写成：\n```Dart\nsayHello(name)\n{\n  return 'Hello $name!';\n}\n```\n如果函数只是简单的返回一个表达式的值，可以使用箭头语法 =>expr;\n```Dart\nsayHello(name) => 'Hello $name!';\n```\nDart中匿名函数的写法 (name)=>’Hello $name!’;\n```Dart\nvar  sayHello = (name)=>'Hello $name!';\n```\n\n## 函数闭包\n```Dart\nFunction makeSubstract(num n)\n{\n  return (num i) => n - i;\n}\n\nvoid main()\n{\n  var x = makeSubstract(5);\n  print(x(2));\n}\n```\n`Dart中函数也是对象`\n```Dart\nvar callbacks = [];\nfor (var i = 0; i < 3; i++) {\n  // 在列表 callbacks 中添加一个函数对象，这个函数会记住 for 循环中当前 i 的值。\n  callbacks.add(() => print('Save $i'));\n}\ncallbacks.forEach((c) => c()); // 分别输出 0 1 2\n```\n\n## 可选参数\nDart中支持两种可选参数：命名可选参数和位置可选参数\n但两种可选不能同时使用\n- 命名可选参数使用大括号`{}`，默认值用冒号`:`\n```Dart\nFunX(a, {b, c:3, d:4, e})\n{\n  print('$a $b $c $d $e');\n}\n```\n- 位置可选参数使用方括号`[]`，默认值用等号`=`\n\n在位置可选参数的函数中，大括号内的参数可以指定0个或多个在调用的时候参数值会依次按顺序赋值。\n```Dart\nFunY(a, [b, c=3, d=4, e])\n{\n  print('$a $b $c $d $e');\n}\n\nvoid main()\n{\n  FunX(1, b:3, d:5);\n  FunY(1, 3, 5);\n}\n```\n","source":"_posts/dart/03_Dart函数.md","raw":"---\ntitle: Dart函数\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-16 17:24:00   \n---\n## 定义函数\n函数也是对象，当没有指定返回值的时候，函数返回null。函数定义方法如下：\n```Dart\nString sayHello(String name)\n{\n  return 'Hello $name!';\n}\n\n//is  is!操作符判断对象是否为指定类型，如num、String等\nassert(sayHello is Function);\n```\n由于类型可选，所以也可以写成：\n```Dart\nsayHello(name)\n{\n  return 'Hello $name!';\n}\n```\n如果函数只是简单的返回一个表达式的值，可以使用箭头语法 =>expr;\n```Dart\nsayHello(name) => 'Hello $name!';\n```\nDart中匿名函数的写法 (name)=>’Hello $name!’;\n```Dart\nvar  sayHello = (name)=>'Hello $name!';\n```\n\n## 函数闭包\n```Dart\nFunction makeSubstract(num n)\n{\n  return (num i) => n - i;\n}\n\nvoid main()\n{\n  var x = makeSubstract(5);\n  print(x(2));\n}\n```\n`Dart中函数也是对象`\n```Dart\nvar callbacks = [];\nfor (var i = 0; i < 3; i++) {\n  // 在列表 callbacks 中添加一个函数对象，这个函数会记住 for 循环中当前 i 的值。\n  callbacks.add(() => print('Save $i'));\n}\ncallbacks.forEach((c) => c()); // 分别输出 0 1 2\n```\n\n## 可选参数\nDart中支持两种可选参数：命名可选参数和位置可选参数\n但两种可选不能同时使用\n- 命名可选参数使用大括号`{}`，默认值用冒号`:`\n```Dart\nFunX(a, {b, c:3, d:4, e})\n{\n  print('$a $b $c $d $e');\n}\n```\n- 位置可选参数使用方括号`[]`，默认值用等号`=`\n\n在位置可选参数的函数中，大括号内的参数可以指定0个或多个在调用的时候参数值会依次按顺序赋值。\n```Dart\nFunY(a, [b, c=3, d=4, e])\n{\n  print('$a $b $c $d $e');\n}\n\nvoid main()\n{\n  FunX(1, b:3, d:5);\n  FunY(1, 3, 5);\n}\n```\n","slug":"dart/03_Dart函数","published":1,"updated":"2019-10-02T09:23:04.183Z","layout":"post","photos":[],"link":"","_id":"ck19bvapu000700wk63w4h6zd","content":"<h2 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h2><p>函数也是对象，当没有指定返回值的时候，函数返回null。函数定义方法如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> sayHello(<span class=\"built_in\">String</span> name)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello <span class=\"subst\">$name</span>!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is  is!操作符判断对象是否为指定类型，如num、String等</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(sayHello <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);</span><br></pre></td></tr></table></figure>\n\n<p>由于类型可选，所以也可以写成：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sayHello(name)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello <span class=\"subst\">$name</span>!'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果函数只是简单的返回一个表达式的值，可以使用箭头语法 =&gt;expr;</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sayHello(name) =&gt; <span class=\"string\">'Hello <span class=\"subst\">$name</span>!'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Dart中匿名函数的写法 (name)=&gt;’Hello $name!’;</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span>  sayHello = (name)=&gt;<span class=\"string\">'Hello <span class=\"subst\">$name</span>!'</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数闭包\"><a href=\"#函数闭包\" class=\"headerlink\" title=\"函数闭包\"></a>函数闭包</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span> makeSubstract(<span class=\"built_in\">num</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">num</span> i) =&gt; n - i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = makeSubstract(<span class=\"number\">5</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x(<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Dart中函数也是对象</code></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> callbacks = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在列表 callbacks 中添加一个函数对象，这个函数会记住 for 循环中当前 i 的值。</span></span><br><span class=\"line\">  callbacks.add(() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'Save <span class=\"subst\">$i</span>'</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">callbacks.forEach((c) =&gt; c()); <span class=\"comment\">// 分别输出 0 1 2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>Dart中支持两种可选参数：命名可选参数和位置可选参数<br>但两种可选不能同时使用</p>\n<ul>\n<li><p>命名可选参数使用大括号<code>{}</code>，默认值用冒号<code>:</code></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FunX(a, &#123;b, c:<span class=\"number\">3</span>, d:<span class=\"number\">4</span>, e&#125;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$a</span> <span class=\"subst\">$b</span> <span class=\"subst\">$c</span> <span class=\"subst\">$d</span> <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>位置可选参数使用方括号<code>[]</code>，默认值用等号<code>=</code></p>\n</li>\n</ul>\n<p>在位置可选参数的函数中，大括号内的参数可以指定0个或多个在调用的时候参数值会依次按顺序赋值。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FunY(a, [b, c=<span class=\"number\">3</span>, d=<span class=\"number\">4</span>, e])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$a</span> <span class=\"subst\">$b</span> <span class=\"subst\">$c</span> <span class=\"subst\">$d</span> <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  FunX(<span class=\"number\">1</span>, b:<span class=\"number\">3</span>, d:<span class=\"number\">5</span>);</span><br><span class=\"line\">  FunY(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h2><p>函数也是对象，当没有指定返回值的时候，函数返回null。函数定义方法如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> sayHello(<span class=\"built_in\">String</span> name)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello <span class=\"subst\">$name</span>!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is  is!操作符判断对象是否为指定类型，如num、String等</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(sayHello <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);</span><br></pre></td></tr></table></figure>\n\n<p>由于类型可选，所以也可以写成：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sayHello(name)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello <span class=\"subst\">$name</span>!'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果函数只是简单的返回一个表达式的值，可以使用箭头语法 =&gt;expr;</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sayHello(name) =&gt; <span class=\"string\">'Hello <span class=\"subst\">$name</span>!'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Dart中匿名函数的写法 (name)=&gt;’Hello $name!’;</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span>  sayHello = (name)=&gt;<span class=\"string\">'Hello <span class=\"subst\">$name</span>!'</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数闭包\"><a href=\"#函数闭包\" class=\"headerlink\" title=\"函数闭包\"></a>函数闭包</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span> makeSubstract(<span class=\"built_in\">num</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">num</span> i) =&gt; n - i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = makeSubstract(<span class=\"number\">5</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(x(<span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Dart中函数也是对象</code></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> callbacks = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在列表 callbacks 中添加一个函数对象，这个函数会记住 for 循环中当前 i 的值。</span></span><br><span class=\"line\">  callbacks.add(() =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">'Save <span class=\"subst\">$i</span>'</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">callbacks.forEach((c) =&gt; c()); <span class=\"comment\">// 分别输出 0 1 2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>Dart中支持两种可选参数：命名可选参数和位置可选参数<br>但两种可选不能同时使用</p>\n<ul>\n<li><p>命名可选参数使用大括号<code>{}</code>，默认值用冒号<code>:</code></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FunX(a, &#123;b, c:<span class=\"number\">3</span>, d:<span class=\"number\">4</span>, e&#125;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$a</span> <span class=\"subst\">$b</span> <span class=\"subst\">$c</span> <span class=\"subst\">$d</span> <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>位置可选参数使用方括号<code>[]</code>，默认值用等号<code>=</code></p>\n</li>\n</ul>\n<p>在位置可选参数的函数中，大括号内的参数可以指定0个或多个在调用的时候参数值会依次按顺序赋值。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FunY(a, [b, c=<span class=\"number\">3</span>, d=<span class=\"number\">4</span>, e])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$a</span> <span class=\"subst\">$b</span> <span class=\"subst\">$c</span> <span class=\"subst\">$d</span> <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  FunX(<span class=\"number\">1</span>, b:<span class=\"number\">3</span>, d:<span class=\"number\">5</span>);</span><br><span class=\"line\">  FunY(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Dart流程控制","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-17T11:24:00.000Z","_content":"\n> 流程控制在大部分语言中大同小异，在Dart中只有最后一个assert比较特殊。\n### 常用流程控制\n- if 和 else\n- for循环\n- while和do-while循环\n- break和continue\n- switch和case\n- assert\n\n### if 和 else\n> 与JavaScript不同的是，条件必须使用布尔值，不允许其他值。\n\n### For循环\n```Dart\n// 基本For循环\nvar message = StringBuffer('Dart is fun');\nfor (var i = 0; i < 5; i++) {\n  message.write('!');\n}\n\n// Dart for循环内部的闭包捕获了索引的值，避免了JavaScript中常见的陷阱。例如:\nvar callbacks = [];\nfor (var i = 0; i < 2; i++) {\n  callbacks.add(() => print(i));\n}\ncallbacks.forEach((c) => c());\n\n```\n\n### While 和 do-while 循环\n```Dart\n// while循环在循环之前先检验条件是否为真\nwhile (!isDone()) {\n  doSomething();\n}\n\n// do-while循环在一次循环结束之后检查条件是否为真\ndo {\n  printLine();\n} while (!atEndOfPage());\n// 所以使用while和do-while要非常小心，因为使用do-while如果条件为假也会至少执行一次循环体中的语句。\n```\n\n### Break 和 continue\n\n```Dart\n// 使用break终止循环：\nwhile (true) {\n  if (shutDownRequested()) break;\n  processIncomingRequests();\n}\n\n// 使用continue跳出本次循环继续下次循环：\nfor (int i = 0; i < candidates.length; i++) {\n  var candidate = candidates[i];\n  if (candidate.yearsExperience < 5) {\n    continue;\n  }\n  candidate.interview();\n}\n\n```\n\n### 可迭代的循环\n```Dart\n// 如果你使用的是可迭代的，比如列表或集合，你可能会用不同的方式来写这个例子:\ncandidates\n    .where((c) => c.yearsExperience >= 5)\n    .forEach((c) => c.interview());\n\nclass A {\n  var yearsExperience;\n  A(int year)\n  {\n    this.yearsExperience = year;\n  }\n  interview() {\n    print(this.yearsExperience);\n  }\n}\n\nvoid main() {\n  List personList = [\n    A(1),\n    A(2),\n    A(5),\n    A(6)\n  ];\n\n  ///第一种写法\n  for(int i = 0; i < personList.length; i++) {\n    var person = personList[i];\n    if (person.yearsExperience < 5) {\n      continue;\n    }\n\n    person.interview();\n  }\n\n  ///第二种写法\n  personList\n      .where((c) => c.yearsExperience >= 5)\n      .forEach((c) => c.interview());\n\n}\n```\n>两次结果都相同，那么这儿的where()方法究竟是什么呢，我们在后续会接触到，他是dart.core中的iterable.dart中的方法，他返回复合where()中条件的集合视图，所以在where()后边我们可以继续调用forEach()，当然如果where()返回的集合视图为空也不会出现错误，仅仅是forEach()不执行而已。这儿where()的作用类似于过滤器。\n\n### switch 和 case\n在Dart中switch语句使用 “==”运算来比较整数，字符串或者编译时常量。被比较对象必须都是同一个类的实例(而不是它的任何子类型)，并且这个类不能重写“==”操作。枚举类型在switch语句是一种非常好的应用场景。\n\n>注意:Dart中的Switch语句适用于有限的情况，例如在解释器或扫描器中。\n\nswitch的规则是每个非空的case子句以一个break语句结束。结束非空case子句的其他有效方法是continue、throw或return语句。\n\n当没有case子句匹配时，使用default子句执行代码:\n```Dart\nvar command = 'OPEN';\nswitch (command) {\n  case 'CLOSED':\n    executeClosed();\n    break;\n  case 'PENDING':\n    executePending();\n    break;\n  case 'APPROVED':\n    executeApproved();\n    break;\n  case 'DENIED':\n    executeDenied();\n    break;\n  case 'OPEN':\n    executeOpen();\n    break;\n  default:\n    executeUnknown();\n}\n```\n下面的示例省略了case子句中的break语句，从而产生错误:\n```Dart\nvar command = 'OPEN';\nswitch (command) {\n  case 'OPEN':\n    executeOpen();\n    // ERROR: Missing break\n\n  case 'CLOSED':\n    executeClosed();\n    break;\n}\n```\n然而，Dart支持空的case子句,支持fall-through的格式:\n```Dart\nvar command = 'CLOSED';\nswitch (command) {\n  case 'CLOSED': // Empty case falls through.\n  case 'NOW_CLOSED':\n    // 无论command是CLOSED还是NOW_CLOSED都执行\n    executeNowClosed();\n    break;\n}\n```\n如果你真的需要使用fall-through格式，你可以使用continue语句和一个标签，例如：\n```Dart\nvar command = 'CLOSED';\nswitch (command) {\n  case 'CLOSED':\n    executeClosed();\n    continue nowClosed;\n  // Continues executing at the nowClosed label.\n\n  nowClosed:\n  case 'NOW_CLOSED':\n    // Runs for both CLOSED and NOW_CLOSED.\n    executeNowClosed();\n    break;\n}\n```\ncase子句可以有局部变量，只能在该子句的范围内可见。\n\n### Assert (断言)\n如果布尔条件为false，则使用assert语句中断正常执行。\n> Assert语句不会影响生产环境中代码的执行，它仅仅在测试环境中起作用。在Flutter的调试模式下可以使用assert。默认情况下，像(dartdevc typically)只支持开发环境的工具默认支持assert。例如dart和dart2js通过命令行标记：--enable-asserts来支持asserts。\n\n要将提示消息附加到断言，请添加一个字符串作为第二个参数。\n```Dart\nassert(urlString.startsWith('https'),\n    'URL ($urlString) should start with \"https\".');\n```\n断言的第一个参数可以是任何解析为布尔值的表达式。如果表达式的值为true，则断言成功并继续执行。如果是false，则断言失败，并抛出异常(AssertionError)。\n","source":"_posts/dart/05_Dart流程控制.md","raw":"---\ntitle: Dart流程控制\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-17 19:24:00   \n---\n\n> 流程控制在大部分语言中大同小异，在Dart中只有最后一个assert比较特殊。\n### 常用流程控制\n- if 和 else\n- for循环\n- while和do-while循环\n- break和continue\n- switch和case\n- assert\n\n### if 和 else\n> 与JavaScript不同的是，条件必须使用布尔值，不允许其他值。\n\n### For循环\n```Dart\n// 基本For循环\nvar message = StringBuffer('Dart is fun');\nfor (var i = 0; i < 5; i++) {\n  message.write('!');\n}\n\n// Dart for循环内部的闭包捕获了索引的值，避免了JavaScript中常见的陷阱。例如:\nvar callbacks = [];\nfor (var i = 0; i < 2; i++) {\n  callbacks.add(() => print(i));\n}\ncallbacks.forEach((c) => c());\n\n```\n\n### While 和 do-while 循环\n```Dart\n// while循环在循环之前先检验条件是否为真\nwhile (!isDone()) {\n  doSomething();\n}\n\n// do-while循环在一次循环结束之后检查条件是否为真\ndo {\n  printLine();\n} while (!atEndOfPage());\n// 所以使用while和do-while要非常小心，因为使用do-while如果条件为假也会至少执行一次循环体中的语句。\n```\n\n### Break 和 continue\n\n```Dart\n// 使用break终止循环：\nwhile (true) {\n  if (shutDownRequested()) break;\n  processIncomingRequests();\n}\n\n// 使用continue跳出本次循环继续下次循环：\nfor (int i = 0; i < candidates.length; i++) {\n  var candidate = candidates[i];\n  if (candidate.yearsExperience < 5) {\n    continue;\n  }\n  candidate.interview();\n}\n\n```\n\n### 可迭代的循环\n```Dart\n// 如果你使用的是可迭代的，比如列表或集合，你可能会用不同的方式来写这个例子:\ncandidates\n    .where((c) => c.yearsExperience >= 5)\n    .forEach((c) => c.interview());\n\nclass A {\n  var yearsExperience;\n  A(int year)\n  {\n    this.yearsExperience = year;\n  }\n  interview() {\n    print(this.yearsExperience);\n  }\n}\n\nvoid main() {\n  List personList = [\n    A(1),\n    A(2),\n    A(5),\n    A(6)\n  ];\n\n  ///第一种写法\n  for(int i = 0; i < personList.length; i++) {\n    var person = personList[i];\n    if (person.yearsExperience < 5) {\n      continue;\n    }\n\n    person.interview();\n  }\n\n  ///第二种写法\n  personList\n      .where((c) => c.yearsExperience >= 5)\n      .forEach((c) => c.interview());\n\n}\n```\n>两次结果都相同，那么这儿的where()方法究竟是什么呢，我们在后续会接触到，他是dart.core中的iterable.dart中的方法，他返回复合where()中条件的集合视图，所以在where()后边我们可以继续调用forEach()，当然如果where()返回的集合视图为空也不会出现错误，仅仅是forEach()不执行而已。这儿where()的作用类似于过滤器。\n\n### switch 和 case\n在Dart中switch语句使用 “==”运算来比较整数，字符串或者编译时常量。被比较对象必须都是同一个类的实例(而不是它的任何子类型)，并且这个类不能重写“==”操作。枚举类型在switch语句是一种非常好的应用场景。\n\n>注意:Dart中的Switch语句适用于有限的情况，例如在解释器或扫描器中。\n\nswitch的规则是每个非空的case子句以一个break语句结束。结束非空case子句的其他有效方法是continue、throw或return语句。\n\n当没有case子句匹配时，使用default子句执行代码:\n```Dart\nvar command = 'OPEN';\nswitch (command) {\n  case 'CLOSED':\n    executeClosed();\n    break;\n  case 'PENDING':\n    executePending();\n    break;\n  case 'APPROVED':\n    executeApproved();\n    break;\n  case 'DENIED':\n    executeDenied();\n    break;\n  case 'OPEN':\n    executeOpen();\n    break;\n  default:\n    executeUnknown();\n}\n```\n下面的示例省略了case子句中的break语句，从而产生错误:\n```Dart\nvar command = 'OPEN';\nswitch (command) {\n  case 'OPEN':\n    executeOpen();\n    // ERROR: Missing break\n\n  case 'CLOSED':\n    executeClosed();\n    break;\n}\n```\n然而，Dart支持空的case子句,支持fall-through的格式:\n```Dart\nvar command = 'CLOSED';\nswitch (command) {\n  case 'CLOSED': // Empty case falls through.\n  case 'NOW_CLOSED':\n    // 无论command是CLOSED还是NOW_CLOSED都执行\n    executeNowClosed();\n    break;\n}\n```\n如果你真的需要使用fall-through格式，你可以使用continue语句和一个标签，例如：\n```Dart\nvar command = 'CLOSED';\nswitch (command) {\n  case 'CLOSED':\n    executeClosed();\n    continue nowClosed;\n  // Continues executing at the nowClosed label.\n\n  nowClosed:\n  case 'NOW_CLOSED':\n    // Runs for both CLOSED and NOW_CLOSED.\n    executeNowClosed();\n    break;\n}\n```\ncase子句可以有局部变量，只能在该子句的范围内可见。\n\n### Assert (断言)\n如果布尔条件为false，则使用assert语句中断正常执行。\n> Assert语句不会影响生产环境中代码的执行，它仅仅在测试环境中起作用。在Flutter的调试模式下可以使用assert。默认情况下，像(dartdevc typically)只支持开发环境的工具默认支持assert。例如dart和dart2js通过命令行标记：--enable-asserts来支持asserts。\n\n要将提示消息附加到断言，请添加一个字符串作为第二个参数。\n```Dart\nassert(urlString.startsWith('https'),\n    'URL ($urlString) should start with \"https\".');\n```\n断言的第一个参数可以是任何解析为布尔值的表达式。如果表达式的值为true，则断言成功并继续执行。如果是false，则断言失败，并抛出异常(AssertionError)。\n","slug":"dart/05_Dart流程控制","published":1,"updated":"2019-10-02T09:23:43.149Z","layout":"post","photos":[],"link":"","_id":"ck19bvaq3000b00wkg9xx6t04","content":"<blockquote>\n<p>流程控制在大部分语言中大同小异，在Dart中只有最后一个assert比较特殊。</p>\n</blockquote>\n<h3 id=\"常用流程控制\"><a href=\"#常用流程控制\" class=\"headerlink\" title=\"常用流程控制\"></a>常用流程控制</h3><ul>\n<li>if 和 else</li>\n<li>for循环</li>\n<li>while和do-while循环</li>\n<li>break和continue</li>\n<li>switch和case</li>\n<li>assert</li>\n</ul>\n<h3 id=\"if-和-else\"><a href=\"#if-和-else\" class=\"headerlink\" title=\"if 和 else\"></a>if 和 else</h3><blockquote>\n<p>与JavaScript不同的是，条件必须使用布尔值，不允许其他值。</p>\n</blockquote>\n<h3 id=\"For循环\"><a href=\"#For循环\" class=\"headerlink\" title=\"For循环\"></a>For循环</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本For循环</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"built_in\">StringBuffer</span>(<span class=\"string\">'Dart is fun'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  message.write(<span class=\"string\">'!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dart for循环内部的闭包捕获了索引的值，避免了JavaScript中常见的陷阱。例如:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> callbacks = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">  callbacks.add(() =&gt; <span class=\"built_in\">print</span>(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">callbacks.forEach((c) =&gt; c());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"While-和-do-while-循环\"><a href=\"#While-和-do-while-循环\" class=\"headerlink\" title=\"While 和 do-while 循环\"></a>While 和 do-while 循环</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// while循环在循环之前先检验条件是否为真</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!isDone()) &#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// do-while循环在一次循环结束之后检查条件是否为真</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  printLine();</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (!atEndOfPage());</span><br><span class=\"line\"><span class=\"comment\">// 所以使用while和do-while要非常小心，因为使用do-while如果条件为假也会至少执行一次循环体中的语句。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Break-和-continue\"><a href=\"#Break-和-continue\" class=\"headerlink\" title=\"Break 和 continue\"></a>Break 和 continue</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用break终止循环：</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shutDownRequested()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  processIncomingRequests();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用continue跳出本次循环继续下次循环：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> candidate = candidates[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (candidate.yearsExperience &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  candidate.interview();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可迭代的循环\"><a href=\"#可迭代的循环\" class=\"headerlink\" title=\"可迭代的循环\"></a>可迭代的循环</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果你使用的是可迭代的，比如列表或集合，你可能会用不同的方式来写这个例子:</span></span><br><span class=\"line\">candidates</span><br><span class=\"line\">    .where((c) =&gt; c.yearsExperience &gt;= <span class=\"number\">5</span>)</span><br><span class=\"line\">    .forEach((c) =&gt; c.interview());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> yearsExperience;</span><br><span class=\"line\">  A(<span class=\"built_in\">int</span> year)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.yearsExperience = year;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  interview() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"keyword\">this</span>.yearsExperience);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> personList = [</span><br><span class=\"line\">    A(<span class=\"number\">1</span>),</span><br><span class=\"line\">    A(<span class=\"number\">2</span>),</span><br><span class=\"line\">    A(<span class=\"number\">5</span>),</span><br><span class=\"line\">    A(<span class=\"number\">6</span>)</span><br><span class=\"line\">  ];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///第一种写法</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; personList.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> person = personList[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (person.yearsExperience &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    person.interview();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///第二种写法</span></span><br><span class=\"line\">  personList</span><br><span class=\"line\">      .where((c) =&gt; c.yearsExperience &gt;= <span class=\"number\">5</span>)</span><br><span class=\"line\">      .forEach((c) =&gt; c.interview());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>两次结果都相同，那么这儿的where()方法究竟是什么呢，我们在后续会接触到，他是dart.core中的iterable.dart中的方法，他返回复合where()中条件的集合视图，所以在where()后边我们可以继续调用forEach()，当然如果where()返回的集合视图为空也不会出现错误，仅仅是forEach()不执行而已。这儿where()的作用类似于过滤器。</p>\n</blockquote>\n<h3 id=\"switch-和-case\"><a href=\"#switch-和-case\" class=\"headerlink\" title=\"switch 和 case\"></a>switch 和 case</h3><p>在Dart中switch语句使用 “==”运算来比较整数，字符串或者编译时常量。被比较对象必须都是同一个类的实例(而不是它的任何子类型)，并且这个类不能重写“==”操作。枚举类型在switch语句是一种非常好的应用场景。</p>\n<blockquote>\n<p>注意:Dart中的Switch语句适用于有限的情况，例如在解释器或扫描器中。</p>\n</blockquote>\n<p>switch的规则是每个非空的case子句以一个break语句结束。结束非空case子句的其他有效方法是continue、throw或return语句。</p>\n<p>当没有case子句匹配时，使用default子句执行代码:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'OPEN'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>:</span><br><span class=\"line\">    executeClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'PENDING'</span>:</span><br><span class=\"line\">    executePending();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'APPROVED'</span>:</span><br><span class=\"line\">    executeApproved();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'DENIED'</span>:</span><br><span class=\"line\">    executeDenied();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'OPEN'</span>:</span><br><span class=\"line\">    executeOpen();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    executeUnknown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的示例省略了case子句中的break语句，从而产生错误:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'OPEN'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'OPEN'</span>:</span><br><span class=\"line\">    executeOpen();</span><br><span class=\"line\">    <span class=\"comment\">// ERROR: Missing break</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>:</span><br><span class=\"line\">    executeClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然而，Dart支持空的case子句,支持fall-through的格式:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'CLOSED'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>: <span class=\"comment\">// Empty case falls through.</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'NOW_CLOSED'</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 无论command是CLOSED还是NOW_CLOSED都执行</span></span><br><span class=\"line\">    executeNowClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你真的需要使用fall-through格式，你可以使用continue语句和一个标签，例如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'CLOSED'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>:</span><br><span class=\"line\">    executeClosed();</span><br><span class=\"line\">    <span class=\"keyword\">continue</span> nowClosed;</span><br><span class=\"line\">  <span class=\"comment\">// Continues executing at the nowClosed label.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  nowClosed:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'NOW_CLOSED'</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class=\"line\">    executeNowClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>case子句可以有局部变量，只能在该子句的范围内可见。</p>\n<h3 id=\"Assert-断言\"><a href=\"#Assert-断言\" class=\"headerlink\" title=\"Assert (断言)\"></a>Assert (断言)</h3><p>如果布尔条件为false，则使用assert语句中断正常执行。</p>\n<blockquote>\n<p>Assert语句不会影响生产环境中代码的执行，它仅仅在测试环境中起作用。在Flutter的调试模式下可以使用assert。默认情况下，像(dartdevc typically)只支持开发环境的工具默认支持assert。例如dart和dart2js通过命令行标记：–enable-asserts来支持asserts。</p>\n</blockquote>\n<p>要将提示消息附加到断言，请添加一个字符串作为第二个参数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(urlString.startsWith(<span class=\"string\">'https'</span>),</span><br><span class=\"line\">    <span class=\"string\">'URL (<span class=\"subst\">$urlString</span>) should start with \"https\".'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>断言的第一个参数可以是任何解析为布尔值的表达式。如果表达式的值为true，则断言成功并继续执行。如果是false，则断言失败，并抛出异常(AssertionError)。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>流程控制在大部分语言中大同小异，在Dart中只有最后一个assert比较特殊。</p>\n</blockquote>\n<h3 id=\"常用流程控制\"><a href=\"#常用流程控制\" class=\"headerlink\" title=\"常用流程控制\"></a>常用流程控制</h3><ul>\n<li>if 和 else</li>\n<li>for循环</li>\n<li>while和do-while循环</li>\n<li>break和continue</li>\n<li>switch和case</li>\n<li>assert</li>\n</ul>\n<h3 id=\"if-和-else\"><a href=\"#if-和-else\" class=\"headerlink\" title=\"if 和 else\"></a>if 和 else</h3><blockquote>\n<p>与JavaScript不同的是，条件必须使用布尔值，不允许其他值。</p>\n</blockquote>\n<h3 id=\"For循环\"><a href=\"#For循环\" class=\"headerlink\" title=\"For循环\"></a>For循环</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本For循环</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"built_in\">StringBuffer</span>(<span class=\"string\">'Dart is fun'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  message.write(<span class=\"string\">'!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dart for循环内部的闭包捕获了索引的值，避免了JavaScript中常见的陷阱。例如:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> callbacks = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">  callbacks.add(() =&gt; <span class=\"built_in\">print</span>(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">callbacks.forEach((c) =&gt; c());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"While-和-do-while-循环\"><a href=\"#While-和-do-while-循环\" class=\"headerlink\" title=\"While 和 do-while 循环\"></a>While 和 do-while 循环</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// while循环在循环之前先检验条件是否为真</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!isDone()) &#123;</span><br><span class=\"line\">  doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// do-while循环在一次循环结束之后检查条件是否为真</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  printLine();</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (!atEndOfPage());</span><br><span class=\"line\"><span class=\"comment\">// 所以使用while和do-while要非常小心，因为使用do-while如果条件为假也会至少执行一次循环体中的语句。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Break-和-continue\"><a href=\"#Break-和-continue\" class=\"headerlink\" title=\"Break 和 continue\"></a>Break 和 continue</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用break终止循环：</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shutDownRequested()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  processIncomingRequests();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用continue跳出本次循环继续下次循环：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> candidate = candidates[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (candidate.yearsExperience &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  candidate.interview();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可迭代的循环\"><a href=\"#可迭代的循环\" class=\"headerlink\" title=\"可迭代的循环\"></a>可迭代的循环</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果你使用的是可迭代的，比如列表或集合，你可能会用不同的方式来写这个例子:</span></span><br><span class=\"line\">candidates</span><br><span class=\"line\">    .where((c) =&gt; c.yearsExperience &gt;= <span class=\"number\">5</span>)</span><br><span class=\"line\">    .forEach((c) =&gt; c.interview());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> yearsExperience;</span><br><span class=\"line\">  A(<span class=\"built_in\">int</span> year)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.yearsExperience = year;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  interview() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"keyword\">this</span>.yearsExperience);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> personList = [</span><br><span class=\"line\">    A(<span class=\"number\">1</span>),</span><br><span class=\"line\">    A(<span class=\"number\">2</span>),</span><br><span class=\"line\">    A(<span class=\"number\">5</span>),</span><br><span class=\"line\">    A(<span class=\"number\">6</span>)</span><br><span class=\"line\">  ];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///第一种写法</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; personList.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> person = personList[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (person.yearsExperience &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    person.interview();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///第二种写法</span></span><br><span class=\"line\">  personList</span><br><span class=\"line\">      .where((c) =&gt; c.yearsExperience &gt;= <span class=\"number\">5</span>)</span><br><span class=\"line\">      .forEach((c) =&gt; c.interview());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>两次结果都相同，那么这儿的where()方法究竟是什么呢，我们在后续会接触到，他是dart.core中的iterable.dart中的方法，他返回复合where()中条件的集合视图，所以在where()后边我们可以继续调用forEach()，当然如果where()返回的集合视图为空也不会出现错误，仅仅是forEach()不执行而已。这儿where()的作用类似于过滤器。</p>\n</blockquote>\n<h3 id=\"switch-和-case\"><a href=\"#switch-和-case\" class=\"headerlink\" title=\"switch 和 case\"></a>switch 和 case</h3><p>在Dart中switch语句使用 “==”运算来比较整数，字符串或者编译时常量。被比较对象必须都是同一个类的实例(而不是它的任何子类型)，并且这个类不能重写“==”操作。枚举类型在switch语句是一种非常好的应用场景。</p>\n<blockquote>\n<p>注意:Dart中的Switch语句适用于有限的情况，例如在解释器或扫描器中。</p>\n</blockquote>\n<p>switch的规则是每个非空的case子句以一个break语句结束。结束非空case子句的其他有效方法是continue、throw或return语句。</p>\n<p>当没有case子句匹配时，使用default子句执行代码:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'OPEN'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>:</span><br><span class=\"line\">    executeClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'PENDING'</span>:</span><br><span class=\"line\">    executePending();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'APPROVED'</span>:</span><br><span class=\"line\">    executeApproved();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'DENIED'</span>:</span><br><span class=\"line\">    executeDenied();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'OPEN'</span>:</span><br><span class=\"line\">    executeOpen();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    executeUnknown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的示例省略了case子句中的break语句，从而产生错误:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'OPEN'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'OPEN'</span>:</span><br><span class=\"line\">    executeOpen();</span><br><span class=\"line\">    <span class=\"comment\">// ERROR: Missing break</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>:</span><br><span class=\"line\">    executeClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然而，Dart支持空的case子句,支持fall-through的格式:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'CLOSED'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>: <span class=\"comment\">// Empty case falls through.</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'NOW_CLOSED'</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 无论command是CLOSED还是NOW_CLOSED都执行</span></span><br><span class=\"line\">    executeNowClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你真的需要使用fall-through格式，你可以使用continue语句和一个标签，例如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> command = <span class=\"string\">'CLOSED'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (command) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'CLOSED'</span>:</span><br><span class=\"line\">    executeClosed();</span><br><span class=\"line\">    <span class=\"keyword\">continue</span> nowClosed;</span><br><span class=\"line\">  <span class=\"comment\">// Continues executing at the nowClosed label.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  nowClosed:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'NOW_CLOSED'</span>:</span><br><span class=\"line\">    <span class=\"comment\">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class=\"line\">    executeNowClosed();</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>case子句可以有局部变量，只能在该子句的范围内可见。</p>\n<h3 id=\"Assert-断言\"><a href=\"#Assert-断言\" class=\"headerlink\" title=\"Assert (断言)\"></a>Assert (断言)</h3><p>如果布尔条件为false，则使用assert语句中断正常执行。</p>\n<blockquote>\n<p>Assert语句不会影响生产环境中代码的执行，它仅仅在测试环境中起作用。在Flutter的调试模式下可以使用assert。默认情况下，像(dartdevc typically)只支持开发环境的工具默认支持assert。例如dart和dart2js通过命令行标记：–enable-asserts来支持asserts。</p>\n</blockquote>\n<p>要将提示消息附加到断言，请添加一个字符串作为第二个参数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(urlString.startsWith(<span class=\"string\">'https'</span>),</span><br><span class=\"line\">    <span class=\"string\">'URL (<span class=\"subst\">$urlString</span>) should start with \"https\".'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>断言的第一个参数可以是任何解析为布尔值的表达式。如果表达式的值为true，则断言成功并继续执行。如果是false，则断言失败，并抛出异常(AssertionError)。</p>\n"},{"title":"Dart异常处理","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-17T15:24:00.000Z","_content":"## Exceptions\n你的Dart代码可以抛出和捕获异常。异常是指程序执行中发生的意料之外的错误。如果没有捕获异常，引发异常的隔离程序将被挂起，通常隔离程序及其程序将被终止。\n\n与Java相反，Dart的所有异常都是未检查的异常。方法不声明它们可能抛出哪些异常，也不要求您捕获任何异常。\n\nDart提供Exception和Error类型，以及许多预定义的子类型。当然你可以自己定义异常。但是，Dart程序可以抛出任何非空对象不仅仅是异常和错误对象。\n\n## Throw\n这里有一个抛出或挂起异常的例子:\n```Dart\nthrow FormatException('Expected at least 1 section');\n```\n你也可以抛出任意对象:\n```Dart\nthrow 'Out of llamas!';\n```\n> 注意：在正式使用中通常抛出的是实现了Error或Exception类型的对象；\n\n因为抛出异常是一个 表达式 ，您可以在=>语句中抛出异常，也可以在任何允许表达式的地方抛出异常:\n```Dart\nvoid distanceTo(Point other) => throw UnimplementedError();\n```\n## Catch\n捕获异常将阻止异常传播(除非重新抛出异常)。捕获异常后我们可以去判断并处理相应的异常。\n```Dart\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  buyMoreLlamas();\n}\n```\n要处理可以抛出多种异常类型的代码，可以指定多个catch子句。与抛出对象的类型匹配的第一个catch子句处理异常。如果catch子句没有指定类型，则该子句可以处理任何类型的抛出对象:\n```Dart\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  // A specific exception\n  buyMoreLlamas();\n} on Exception catch (e) {\n  // Anything else that is an exception\n  print('Unknown exception: $e');\n} catch (e) {\n  // No specified type, handles all\n  print('Something really unknown: $e');\n}\n```\n正如前面的代码所示，您可以使用on或catch或both。在需要指定异常类型时使用。当您的异常处理程序需要异常对象时，请使用catch。\n\n可以指定catch()的一个或两个参数。第一个是抛出的异常，第二个是堆栈跟踪(StackTrace对象)。\n```Dart\ntry {\n  // ···\n} on Exception catch (e) {\n  print('Exception details:\\n $e');\n} catch (e, s) {\n  print('Exception details:\\n $e');\n  print('Stack trace:\\n $s');\n}\n```\n要在捕获中处理异常，同时允许其继续传播，请使用rethrow关键字。\n```Dart\nvoid misbehave() {\n  try {\n    dynamic foo = true;\n    print(foo++); // Runtime error\n  } catch (e) {\n    print('misbehave() partially handled ${e.runtimeType}.');\n    rethrow; // Allow callers to see the exception.\n  }\n}\n\nvoid main() {\n  try {\n    misbehave();\n  } catch (e) {\n    print('main() finished handling ${e.runtimeType}.');\n  }\n}\n```\n## Finally\n要确保在抛出异常时运行某些业务代码，请使用finally子句。如果没有catch子句匹配异常，则在finally子句运行后传播异常:\n```Dart\ntry {\n  breedMoreLlamas();\n} finally {\n  // Always clean up, even if an exception is thrown.\n  cleanLlamaStalls();\n}\n```\nfinally子句在所有匹配到的catch子句之后运行:\n```Dart\ntry {\n  breedMoreLlamas();\n} catch (e) {\n  print('Error: $e'); // Handle the exception first.\n} finally {\n  cleanLlamaStalls(); // Then clean up.\n}\n```\n","source":"_posts/dart/06_Dart异常处理.md","raw":"---\ntitle: Dart异常处理\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-17 23:24:00   \n---\n## Exceptions\n你的Dart代码可以抛出和捕获异常。异常是指程序执行中发生的意料之外的错误。如果没有捕获异常，引发异常的隔离程序将被挂起，通常隔离程序及其程序将被终止。\n\n与Java相反，Dart的所有异常都是未检查的异常。方法不声明它们可能抛出哪些异常，也不要求您捕获任何异常。\n\nDart提供Exception和Error类型，以及许多预定义的子类型。当然你可以自己定义异常。但是，Dart程序可以抛出任何非空对象不仅仅是异常和错误对象。\n\n## Throw\n这里有一个抛出或挂起异常的例子:\n```Dart\nthrow FormatException('Expected at least 1 section');\n```\n你也可以抛出任意对象:\n```Dart\nthrow 'Out of llamas!';\n```\n> 注意：在正式使用中通常抛出的是实现了Error或Exception类型的对象；\n\n因为抛出异常是一个 表达式 ，您可以在=>语句中抛出异常，也可以在任何允许表达式的地方抛出异常:\n```Dart\nvoid distanceTo(Point other) => throw UnimplementedError();\n```\n## Catch\n捕获异常将阻止异常传播(除非重新抛出异常)。捕获异常后我们可以去判断并处理相应的异常。\n```Dart\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  buyMoreLlamas();\n}\n```\n要处理可以抛出多种异常类型的代码，可以指定多个catch子句。与抛出对象的类型匹配的第一个catch子句处理异常。如果catch子句没有指定类型，则该子句可以处理任何类型的抛出对象:\n```Dart\ntry {\n  breedMoreLlamas();\n} on OutOfLlamasException {\n  // A specific exception\n  buyMoreLlamas();\n} on Exception catch (e) {\n  // Anything else that is an exception\n  print('Unknown exception: $e');\n} catch (e) {\n  // No specified type, handles all\n  print('Something really unknown: $e');\n}\n```\n正如前面的代码所示，您可以使用on或catch或both。在需要指定异常类型时使用。当您的异常处理程序需要异常对象时，请使用catch。\n\n可以指定catch()的一个或两个参数。第一个是抛出的异常，第二个是堆栈跟踪(StackTrace对象)。\n```Dart\ntry {\n  // ···\n} on Exception catch (e) {\n  print('Exception details:\\n $e');\n} catch (e, s) {\n  print('Exception details:\\n $e');\n  print('Stack trace:\\n $s');\n}\n```\n要在捕获中处理异常，同时允许其继续传播，请使用rethrow关键字。\n```Dart\nvoid misbehave() {\n  try {\n    dynamic foo = true;\n    print(foo++); // Runtime error\n  } catch (e) {\n    print('misbehave() partially handled ${e.runtimeType}.');\n    rethrow; // Allow callers to see the exception.\n  }\n}\n\nvoid main() {\n  try {\n    misbehave();\n  } catch (e) {\n    print('main() finished handling ${e.runtimeType}.');\n  }\n}\n```\n## Finally\n要确保在抛出异常时运行某些业务代码，请使用finally子句。如果没有catch子句匹配异常，则在finally子句运行后传播异常:\n```Dart\ntry {\n  breedMoreLlamas();\n} finally {\n  // Always clean up, even if an exception is thrown.\n  cleanLlamaStalls();\n}\n```\nfinally子句在所有匹配到的catch子句之后运行:\n```Dart\ntry {\n  breedMoreLlamas();\n} catch (e) {\n  print('Error: $e'); // Handle the exception first.\n} finally {\n  cleanLlamaStalls(); // Then clean up.\n}\n```\n","slug":"dart/06_Dart异常处理","published":1,"updated":"2019-10-02T09:24:13.040Z","layout":"post","photos":[],"link":"","_id":"ck19bvaq7000d00wkeizv5tzg","content":"<h2 id=\"Exceptions\"><a href=\"#Exceptions\" class=\"headerlink\" title=\"Exceptions\"></a>Exceptions</h2><p>你的Dart代码可以抛出和捕获异常。异常是指程序执行中发生的意料之外的错误。如果没有捕获异常，引发异常的隔离程序将被挂起，通常隔离程序及其程序将被终止。</p>\n<p>与Java相反，Dart的所有异常都是未检查的异常。方法不声明它们可能抛出哪些异常，也不要求您捕获任何异常。</p>\n<p>Dart提供Exception和Error类型，以及许多预定义的子类型。当然你可以自己定义异常。但是，Dart程序可以抛出任何非空对象不仅仅是异常和错误对象。</p>\n<h2 id=\"Throw\"><a href=\"#Throw\" class=\"headerlink\" title=\"Throw\"></a>Throw</h2><p>这里有一个抛出或挂起异常的例子:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> FormatException(<span class=\"string\">'Expected at least 1 section'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>你也可以抛出任意对象:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'Out of llamas!'</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：在正式使用中通常抛出的是实现了Error或Exception类型的对象；</p>\n</blockquote>\n<p>因为抛出异常是一个 表达式 ，您可以在=&gt;语句中抛出异常，也可以在任何允许表达式的地方抛出异常:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> distanceTo(Point other) =&gt; <span class=\"keyword\">throw</span> UnimplementedError();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Catch\"><a href=\"#Catch\" class=\"headerlink\" title=\"Catch\"></a>Catch</h2><p>捕获异常将阻止异常传播(除非重新抛出异常)。捕获异常后我们可以去判断并处理相应的异常。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要处理可以抛出多种异常类型的代码，可以指定多个catch子句。与抛出对象的类型匹配的第一个catch子句处理异常。如果catch子句没有指定类型，则该子句可以处理任何类型的抛出对象:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A specific exception</span></span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Anything else that is an exception</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown exception: <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// No specified type, handles all</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Something really unknown: <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正如前面的代码所示，您可以使用on或catch或both。在需要指定异常类型时使用。当您的异常处理程序需要异常对象时，请使用catch。</p>\n<p>可以指定catch()的一个或两个参数。第一个是抛出的异常，第二个是堆栈跟踪(StackTrace对象)。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Exception details:\\n <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e, s) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Exception details:\\n <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Stack trace:\\n <span class=\"subst\">$s</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要在捕获中处理异常，同时允许其继续传播，请使用rethrow关键字。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> misbehave() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> foo = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(foo++); <span class=\"comment\">// Runtime error</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'misbehave() partially handled <span class=\"subst\">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">rethrow</span>; <span class=\"comment\">// Allow callers to see the exception.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    misbehave();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'main() finished handling <span class=\"subst\">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Finally\"><a href=\"#Finally\" class=\"headerlink\" title=\"Finally\"></a>Finally</h2><p>要确保在抛出异常时运行某些业务代码，请使用finally子句。如果没有catch子句匹配异常，则在finally子句运行后传播异常:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Always clean up, even if an exception is thrown.</span></span><br><span class=\"line\">  cleanLlamaStalls();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>finally子句在所有匹配到的catch子句之后运行:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Error: <span class=\"subst\">$e</span>'</span>); <span class=\"comment\">// Handle the exception first.</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  cleanLlamaStalls(); <span class=\"comment\">// Then clean up.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Exceptions\"><a href=\"#Exceptions\" class=\"headerlink\" title=\"Exceptions\"></a>Exceptions</h2><p>你的Dart代码可以抛出和捕获异常。异常是指程序执行中发生的意料之外的错误。如果没有捕获异常，引发异常的隔离程序将被挂起，通常隔离程序及其程序将被终止。</p>\n<p>与Java相反，Dart的所有异常都是未检查的异常。方法不声明它们可能抛出哪些异常，也不要求您捕获任何异常。</p>\n<p>Dart提供Exception和Error类型，以及许多预定义的子类型。当然你可以自己定义异常。但是，Dart程序可以抛出任何非空对象不仅仅是异常和错误对象。</p>\n<h2 id=\"Throw\"><a href=\"#Throw\" class=\"headerlink\" title=\"Throw\"></a>Throw</h2><p>这里有一个抛出或挂起异常的例子:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> FormatException(<span class=\"string\">'Expected at least 1 section'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>你也可以抛出任意对象:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">'Out of llamas!'</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：在正式使用中通常抛出的是实现了Error或Exception类型的对象；</p>\n</blockquote>\n<p>因为抛出异常是一个 表达式 ，您可以在=&gt;语句中抛出异常，也可以在任何允许表达式的地方抛出异常:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> distanceTo(Point other) =&gt; <span class=\"keyword\">throw</span> UnimplementedError();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Catch\"><a href=\"#Catch\" class=\"headerlink\" title=\"Catch\"></a>Catch</h2><p>捕获异常将阻止异常传播(除非重新抛出异常)。捕获异常后我们可以去判断并处理相应的异常。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要处理可以抛出多种异常类型的代码，可以指定多个catch子句。与抛出对象的类型匹配的第一个catch子句处理异常。如果catch子句没有指定类型，则该子句可以处理任何类型的抛出对象:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; on OutOfLlamasException &#123;</span><br><span class=\"line\">  <span class=\"comment\">// A specific exception</span></span><br><span class=\"line\">  buyMoreLlamas();</span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Anything else that is an exception</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Unknown exception: <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// No specified type, handles all</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Something really unknown: <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正如前面的代码所示，您可以使用on或catch或both。在需要指定异常类型时使用。当您的异常处理程序需要异常对象时，请使用catch。</p>\n<p>可以指定catch()的一个或两个参数。第一个是抛出的异常，第二个是堆栈跟踪(StackTrace对象)。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125; on Exception <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Exception details:\\n <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e, s) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Exception details:\\n <span class=\"subst\">$e</span>'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Stack trace:\\n <span class=\"subst\">$s</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要在捕获中处理异常，同时允许其继续传播，请使用rethrow关键字。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> misbehave() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">dynamic</span> foo = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(foo++); <span class=\"comment\">// Runtime error</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'misbehave() partially handled <span class=\"subst\">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">rethrow</span>; <span class=\"comment\">// Allow callers to see the exception.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    misbehave();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'main() finished handling <span class=\"subst\">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Finally\"><a href=\"#Finally\" class=\"headerlink\" title=\"Finally\"></a>Finally</h2><p>要确保在抛出异常时运行某些业务代码，请使用finally子句。如果没有catch子句匹配异常，则在finally子句运行后传播异常:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Always clean up, even if an exception is thrown.</span></span><br><span class=\"line\">  cleanLlamaStalls();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>finally子句在所有匹配到的catch子句之后运行:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  breedMoreLlamas();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'Error: <span class=\"subst\">$e</span>'</span>); <span class=\"comment\">// Handle the exception first.</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  cleanLlamaStalls(); <span class=\"comment\">// Then clean up.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Dart运算符","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-17T09:24:00.000Z","_content":"### 按照运算符优先级高低进行排序\n\n描述|操作符\n--|--\n一元后置操作符|\texpr++    expr--    ()    []    .    ?.\n一元前置操作符|\t-expr    !expr    ~expr    ++expr    --expr\n乘除运算|\t*    /    %    ~/\n加减运算|\t+    -\n移位运算|\t<<    >>\n按位与|\t&\n按位异或|\t^\n按位或|\t`|`\n关系和类型测试|\t>=    >    <=    <    as    is    is!\n相等|\t==    ！=\n逻辑与|\t&&\n逻辑或|\t`||`\n是否为null|\t??\n天健判断（三元运算）|\texpr1 ? expr2 : expr3\n级联|\t..\n赋值|\t=    *=    /=    ~/=    %=    +=    -=    <<=    >>=    &=    ^=   \n> 当使用操作符后，就变成了表达式。\n\n### 算术运算符\n\n运算符|说明\n--|--\n+ | 加法\n- | 减法\n-expr | 一元减号，也称为否定\n*  | 乘法\n/ | 除法\n~/  | 取模运算\n%  | 取余运算\n\n```Dart\nassert(2 + 3 == 5);\nassert(2 - 3 == -1);\nassert(2 * 3 == 6);\nassert(5 / 2 == 2.5); // Result is a double\nassert(5 ~/ 2 == 2); // Result is an int\nassert(5 % 2 == 1); // Remainder\n\nassert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');\n\n\n// Dart还支持前缀和后缀递增和递减运算符。\nvar a, b;\n\na = 0;\nb = ++a; // Increment a before b gets its value.\nassert(a == b); // 1 == 1\n\na = 0;\nb = a++; // Increment a AFTER b gets its value.\nassert(a != b); // 1 != 0\n\na = 0;\nb = --a; // Decrement a before b gets its value.\nassert(a == b); // -1 == -1\n\na = 0;\nb = a--; // Decrement a AFTER b gets its value.\nassert(a != b); // -1 != 0\n```\n\n### 相等和关系运算符\n\n运算符|说明\n--|--\n==|\t相等\n!=|\t不等\n>|\t大于\n<|\t小于\n>=|\t大于等于\n<=|\t小于等于\n\n### 类型测试操作符\n> a, is, and is!操作符可以方便地在运行时检查类型。\n\n运算符|说明\n--|--\nas|\t形态转换\nis|\t如果对象具有指定的类型，则为True\nis!|\t如果对象具有指定的类型，则为False\n\n### 赋值运算符\n> ??=操作符仅仅在变量为null时会赋值。未初始化和后来手动赋值为null的情况都会执行此操作赋值。\n\n```Dart\n// Assign value to a\na = value;\n// Assign value to b if b is null; otherwise, b stays the same\n// 仅仅在b为空的情况下b被赋值value否则b的值不变\nb ??= value;\n```\n\n### 复合赋值操作符\n> 如+=将操作与赋值合并。\n\n`=`\t|`-=`|\t`/=`|\t`%=`|\t`>>=`|\t`^=`\n--|--|--|--|--|--\n`+=`|\t`*=`|\t`~/=`|\t`<<=`|\t`&=`|\t`|=`\n\n### 逻辑运算符\n> 可以使用逻辑运算符组合布尔表达式或取反布尔表达式。\n\n运算符\t|说明\n--|--\n`!expr` |\t对!后的表达式结果取反(如果表达式结果为false则表达式前加！使其变为true，反之亦然)\n`||`\t|逻辑或\n`&&`\t|逻辑与（且）\n\n### 位和移位运算\n运算符\t|说明\n--|--\n`&`\t|按位与\n`|`\t|按位或\n`^`\t|按位异或\n`~expr`\t|按位取反\n`<<`\t|左移\n`>>`\t|右移\n\n```Dart\nfinal value = 0x22;\nfinal bitmask = 0x0f;\n\nassert((value & bitmask) == 0x02); // AND\nassert((value & ~bitmask) == 0x20); // AND NOT\nassert((value | bitmask) == 0x2f); // OR\nassert((value ^ bitmask) == 0x2d); // XOR\nassert((value << 4) == 0x220); // Shift left\nassert((value >> 4) == 0x02); // Shift right\n```\n### 条件表达式\n```Dart\n// 如果条件为真，则计算expr1(并返回其值);否则，计算并返回expr2的值。\ncondition ? expr1 : expr2\n\n// 如果expr1是非空的，则返回其值;否则，计算并返回expr2的值。\nexpr1 ?? expr2\n\n// 基于布尔表达式的结果选择赋值\nvar visibility = isPublic ? 'public' : 'private';\n\n// 布尔表达式只想判断值是否为null\nString playerName(String name) => name ?? 'Guest';\n\n```\n\n### 级联表示法\n> `..` 允许您在同一个对象上创建一个操作序列。\n\n### 其它运算符\n运算符\t|名称|\t说明\n--|--|--\n`()`|\t功能函数|\t表示一个函数调用\n`[]`|\t访问列表|\t引用列表中指定索引处的值\n`·`\t|访问成员|\t表示表达式的属性;例如:foo.bar从表达式foo中选择属性bar，如果foo为null，会抛出异常\n`?.`\t|根据条件访问成员|\t和(.)相似，但是左边的操作数可以为空；例如： foo?.bar 从foo的表达式中选择bar属性，如果foo为空则返回null\n","source":"_posts/dart/04_Dart运算符.md","raw":"---\ntitle: Dart运算符\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-17 17:24:00   \n---\n### 按照运算符优先级高低进行排序\n\n描述|操作符\n--|--\n一元后置操作符|\texpr++    expr--    ()    []    .    ?.\n一元前置操作符|\t-expr    !expr    ~expr    ++expr    --expr\n乘除运算|\t*    /    %    ~/\n加减运算|\t+    -\n移位运算|\t<<    >>\n按位与|\t&\n按位异或|\t^\n按位或|\t`|`\n关系和类型测试|\t>=    >    <=    <    as    is    is!\n相等|\t==    ！=\n逻辑与|\t&&\n逻辑或|\t`||`\n是否为null|\t??\n天健判断（三元运算）|\texpr1 ? expr2 : expr3\n级联|\t..\n赋值|\t=    *=    /=    ~/=    %=    +=    -=    <<=    >>=    &=    ^=   \n> 当使用操作符后，就变成了表达式。\n\n### 算术运算符\n\n运算符|说明\n--|--\n+ | 加法\n- | 减法\n-expr | 一元减号，也称为否定\n*  | 乘法\n/ | 除法\n~/  | 取模运算\n%  | 取余运算\n\n```Dart\nassert(2 + 3 == 5);\nassert(2 - 3 == -1);\nassert(2 * 3 == 6);\nassert(5 / 2 == 2.5); // Result is a double\nassert(5 ~/ 2 == 2); // Result is an int\nassert(5 % 2 == 1); // Remainder\n\nassert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');\n\n\n// Dart还支持前缀和后缀递增和递减运算符。\nvar a, b;\n\na = 0;\nb = ++a; // Increment a before b gets its value.\nassert(a == b); // 1 == 1\n\na = 0;\nb = a++; // Increment a AFTER b gets its value.\nassert(a != b); // 1 != 0\n\na = 0;\nb = --a; // Decrement a before b gets its value.\nassert(a == b); // -1 == -1\n\na = 0;\nb = a--; // Decrement a AFTER b gets its value.\nassert(a != b); // -1 != 0\n```\n\n### 相等和关系运算符\n\n运算符|说明\n--|--\n==|\t相等\n!=|\t不等\n>|\t大于\n<|\t小于\n>=|\t大于等于\n<=|\t小于等于\n\n### 类型测试操作符\n> a, is, and is!操作符可以方便地在运行时检查类型。\n\n运算符|说明\n--|--\nas|\t形态转换\nis|\t如果对象具有指定的类型，则为True\nis!|\t如果对象具有指定的类型，则为False\n\n### 赋值运算符\n> ??=操作符仅仅在变量为null时会赋值。未初始化和后来手动赋值为null的情况都会执行此操作赋值。\n\n```Dart\n// Assign value to a\na = value;\n// Assign value to b if b is null; otherwise, b stays the same\n// 仅仅在b为空的情况下b被赋值value否则b的值不变\nb ??= value;\n```\n\n### 复合赋值操作符\n> 如+=将操作与赋值合并。\n\n`=`\t|`-=`|\t`/=`|\t`%=`|\t`>>=`|\t`^=`\n--|--|--|--|--|--\n`+=`|\t`*=`|\t`~/=`|\t`<<=`|\t`&=`|\t`|=`\n\n### 逻辑运算符\n> 可以使用逻辑运算符组合布尔表达式或取反布尔表达式。\n\n运算符\t|说明\n--|--\n`!expr` |\t对!后的表达式结果取反(如果表达式结果为false则表达式前加！使其变为true，反之亦然)\n`||`\t|逻辑或\n`&&`\t|逻辑与（且）\n\n### 位和移位运算\n运算符\t|说明\n--|--\n`&`\t|按位与\n`|`\t|按位或\n`^`\t|按位异或\n`~expr`\t|按位取反\n`<<`\t|左移\n`>>`\t|右移\n\n```Dart\nfinal value = 0x22;\nfinal bitmask = 0x0f;\n\nassert((value & bitmask) == 0x02); // AND\nassert((value & ~bitmask) == 0x20); // AND NOT\nassert((value | bitmask) == 0x2f); // OR\nassert((value ^ bitmask) == 0x2d); // XOR\nassert((value << 4) == 0x220); // Shift left\nassert((value >> 4) == 0x02); // Shift right\n```\n### 条件表达式\n```Dart\n// 如果条件为真，则计算expr1(并返回其值);否则，计算并返回expr2的值。\ncondition ? expr1 : expr2\n\n// 如果expr1是非空的，则返回其值;否则，计算并返回expr2的值。\nexpr1 ?? expr2\n\n// 基于布尔表达式的结果选择赋值\nvar visibility = isPublic ? 'public' : 'private';\n\n// 布尔表达式只想判断值是否为null\nString playerName(String name) => name ?? 'Guest';\n\n```\n\n### 级联表示法\n> `..` 允许您在同一个对象上创建一个操作序列。\n\n### 其它运算符\n运算符\t|名称|\t说明\n--|--|--\n`()`|\t功能函数|\t表示一个函数调用\n`[]`|\t访问列表|\t引用列表中指定索引处的值\n`·`\t|访问成员|\t表示表达式的属性;例如:foo.bar从表达式foo中选择属性bar，如果foo为null，会抛出异常\n`?.`\t|根据条件访问成员|\t和(.)相似，但是左边的操作数可以为空；例如： foo?.bar 从foo的表达式中选择bar属性，如果foo为空则返回null\n","slug":"dart/04_Dart运算符","published":1,"updated":"2019-10-02T09:23:02.239Z","layout":"post","photos":[],"link":"","_id":"ck19bvaqe000i00wklriutil8","content":"<h3 id=\"按照运算符优先级高低进行排序\"><a href=\"#按照运算符优先级高低进行排序\" class=\"headerlink\" title=\"按照运算符优先级高低进行排序\"></a>按照运算符优先级高低进行排序</h3><table>\n<thead>\n<tr>\n<th>描述</th>\n<th>操作符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一元后置操作符</td>\n<td>expr++    expr–    ()    []    .    ?.</td>\n</tr>\n<tr>\n<td>一元前置操作符</td>\n<td>-expr    !expr    ~expr    ++expr    –expr</td>\n</tr>\n<tr>\n<td>乘除运算</td>\n<td>*    /    %    ~/</td>\n</tr>\n<tr>\n<td>加减运算</td>\n<td>+    -</td>\n</tr>\n<tr>\n<td>移位运算</td>\n<td>&lt;&lt;    &gt;&gt;</td>\n</tr>\n<tr>\n<td>按位与</td>\n<td>&amp;</td>\n</tr>\n<tr>\n<td>按位异或</td>\n<td>^</td>\n</tr>\n<tr>\n<td>按位或</td>\n<td>`</td>\n</tr>\n<tr>\n<td>关系和类型测试</td>\n<td>&gt;=    &gt;    &lt;=    &lt;    as    is    is!</td>\n</tr>\n<tr>\n<td>相等</td>\n<td>==    ！=</td>\n</tr>\n<tr>\n<td>逻辑与</td>\n<td>&amp;&amp;</td>\n</tr>\n<tr>\n<td>逻辑或</td>\n<td>`</td>\n</tr>\n<tr>\n<td>是否为null</td>\n<td>??</td>\n</tr>\n<tr>\n<td>天健判断（三元运算）</td>\n<td>expr1 ? expr2 : expr3</td>\n</tr>\n<tr>\n<td>级联</td>\n<td>..</td>\n</tr>\n<tr>\n<td>赋值</td>\n<td>=    *=    /=    ~/=    %=    +=    -=    &lt;&lt;=    &gt;&gt;=    &amp;=    ^=</td>\n</tr>\n<tr>\n<td>&gt; 当使用操作符后，就变成了表达式。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>加法</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n</tr>\n<tr>\n<td>-expr</td>\n<td>一元减号，也称为否定</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法</td>\n</tr>\n<tr>\n<td>~/</td>\n<td>取模运算</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取余运算</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">2</span> + <span class=\"number\">3</span> == <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">2</span> - <span class=\"number\">3</span> == <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">2</span> * <span class=\"number\">3</span> == <span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">5</span> / <span class=\"number\">2</span> == <span class=\"number\">2.5</span>); <span class=\"comment\">// Result is a double</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">5</span> ~/ <span class=\"number\">2</span> == <span class=\"number\">2</span>); <span class=\"comment\">// Result is an int</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">5</span> % <span class=\"number\">2</span> == <span class=\"number\">1</span>); <span class=\"comment\">// Remainder</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"string\">'5/2 = <span class=\"subst\">$&#123;<span class=\"number\">5</span> ~/ <span class=\"number\">2</span>&#125;</span> r <span class=\"subst\">$&#123;<span class=\"number\">5</span> % <span class=\"number\">2</span>&#125;</span>'</span> == <span class=\"string\">'5/2 = 2 r 1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dart还支持前缀和后缀递增和递减运算符。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\">b = ++a; <span class=\"comment\">// Increment a before b gets its value.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(a == b); <span class=\"comment\">// 1 == 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\">b = a++; <span class=\"comment\">// Increment a AFTER b gets its value.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(a != b); <span class=\"comment\">// 1 != 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\">b = --a; <span class=\"comment\">// Decrement a before b gets its value.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(a == b); <span class=\"comment\">// -1 == -1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\">b = a--; <span class=\"comment\">// Decrement a AFTER b gets its value.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(a != b); <span class=\"comment\">// -1 != 0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"相等和关系运算符\"><a href=\"#相等和关系运算符\" class=\"headerlink\" title=\"相等和关系运算符\"></a>相等和关系运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>==</td>\n<td>相等</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不等</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n</tbody></table>\n<h3 id=\"类型测试操作符\"><a href=\"#类型测试操作符\" class=\"headerlink\" title=\"类型测试操作符\"></a>类型测试操作符</h3><blockquote>\n<p>a, is, and is!操作符可以方便地在运行时检查类型。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>as</td>\n<td>形态转换</td>\n</tr>\n<tr>\n<td>is</td>\n<td>如果对象具有指定的类型，则为True</td>\n</tr>\n<tr>\n<td>is!</td>\n<td>如果对象具有指定的类型，则为False</td>\n</tr>\n</tbody></table>\n<h3 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><blockquote>\n<p>??=操作符仅仅在变量为null时会赋值。未初始化和后来手动赋值为null的情况都会执行此操作赋值。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Assign value to a</span></span><br><span class=\"line\">a = value;</span><br><span class=\"line\"><span class=\"comment\">// Assign value to b if b is null; otherwise, b stays the same</span></span><br><span class=\"line\"><span class=\"comment\">// 仅仅在b为空的情况下b被赋值value否则b的值不变</span></span><br><span class=\"line\">b ??= value;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复合赋值操作符\"><a href=\"#复合赋值操作符\" class=\"headerlink\" title=\"复合赋值操作符\"></a>复合赋值操作符</h3><blockquote>\n<p>如+=将操作与赋值合并。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th><code>=</code></th>\n<th><code>-=</code></th>\n<th><code>/=</code></th>\n<th><code>%=</code></th>\n<th><code>&gt;&gt;=</code></th>\n<th><code>^=</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>+=</code></td>\n<td><code>*=</code></td>\n<td><code>~/=</code></td>\n<td><code>&lt;&lt;=</code></td>\n<td><code>&amp;=</code></td>\n<td>`</td>\n</tr>\n</tbody></table>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><blockquote>\n<p>可以使用逻辑运算符组合布尔表达式或取反布尔表达式。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>!expr</code></td>\n<td>对!后的表达式结果取反(如果表达式结果为false则表达式前加！使其变为true，反之亦然)</td>\n</tr>\n<tr>\n<td>`</td>\n<td></td>\n</tr>\n<tr>\n<td><code>&amp;&amp;</code></td>\n<td>逻辑与（且）</td>\n</tr>\n</tbody></table>\n<h3 id=\"位和移位运算\"><a href=\"#位和移位运算\" class=\"headerlink\" title=\"位和移位运算\"></a>位和移位运算</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&amp;</code></td>\n<td>按位与</td>\n</tr>\n<tr>\n<td>`</td>\n<td>`</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>按位异或</td>\n</tr>\n<tr>\n<td><code>~expr</code></td>\n<td>按位取反</td>\n</tr>\n<tr>\n<td><code>&lt;&lt;</code></td>\n<td>左移</td>\n</tr>\n<tr>\n<td><code>&gt;&gt;</code></td>\n<td>右移</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> value = <span class=\"number\">0x22</span>;</span><br><span class=\"line\"><span class=\"keyword\">final</span> bitmask = <span class=\"number\">0x0f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value &amp; bitmask) == <span class=\"number\">0x02</span>); <span class=\"comment\">// AND</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value &amp; ~bitmask) == <span class=\"number\">0x20</span>); <span class=\"comment\">// AND NOT</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value | bitmask) == <span class=\"number\">0x2f</span>); <span class=\"comment\">// OR</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value ^ bitmask) == <span class=\"number\">0x2d</span>); <span class=\"comment\">// XOR</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value &lt;&lt; <span class=\"number\">4</span>) == <span class=\"number\">0x220</span>); <span class=\"comment\">// Shift left</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value &gt;&gt; <span class=\"number\">4</span>) == <span class=\"number\">0x02</span>); <span class=\"comment\">// Shift right</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件表达式\"><a href=\"#条件表达式\" class=\"headerlink\" title=\"条件表达式\"></a>条件表达式</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果条件为真，则计算expr1(并返回其值);否则，计算并返回expr2的值。</span></span><br><span class=\"line\">condition ? expr1 : expr2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果expr1是非空的，则返回其值;否则，计算并返回expr2的值。</span></span><br><span class=\"line\">expr1 ?? expr2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于布尔表达式的结果选择赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> visibility = isPublic ? <span class=\"string\">'public'</span> : <span class=\"string\">'private'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 布尔表达式只想判断值是否为null</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> playerName(<span class=\"built_in\">String</span> name) =&gt; name ?? <span class=\"string\">'Guest'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"级联表示法\"><a href=\"#级联表示法\" class=\"headerlink\" title=\"级联表示法\"></a>级联表示法</h3><blockquote>\n<p><code>..</code> 允许您在同一个对象上创建一个操作序列。</p>\n</blockquote>\n<h3 id=\"其它运算符\"><a href=\"#其它运算符\" class=\"headerlink\" title=\"其它运算符\"></a>其它运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>()</code></td>\n<td>功能函数</td>\n<td>表示一个函数调用</td>\n</tr>\n<tr>\n<td><code>[]</code></td>\n<td>访问列表</td>\n<td>引用列表中指定索引处的值</td>\n</tr>\n<tr>\n<td><code>·</code></td>\n<td>访问成员</td>\n<td>表示表达式的属性;例如:foo.bar从表达式foo中选择属性bar，如果foo为null，会抛出异常</td>\n</tr>\n<tr>\n<td><code>?.</code></td>\n<td>根据条件访问成员</td>\n<td>和(.)相似，但是左边的操作数可以为空；例如： foo?.bar 从foo的表达式中选择bar属性，如果foo为空则返回null</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"按照运算符优先级高低进行排序\"><a href=\"#按照运算符优先级高低进行排序\" class=\"headerlink\" title=\"按照运算符优先级高低进行排序\"></a>按照运算符优先级高低进行排序</h3><table>\n<thead>\n<tr>\n<th>描述</th>\n<th>操作符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一元后置操作符</td>\n<td>expr++    expr–    ()    []    .    ?.</td>\n</tr>\n<tr>\n<td>一元前置操作符</td>\n<td>-expr    !expr    ~expr    ++expr    –expr</td>\n</tr>\n<tr>\n<td>乘除运算</td>\n<td>*    /    %    ~/</td>\n</tr>\n<tr>\n<td>加减运算</td>\n<td>+    -</td>\n</tr>\n<tr>\n<td>移位运算</td>\n<td>&lt;&lt;    &gt;&gt;</td>\n</tr>\n<tr>\n<td>按位与</td>\n<td>&amp;</td>\n</tr>\n<tr>\n<td>按位异或</td>\n<td>^</td>\n</tr>\n<tr>\n<td>按位或</td>\n<td>`</td>\n</tr>\n<tr>\n<td>关系和类型测试</td>\n<td>&gt;=    &gt;    &lt;=    &lt;    as    is    is!</td>\n</tr>\n<tr>\n<td>相等</td>\n<td>==    ！=</td>\n</tr>\n<tr>\n<td>逻辑与</td>\n<td>&amp;&amp;</td>\n</tr>\n<tr>\n<td>逻辑或</td>\n<td>`</td>\n</tr>\n<tr>\n<td>是否为null</td>\n<td>??</td>\n</tr>\n<tr>\n<td>天健判断（三元运算）</td>\n<td>expr1 ? expr2 : expr3</td>\n</tr>\n<tr>\n<td>级联</td>\n<td>..</td>\n</tr>\n<tr>\n<td>赋值</td>\n<td>=    *=    /=    ~/=    %=    +=    -=    &lt;&lt;=    &gt;&gt;=    &amp;=    ^=</td>\n</tr>\n<tr>\n<td>&gt; 当使用操作符后，就变成了表达式。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>加法</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n</tr>\n<tr>\n<td>-expr</td>\n<td>一元减号，也称为否定</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法</td>\n</tr>\n<tr>\n<td>~/</td>\n<td>取模运算</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取余运算</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">2</span> + <span class=\"number\">3</span> == <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">2</span> - <span class=\"number\">3</span> == <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">2</span> * <span class=\"number\">3</span> == <span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">5</span> / <span class=\"number\">2</span> == <span class=\"number\">2.5</span>); <span class=\"comment\">// Result is a double</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">5</span> ~/ <span class=\"number\">2</span> == <span class=\"number\">2</span>); <span class=\"comment\">// Result is an int</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"number\">5</span> % <span class=\"number\">2</span> == <span class=\"number\">1</span>); <span class=\"comment\">// Remainder</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(<span class=\"string\">'5/2 = <span class=\"subst\">$&#123;<span class=\"number\">5</span> ~/ <span class=\"number\">2</span>&#125;</span> r <span class=\"subst\">$&#123;<span class=\"number\">5</span> % <span class=\"number\">2</span>&#125;</span>'</span> == <span class=\"string\">'5/2 = 2 r 1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dart还支持前缀和后缀递增和递减运算符。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a, b;</span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\">b = ++a; <span class=\"comment\">// Increment a before b gets its value.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(a == b); <span class=\"comment\">// 1 == 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\">b = a++; <span class=\"comment\">// Increment a AFTER b gets its value.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(a != b); <span class=\"comment\">// 1 != 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\">b = --a; <span class=\"comment\">// Decrement a before b gets its value.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(a == b); <span class=\"comment\">// -1 == -1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">0</span>;</span><br><span class=\"line\">b = a--; <span class=\"comment\">// Decrement a AFTER b gets its value.</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(a != b); <span class=\"comment\">// -1 != 0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"相等和关系运算符\"><a href=\"#相等和关系运算符\" class=\"headerlink\" title=\"相等和关系运算符\"></a>相等和关系运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>==</td>\n<td>相等</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不等</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n</tbody></table>\n<h3 id=\"类型测试操作符\"><a href=\"#类型测试操作符\" class=\"headerlink\" title=\"类型测试操作符\"></a>类型测试操作符</h3><blockquote>\n<p>a, is, and is!操作符可以方便地在运行时检查类型。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>as</td>\n<td>形态转换</td>\n</tr>\n<tr>\n<td>is</td>\n<td>如果对象具有指定的类型，则为True</td>\n</tr>\n<tr>\n<td>is!</td>\n<td>如果对象具有指定的类型，则为False</td>\n</tr>\n</tbody></table>\n<h3 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><blockquote>\n<p>??=操作符仅仅在变量为null时会赋值。未初始化和后来手动赋值为null的情况都会执行此操作赋值。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Assign value to a</span></span><br><span class=\"line\">a = value;</span><br><span class=\"line\"><span class=\"comment\">// Assign value to b if b is null; otherwise, b stays the same</span></span><br><span class=\"line\"><span class=\"comment\">// 仅仅在b为空的情况下b被赋值value否则b的值不变</span></span><br><span class=\"line\">b ??= value;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复合赋值操作符\"><a href=\"#复合赋值操作符\" class=\"headerlink\" title=\"复合赋值操作符\"></a>复合赋值操作符</h3><blockquote>\n<p>如+=将操作与赋值合并。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th><code>=</code></th>\n<th><code>-=</code></th>\n<th><code>/=</code></th>\n<th><code>%=</code></th>\n<th><code>&gt;&gt;=</code></th>\n<th><code>^=</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>+=</code></td>\n<td><code>*=</code></td>\n<td><code>~/=</code></td>\n<td><code>&lt;&lt;=</code></td>\n<td><code>&amp;=</code></td>\n<td>`</td>\n</tr>\n</tbody></table>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><blockquote>\n<p>可以使用逻辑运算符组合布尔表达式或取反布尔表达式。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>!expr</code></td>\n<td>对!后的表达式结果取反(如果表达式结果为false则表达式前加！使其变为true，反之亦然)</td>\n</tr>\n<tr>\n<td>`</td>\n<td></td>\n</tr>\n<tr>\n<td><code>&amp;&amp;</code></td>\n<td>逻辑与（且）</td>\n</tr>\n</tbody></table>\n<h3 id=\"位和移位运算\"><a href=\"#位和移位运算\" class=\"headerlink\" title=\"位和移位运算\"></a>位和移位运算</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&amp;</code></td>\n<td>按位与</td>\n</tr>\n<tr>\n<td>`</td>\n<td>`</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>按位异或</td>\n</tr>\n<tr>\n<td><code>~expr</code></td>\n<td>按位取反</td>\n</tr>\n<tr>\n<td><code>&lt;&lt;</code></td>\n<td>左移</td>\n</tr>\n<tr>\n<td><code>&gt;&gt;</code></td>\n<td>右移</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> value = <span class=\"number\">0x22</span>;</span><br><span class=\"line\"><span class=\"keyword\">final</span> bitmask = <span class=\"number\">0x0f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value &amp; bitmask) == <span class=\"number\">0x02</span>); <span class=\"comment\">// AND</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value &amp; ~bitmask) == <span class=\"number\">0x20</span>); <span class=\"comment\">// AND NOT</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value | bitmask) == <span class=\"number\">0x2f</span>); <span class=\"comment\">// OR</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value ^ bitmask) == <span class=\"number\">0x2d</span>); <span class=\"comment\">// XOR</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value &lt;&lt; <span class=\"number\">4</span>) == <span class=\"number\">0x220</span>); <span class=\"comment\">// Shift left</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>((value &gt;&gt; <span class=\"number\">4</span>) == <span class=\"number\">0x02</span>); <span class=\"comment\">// Shift right</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件表达式\"><a href=\"#条件表达式\" class=\"headerlink\" title=\"条件表达式\"></a>条件表达式</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果条件为真，则计算expr1(并返回其值);否则，计算并返回expr2的值。</span></span><br><span class=\"line\">condition ? expr1 : expr2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果expr1是非空的，则返回其值;否则，计算并返回expr2的值。</span></span><br><span class=\"line\">expr1 ?? expr2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基于布尔表达式的结果选择赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> visibility = isPublic ? <span class=\"string\">'public'</span> : <span class=\"string\">'private'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 布尔表达式只想判断值是否为null</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> playerName(<span class=\"built_in\">String</span> name) =&gt; name ?? <span class=\"string\">'Guest'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"级联表示法\"><a href=\"#级联表示法\" class=\"headerlink\" title=\"级联表示法\"></a>级联表示法</h3><blockquote>\n<p><code>..</code> 允许您在同一个对象上创建一个操作序列。</p>\n</blockquote>\n<h3 id=\"其它运算符\"><a href=\"#其它运算符\" class=\"headerlink\" title=\"其它运算符\"></a>其它运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>()</code></td>\n<td>功能函数</td>\n<td>表示一个函数调用</td>\n</tr>\n<tr>\n<td><code>[]</code></td>\n<td>访问列表</td>\n<td>引用列表中指定索引处的值</td>\n</tr>\n<tr>\n<td><code>·</code></td>\n<td>访问成员</td>\n<td>表示表达式的属性;例如:foo.bar从表达式foo中选择属性bar，如果foo为null，会抛出异常</td>\n</tr>\n<tr>\n<td><code>?.</code></td>\n<td>根据条件访问成员</td>\n<td>和(.)相似，但是左边的操作数可以为空；例如： foo?.bar 从foo的表达式中选择bar属性，如果foo为空则返回null</td>\n</tr>\n</tbody></table>\n"},{"title":"Dart异步支持","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-18T12:54:00.000Z","_content":"Dart库中有非常多的函数返回Future对象或Stream对象。这些函数是异步的：在可能耗时的操作(例如I/O)操作的语句之后不等到操作执行完成就返回。\n\nasync和await关键字支持异步编程，允许您编写类似于同步代码的异步代码。\n\n## 处理Futures\n当你需要一个完整的Futures的结果时，你有两个选择:\n- 使用async和await\n- 使用Future的API，如[库的引导]中描述的一样。\n  \n使用async和await的代码虽然是异步的，但是看起来很像同步代码。例如，以下代码使用await来等待异步函数执行的结果：\n```dart\nawait lookUpVersion();\n// 要使用await必须是对一个使用async标注的异步函数：\n\nFuture checkVersion() async {\n  var version = await lookUpVersion();\n  // Do something with version\n}\n```\n> 注意:尽管异步函数可能执行耗时的操作，但它不会等待这些操作。相反，异步函数一直执行直到遇到第一个await表达式([查看详细信息])。然后它返回一个Futures的对象，只有在await表达式完成之后才恢复执行。\n\n使用try,catch和finally来处理使用await的代码中的错误：\n```dart\ntry {\n  version = await lookUpVersion();\n} catch (e) {\n  // React to inability to look up the version\n}\n```\n你可以在异步函数中多次使用await。例如，以下代码执行了三次await来获取函数的结果。\n```dart\nvar entrypoint = await findEntrypoint();\nvar exitCode = await runExecutable(entrypoint, args);\nawait flushThenExit(exitCode);\n```\n在await表达式中，表达式的值通常是一个Future对象。如果不是，那么这个值将被自动包装成Future。Futrue对象指示返回结果一定是一个对象。表达式的值就是被返回的对象。await表达式会让程序执行挂起，直到返回的对象可用。\n\n如果在使用await时出现编译时错误，请确保await在异步函数中 。例如，要在应用程序的main()函数中使用wait, main()的主体必须标记为async:\n```dart\nFuture main() async {\n  checkVersion();\n  print('In main: version is ${await lookUpVersion()}');\n}\n```\n## 声明异步函数\n异步函数是函数体被用async修饰符标记的函数。\n向函数中添加async关键字将使其返回一个Future。例如，请思考下例中返回一个字符串的同步函数:\n```dart\nString lookUpVersion() => '1.0.0';\n```\n如果你将他改变成一个异步函数，他的返回值将是一个Future：\n```dart\nFuture<String> lookUpVersion() async => '1.0.0';\n```\n注意，函数的主体不需要使用Future的API。如果需要，Dart将创建Future的对象。\n如果您的函数没有返回一个有用的值，那么将其返回Future<void>类型。\n\n## 处理流(Stream)\n当您需要从Stream获取值时，您有两个选择:\n- 使用async和异步的for循环(await for)\n- 使用Stream API，如[库的引导]中的描述\n> 注意:在使用await for之前，请确保它使代码更清晰，并且您确实希望等待流（Stream）的所有结果。例如，您通常不应该为UI事件侦听器使用await，因为UI框架会发送无穷无尽的事件流。\n\n## 异步for循环有以下形式:\n```dart\nawait for (varOrType identifier in expression) {\n  // Executes each time the stream emits a value.\n}\n```\n表达式的值必须具有Stream类型。执行过程如下:\n\n1. 等待流发出值。\n2. 执行for循环的主体，并将变量设置为发出的值。\n3. 重复1和2，直到流关闭。\n4. 要停止侦听流，您可以使用break或return语句，该语句将跳出for循环，并从流中取消订阅。\n\n如果在实现异步for循环时出现编译时错误，请确保await在异步函数中。例如，要在应用程序的main()函数中使用异步For循环，main()的主体必须标记为async:\n```dart\nFuture main() async {\n  // ...\n  await for (var request in requestServer) {\n    handleRequest(request);\n  }\n  // ...\n}\n```\n有关异步编程的更多信息，请参阅[[库引导文档]]()的dart:async部分。还可以参阅文章[[Dart语言异步支持:阶段1]]()和[[Dart语言异步支持:阶段2]]()和[[Dart语言规范]]()。","source":"_posts/dart/10_异步支持.md","raw":"---\ntitle: Dart异步支持\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-18 20:54:00   \n---\nDart库中有非常多的函数返回Future对象或Stream对象。这些函数是异步的：在可能耗时的操作(例如I/O)操作的语句之后不等到操作执行完成就返回。\n\nasync和await关键字支持异步编程，允许您编写类似于同步代码的异步代码。\n\n## 处理Futures\n当你需要一个完整的Futures的结果时，你有两个选择:\n- 使用async和await\n- 使用Future的API，如[库的引导]中描述的一样。\n  \n使用async和await的代码虽然是异步的，但是看起来很像同步代码。例如，以下代码使用await来等待异步函数执行的结果：\n```dart\nawait lookUpVersion();\n// 要使用await必须是对一个使用async标注的异步函数：\n\nFuture checkVersion() async {\n  var version = await lookUpVersion();\n  // Do something with version\n}\n```\n> 注意:尽管异步函数可能执行耗时的操作，但它不会等待这些操作。相反，异步函数一直执行直到遇到第一个await表达式([查看详细信息])。然后它返回一个Futures的对象，只有在await表达式完成之后才恢复执行。\n\n使用try,catch和finally来处理使用await的代码中的错误：\n```dart\ntry {\n  version = await lookUpVersion();\n} catch (e) {\n  // React to inability to look up the version\n}\n```\n你可以在异步函数中多次使用await。例如，以下代码执行了三次await来获取函数的结果。\n```dart\nvar entrypoint = await findEntrypoint();\nvar exitCode = await runExecutable(entrypoint, args);\nawait flushThenExit(exitCode);\n```\n在await表达式中，表达式的值通常是一个Future对象。如果不是，那么这个值将被自动包装成Future。Futrue对象指示返回结果一定是一个对象。表达式的值就是被返回的对象。await表达式会让程序执行挂起，直到返回的对象可用。\n\n如果在使用await时出现编译时错误，请确保await在异步函数中 。例如，要在应用程序的main()函数中使用wait, main()的主体必须标记为async:\n```dart\nFuture main() async {\n  checkVersion();\n  print('In main: version is ${await lookUpVersion()}');\n}\n```\n## 声明异步函数\n异步函数是函数体被用async修饰符标记的函数。\n向函数中添加async关键字将使其返回一个Future。例如，请思考下例中返回一个字符串的同步函数:\n```dart\nString lookUpVersion() => '1.0.0';\n```\n如果你将他改变成一个异步函数，他的返回值将是一个Future：\n```dart\nFuture<String> lookUpVersion() async => '1.0.0';\n```\n注意，函数的主体不需要使用Future的API。如果需要，Dart将创建Future的对象。\n如果您的函数没有返回一个有用的值，那么将其返回Future<void>类型。\n\n## 处理流(Stream)\n当您需要从Stream获取值时，您有两个选择:\n- 使用async和异步的for循环(await for)\n- 使用Stream API，如[库的引导]中的描述\n> 注意:在使用await for之前，请确保它使代码更清晰，并且您确实希望等待流（Stream）的所有结果。例如，您通常不应该为UI事件侦听器使用await，因为UI框架会发送无穷无尽的事件流。\n\n## 异步for循环有以下形式:\n```dart\nawait for (varOrType identifier in expression) {\n  // Executes each time the stream emits a value.\n}\n```\n表达式的值必须具有Stream类型。执行过程如下:\n\n1. 等待流发出值。\n2. 执行for循环的主体，并将变量设置为发出的值。\n3. 重复1和2，直到流关闭。\n4. 要停止侦听流，您可以使用break或return语句，该语句将跳出for循环，并从流中取消订阅。\n\n如果在实现异步for循环时出现编译时错误，请确保await在异步函数中。例如，要在应用程序的main()函数中使用异步For循环，main()的主体必须标记为async:\n```dart\nFuture main() async {\n  // ...\n  await for (var request in requestServer) {\n    handleRequest(request);\n  }\n  // ...\n}\n```\n有关异步编程的更多信息，请参阅[[库引导文档]]()的dart:async部分。还可以参阅文章[[Dart语言异步支持:阶段1]]()和[[Dart语言异步支持:阶段2]]()和[[Dart语言规范]]()。","slug":"dart/10_异步支持","published":1,"updated":"2019-10-02T09:26:58.845Z","layout":"post","photos":[],"link":"","_id":"ck19bvaqk000k00wk8l9cyncc","content":"<p>Dart库中有非常多的函数返回Future对象或Stream对象。这些函数是异步的：在可能耗时的操作(例如I/O)操作的语句之后不等到操作执行完成就返回。</p>\n<p>async和await关键字支持异步编程，允许您编写类似于同步代码的异步代码。</p>\n<h2 id=\"处理Futures\"><a href=\"#处理Futures\" class=\"headerlink\" title=\"处理Futures\"></a>处理Futures</h2><p>当你需要一个完整的Futures的结果时，你有两个选择:</p>\n<ul>\n<li>使用async和await</li>\n<li>使用Future的API，如[库的引导]中描述的一样。</li>\n</ul>\n<p>使用async和await的代码虽然是异步的，但是看起来很像同步代码。例如，以下代码使用await来等待异步函数执行的结果：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\"><span class=\"comment\">// 要使用await必须是对一个使用async标注的异步函数：</span></span><br><span class=\"line\"></span><br><span class=\"line\">Future checkVersion() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> version = <span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\">  <span class=\"comment\">// Do something with version</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:尽管异步函数可能执行耗时的操作，但它不会等待这些操作。相反，异步函数一直执行直到遇到第一个await表达式([查看详细信息])。然后它返回一个Futures的对象，只有在await表达式完成之后才恢复执行。</p>\n</blockquote>\n<p>使用try,catch和finally来处理使用await的代码中的错误：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  version = <span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// React to inability to look up the version</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以在异步函数中多次使用await。例如，以下代码执行了三次await来获取函数的结果。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> entrypoint = <span class=\"keyword\">await</span> findEntrypoint();</span><br><span class=\"line\"><span class=\"keyword\">var</span> exitCode = <span class=\"keyword\">await</span> runExecutable(entrypoint, args);</span><br><span class=\"line\"><span class=\"keyword\">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure>\n\n<p>在await表达式中，表达式的值通常是一个Future对象。如果不是，那么这个值将被自动包装成Future。Futrue对象指示返回结果一定是一个对象。表达式的值就是被返回的对象。await表达式会让程序执行挂起，直到返回的对象可用。</p>\n<p>如果在使用await时出现编译时错误，请确保await在异步函数中 。例如，要在应用程序的main()函数中使用wait, main()的主体必须标记为async:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  checkVersion();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In main: version is <span class=\"subst\">$&#123;await lookUpVersion()&#125;</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"声明异步函数\"><a href=\"#声明异步函数\" class=\"headerlink\" title=\"声明异步函数\"></a>声明异步函数</h2><p>异步函数是函数体被用async修饰符标记的函数。<br>向函数中添加async关键字将使其返回一个Future。例如，请思考下例中返回一个字符串的同步函数:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> lookUpVersion() =&gt; <span class=\"string\">'1.0.0'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果你将他改变成一个异步函数，他的返回值将是一个Future：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;<span class=\"built_in\">String</span>&gt; lookUpVersion() <span class=\"keyword\">async</span> =&gt; <span class=\"string\">'1.0.0'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意，函数的主体不需要使用Future的API。如果需要，Dart将创建Future的对象。<br>如果您的函数没有返回一个有用的值，那么将其返回Future<void>类型。</void></p>\n<h2 id=\"处理流-Stream\"><a href=\"#处理流-Stream\" class=\"headerlink\" title=\"处理流(Stream)\"></a>处理流(Stream)</h2><p>当您需要从Stream获取值时，您有两个选择:</p>\n<ul>\n<li>使用async和异步的for循环(await for)</li>\n<li>使用Stream API，如[库的引导]中的描述<blockquote>\n<p>注意:在使用await for之前，请确保它使代码更清晰，并且您确实希望等待流（Stream）的所有结果。例如，您通常不应该为UI事件侦听器使用await，因为UI框架会发送无穷无尽的事件流。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"异步for循环有以下形式\"><a href=\"#异步for循环有以下形式\" class=\"headerlink\" title=\"异步for循环有以下形式:\"></a>异步for循环有以下形式:</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (varOrType identifier <span class=\"keyword\">in</span> expression) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Executes each time the stream emits a value.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>表达式的值必须具有Stream类型。执行过程如下:</p>\n<ol>\n<li>等待流发出值。</li>\n<li>执行for循环的主体，并将变量设置为发出的值。</li>\n<li>重复1和2，直到流关闭。</li>\n<li>要停止侦听流，您可以使用break或return语句，该语句将跳出for循环，并从流中取消订阅。</li>\n</ol>\n<p>如果在实现异步for循环时出现编译时错误，请确保await在异步函数中。例如，要在应用程序的main()函数中使用异步For循环，main()的主体必须标记为async:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> request <span class=\"keyword\">in</span> requestServer) &#123;</span><br><span class=\"line\">    handleRequest(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有关异步编程的更多信息，请参阅<a href>[库引导文档]</a>的dart:async部分。还可以参阅文章<a href>[Dart语言异步支持:阶段1]</a>和<a href>[Dart语言异步支持:阶段2]</a>和<a href>[Dart语言规范]</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Dart库中有非常多的函数返回Future对象或Stream对象。这些函数是异步的：在可能耗时的操作(例如I/O)操作的语句之后不等到操作执行完成就返回。</p>\n<p>async和await关键字支持异步编程，允许您编写类似于同步代码的异步代码。</p>\n<h2 id=\"处理Futures\"><a href=\"#处理Futures\" class=\"headerlink\" title=\"处理Futures\"></a>处理Futures</h2><p>当你需要一个完整的Futures的结果时，你有两个选择:</p>\n<ul>\n<li>使用async和await</li>\n<li>使用Future的API，如[库的引导]中描述的一样。</li>\n</ul>\n<p>使用async和await的代码虽然是异步的，但是看起来很像同步代码。例如，以下代码使用await来等待异步函数执行的结果：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\"><span class=\"comment\">// 要使用await必须是对一个使用async标注的异步函数：</span></span><br><span class=\"line\"></span><br><span class=\"line\">Future checkVersion() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> version = <span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\">  <span class=\"comment\">// Do something with version</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:尽管异步函数可能执行耗时的操作，但它不会等待这些操作。相反，异步函数一直执行直到遇到第一个await表达式([查看详细信息])。然后它返回一个Futures的对象，只有在await表达式完成之后才恢复执行。</p>\n</blockquote>\n<p>使用try,catch和finally来处理使用await的代码中的错误：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  version = <span class=\"keyword\">await</span> lookUpVersion();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// React to inability to look up the version</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以在异步函数中多次使用await。例如，以下代码执行了三次await来获取函数的结果。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> entrypoint = <span class=\"keyword\">await</span> findEntrypoint();</span><br><span class=\"line\"><span class=\"keyword\">var</span> exitCode = <span class=\"keyword\">await</span> runExecutable(entrypoint, args);</span><br><span class=\"line\"><span class=\"keyword\">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure>\n\n<p>在await表达式中，表达式的值通常是一个Future对象。如果不是，那么这个值将被自动包装成Future。Futrue对象指示返回结果一定是一个对象。表达式的值就是被返回的对象。await表达式会让程序执行挂起，直到返回的对象可用。</p>\n<p>如果在使用await时出现编译时错误，请确保await在异步函数中 。例如，要在应用程序的main()函数中使用wait, main()的主体必须标记为async:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  checkVersion();</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In main: version is <span class=\"subst\">$&#123;await lookUpVersion()&#125;</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"声明异步函数\"><a href=\"#声明异步函数\" class=\"headerlink\" title=\"声明异步函数\"></a>声明异步函数</h2><p>异步函数是函数体被用async修饰符标记的函数。<br>向函数中添加async关键字将使其返回一个Future。例如，请思考下例中返回一个字符串的同步函数:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> lookUpVersion() =&gt; <span class=\"string\">'1.0.0'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果你将他改变成一个异步函数，他的返回值将是一个Future：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;<span class=\"built_in\">String</span>&gt; lookUpVersion() <span class=\"keyword\">async</span> =&gt; <span class=\"string\">'1.0.0'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意，函数的主体不需要使用Future的API。如果需要，Dart将创建Future的对象。<br>如果您的函数没有返回一个有用的值，那么将其返回Future<void>类型。</void></p>\n<h2 id=\"处理流-Stream\"><a href=\"#处理流-Stream\" class=\"headerlink\" title=\"处理流(Stream)\"></a>处理流(Stream)</h2><p>当您需要从Stream获取值时，您有两个选择:</p>\n<ul>\n<li>使用async和异步的for循环(await for)</li>\n<li>使用Stream API，如[库的引导]中的描述<blockquote>\n<p>注意:在使用await for之前，请确保它使代码更清晰，并且您确实希望等待流（Stream）的所有结果。例如，您通常不应该为UI事件侦听器使用await，因为UI框架会发送无穷无尽的事件流。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"异步for循环有以下形式\"><a href=\"#异步for循环有以下形式\" class=\"headerlink\" title=\"异步for循环有以下形式:\"></a>异步for循环有以下形式:</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (varOrType identifier <span class=\"keyword\">in</span> expression) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Executes each time the stream emits a value.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>表达式的值必须具有Stream类型。执行过程如下:</p>\n<ol>\n<li>等待流发出值。</li>\n<li>执行for循环的主体，并将变量设置为发出的值。</li>\n<li>重复1和2，直到流关闭。</li>\n<li>要停止侦听流，您可以使用break或return语句，该语句将跳出for循环，并从流中取消订阅。</li>\n</ol>\n<p>如果在实现异步for循环时出现编译时错误，请确保await在异步函数中。例如，要在应用程序的main()函数中使用异步For循环，main()的主体必须标记为async:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future main() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> request <span class=\"keyword\">in</span> requestServer) &#123;</span><br><span class=\"line\">    handleRequest(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有关异步编程的更多信息，请参阅<a href>[库引导文档]</a>的dart:async部分。还可以参阅文章<a href>[Dart语言异步支持:阶段1]</a>和<a href>[Dart语言异步支持:阶段2]</a>和<a href>[Dart语言规范]</a>。</p>\n"},{"title":"Dart生成器等","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-18T13:14:00.000Z","_content":"## 生成器\n当您需要延迟地生成一个值序列时，请考虑使用生成器函数。Dart内置支持两种生成器函数:\n\n1. 同步生成器：返回Iterable对象\n2. 异步生成器：返回Stream对象\n\n要实现同步生成器函数，将函数体标记为`sync*`，并使用`yield`语句传递值:\n\n```dart\nIterable<int> naturalsTo(int n) sync* {\n  int k = 0;\n  while (k < n) yield k++;\n}\n```\n要实现异步生成器函数，将函数体标记为`async*`，并使用`yield`语句传递值:\n```dart\nStream<int> asynchronousNaturalsTo(int n) async* {\n  int k = 0;\n  while (k < n) yield k++;\n}\n```\n如果您的生成器是递归的，您可以使用`yield*`来改进它的性能:\n```dart\nIterable<int> naturalsDownFrom(int n) sync* {\n  if (n > 0) {\n    yield n;\n    yield* naturalsDownFrom(n - 1);\n  }\n}\n```\n有关生成器的更多信息，请参阅文章[Dart语言异步支持:Phase 2]。\n\n## 可调用的类\n实现call()方法可以让你的Dart类像函数一样被调用。\n\n在下面的示例中，WannabeFunction类定义了一个call()函数，该函数接受三个字符串并将它们连接起来，每个字符串用空格分隔，并在结尾加一个感叹号。\n```dart\nclass WannabeFunction {\n  call(String a, String b, String c) => '$a $b $c!';\n}\n\nmain() {\n  var wf = new WannabeFunction();\n  var out = wf(\"Hi\", \"there,\", \"gang\");\n  print('$out');\n}\n```\n```Shell\n///执行结果\nHi there, gang!\n```\n\n有关类的更多信息，请参见[Dart中的模拟函数]。\n\n## 隔离器\n大多数计算机，甚至在移动平台上，都有多核cpu。为了利用所有这些核心，开发人员通常使用同时运行的共享内存线程。但是，共享状态并发容易出错并且可能增加代码的复杂度。\n\n不同于线程，所有Dart代码都运行在隔离器内部，而不是线程。每个隔离都有它自己的内存堆，确保任何其他隔离器都不能访问隔离状态。\n\n有关更多信息，请参见[dart:isolate库文档]。\n\n## 类型定义\n在Dart中，函数是对象，就像字符串和数字是对象一样。typedef或function-type为函数提供一个类型别名，你可以在声明字段和返回类型时使用这个名称。当函数类型被分配给变量时，typedef保留类型信息。\n\n以下代码不使用typedef：\n```dart\nclass SortedCollection {\n  Function compare;\n\n  SortedCollection(int f(Object a, Object b)) {\n    compare = f;\n  }\n}\n\n// Initial, broken implementation.\nint sort(Object a, Object b) => 0;\n\nvoid main() {\n  SortedCollection coll = SortedCollection(sort);\n\n  // All we know is that compare is a function,\n  // but what type of function?\n  assert(coll.compare is Function);\n}\n```\n\n当给compare分配f时类型信息会丢失。f的类型是(Object, Object)->int(int表示返回值类型),当然compare的类型是Function。如果我们更改代码以使用显式名称和保留类型信息，开发人员和工具都可以使用这些信息。\n```dart\ntypedef Compare = int Function(Object a, Object b);\n\nclass SortedCollection {\n  Compare compare;\n\n  SortedCollection(this.compare);\n}\n\n// Initial, broken implementation.\nint sort(Object a, Object b) => 0;\n\nvoid main() {\n  SortedCollection coll = SortedCollection(sort);\n  assert(coll.compare is Function);\n  assert(coll.compare is Compare);\n}\n```\n> 注意:目前，typedefs仅限于函数类型。我们期望这种情况会改变。\n\n因为typedef仅仅是别名，所以它们提供了一种检查任何函数类型的方法。例如:\n```DART\ntypedef Compare<T> = int Function(T a, T b);\n\nint sort(int a, int b) => a - b;\n\nvoid main() {\n  assert(sort is Compare<int>); // True!\n}\n```\n\n## 元数据\n使用元数据提供关于代码的附加信息。元数据注释以字符@开头，后跟对编译时常量(如deprecated)的引用或对常量构造函数的调用。\n\n所有Dart代码都可以使用两个注释:@deprecated和@override。有关使用@override的示例，请参见扩展类。这里有一个使用@deprecated注释的例子:\n```dart\nclass Television {\n  /// _Deprecated: Use [turnOn] instead._\n  @deprecated\n  void activate() {\n    turnOn();\n  }\n\n  /// Turns the TV's power on.\n  void turnOn() {...}\n}\n```\n您可以定义自己的元数据注释。这里有一个定义带有两个参数的@todo注释的示例:\n```dart\nlibrary todo;\n\nclass Todo {\n  final String who;\n  final String what;\n\n  const Todo(this.who, this.what);\n}\n\n// 这里有一个使用@todo注释的例子:\nimport 'todo.dart';\n\n@Todo('seth', 'make this do something')\nvoid doSomething() {\n  print('do something');\n}\n```\n元数据可以出现在库、类、类型定义、类型参数、构造函数、工厂、函数、字段、参数或变量声明之前，也可以出现在导入或导出指令之前。您可以使用反射在运行时检索元数据。","source":"_posts/dart/11_生成器等.md","raw":"---\ntitle: Dart生成器等\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-18 21:14:00   \n---\n## 生成器\n当您需要延迟地生成一个值序列时，请考虑使用生成器函数。Dart内置支持两种生成器函数:\n\n1. 同步生成器：返回Iterable对象\n2. 异步生成器：返回Stream对象\n\n要实现同步生成器函数，将函数体标记为`sync*`，并使用`yield`语句传递值:\n\n```dart\nIterable<int> naturalsTo(int n) sync* {\n  int k = 0;\n  while (k < n) yield k++;\n}\n```\n要实现异步生成器函数，将函数体标记为`async*`，并使用`yield`语句传递值:\n```dart\nStream<int> asynchronousNaturalsTo(int n) async* {\n  int k = 0;\n  while (k < n) yield k++;\n}\n```\n如果您的生成器是递归的，您可以使用`yield*`来改进它的性能:\n```dart\nIterable<int> naturalsDownFrom(int n) sync* {\n  if (n > 0) {\n    yield n;\n    yield* naturalsDownFrom(n - 1);\n  }\n}\n```\n有关生成器的更多信息，请参阅文章[Dart语言异步支持:Phase 2]。\n\n## 可调用的类\n实现call()方法可以让你的Dart类像函数一样被调用。\n\n在下面的示例中，WannabeFunction类定义了一个call()函数，该函数接受三个字符串并将它们连接起来，每个字符串用空格分隔，并在结尾加一个感叹号。\n```dart\nclass WannabeFunction {\n  call(String a, String b, String c) => '$a $b $c!';\n}\n\nmain() {\n  var wf = new WannabeFunction();\n  var out = wf(\"Hi\", \"there,\", \"gang\");\n  print('$out');\n}\n```\n```Shell\n///执行结果\nHi there, gang!\n```\n\n有关类的更多信息，请参见[Dart中的模拟函数]。\n\n## 隔离器\n大多数计算机，甚至在移动平台上，都有多核cpu。为了利用所有这些核心，开发人员通常使用同时运行的共享内存线程。但是，共享状态并发容易出错并且可能增加代码的复杂度。\n\n不同于线程，所有Dart代码都运行在隔离器内部，而不是线程。每个隔离都有它自己的内存堆，确保任何其他隔离器都不能访问隔离状态。\n\n有关更多信息，请参见[dart:isolate库文档]。\n\n## 类型定义\n在Dart中，函数是对象，就像字符串和数字是对象一样。typedef或function-type为函数提供一个类型别名，你可以在声明字段和返回类型时使用这个名称。当函数类型被分配给变量时，typedef保留类型信息。\n\n以下代码不使用typedef：\n```dart\nclass SortedCollection {\n  Function compare;\n\n  SortedCollection(int f(Object a, Object b)) {\n    compare = f;\n  }\n}\n\n// Initial, broken implementation.\nint sort(Object a, Object b) => 0;\n\nvoid main() {\n  SortedCollection coll = SortedCollection(sort);\n\n  // All we know is that compare is a function,\n  // but what type of function?\n  assert(coll.compare is Function);\n}\n```\n\n当给compare分配f时类型信息会丢失。f的类型是(Object, Object)->int(int表示返回值类型),当然compare的类型是Function。如果我们更改代码以使用显式名称和保留类型信息，开发人员和工具都可以使用这些信息。\n```dart\ntypedef Compare = int Function(Object a, Object b);\n\nclass SortedCollection {\n  Compare compare;\n\n  SortedCollection(this.compare);\n}\n\n// Initial, broken implementation.\nint sort(Object a, Object b) => 0;\n\nvoid main() {\n  SortedCollection coll = SortedCollection(sort);\n  assert(coll.compare is Function);\n  assert(coll.compare is Compare);\n}\n```\n> 注意:目前，typedefs仅限于函数类型。我们期望这种情况会改变。\n\n因为typedef仅仅是别名，所以它们提供了一种检查任何函数类型的方法。例如:\n```DART\ntypedef Compare<T> = int Function(T a, T b);\n\nint sort(int a, int b) => a - b;\n\nvoid main() {\n  assert(sort is Compare<int>); // True!\n}\n```\n\n## 元数据\n使用元数据提供关于代码的附加信息。元数据注释以字符@开头，后跟对编译时常量(如deprecated)的引用或对常量构造函数的调用。\n\n所有Dart代码都可以使用两个注释:@deprecated和@override。有关使用@override的示例，请参见扩展类。这里有一个使用@deprecated注释的例子:\n```dart\nclass Television {\n  /// _Deprecated: Use [turnOn] instead._\n  @deprecated\n  void activate() {\n    turnOn();\n  }\n\n  /// Turns the TV's power on.\n  void turnOn() {...}\n}\n```\n您可以定义自己的元数据注释。这里有一个定义带有两个参数的@todo注释的示例:\n```dart\nlibrary todo;\n\nclass Todo {\n  final String who;\n  final String what;\n\n  const Todo(this.who, this.what);\n}\n\n// 这里有一个使用@todo注释的例子:\nimport 'todo.dart';\n\n@Todo('seth', 'make this do something')\nvoid doSomething() {\n  print('do something');\n}\n```\n元数据可以出现在库、类、类型定义、类型参数、构造函数、工厂、函数、字段、参数或变量声明之前，也可以出现在导入或导出指令之前。您可以使用反射在运行时检索元数据。","slug":"dart/11_生成器等","published":1,"updated":"2019-10-02T09:27:29.672Z","layout":"post","photos":[],"link":"","_id":"ck19bvaqq000p00wklz1j5wp6","content":"<h2 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h2><p>当您需要延迟地生成一个值序列时，请考虑使用生成器函数。Dart内置支持两种生成器函数:</p>\n<ol>\n<li>同步生成器：返回Iterable对象</li>\n<li>异步生成器：返回Stream对象</li>\n</ol>\n<p>要实现同步生成器函数，将函数体标记为<code>sync*</code>，并使用<code>yield</code>语句传递值:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span>&lt;<span class=\"built_in\">int</span>&gt; naturalsTo(<span class=\"built_in\">int</span> n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n) <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要实现异步生成器函数，将函数体标记为<code>async*</code>，并使用<code>yield</code>语句传递值:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;<span class=\"built_in\">int</span>&gt; asynchronousNaturalsTo(<span class=\"built_in\">int</span> n) <span class=\"keyword\">async</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n) <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果您的生成器是递归的，您可以使用<code>yield*</code>来改进它的性能:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span>&lt;<span class=\"built_in\">int</span>&gt; naturalsDownFrom(<span class=\"built_in\">int</span> n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>* naturalsDownFrom(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有关生成器的更多信息，请参阅文章[Dart语言异步支持:Phase 2]。</p>\n<h2 id=\"可调用的类\"><a href=\"#可调用的类\" class=\"headerlink\" title=\"可调用的类\"></a>可调用的类</h2><p>实现call()方法可以让你的Dart类像函数一样被调用。</p>\n<p>在下面的示例中，WannabeFunction类定义了一个call()函数，该函数接受三个字符串并将它们连接起来，每个字符串用空格分隔，并在结尾加一个感叹号。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WannabeFunction</span> </span>&#123;</span><br><span class=\"line\">  call(<span class=\"built_in\">String</span> a, <span class=\"built_in\">String</span> b, <span class=\"built_in\">String</span> c) =&gt; <span class=\"string\">'<span class=\"subst\">$a</span> <span class=\"subst\">$b</span> <span class=\"subst\">$c</span>!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wf = <span class=\"keyword\">new</span> WannabeFunction();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> out = wf(<span class=\"string\">\"Hi\"</span>, <span class=\"string\">\"there,\"</span>, <span class=\"string\">\"gang\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$out</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">///执行结果</span><br><span class=\"line\">Hi there, gang!</span><br></pre></td></tr></table></figure>\n\n<p>有关类的更多信息，请参见[Dart中的模拟函数]。</p>\n<h2 id=\"隔离器\"><a href=\"#隔离器\" class=\"headerlink\" title=\"隔离器\"></a>隔离器</h2><p>大多数计算机，甚至在移动平台上，都有多核cpu。为了利用所有这些核心，开发人员通常使用同时运行的共享内存线程。但是，共享状态并发容易出错并且可能增加代码的复杂度。</p>\n<p>不同于线程，所有Dart代码都运行在隔离器内部，而不是线程。每个隔离都有它自己的内存堆，确保任何其他隔离器都不能访问隔离状态。</p>\n<p>有关更多信息，请参见[dart:isolate库文档]。</p>\n<h2 id=\"类型定义\"><a href=\"#类型定义\" class=\"headerlink\" title=\"类型定义\"></a>类型定义</h2><p>在Dart中，函数是对象，就像字符串和数字是对象一样。typedef或function-type为函数提供一个类型别名，你可以在声明字段和返回类型时使用这个名称。当函数类型被分配给变量时，typedef保留类型信息。</p>\n<p>以下代码不使用typedef：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedCollection</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> compare;</span><br><span class=\"line\"></span><br><span class=\"line\">  SortedCollection(<span class=\"built_in\">int</span> f(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b)) &#123;</span><br><span class=\"line\">    compare = f;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initial, broken implementation.</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  SortedCollection coll = SortedCollection(sort);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// All we know is that compare is a function,</span></span><br><span class=\"line\">  <span class=\"comment\">// but what type of function?</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(coll.compare <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当给compare分配f时类型信息会丢失。f的类型是(Object, Object)-&gt;int(int表示返回值类型),当然compare的类型是Function。如果我们更改代码以使用显式名称和保留类型信息，开发人员和工具都可以使用这些信息。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Compare = <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedCollection</span> </span>&#123;</span><br><span class=\"line\">  Compare compare;</span><br><span class=\"line\"></span><br><span class=\"line\">  SortedCollection(<span class=\"keyword\">this</span>.compare);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initial, broken implementation.</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  SortedCollection coll = SortedCollection(sort);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(coll.compare <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(coll.compare <span class=\"keyword\">is</span> Compare);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:目前，typedefs仅限于函数类型。我们期望这种情况会改变。</p>\n</blockquote>\n<p>因为typedef仅仅是别名，所以它们提供了一种检查任何函数类型的方法。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Compare&lt;T&gt; = <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(T a, T b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b) =&gt; a - b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(sort <span class=\"keyword\">is</span> Compare&lt;<span class=\"built_in\">int</span>&gt;); <span class=\"comment\">// True!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元数据\"><a href=\"#元数据\" class=\"headerlink\" title=\"元数据\"></a>元数据</h2><p>使用元数据提供关于代码的附加信息。元数据注释以字符@开头，后跟对编译时常量(如deprecated)的引用或对常量构造函数的调用。</p>\n<p>所有Dart代码都可以使用两个注释:@deprecated和@override。有关使用@override的示例，请参见扩展类。这里有一个使用@deprecated注释的例子:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// _Deprecated: Use [turnOn] instead._</span></span><br><span class=\"line\">  <span class=\"meta\">@deprecated</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> activate() &#123;</span><br><span class=\"line\">    turnOn();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// Turns the TV's power on.</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您可以定义自己的元数据注释。这里有一个定义带有两个参数的@todo注释的示例:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">library</span> todo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Todo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> who;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> what;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Todo(<span class=\"keyword\">this</span>.who, <span class=\"keyword\">this</span>.what);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里有一个使用@todo注释的例子:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'todo.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Todo</span>(<span class=\"string\">'seth'</span>, <span class=\"string\">'make this do something'</span>)</span><br><span class=\"line\"><span class=\"keyword\">void</span> doSomething() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'do something'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元数据可以出现在库、类、类型定义、类型参数、构造函数、工厂、函数、字段、参数或变量声明之前，也可以出现在导入或导出指令之前。您可以使用反射在运行时检索元数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h2><p>当您需要延迟地生成一个值序列时，请考虑使用生成器函数。Dart内置支持两种生成器函数:</p>\n<ol>\n<li>同步生成器：返回Iterable对象</li>\n<li>异步生成器：返回Stream对象</li>\n</ol>\n<p>要实现同步生成器函数，将函数体标记为<code>sync*</code>，并使用<code>yield</code>语句传递值:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span>&lt;<span class=\"built_in\">int</span>&gt; naturalsTo(<span class=\"built_in\">int</span> n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n) <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要实现异步生成器函数，将函数体标记为<code>async*</code>，并使用<code>yield</code>语句传递值:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;<span class=\"built_in\">int</span>&gt; asynchronousNaturalsTo(<span class=\"built_in\">int</span> n) <span class=\"keyword\">async</span>* &#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (k &lt; n) <span class=\"keyword\">yield</span> k++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果您的生成器是递归的，您可以使用<code>yield*</code>来改进它的性能:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Iterable</span>&lt;<span class=\"built_in\">int</span>&gt; naturalsDownFrom(<span class=\"built_in\">int</span> n) <span class=\"keyword\">sync</span>* &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>* naturalsDownFrom(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有关生成器的更多信息，请参阅文章[Dart语言异步支持:Phase 2]。</p>\n<h2 id=\"可调用的类\"><a href=\"#可调用的类\" class=\"headerlink\" title=\"可调用的类\"></a>可调用的类</h2><p>实现call()方法可以让你的Dart类像函数一样被调用。</p>\n<p>在下面的示例中，WannabeFunction类定义了一个call()函数，该函数接受三个字符串并将它们连接起来，每个字符串用空格分隔，并在结尾加一个感叹号。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WannabeFunction</span> </span>&#123;</span><br><span class=\"line\">  call(<span class=\"built_in\">String</span> a, <span class=\"built_in\">String</span> b, <span class=\"built_in\">String</span> c) =&gt; <span class=\"string\">'<span class=\"subst\">$a</span> <span class=\"subst\">$b</span> <span class=\"subst\">$c</span>!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wf = <span class=\"keyword\">new</span> WannabeFunction();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> out = wf(<span class=\"string\">\"Hi\"</span>, <span class=\"string\">\"there,\"</span>, <span class=\"string\">\"gang\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'<span class=\"subst\">$out</span>'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">///执行结果</span><br><span class=\"line\">Hi there, gang!</span><br></pre></td></tr></table></figure>\n\n<p>有关类的更多信息，请参见[Dart中的模拟函数]。</p>\n<h2 id=\"隔离器\"><a href=\"#隔离器\" class=\"headerlink\" title=\"隔离器\"></a>隔离器</h2><p>大多数计算机，甚至在移动平台上，都有多核cpu。为了利用所有这些核心，开发人员通常使用同时运行的共享内存线程。但是，共享状态并发容易出错并且可能增加代码的复杂度。</p>\n<p>不同于线程，所有Dart代码都运行在隔离器内部，而不是线程。每个隔离都有它自己的内存堆，确保任何其他隔离器都不能访问隔离状态。</p>\n<p>有关更多信息，请参见[dart:isolate库文档]。</p>\n<h2 id=\"类型定义\"><a href=\"#类型定义\" class=\"headerlink\" title=\"类型定义\"></a>类型定义</h2><p>在Dart中，函数是对象，就像字符串和数字是对象一样。typedef或function-type为函数提供一个类型别名，你可以在声明字段和返回类型时使用这个名称。当函数类型被分配给变量时，typedef保留类型信息。</p>\n<p>以下代码不使用typedef：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedCollection</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span> compare;</span><br><span class=\"line\"></span><br><span class=\"line\">  SortedCollection(<span class=\"built_in\">int</span> f(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b)) &#123;</span><br><span class=\"line\">    compare = f;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initial, broken implementation.</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  SortedCollection coll = SortedCollection(sort);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// All we know is that compare is a function,</span></span><br><span class=\"line\">  <span class=\"comment\">// but what type of function?</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(coll.compare <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当给compare分配f时类型信息会丢失。f的类型是(Object, Object)-&gt;int(int表示返回值类型),当然compare的类型是Function。如果我们更改代码以使用显式名称和保留类型信息，开发人员和工具都可以使用这些信息。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Compare = <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortedCollection</span> </span>&#123;</span><br><span class=\"line\">  Compare compare;</span><br><span class=\"line\"></span><br><span class=\"line\">  SortedCollection(<span class=\"keyword\">this</span>.compare);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initial, broken implementation.</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">Object</span> a, <span class=\"built_in\">Object</span> b) =&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  SortedCollection coll = SortedCollection(sort);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(coll.compare <span class=\"keyword\">is</span> <span class=\"built_in\">Function</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(coll.compare <span class=\"keyword\">is</span> Compare);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:目前，typedefs仅限于函数类型。我们期望这种情况会改变。</p>\n</blockquote>\n<p>因为typedef仅仅是别名，所以它们提供了一种检查任何函数类型的方法。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Compare&lt;T&gt; = <span class=\"built_in\">int</span> <span class=\"built_in\">Function</span>(T a, T b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> sort(<span class=\"built_in\">int</span> a, <span class=\"built_in\">int</span> b) =&gt; a - b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(sort <span class=\"keyword\">is</span> Compare&lt;<span class=\"built_in\">int</span>&gt;); <span class=\"comment\">// True!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元数据\"><a href=\"#元数据\" class=\"headerlink\" title=\"元数据\"></a>元数据</h2><p>使用元数据提供关于代码的附加信息。元数据注释以字符@开头，后跟对编译时常量(如deprecated)的引用或对常量构造函数的调用。</p>\n<p>所有Dart代码都可以使用两个注释:@deprecated和@override。有关使用@override的示例，请参见扩展类。这里有一个使用@deprecated注释的例子:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// _Deprecated: Use [turnOn] instead._</span></span><br><span class=\"line\">  <span class=\"meta\">@deprecated</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> activate() &#123;</span><br><span class=\"line\">    turnOn();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// Turns the TV's power on.</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您可以定义自己的元数据注释。这里有一个定义带有两个参数的@todo注释的示例:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">library</span> todo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Todo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> who;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> what;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Todo(<span class=\"keyword\">this</span>.who, <span class=\"keyword\">this</span>.what);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里有一个使用@todo注释的例子:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'todo.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Todo</span>(<span class=\"string\">'seth'</span>, <span class=\"string\">'make this do something'</span>)</span><br><span class=\"line\"><span class=\"keyword\">void</span> doSomething() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'do something'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>元数据可以出现在库、类、类型定义、类型参数、构造函数、工厂、函数、字段、参数或变量声明之前，也可以出现在导入或导出指令之前。您可以使用反射在运行时检索元数据。</p>\n"},{"title":"Dart库和可见性","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-18T12:14:00.000Z","_content":"\nimport和library指令可以帮助您创建模块化和可共享的代码库。库不仅提供api，而且包含隐私部分：以下划线(_)开头的标识符仅在库中可见。每个Dart应用程序都是一个库，即使它不使用库指令。\n\n可以使用包来分发库。有关Pub Package和Asset Manager的信息，请参见[Pub Package和Asset Manager], Pub是SDK中包含的包管理器。\n\n## 使用库\n使用`import`来指定如何在另一个库的范围中使用来自一个库的命名空间。\n\n例如，Dart web应用程序通常使用Dart:html库，它们可以这样导入:\n```dart\nimport 'dart:html';\n```\n导入一个库仅仅需要提供库的URI。对于内置库，URI具有特定的形式（dart:scheme）。对于其他库，可以使用文件路径或者包:scheme的形式。包:scheme形式指定包管理器(如pub工具)提供的库。例如:\n```dart\nimport 'package:test/test.dart';\n```\n> 注意:URI表示统一资源标识符。url(统一资源定位器)是一种常见的URI。\n\n## 指定一个库前缀\n如果您导入两个具有冲突标识符的库，那么您可以为一个或两个库指定一个前缀。例如，如果library1和library2都有一个Element类，那么你可以用以下的方法:\n```dart\nimport 'package:lib1/lib1.dart';\nimport 'package:lib2/lib2.dart' as lib2;\n\n// Uses Element from lib1.\nElement element1 = Element();\n\n// Uses Element from lib2.\nlib2.Element element2 = lib2.Element();\n```\n## 只导入库的一部分\n如果您只想使用库的一部分，您可以有选择地导入库。例如:\n```dart\n// Import only foo.\nimport 'package:lib1/lib1.dart' show foo;\n\n// Import all names EXCEPT foo.\nimport 'package:lib2/lib2.dart' hide foo;\n```\n## 懒加载库\n延迟加载(也称为懒加载)允许应用程序在需要时按需加载库。以下是一些您可能使用延迟加载的情况:\n- 减少应用程序的初始启动时间。\n- 例如，要执行A/B测试——尝试算法的其他实现。\n- 加载很少使用的功能，如可选屏幕和对话框。\n\n要延迟加载库，必须首先使用deferred as进行导入。\n```dart\nimport 'package:greetings/hello.dart' deferred as hello;\n```\n当您需要库时，使用库的标识符调用`loadLibrary()`。\n```dart\nFuture greet() async {\n  await hello.loadLibrary();\n  hello.printGreeting();\n}\n```\n在前面的代码中，wait关键字暂停执行，直到加载库。有关async和waiting的更多信息，请参见[异步支持]。\n您可以在库上多次调用loadLibrary()，没有问题。该库只加载一次。\n在使用延迟加载时，请记住以下几点:\n\n- 在导入文件中，递延库的常量不是常量。记住，这些常量在延迟库加载之前是不存在的。\n- 您不能在导入文件中使用来自延迟库的类型。相反，考虑将接口类型移动到由延迟库和导入文件导入的库。\n- Dart隐式地将loadLibrary()插入到您定义使用deferred作为名称空间的名称空间中。函数的作用是:返回一个未来。\n\n> Dart VM差异:由于问题#33118,Dart VM甚至在调用loadLibrary()之前就允许访问递延库的成员。我们希望这个bug能够很快得到修复，所以不要依赖于当前的VM行为。\n\n## 库的实现\n有关如何实现库包的建议，请参阅[创建库包]，包括:\n\n- 如何组织库的代码。\n- 如何使用export指令。\n- 何时使用part指令。","source":"_posts/dart/09_库和可见性.md","raw":"---\ntitle: Dart库和可见性\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-18 20:14:00   \n---\n\nimport和library指令可以帮助您创建模块化和可共享的代码库。库不仅提供api，而且包含隐私部分：以下划线(_)开头的标识符仅在库中可见。每个Dart应用程序都是一个库，即使它不使用库指令。\n\n可以使用包来分发库。有关Pub Package和Asset Manager的信息，请参见[Pub Package和Asset Manager], Pub是SDK中包含的包管理器。\n\n## 使用库\n使用`import`来指定如何在另一个库的范围中使用来自一个库的命名空间。\n\n例如，Dart web应用程序通常使用Dart:html库，它们可以这样导入:\n```dart\nimport 'dart:html';\n```\n导入一个库仅仅需要提供库的URI。对于内置库，URI具有特定的形式（dart:scheme）。对于其他库，可以使用文件路径或者包:scheme的形式。包:scheme形式指定包管理器(如pub工具)提供的库。例如:\n```dart\nimport 'package:test/test.dart';\n```\n> 注意:URI表示统一资源标识符。url(统一资源定位器)是一种常见的URI。\n\n## 指定一个库前缀\n如果您导入两个具有冲突标识符的库，那么您可以为一个或两个库指定一个前缀。例如，如果library1和library2都有一个Element类，那么你可以用以下的方法:\n```dart\nimport 'package:lib1/lib1.dart';\nimport 'package:lib2/lib2.dart' as lib2;\n\n// Uses Element from lib1.\nElement element1 = Element();\n\n// Uses Element from lib2.\nlib2.Element element2 = lib2.Element();\n```\n## 只导入库的一部分\n如果您只想使用库的一部分，您可以有选择地导入库。例如:\n```dart\n// Import only foo.\nimport 'package:lib1/lib1.dart' show foo;\n\n// Import all names EXCEPT foo.\nimport 'package:lib2/lib2.dart' hide foo;\n```\n## 懒加载库\n延迟加载(也称为懒加载)允许应用程序在需要时按需加载库。以下是一些您可能使用延迟加载的情况:\n- 减少应用程序的初始启动时间。\n- 例如，要执行A/B测试——尝试算法的其他实现。\n- 加载很少使用的功能，如可选屏幕和对话框。\n\n要延迟加载库，必须首先使用deferred as进行导入。\n```dart\nimport 'package:greetings/hello.dart' deferred as hello;\n```\n当您需要库时，使用库的标识符调用`loadLibrary()`。\n```dart\nFuture greet() async {\n  await hello.loadLibrary();\n  hello.printGreeting();\n}\n```\n在前面的代码中，wait关键字暂停执行，直到加载库。有关async和waiting的更多信息，请参见[异步支持]。\n您可以在库上多次调用loadLibrary()，没有问题。该库只加载一次。\n在使用延迟加载时，请记住以下几点:\n\n- 在导入文件中，递延库的常量不是常量。记住，这些常量在延迟库加载之前是不存在的。\n- 您不能在导入文件中使用来自延迟库的类型。相反，考虑将接口类型移动到由延迟库和导入文件导入的库。\n- Dart隐式地将loadLibrary()插入到您定义使用deferred作为名称空间的名称空间中。函数的作用是:返回一个未来。\n\n> Dart VM差异:由于问题#33118,Dart VM甚至在调用loadLibrary()之前就允许访问递延库的成员。我们希望这个bug能够很快得到修复，所以不要依赖于当前的VM行为。\n\n## 库的实现\n有关如何实现库包的建议，请参阅[创建库包]，包括:\n\n- 如何组织库的代码。\n- 如何使用export指令。\n- 何时使用part指令。","slug":"dart/09_库和可见性","published":1,"updated":"2019-10-02T09:26:28.181Z","layout":"post","photos":[],"link":"","_id":"ck19bvaqu000q00wkm4l4oxfo","content":"<p>import和library指令可以帮助您创建模块化和可共享的代码库。库不仅提供api，而且包含隐私部分：以下划线(_)开头的标识符仅在库中可见。每个Dart应用程序都是一个库，即使它不使用库指令。</p>\n<p>可以使用包来分发库。有关Pub Package和Asset Manager的信息，请参见[Pub Package和Asset Manager], Pub是SDK中包含的包管理器。</p>\n<h2 id=\"使用库\"><a href=\"#使用库\" class=\"headerlink\" title=\"使用库\"></a>使用库</h2><p>使用<code>import</code>来指定如何在另一个库的范围中使用来自一个库的命名空间。</p>\n<p>例如，Dart web应用程序通常使用Dart:html库，它们可以这样导入:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:html'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>导入一个库仅仅需要提供库的URI。对于内置库，URI具有特定的形式（dart:scheme）。对于其他库，可以使用文件路径或者包:scheme的形式。包:scheme形式指定包管理器(如pub工具)提供的库。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:test/test.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:URI表示统一资源标识符。url(统一资源定位器)是一种常见的URI。</p>\n</blockquote>\n<h2 id=\"指定一个库前缀\"><a href=\"#指定一个库前缀\" class=\"headerlink\" title=\"指定一个库前缀\"></a>指定一个库前缀</h2><p>如果您导入两个具有冲突标识符的库，那么您可以为一个或两个库指定一个前缀。例如，如果library1和library2都有一个Element类，那么你可以用以下的方法:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> <span class=\"keyword\">as</span> lib2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Uses Element from lib1.</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> element1 = <span class=\"built_in\">Element</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Uses Element from lib2.</span></span><br><span class=\"line\">lib2.<span class=\"built_in\">Element</span> element2 = lib2.<span class=\"built_in\">Element</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"只导入库的一部分\"><a href=\"#只导入库的一部分\" class=\"headerlink\" title=\"只导入库的一部分\"></a>只导入库的一部分</h2><p>如果您只想使用库的一部分，您可以有选择地导入库。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Import only foo.</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span> show foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Import all names EXCEPT foo.</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"懒加载库\"><a href=\"#懒加载库\" class=\"headerlink\" title=\"懒加载库\"></a>懒加载库</h2><p>延迟加载(也称为懒加载)允许应用程序在需要时按需加载库。以下是一些您可能使用延迟加载的情况:</p>\n<ul>\n<li>减少应用程序的初始启动时间。</li>\n<li>例如，要执行A/B测试——尝试算法的其他实现。</li>\n<li>加载很少使用的功能，如可选屏幕和对话框。</li>\n</ul>\n<p>要延迟加载库，必须首先使用deferred as进行导入。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:greetings/hello.dart'</span> deferred <span class=\"keyword\">as</span> hello;</span><br></pre></td></tr></table></figure>\n\n<p>当您需要库时，使用库的标识符调用<code>loadLibrary()</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future greet() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> hello.loadLibrary();</span><br><span class=\"line\">  hello.printGreeting();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在前面的代码中，wait关键字暂停执行，直到加载库。有关async和waiting的更多信息，请参见[异步支持]。<br>您可以在库上多次调用loadLibrary()，没有问题。该库只加载一次。<br>在使用延迟加载时，请记住以下几点:</p>\n<ul>\n<li>在导入文件中，递延库的常量不是常量。记住，这些常量在延迟库加载之前是不存在的。</li>\n<li>您不能在导入文件中使用来自延迟库的类型。相反，考虑将接口类型移动到由延迟库和导入文件导入的库。</li>\n<li>Dart隐式地将loadLibrary()插入到您定义使用deferred作为名称空间的名称空间中。函数的作用是:返回一个未来。</li>\n</ul>\n<blockquote>\n<p>Dart VM差异:由于问题#33118,Dart VM甚至在调用loadLibrary()之前就允许访问递延库的成员。我们希望这个bug能够很快得到修复，所以不要依赖于当前的VM行为。</p>\n</blockquote>\n<h2 id=\"库的实现\"><a href=\"#库的实现\" class=\"headerlink\" title=\"库的实现\"></a>库的实现</h2><p>有关如何实现库包的建议，请参阅[创建库包]，包括:</p>\n<ul>\n<li>如何组织库的代码。</li>\n<li>如何使用export指令。</li>\n<li>何时使用part指令。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>import和library指令可以帮助您创建模块化和可共享的代码库。库不仅提供api，而且包含隐私部分：以下划线(_)开头的标识符仅在库中可见。每个Dart应用程序都是一个库，即使它不使用库指令。</p>\n<p>可以使用包来分发库。有关Pub Package和Asset Manager的信息，请参见[Pub Package和Asset Manager], Pub是SDK中包含的包管理器。</p>\n<h2 id=\"使用库\"><a href=\"#使用库\" class=\"headerlink\" title=\"使用库\"></a>使用库</h2><p>使用<code>import</code>来指定如何在另一个库的范围中使用来自一个库的命名空间。</p>\n<p>例如，Dart web应用程序通常使用Dart:html库，它们可以这样导入:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:html'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>导入一个库仅仅需要提供库的URI。对于内置库，URI具有特定的形式（dart:scheme）。对于其他库，可以使用文件路径或者包:scheme的形式。包:scheme形式指定包管理器(如pub工具)提供的库。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:test/test.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:URI表示统一资源标识符。url(统一资源定位器)是一种常见的URI。</p>\n</blockquote>\n<h2 id=\"指定一个库前缀\"><a href=\"#指定一个库前缀\" class=\"headerlink\" title=\"指定一个库前缀\"></a>指定一个库前缀</h2><p>如果您导入两个具有冲突标识符的库，那么您可以为一个或两个库指定一个前缀。例如，如果library1和library2都有一个Element类，那么你可以用以下的方法:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> <span class=\"keyword\">as</span> lib2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Uses Element from lib1.</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> element1 = <span class=\"built_in\">Element</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Uses Element from lib2.</span></span><br><span class=\"line\">lib2.<span class=\"built_in\">Element</span> element2 = lib2.<span class=\"built_in\">Element</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"只导入库的一部分\"><a href=\"#只导入库的一部分\" class=\"headerlink\" title=\"只导入库的一部分\"></a>只导入库的一部分</h2><p>如果您只想使用库的一部分，您可以有选择地导入库。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Import only foo.</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib1/lib1.dart'</span> show foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Import all names EXCEPT foo.</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"懒加载库\"><a href=\"#懒加载库\" class=\"headerlink\" title=\"懒加载库\"></a>懒加载库</h2><p>延迟加载(也称为懒加载)允许应用程序在需要时按需加载库。以下是一些您可能使用延迟加载的情况:</p>\n<ul>\n<li>减少应用程序的初始启动时间。</li>\n<li>例如，要执行A/B测试——尝试算法的其他实现。</li>\n<li>加载很少使用的功能，如可选屏幕和对话框。</li>\n</ul>\n<p>要延迟加载库，必须首先使用deferred as进行导入。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:greetings/hello.dart'</span> deferred <span class=\"keyword\">as</span> hello;</span><br></pre></td></tr></table></figure>\n\n<p>当您需要库时，使用库的标识符调用<code>loadLibrary()</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future greet() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> hello.loadLibrary();</span><br><span class=\"line\">  hello.printGreeting();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在前面的代码中，wait关键字暂停执行，直到加载库。有关async和waiting的更多信息，请参见[异步支持]。<br>您可以在库上多次调用loadLibrary()，没有问题。该库只加载一次。<br>在使用延迟加载时，请记住以下几点:</p>\n<ul>\n<li>在导入文件中，递延库的常量不是常量。记住，这些常量在延迟库加载之前是不存在的。</li>\n<li>您不能在导入文件中使用来自延迟库的类型。相反，考虑将接口类型移动到由延迟库和导入文件导入的库。</li>\n<li>Dart隐式地将loadLibrary()插入到您定义使用deferred作为名称空间的名称空间中。函数的作用是:返回一个未来。</li>\n</ul>\n<blockquote>\n<p>Dart VM差异:由于问题#33118,Dart VM甚至在调用loadLibrary()之前就允许访问递延库的成员。我们希望这个bug能够很快得到修复，所以不要依赖于当前的VM行为。</p>\n</blockquote>\n<h2 id=\"库的实现\"><a href=\"#库的实现\" class=\"headerlink\" title=\"库的实现\"></a>库的实现</h2><p>有关如何实现库包的建议，请参阅[创建库包]，包括:</p>\n<ul>\n<li>如何组织库的代码。</li>\n<li>如何使用export指令。</li>\n<li>何时使用part指令。</li>\n</ul>\n"},{"title":"Flutter初识和安装","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-19T03:14:00.000Z","_content":"\n## Flutter概述\n> Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。\n\n\n## 特点\n* 跨平台自绘引擎\n* 高性能\n* 采用Dart语言开发。\n\n\n## Flutter框架结构\n\n![](https://cdn.nlark.com/yuque/0/2019/jpeg/179485/1550222890484-6afbf8ea-74eb-433b-8da0-cb79603c6804.jpeg#align=left&display=inline&height=411&linkTarget=_blank&originHeight=449&originWidth=815&size=0&width=746)\n\n## 安装软件（Windows）\n\n1. git\n1. Dart ([https://www.dartlang.org/tools/sdk#install](https://www.dartlang.org/tools/sdk#install))\n1. Flutter ([https://flutter.io/docs/get-started/install](https://flutter.io/docs/get-started/install))\n1. Java(开发Android)\n1. Android Studio\n1. Intellij IDEA(可选)\n\n## 配置环境变量(Path)\n\n* %JAVA_HOME%\\bin\n* %DART_HOME%\\bin\n* %ANDROID_HOME%\\tools\n* %FLUTTER_HOME%\\bin\n\n## IDE 插件\n\n* Flutter\n\n## Hello Word\n### 创建步骤\n1. 创建一个简单的、基于模板的 Flutter 工程，按照指南中所描述的步骤，然后将项目命名为 startup_namer（而不是 myapp），接下来你将会修改这个工程来完成最终的 App。\n2. 删除 lib/main.dart 中的所有代码，然后替换为下面的代码，它将在屏幕的中心显示\"Hello World\"。\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(new MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n      title: 'Welcome to Flutter',\n      home: new Scaffold(\n        appBar: new AppBar(\n          title: const Text('Welcome to Flutter'),\n        ),\n        body: const Center(\n          child: const Text('Hello World'),\n        ),\n      ),\n    );\n  }\n}\n```\n3. 运行你的工程项目。\n  \n![](img/hello_word_android.png) ![](img/hello_word_ios.png)\n\n### 观察分析\n- 本示例创建了一个具有 Material Design 风格的应用，Material 是一种移动端和网页端通用的视觉设计语言，Flutter 提供了丰富的 Material 风格的 widgets。\n- 主函数（main）使用了 (=>) 符号，这是 Dart 中单行函数或方法的简写。\n- 该应用程序继承了 StatelessWidget，这将会使应用本身也成为一个 widget。在 Flutter 中，大多数东西都是 widget，包括对齐 (alignment)、填充 (padding) 和布局 (layout)。\n- Scaffold 是 Material library 中提供的一个 widget，它提供了默认的导航栏、标题和包含主屏幕 widget 树的 body 属性。widget 树可以很复杂。\n- 一个 widget 的主要工作是提供一个 build() 方法来描述如何根据其他较低级别的 widgets 来显示自己。\n- 本示例中的 body 的 widget 树中包含了一个 Center widget，Center widget 又包含一个 Text 子 widget，Center widget 可以将其子 widget 树对其到屏幕中心。","source":"_posts/flutter/01_初识与安装.md","raw":"---\ntitle: Flutter初识和安装\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-19 11:14:00   \n---\n\n## Flutter概述\n> Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。\n\n\n## 特点\n* 跨平台自绘引擎\n* 高性能\n* 采用Dart语言开发。\n\n\n## Flutter框架结构\n\n![](https://cdn.nlark.com/yuque/0/2019/jpeg/179485/1550222890484-6afbf8ea-74eb-433b-8da0-cb79603c6804.jpeg#align=left&display=inline&height=411&linkTarget=_blank&originHeight=449&originWidth=815&size=0&width=746)\n\n## 安装软件（Windows）\n\n1. git\n1. Dart ([https://www.dartlang.org/tools/sdk#install](https://www.dartlang.org/tools/sdk#install))\n1. Flutter ([https://flutter.io/docs/get-started/install](https://flutter.io/docs/get-started/install))\n1. Java(开发Android)\n1. Android Studio\n1. Intellij IDEA(可选)\n\n## 配置环境变量(Path)\n\n* %JAVA_HOME%\\bin\n* %DART_HOME%\\bin\n* %ANDROID_HOME%\\tools\n* %FLUTTER_HOME%\\bin\n\n## IDE 插件\n\n* Flutter\n\n## Hello Word\n### 创建步骤\n1. 创建一个简单的、基于模板的 Flutter 工程，按照指南中所描述的步骤，然后将项目命名为 startup_namer（而不是 myapp），接下来你将会修改这个工程来完成最终的 App。\n2. 删除 lib/main.dart 中的所有代码，然后替换为下面的代码，它将在屏幕的中心显示\"Hello World\"。\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(new MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n      title: 'Welcome to Flutter',\n      home: new Scaffold(\n        appBar: new AppBar(\n          title: const Text('Welcome to Flutter'),\n        ),\n        body: const Center(\n          child: const Text('Hello World'),\n        ),\n      ),\n    );\n  }\n}\n```\n3. 运行你的工程项目。\n  \n![](img/hello_word_android.png) ![](img/hello_word_ios.png)\n\n### 观察分析\n- 本示例创建了一个具有 Material Design 风格的应用，Material 是一种移动端和网页端通用的视觉设计语言，Flutter 提供了丰富的 Material 风格的 widgets。\n- 主函数（main）使用了 (=>) 符号，这是 Dart 中单行函数或方法的简写。\n- 该应用程序继承了 StatelessWidget，这将会使应用本身也成为一个 widget。在 Flutter 中，大多数东西都是 widget，包括对齐 (alignment)、填充 (padding) 和布局 (layout)。\n- Scaffold 是 Material library 中提供的一个 widget，它提供了默认的导航栏、标题和包含主屏幕 widget 树的 body 属性。widget 树可以很复杂。\n- 一个 widget 的主要工作是提供一个 build() 方法来描述如何根据其他较低级别的 widgets 来显示自己。\n- 本示例中的 body 的 widget 树中包含了一个 Center widget，Center widget 又包含一个 Text 子 widget，Center widget 可以将其子 widget 树对其到屏幕中心。","slug":"flutter/01_初识与安装","published":1,"updated":"2019-10-02T10:32:44.219Z","layout":"post","photos":[],"link":"","_id":"ck19bvar0000v00wk8ebhxsqe","content":"<h2 id=\"Flutter概述\"><a href=\"#Flutter概述\" class=\"headerlink\" title=\"Flutter概述\"></a>Flutter概述</h2><blockquote>\n<p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p>\n</blockquote>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>跨平台自绘引擎</li>\n<li>高性能</li>\n<li>采用Dart语言开发。</li>\n</ul>\n<h2 id=\"Flutter框架结构\"><a href=\"#Flutter框架结构\" class=\"headerlink\" title=\"Flutter框架结构\"></a>Flutter框架结构</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/179485/1550222890484-6afbf8ea-74eb-433b-8da0-cb79603c6804.jpeg#align=left&display=inline&height=411&linkTarget=_blank&originHeight=449&originWidth=815&size=0&width=746\" alt></p>\n<h2 id=\"安装软件（Windows）\"><a href=\"#安装软件（Windows）\" class=\"headerlink\" title=\"安装软件（Windows）\"></a>安装软件（Windows）</h2><ol>\n<li>git</li>\n<li>Dart (<a href=\"https://www.dartlang.org/tools/sdk#install\" target=\"_blank\" rel=\"noopener\">https://www.dartlang.org/tools/sdk#install</a>)</li>\n<li>Flutter (<a href=\"https://flutter.io/docs/get-started/install\" target=\"_blank\" rel=\"noopener\">https://flutter.io/docs/get-started/install</a>)</li>\n<li>Java(开发Android)</li>\n<li>Android Studio</li>\n<li>Intellij IDEA(可选)</li>\n</ol>\n<h2 id=\"配置环境变量-Path\"><a href=\"#配置环境变量-Path\" class=\"headerlink\" title=\"配置环境变量(Path)\"></a>配置环境变量(Path)</h2><ul>\n<li>%JAVA_HOME%\\bin</li>\n<li>%DART_HOME%\\bin</li>\n<li>%ANDROID_HOME%\\tools</li>\n<li>%FLUTTER_HOME%\\bin</li>\n</ul>\n<h2 id=\"IDE-插件\"><a href=\"#IDE-插件\" class=\"headerlink\" title=\"IDE 插件\"></a>IDE 插件</h2><ul>\n<li>Flutter</li>\n</ul>\n<h2 id=\"Hello-Word\"><a href=\"#Hello-Word\" class=\"headerlink\" title=\"Hello Word\"></a>Hello Word</h2><h3 id=\"创建步骤\"><a href=\"#创建步骤\" class=\"headerlink\" title=\"创建步骤\"></a>创建步骤</h3><ol>\n<li><p>创建一个简单的、基于模板的 Flutter 工程，按照指南中所描述的步骤，然后将项目命名为 startup_namer（而不是 myapp），接下来你将会修改这个工程来完成最终的 App。</p>\n</li>\n<li><p>删除 lib/main.dart 中的所有代码，然后替换为下面的代码，它将在屏幕的中心显示”Hello World”。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() =&gt; runApp(<span class=\"keyword\">new</span> MyApp());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Welcome to Flutter'</span>,</span><br><span class=\"line\">      home: <span class=\"keyword\">new</span> Scaffold(</span><br><span class=\"line\">        appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">          title: <span class=\"keyword\">const</span> Text(<span class=\"string\">'Welcome to Flutter'</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: <span class=\"keyword\">const</span> Center(</span><br><span class=\"line\">          child: <span class=\"keyword\">const</span> Text(<span class=\"string\">'Hello World'</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行你的工程项目。</p>\n</li>\n</ol>\n<p><img src=\"img/hello_word_android.png\" alt> <img src=\"img/hello_word_ios.png\" alt></p>\n<h3 id=\"观察分析\"><a href=\"#观察分析\" class=\"headerlink\" title=\"观察分析\"></a>观察分析</h3><ul>\n<li>本示例创建了一个具有 Material Design 风格的应用，Material 是一种移动端和网页端通用的视觉设计语言，Flutter 提供了丰富的 Material 风格的 widgets。</li>\n<li>主函数（main）使用了 (=&gt;) 符号，这是 Dart 中单行函数或方法的简写。</li>\n<li>该应用程序继承了 StatelessWidget，这将会使应用本身也成为一个 widget。在 Flutter 中，大多数东西都是 widget，包括对齐 (alignment)、填充 (padding) 和布局 (layout)。</li>\n<li>Scaffold 是 Material library 中提供的一个 widget，它提供了默认的导航栏、标题和包含主屏幕 widget 树的 body 属性。widget 树可以很复杂。</li>\n<li>一个 widget 的主要工作是提供一个 build() 方法来描述如何根据其他较低级别的 widgets 来显示自己。</li>\n<li>本示例中的 body 的 widget 树中包含了一个 Center widget，Center widget 又包含一个 Text 子 widget，Center widget 可以将其子 widget 树对其到屏幕中心。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Flutter概述\"><a href=\"#Flutter概述\" class=\"headerlink\" title=\"Flutter概述\"></a>Flutter概述</h2><blockquote>\n<p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p>\n</blockquote>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>跨平台自绘引擎</li>\n<li>高性能</li>\n<li>采用Dart语言开发。</li>\n</ul>\n<h2 id=\"Flutter框架结构\"><a href=\"#Flutter框架结构\" class=\"headerlink\" title=\"Flutter框架结构\"></a>Flutter框架结构</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/179485/1550222890484-6afbf8ea-74eb-433b-8da0-cb79603c6804.jpeg#align=left&display=inline&height=411&linkTarget=_blank&originHeight=449&originWidth=815&size=0&width=746\" alt></p>\n<h2 id=\"安装软件（Windows）\"><a href=\"#安装软件（Windows）\" class=\"headerlink\" title=\"安装软件（Windows）\"></a>安装软件（Windows）</h2><ol>\n<li>git</li>\n<li>Dart (<a href=\"https://www.dartlang.org/tools/sdk#install\" target=\"_blank\" rel=\"noopener\">https://www.dartlang.org/tools/sdk#install</a>)</li>\n<li>Flutter (<a href=\"https://flutter.io/docs/get-started/install\" target=\"_blank\" rel=\"noopener\">https://flutter.io/docs/get-started/install</a>)</li>\n<li>Java(开发Android)</li>\n<li>Android Studio</li>\n<li>Intellij IDEA(可选)</li>\n</ol>\n<h2 id=\"配置环境变量-Path\"><a href=\"#配置环境变量-Path\" class=\"headerlink\" title=\"配置环境变量(Path)\"></a>配置环境变量(Path)</h2><ul>\n<li>%JAVA_HOME%\\bin</li>\n<li>%DART_HOME%\\bin</li>\n<li>%ANDROID_HOME%\\tools</li>\n<li>%FLUTTER_HOME%\\bin</li>\n</ul>\n<h2 id=\"IDE-插件\"><a href=\"#IDE-插件\" class=\"headerlink\" title=\"IDE 插件\"></a>IDE 插件</h2><ul>\n<li>Flutter</li>\n</ul>\n<h2 id=\"Hello-Word\"><a href=\"#Hello-Word\" class=\"headerlink\" title=\"Hello Word\"></a>Hello Word</h2><h3 id=\"创建步骤\"><a href=\"#创建步骤\" class=\"headerlink\" title=\"创建步骤\"></a>创建步骤</h3><ol>\n<li><p>创建一个简单的、基于模板的 Flutter 工程，按照指南中所描述的步骤，然后将项目命名为 startup_namer（而不是 myapp），接下来你将会修改这个工程来完成最终的 App。</p>\n</li>\n<li><p>删除 lib/main.dart 中的所有代码，然后替换为下面的代码，它将在屏幕的中心显示”Hello World”。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() =&gt; runApp(<span class=\"keyword\">new</span> MyApp());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Welcome to Flutter'</span>,</span><br><span class=\"line\">      home: <span class=\"keyword\">new</span> Scaffold(</span><br><span class=\"line\">        appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">          title: <span class=\"keyword\">const</span> Text(<span class=\"string\">'Welcome to Flutter'</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: <span class=\"keyword\">const</span> Center(</span><br><span class=\"line\">          child: <span class=\"keyword\">const</span> Text(<span class=\"string\">'Hello World'</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行你的工程项目。</p>\n</li>\n</ol>\n<p><img src=\"img/hello_word_android.png\" alt> <img src=\"img/hello_word_ios.png\" alt></p>\n<h3 id=\"观察分析\"><a href=\"#观察分析\" class=\"headerlink\" title=\"观察分析\"></a>观察分析</h3><ul>\n<li>本示例创建了一个具有 Material Design 风格的应用，Material 是一种移动端和网页端通用的视觉设计语言，Flutter 提供了丰富的 Material 风格的 widgets。</li>\n<li>主函数（main）使用了 (=&gt;) 符号，这是 Dart 中单行函数或方法的简写。</li>\n<li>该应用程序继承了 StatelessWidget，这将会使应用本身也成为一个 widget。在 Flutter 中，大多数东西都是 widget，包括对齐 (alignment)、填充 (padding) 和布局 (layout)。</li>\n<li>Scaffold 是 Material library 中提供的一个 widget，它提供了默认的导航栏、标题和包含主屏幕 widget 树的 body 属性。widget 树可以很复杂。</li>\n<li>一个 widget 的主要工作是提供一个 build() 方法来描述如何根据其他较低级别的 widgets 来显示自己。</li>\n<li>本示例中的 body 的 widget 树中包含了一个 Center widget，Center widget 又包含一个 Text 子 widget，Center widget 可以将其子 widget 树对其到屏幕中心。</li>\n</ul>\n"},{"title":"Eclipse.ini参数设置","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-04-16T06:03:00.000Z","_content":"### vmargs下常见参数的意思：\n```\n-vmargs  \n-Xms40m  \n-Xmx256m  \n-XX:PermSize=64M  \n-XX:MaxPermSize=128M\n```\n\n- -vmargs: 说明后面是VM的参数  \n- -Xms40m: 虚拟机占用系统的最小内存,初始分配  \n- -Xmx256m: 虚拟机占用系统的最大内存,按需分配  \n- -XX:PermSize: 最小堆大小。一般报内存不足时,都是说这个太小, 堆空间剩余小于5%就会警告,建议把这个稍微设大一点,不过要视自己机器内存大小来设置，但不能超过MaxPermSize  \n- -XX:MaxPermSize: 最大堆大小。这个也适当大些所以若出现问题，首先请调整 `-Xms40m：`将其设置的小一些，就可以解决问题`PermSize`和`MaxPermSize`指虚拟机为java永久生成对象（Permanate generation）等这些可反射对象分配内 存的限制，这些内存不包括在Heap（堆内存）区之中.\n\n### 解决Failed to creat java virtual machine问题:  \n打开eclipse安装目录下的eclipse.ini文件，修改：  \n```\n--launcher.XXMaxPermSize  \n128M;  \n```\n为：\n```  \n--launcher.XXMaxPermSize  \n256m\n```\n设置Eclipse使用的JRE为本机安装的JDK目录：  \n在eclipse.ini中添加两行  \n```\n -vm  \nC:\\\\Program Files\\\\Java\\\\jdk1.6.0_10\\\\bin\\\\javaw.exe   \n```\n* 注意: 要写在两行，写在一行不能生效；这两行要定在-vmargs之前，不然也不能生效。\n\n### 我的eclipes.ini文件配置如下：\n\n```\n-startup\nplugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar\n--launcher.library\nplugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.200.v20140603-1326\n-product\norg.eclipse.epp.package.java.product\n-showsplash\norg.eclipse.platform\n--launcher.defaultAction\nopenFile\n--launcher.XXMaxPermSize\n384M\n-vm\nC:\\Program Files\\Java\\jre7\\bin\\javaw.exe\n-vmargs\n-Dcom.sun.management.jmxremote \n-Dosgi.requiredJavaVersion=1.6\n-Xverify:none\n-Xmn128m\n-Xms256m\n-Xmx768m\n-Xss1m\n-XX:PermSize=128M\n-XX:MaxPermSize=512M\n```","source":"_posts/ide/Eclipse.ini参数设置.md","raw":"title: Eclipse.ini参数设置\nauthor: JsonYe\ntags:\n  - eclipse\ncategories:\n  - IDE  \ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-04-16 14:03:00\n---\n### vmargs下常见参数的意思：\n```\n-vmargs  \n-Xms40m  \n-Xmx256m  \n-XX:PermSize=64M  \n-XX:MaxPermSize=128M\n```\n\n- -vmargs: 说明后面是VM的参数  \n- -Xms40m: 虚拟机占用系统的最小内存,初始分配  \n- -Xmx256m: 虚拟机占用系统的最大内存,按需分配  \n- -XX:PermSize: 最小堆大小。一般报内存不足时,都是说这个太小, 堆空间剩余小于5%就会警告,建议把这个稍微设大一点,不过要视自己机器内存大小来设置，但不能超过MaxPermSize  \n- -XX:MaxPermSize: 最大堆大小。这个也适当大些所以若出现问题，首先请调整 `-Xms40m：`将其设置的小一些，就可以解决问题`PermSize`和`MaxPermSize`指虚拟机为java永久生成对象（Permanate generation）等这些可反射对象分配内 存的限制，这些内存不包括在Heap（堆内存）区之中.\n\n### 解决Failed to creat java virtual machine问题:  \n打开eclipse安装目录下的eclipse.ini文件，修改：  \n```\n--launcher.XXMaxPermSize  \n128M;  \n```\n为：\n```  \n--launcher.XXMaxPermSize  \n256m\n```\n设置Eclipse使用的JRE为本机安装的JDK目录：  \n在eclipse.ini中添加两行  \n```\n -vm  \nC:\\\\Program Files\\\\Java\\\\jdk1.6.0_10\\\\bin\\\\javaw.exe   \n```\n* 注意: 要写在两行，写在一行不能生效；这两行要定在-vmargs之前，不然也不能生效。\n\n### 我的eclipes.ini文件配置如下：\n\n```\n-startup\nplugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar\n--launcher.library\nplugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.200.v20140603-1326\n-product\norg.eclipse.epp.package.java.product\n-showsplash\norg.eclipse.platform\n--launcher.defaultAction\nopenFile\n--launcher.XXMaxPermSize\n384M\n-vm\nC:\\Program Files\\Java\\jre7\\bin\\javaw.exe\n-vmargs\n-Dcom.sun.management.jmxremote \n-Dosgi.requiredJavaVersion=1.6\n-Xverify:none\n-Xmn128m\n-Xms256m\n-Xmx768m\n-Xss1m\n-XX:PermSize=128M\n-XX:MaxPermSize=512M\n```","slug":"ide/Eclipse.ini参数设置","published":1,"updated":"2019-10-02T08:42:28.543Z","layout":"post","photos":[],"link":"","_id":"ck19bvayn001j00wkbbw2q6ev","content":"<h3 id=\"vmargs下常见参数的意思：\"><a href=\"#vmargs下常见参数的意思：\" class=\"headerlink\" title=\"vmargs下常见参数的意思：\"></a>vmargs下常见参数的意思：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-vmargs  </span><br><span class=\"line\">-Xms40m  </span><br><span class=\"line\">-Xmx256m  </span><br><span class=\"line\">-XX:PermSize=64M  </span><br><span class=\"line\">-XX:MaxPermSize=128M</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-vmargs: 说明后面是VM的参数  </li>\n<li>-Xms40m: 虚拟机占用系统的最小内存,初始分配  </li>\n<li>-Xmx256m: 虚拟机占用系统的最大内存,按需分配  </li>\n<li>-XX:PermSize: 最小堆大小。一般报内存不足时,都是说这个太小, 堆空间剩余小于5%就会警告,建议把这个稍微设大一点,不过要视自己机器内存大小来设置，但不能超过MaxPermSize  </li>\n<li>-XX:MaxPermSize: 最大堆大小。这个也适当大些所以若出现问题，首先请调整 <code>-Xms40m：</code>将其设置的小一些，就可以解决问题<code>PermSize</code>和<code>MaxPermSize</code>指虚拟机为java永久生成对象（Permanate generation）等这些可反射对象分配内 存的限制，这些内存不包括在Heap（堆内存）区之中.</li>\n</ul>\n<h3 id=\"解决Failed-to-creat-java-virtual-machine问题\"><a href=\"#解决Failed-to-creat-java-virtual-machine问题\" class=\"headerlink\" title=\"解决Failed to creat java virtual machine问题:\"></a>解决Failed to creat java virtual machine问题:</h3><p>打开eclipse安装目录下的eclipse.ini文件，修改：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--launcher.XXMaxPermSize  </span><br><span class=\"line\">128M;</span><br></pre></td></tr></table></figure>\n\n<p>为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--launcher.XXMaxPermSize  </span><br><span class=\"line\">256m</span><br></pre></td></tr></table></figure>\n\n<p>设置Eclipse使用的JRE为本机安装的JDK目录：<br>在eclipse.ini中添加两行  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> -vm  </span><br><span class=\"line\">C:\\\\Program Files\\\\Java\\\\jdk1.6.0_10\\\\bin\\\\javaw.exe</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意: 要写在两行，写在一行不能生效；这两行要定在-vmargs之前，不然也不能生效。</li>\n</ul>\n<h3 id=\"我的eclipes-ini文件配置如下：\"><a href=\"#我的eclipes-ini文件配置如下：\" class=\"headerlink\" title=\"我的eclipes.ini文件配置如下：\"></a>我的eclipes.ini文件配置如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-startup</span><br><span class=\"line\">plugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar</span><br><span class=\"line\">--launcher.library</span><br><span class=\"line\">plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.200.v20140603-1326</span><br><span class=\"line\">-product</span><br><span class=\"line\">org.eclipse.epp.package.java.product</span><br><span class=\"line\">-showsplash</span><br><span class=\"line\">org.eclipse.platform</span><br><span class=\"line\">--launcher.defaultAction</span><br><span class=\"line\">openFile</span><br><span class=\"line\">--launcher.XXMaxPermSize</span><br><span class=\"line\">384M</span><br><span class=\"line\">-vm</span><br><span class=\"line\">C:\\Program Files\\Java\\jre7\\bin\\javaw.exe</span><br><span class=\"line\">-vmargs</span><br><span class=\"line\">-Dcom.sun.management.jmxremote </span><br><span class=\"line\">-Dosgi.requiredJavaVersion=1.6</span><br><span class=\"line\">-Xverify:none</span><br><span class=\"line\">-Xmn128m</span><br><span class=\"line\">-Xms256m</span><br><span class=\"line\">-Xmx768m</span><br><span class=\"line\">-Xss1m</span><br><span class=\"line\">-XX:PermSize=128M</span><br><span class=\"line\">-XX:MaxPermSize=512M</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vmargs下常见参数的意思：\"><a href=\"#vmargs下常见参数的意思：\" class=\"headerlink\" title=\"vmargs下常见参数的意思：\"></a>vmargs下常见参数的意思：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-vmargs  </span><br><span class=\"line\">-Xms40m  </span><br><span class=\"line\">-Xmx256m  </span><br><span class=\"line\">-XX:PermSize=64M  </span><br><span class=\"line\">-XX:MaxPermSize=128M</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-vmargs: 说明后面是VM的参数  </li>\n<li>-Xms40m: 虚拟机占用系统的最小内存,初始分配  </li>\n<li>-Xmx256m: 虚拟机占用系统的最大内存,按需分配  </li>\n<li>-XX:PermSize: 最小堆大小。一般报内存不足时,都是说这个太小, 堆空间剩余小于5%就会警告,建议把这个稍微设大一点,不过要视自己机器内存大小来设置，但不能超过MaxPermSize  </li>\n<li>-XX:MaxPermSize: 最大堆大小。这个也适当大些所以若出现问题，首先请调整 <code>-Xms40m：</code>将其设置的小一些，就可以解决问题<code>PermSize</code>和<code>MaxPermSize</code>指虚拟机为java永久生成对象（Permanate generation）等这些可反射对象分配内 存的限制，这些内存不包括在Heap（堆内存）区之中.</li>\n</ul>\n<h3 id=\"解决Failed-to-creat-java-virtual-machine问题\"><a href=\"#解决Failed-to-creat-java-virtual-machine问题\" class=\"headerlink\" title=\"解决Failed to creat java virtual machine问题:\"></a>解决Failed to creat java virtual machine问题:</h3><p>打开eclipse安装目录下的eclipse.ini文件，修改：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--launcher.XXMaxPermSize  </span><br><span class=\"line\">128M;</span><br></pre></td></tr></table></figure>\n\n<p>为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--launcher.XXMaxPermSize  </span><br><span class=\"line\">256m</span><br></pre></td></tr></table></figure>\n\n<p>设置Eclipse使用的JRE为本机安装的JDK目录：<br>在eclipse.ini中添加两行  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> -vm  </span><br><span class=\"line\">C:\\\\Program Files\\\\Java\\\\jdk1.6.0_10\\\\bin\\\\javaw.exe</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意: 要写在两行，写在一行不能生效；这两行要定在-vmargs之前，不然也不能生效。</li>\n</ul>\n<h3 id=\"我的eclipes-ini文件配置如下：\"><a href=\"#我的eclipes-ini文件配置如下：\" class=\"headerlink\" title=\"我的eclipes.ini文件配置如下：\"></a>我的eclipes.ini文件配置如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-startup</span><br><span class=\"line\">plugins/org.eclipse.equinox.launcher_1.3.0.v20140415-2008.jar</span><br><span class=\"line\">--launcher.library</span><br><span class=\"line\">plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.200.v20140603-1326</span><br><span class=\"line\">-product</span><br><span class=\"line\">org.eclipse.epp.package.java.product</span><br><span class=\"line\">-showsplash</span><br><span class=\"line\">org.eclipse.platform</span><br><span class=\"line\">--launcher.defaultAction</span><br><span class=\"line\">openFile</span><br><span class=\"line\">--launcher.XXMaxPermSize</span><br><span class=\"line\">384M</span><br><span class=\"line\">-vm</span><br><span class=\"line\">C:\\Program Files\\Java\\jre7\\bin\\javaw.exe</span><br><span class=\"line\">-vmargs</span><br><span class=\"line\">-Dcom.sun.management.jmxremote </span><br><span class=\"line\">-Dosgi.requiredJavaVersion=1.6</span><br><span class=\"line\">-Xverify:none</span><br><span class=\"line\">-Xmn128m</span><br><span class=\"line\">-Xms256m</span><br><span class=\"line\">-Xmx768m</span><br><span class=\"line\">-Xss1m</span><br><span class=\"line\">-XX:PermSize=128M</span><br><span class=\"line\">-XX:MaxPermSize=512M</span><br></pre></td></tr></table></figure>"},{"title":"利用Hexo+GitHub搭建个人博客(一)","author":"JsonYe","date":"2019-09-30T05:55:00.000Z","_content":"\n## 前言\n很久以前的一个想法，就是搭建一个个人博客，把个人在学习、生活中的故事记录下来。`hexo`让我的想法变成了现实。\n下面就简单说一下整体打搭建流程。\n\n## 搭建步骤：\n> 最开始以为要把hexo安装到服务器上，后来了解后恍然大悟，他是在本地安装的，然后将我们写的markdown文件转换为静态网站文件，放到github上，利用github来作为服务器的。\n\n 1. 安装git bash。\n 2. 安装npm。\n 3. 安装NodeJs\n 4. 申请github账户，并创建一个仓库，命名规范为  \"账户名\".github.io。\n 5. 创建SSH并添加到github上。\n 6. 安装hexo。\n 7. 部署项目，本地测试。\n 8. 上传到github上。\n \n到这一步，博客就搭建好了，域名可选择性进行关联。后续可以设置主题、添加RSS、设置评论、以及写文章。具体可参考[官方文档](https://hexo.io/zh-cn/docs/writing.html)","source":"_posts/hexo/利用Hexo+GitHub搭建个人博客.md","raw":"title: 利用Hexo+GitHub搭建个人博客(一)\ncategories:\n  - hexo\ntags:\n  - hexo\nauthor: JsonYe\ndate: 2019-09-30 13:55:00\n---\n\n## 前言\n很久以前的一个想法，就是搭建一个个人博客，把个人在学习、生活中的故事记录下来。`hexo`让我的想法变成了现实。\n下面就简单说一下整体打搭建流程。\n\n## 搭建步骤：\n> 最开始以为要把hexo安装到服务器上，后来了解后恍然大悟，他是在本地安装的，然后将我们写的markdown文件转换为静态网站文件，放到github上，利用github来作为服务器的。\n\n 1. 安装git bash。\n 2. 安装npm。\n 3. 安装NodeJs\n 4. 申请github账户，并创建一个仓库，命名规范为  \"账户名\".github.io。\n 5. 创建SSH并添加到github上。\n 6. 安装hexo。\n 7. 部署项目，本地测试。\n 8. 上传到github上。\n \n到这一步，博客就搭建好了，域名可选择性进行关联。后续可以设置主题、添加RSS、设置评论、以及写文章。具体可参考[官方文档](https://hexo.io/zh-cn/docs/writing.html)","slug":"hexo/利用Hexo+GitHub搭建个人博客","published":1,"updated":"2019-10-02T08:41:54.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck19bvayq001k00wklv5gi413","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>很久以前的一个想法，就是搭建一个个人博客，把个人在学习、生活中的故事记录下来。<code>hexo</code>让我的想法变成了现实。<br>下面就简单说一下整体打搭建流程。</p>\n<h2 id=\"搭建步骤：\"><a href=\"#搭建步骤：\" class=\"headerlink\" title=\"搭建步骤：\"></a>搭建步骤：</h2><blockquote>\n<p>最开始以为要把hexo安装到服务器上，后来了解后恍然大悟，他是在本地安装的，然后将我们写的markdown文件转换为静态网站文件，放到github上，利用github来作为服务器的。</p>\n</blockquote>\n<ol>\n<li>安装git bash。</li>\n<li>安装npm。</li>\n<li>安装NodeJs</li>\n<li>申请github账户，并创建一个仓库，命名规范为  “账户名”.github.io。</li>\n<li>创建SSH并添加到github上。</li>\n<li>安装hexo。</li>\n<li>部署项目，本地测试。</li>\n<li>上传到github上。</li>\n</ol>\n<p>到这一步，博客就搭建好了，域名可选择性进行关联。后续可以设置主题、添加RSS、设置评论、以及写文章。具体可参考<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>很久以前的一个想法，就是搭建一个个人博客，把个人在学习、生活中的故事记录下来。<code>hexo</code>让我的想法变成了现实。<br>下面就简单说一下整体打搭建流程。</p>\n<h2 id=\"搭建步骤：\"><a href=\"#搭建步骤：\" class=\"headerlink\" title=\"搭建步骤：\"></a>搭建步骤：</h2><blockquote>\n<p>最开始以为要把hexo安装到服务器上，后来了解后恍然大悟，他是在本地安装的，然后将我们写的markdown文件转换为静态网站文件，放到github上，利用github来作为服务器的。</p>\n</blockquote>\n<ol>\n<li>安装git bash。</li>\n<li>安装npm。</li>\n<li>安装NodeJs</li>\n<li>申请github账户，并创建一个仓库，命名规范为  “账户名”.github.io。</li>\n<li>创建SSH并添加到github上。</li>\n<li>安装hexo。</li>\n<li>部署项目，本地测试。</li>\n<li>上传到github上。</li>\n</ol>\n<p>到这一步，博客就搭建好了，域名可选择性进行关联。后续可以设置主题、添加RSS、设置评论、以及写文章。具体可参考<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n"},{"title":"利用Hexo+GitHub搭建个人博客(二)","author":"JsonYe","date":"2019-09-30T06:55:00.000Z","_content":"> 安装好hexo后，可进行各项配置\n\n### 关于页面\n使用：`hexo new page “about” `新建一个 关于我 页面。 \n主题的` _config.yml `文件中的 `menu` 中进行匹配 \n不同主题 `_config. yml`文件有区别\n```\nmenu:\n  home: /      //主页\n  categories: /categories //分类\n  archives: /archives   //归档\n  tags: /tags   //标签\n  about: /about   //关于                  （添加此行即可）\n或    \nmenu:\n  - page: home\n    directory: .      //主页\n    icon: fa-home\n  - page: archive\n    directory: archives/    //归档\n    icon: fa-archive\n  - page: about\n    directory: about/    //关于\n    icon: fa-user\n  - page: rss\n    directory: atom.xml    //rss订阅\n    icon: fa-rss\n```\n编辑 about 关于页面 md文件 部署就能看到\n\n### 添加分类\n使用： `hexo new page categories` 新建一个 分类 页面。  \n主题的 `_config.yml` 文件中的 `menu` 中进行匹配\n```\nmenu:\n  home: /      //主页\n  categories: /categories //分类   \n  archives: /archives   //归档\n  tags: /tags   //标签                  \n  about: /about   //关于\n```\n底下代码是一篇包含 分类 文章的例子：\n```\ntitle: 分类测试\ncategories:\n- hexo                       （这个就是文章的分类了）\n```\n\n\n### 添加RSS\n#### 安装\nhexo博客有一个专门生成RSS xml文件的插件`hexo-generator-feed`\n我们来安装它\n```\nnpm install hexo-generator-feed\n```\n\n看到`added 3 packages`说明安装成功了。\n\n#### 启用\n在博客工程文件根目录下`_config.yml`文件中添加如下内容\n```\n# Extensions\nplugins:\n    hexo-generator-feed\n#Feed Atom\nfeed:\n    type: atom\n    path: atom.xml\n    limit: 20\n```\n\n#### 生成RSS\n```\n$ hexo g\n(node:6520) [DEP0061] DeprecationWarning: fs.SyncWriteStream is depre                                                                                                                           cated.\nINFO  Start processing\nINFO  Files loaded in 6.33 s\nINFO  Generated: atom.xml <----------成功生成atom.xml文件\nINFO  Generated: sitemap.xml\nINFO  Generated: baidusitemap.xml\nINFO  Generated: about/index.html\n......\n......\n......\n```","source":"_posts/hexo/hexo配置.md","raw":"title: 利用Hexo+GitHub搭建个人博客(二)\ncategories:\n  - hexo\ntags:\n  - hexo\nauthor: JsonYe\ndate: 2019-09-30 14:55:00\n---\n> 安装好hexo后，可进行各项配置\n\n### 关于页面\n使用：`hexo new page “about” `新建一个 关于我 页面。 \n主题的` _config.yml `文件中的 `menu` 中进行匹配 \n不同主题 `_config. yml`文件有区别\n```\nmenu:\n  home: /      //主页\n  categories: /categories //分类\n  archives: /archives   //归档\n  tags: /tags   //标签\n  about: /about   //关于                  （添加此行即可）\n或    \nmenu:\n  - page: home\n    directory: .      //主页\n    icon: fa-home\n  - page: archive\n    directory: archives/    //归档\n    icon: fa-archive\n  - page: about\n    directory: about/    //关于\n    icon: fa-user\n  - page: rss\n    directory: atom.xml    //rss订阅\n    icon: fa-rss\n```\n编辑 about 关于页面 md文件 部署就能看到\n\n### 添加分类\n使用： `hexo new page categories` 新建一个 分类 页面。  \n主题的 `_config.yml` 文件中的 `menu` 中进行匹配\n```\nmenu:\n  home: /      //主页\n  categories: /categories //分类   \n  archives: /archives   //归档\n  tags: /tags   //标签                  \n  about: /about   //关于\n```\n底下代码是一篇包含 分类 文章的例子：\n```\ntitle: 分类测试\ncategories:\n- hexo                       （这个就是文章的分类了）\n```\n\n\n### 添加RSS\n#### 安装\nhexo博客有一个专门生成RSS xml文件的插件`hexo-generator-feed`\n我们来安装它\n```\nnpm install hexo-generator-feed\n```\n\n看到`added 3 packages`说明安装成功了。\n\n#### 启用\n在博客工程文件根目录下`_config.yml`文件中添加如下内容\n```\n# Extensions\nplugins:\n    hexo-generator-feed\n#Feed Atom\nfeed:\n    type: atom\n    path: atom.xml\n    limit: 20\n```\n\n#### 生成RSS\n```\n$ hexo g\n(node:6520) [DEP0061] DeprecationWarning: fs.SyncWriteStream is depre                                                                                                                           cated.\nINFO  Start processing\nINFO  Files loaded in 6.33 s\nINFO  Generated: atom.xml <----------成功生成atom.xml文件\nINFO  Generated: sitemap.xml\nINFO  Generated: baidusitemap.xml\nINFO  Generated: about/index.html\n......\n......\n......\n```","slug":"hexo/hexo配置","published":1,"updated":"2019-10-02T08:41:26.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck19bvayw001n00wkqm2ijrt8","content":"<blockquote>\n<p>安装好hexo后，可进行各项配置</p>\n</blockquote>\n<h3 id=\"关于页面\"><a href=\"#关于页面\" class=\"headerlink\" title=\"关于页面\"></a>关于页面</h3><p>使用：<code>hexo new page “about”</code>新建一个 关于我 页面。<br>主题的<code>_config.yml</code>文件中的 <code>menu</code> 中进行匹配<br>不同主题 <code>_config. yml</code>文件有区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /      //主页</span><br><span class=\"line\">  categories: /categories //分类</span><br><span class=\"line\">  archives: /archives   //归档</span><br><span class=\"line\">  tags: /tags   //标签</span><br><span class=\"line\">  about: /about   //关于                  （添加此行即可）</span><br><span class=\"line\">或    </span><br><span class=\"line\">menu:</span><br><span class=\"line\">  - page: home</span><br><span class=\"line\">    directory: .      //主页</span><br><span class=\"line\">    icon: fa-home</span><br><span class=\"line\">  - page: archive</span><br><span class=\"line\">    directory: archives/    //归档</span><br><span class=\"line\">    icon: fa-archive</span><br><span class=\"line\">  - page: about</span><br><span class=\"line\">    directory: about/    //关于</span><br><span class=\"line\">    icon: fa-user</span><br><span class=\"line\">  - page: rss</span><br><span class=\"line\">    directory: atom.xml    //rss订阅</span><br><span class=\"line\">    icon: fa-rss</span><br></pre></td></tr></table></figure>\n\n<p>编辑 about 关于页面 md文件 部署就能看到</p>\n<h3 id=\"添加分类\"><a href=\"#添加分类\" class=\"headerlink\" title=\"添加分类\"></a>添加分类</h3><p>使用： <code>hexo new page categories</code> 新建一个 分类 页面。<br>主题的 <code>_config.yml</code> 文件中的 <code>menu</code> 中进行匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /      //主页</span><br><span class=\"line\">  categories: /categories //分类   </span><br><span class=\"line\">  archives: /archives   //归档</span><br><span class=\"line\">  tags: /tags   //标签                  </span><br><span class=\"line\">  about: /about   //关于</span><br></pre></td></tr></table></figure>\n\n<p>底下代码是一篇包含 分类 文章的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 分类测试</span><br><span class=\"line\">categories:</span><br><span class=\"line\">- hexo                       （这个就是文章的分类了）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加RSS\"><a href=\"#添加RSS\" class=\"headerlink\" title=\"添加RSS\"></a>添加RSS</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>hexo博客有一个专门生成RSS xml文件的插件<code>hexo-generator-feed</code><br>我们来安装它</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure>\n\n<p>看到<code>added 3 packages</code>说明安装成功了。</p>\n<h4 id=\"启用\"><a href=\"#启用\" class=\"headerlink\" title=\"启用\"></a>启用</h4><p>在博客工程文件根目录下<code>_config.yml</code>文件中添加如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">    hexo-generator-feed</span><br><span class=\"line\">#Feed Atom</span><br><span class=\"line\">feed:</span><br><span class=\"line\">    type: atom</span><br><span class=\"line\">    path: atom.xml</span><br><span class=\"line\">    limit: 20</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成RSS\"><a href=\"#生成RSS\" class=\"headerlink\" title=\"生成RSS\"></a>生成RSS</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">(node:6520) [DEP0061] DeprecationWarning: fs.SyncWriteStream is depre                                                                                                                           cated.</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Files loaded in 6.33 s</span><br><span class=\"line\">INFO  Generated: atom.xml &lt;----------成功生成atom.xml文件</span><br><span class=\"line\">INFO  Generated: sitemap.xml</span><br><span class=\"line\">INFO  Generated: baidusitemap.xml</span><br><span class=\"line\">INFO  Generated: about/index.html</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>安装好hexo后，可进行各项配置</p>\n</blockquote>\n<h3 id=\"关于页面\"><a href=\"#关于页面\" class=\"headerlink\" title=\"关于页面\"></a>关于页面</h3><p>使用：<code>hexo new page “about”</code>新建一个 关于我 页面。<br>主题的<code>_config.yml</code>文件中的 <code>menu</code> 中进行匹配<br>不同主题 <code>_config. yml</code>文件有区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /      //主页</span><br><span class=\"line\">  categories: /categories //分类</span><br><span class=\"line\">  archives: /archives   //归档</span><br><span class=\"line\">  tags: /tags   //标签</span><br><span class=\"line\">  about: /about   //关于                  （添加此行即可）</span><br><span class=\"line\">或    </span><br><span class=\"line\">menu:</span><br><span class=\"line\">  - page: home</span><br><span class=\"line\">    directory: .      //主页</span><br><span class=\"line\">    icon: fa-home</span><br><span class=\"line\">  - page: archive</span><br><span class=\"line\">    directory: archives/    //归档</span><br><span class=\"line\">    icon: fa-archive</span><br><span class=\"line\">  - page: about</span><br><span class=\"line\">    directory: about/    //关于</span><br><span class=\"line\">    icon: fa-user</span><br><span class=\"line\">  - page: rss</span><br><span class=\"line\">    directory: atom.xml    //rss订阅</span><br><span class=\"line\">    icon: fa-rss</span><br></pre></td></tr></table></figure>\n\n<p>编辑 about 关于页面 md文件 部署就能看到</p>\n<h3 id=\"添加分类\"><a href=\"#添加分类\" class=\"headerlink\" title=\"添加分类\"></a>添加分类</h3><p>使用： <code>hexo new page categories</code> 新建一个 分类 页面。<br>主题的 <code>_config.yml</code> 文件中的 <code>menu</code> 中进行匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: /      //主页</span><br><span class=\"line\">  categories: /categories //分类   </span><br><span class=\"line\">  archives: /archives   //归档</span><br><span class=\"line\">  tags: /tags   //标签                  </span><br><span class=\"line\">  about: /about   //关于</span><br></pre></td></tr></table></figure>\n\n<p>底下代码是一篇包含 分类 文章的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 分类测试</span><br><span class=\"line\">categories:</span><br><span class=\"line\">- hexo                       （这个就是文章的分类了）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加RSS\"><a href=\"#添加RSS\" class=\"headerlink\" title=\"添加RSS\"></a>添加RSS</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>hexo博客有一个专门生成RSS xml文件的插件<code>hexo-generator-feed</code><br>我们来安装它</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure>\n\n<p>看到<code>added 3 packages</code>说明安装成功了。</p>\n<h4 id=\"启用\"><a href=\"#启用\" class=\"headerlink\" title=\"启用\"></a>启用</h4><p>在博客工程文件根目录下<code>_config.yml</code>文件中添加如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">    hexo-generator-feed</span><br><span class=\"line\">#Feed Atom</span><br><span class=\"line\">feed:</span><br><span class=\"line\">    type: atom</span><br><span class=\"line\">    path: atom.xml</span><br><span class=\"line\">    limit: 20</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成RSS\"><a href=\"#生成RSS\" class=\"headerlink\" title=\"生成RSS\"></a>生成RSS</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br><span class=\"line\">(node:6520) [DEP0061] DeprecationWarning: fs.SyncWriteStream is depre                                                                                                                           cated.</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Files loaded in 6.33 s</span><br><span class=\"line\">INFO  Generated: atom.xml &lt;----------成功生成atom.xml文件</span><br><span class=\"line\">INFO  Generated: sitemap.xml</span><br><span class=\"line\">INFO  Generated: baidusitemap.xml</span><br><span class=\"line\">INFO  Generated: about/index.html</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>"},{"title":"PHP开发工具ZendStudio10","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-04-17T08:59:00.000Z","_content":"## 一、zend studio 10破解/汉化，参考文档\n\n[http://blog.csdn.net/qq1355541448/article/details/16807429](http://blog.csdn.net/qq1355541448/article/details/16807429)\n\n## 二、安装Composer\n\n去到官网下载[https://getcomposer.org/download/](https://getcomposer.org/download/)\n\n[![image](http://static.oschina.net/uploads/img/201504/17120800_gpew.png \"image\")](http://static.oschina.net/uploads/img/201504/17120759_Znd7.png)\n\n## 常见问题\n### windows下Composer因php_openssl扩展缺失而安装失败。\n\nComposer( https://getcomposer.org/ )是PHP下的一个依赖管理工具。你可以在你的项目中声明你所需要用到的类库，然后Composer会在项目中为你安装它们。如果你了解Node的 npm 或者Ruby的 Bundler ，就理解它是做什么的了，但是，它不是包管理器。\n\n在Windows的Wamp环境下安装Composer(注：Composer要求PHP版本在5.3.2+)，你可能会遇到这种安装失败的情况：出错信息是\n\n\n```\n \"The openssl extension is missing, which will reduce the security and stability of Composer. If possible you should enable it or recompile php with --with-openssl\" ，大意就是你的PHP缺少openssl扩展。\n\n你可能会去屏幕右下角的Wamp的控制台，去加载php的openssl扩展，或者在php.ini中去掉 extension=php_openssl.dll 这一行开头的注释，然后重启server，结果发现还是不行。\n\n正确的做法是在php的安装目录比如说C:\\wamp\\bin\\php\\php5.3.3\\中，找到找个目录下的php.ini文件，然后去掉 extension=php_openssl.dll 这一行开头的注释，之后就可以顺利安装Composer了。\n\n你可以发现上面出现了两个php.ini，是的Wamp在Apache和在CLI(命令行)模式下使用了不同的php.ini文件，当你在WAMP的控制台去启用php_openssl这个扩展，是启用的Apache的，而非CLI。而修改php安装目录中的php.ini配置文件，则可以启用CLI模式下的openssl。\n```\n\n### Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！[http://my.oschina.net/yearnfar/blog/346727](http://my.oschina.net/yearnfar/blog/346727)\n\nCA证书下载地址：http://curl.haxx.se/docs/caextract.html\n\n然后修改php.ini文件\n\n```\nopenssl.cafile= D:/wamp/php/verify/cacert.pem\n```","source":"_posts/ide/PHP开发工具ZendStudio10.md","raw":"---\ntitle: PHP开发工具ZendStudio10\nauthor: JsonYe\ntags:\n  - php\ncategories:\n  - IDE \ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-04-17 16:59:00\n---\n## 一、zend studio 10破解/汉化，参考文档\n\n[http://blog.csdn.net/qq1355541448/article/details/16807429](http://blog.csdn.net/qq1355541448/article/details/16807429)\n\n## 二、安装Composer\n\n去到官网下载[https://getcomposer.org/download/](https://getcomposer.org/download/)\n\n[![image](http://static.oschina.net/uploads/img/201504/17120800_gpew.png \"image\")](http://static.oschina.net/uploads/img/201504/17120759_Znd7.png)\n\n## 常见问题\n### windows下Composer因php_openssl扩展缺失而安装失败。\n\nComposer( https://getcomposer.org/ )是PHP下的一个依赖管理工具。你可以在你的项目中声明你所需要用到的类库，然后Composer会在项目中为你安装它们。如果你了解Node的 npm 或者Ruby的 Bundler ，就理解它是做什么的了，但是，它不是包管理器。\n\n在Windows的Wamp环境下安装Composer(注：Composer要求PHP版本在5.3.2+)，你可能会遇到这种安装失败的情况：出错信息是\n\n\n```\n \"The openssl extension is missing, which will reduce the security and stability of Composer. If possible you should enable it or recompile php with --with-openssl\" ，大意就是你的PHP缺少openssl扩展。\n\n你可能会去屏幕右下角的Wamp的控制台，去加载php的openssl扩展，或者在php.ini中去掉 extension=php_openssl.dll 这一行开头的注释，然后重启server，结果发现还是不行。\n\n正确的做法是在php的安装目录比如说C:\\wamp\\bin\\php\\php5.3.3\\中，找到找个目录下的php.ini文件，然后去掉 extension=php_openssl.dll 这一行开头的注释，之后就可以顺利安装Composer了。\n\n你可以发现上面出现了两个php.ini，是的Wamp在Apache和在CLI(命令行)模式下使用了不同的php.ini文件，当你在WAMP的控制台去启用php_openssl这个扩展，是启用的Apache的，而非CLI。而修改php安装目录中的php.ini配置文件，则可以启用CLI模式下的openssl。\n```\n\n### Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！[http://my.oschina.net/yearnfar/blog/346727](http://my.oschina.net/yearnfar/blog/346727)\n\nCA证书下载地址：http://curl.haxx.se/docs/caextract.html\n\n然后修改php.ini文件\n\n```\nopenssl.cafile= D:/wamp/php/verify/cacert.pem\n```","slug":"ide/PHP开发工具ZendStudio10","published":1,"updated":"2019-10-02T08:42:31.101Z","layout":"post","photos":[],"link":"","_id":"ck19bvayz001o00wkjiz3ksvq","content":"<h2 id=\"一、zend-studio-10破解-汉化，参考文档\"><a href=\"#一、zend-studio-10破解-汉化，参考文档\" class=\"headerlink\" title=\"一、zend studio 10破解/汉化，参考文档\"></a>一、zend studio 10破解/汉化，参考文档</h2><p><a href=\"http://blog.csdn.net/qq1355541448/article/details/16807429\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq1355541448/article/details/16807429</a></p>\n<h2 id=\"二、安装Composer\"><a href=\"#二、安装Composer\" class=\"headerlink\" title=\"二、安装Composer\"></a>二、安装Composer</h2><p>去到官网下载<a href=\"https://getcomposer.org/download/\" target=\"_blank\" rel=\"noopener\">https://getcomposer.org/download/</a></p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/17120759_Znd7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/17120800_gpew.png\" alt=\"image\" title=\"image\"></a></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"windows下Composer因php-openssl扩展缺失而安装失败。\"><a href=\"#windows下Composer因php-openssl扩展缺失而安装失败。\" class=\"headerlink\" title=\"windows下Composer因php_openssl扩展缺失而安装失败。\"></a>windows下Composer因php_openssl扩展缺失而安装失败。</h3><p>Composer( <a href=\"https://getcomposer.org/\" target=\"_blank\" rel=\"noopener\">https://getcomposer.org/</a> )是PHP下的一个依赖管理工具。你可以在你的项目中声明你所需要用到的类库，然后Composer会在项目中为你安装它们。如果你了解Node的 npm 或者Ruby的 Bundler ，就理解它是做什么的了，但是，它不是包管理器。</p>\n<p>在Windows的Wamp环境下安装Composer(注：Composer要求PHP版本在5.3.2+)，你可能会遇到这种安装失败的情况：出错信息是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;The openssl extension is missing, which will reduce the security and stability of Composer. If possible you should enable it or recompile php with --with-openssl&quot; ，大意就是你的PHP缺少openssl扩展。</span><br><span class=\"line\"></span><br><span class=\"line\">你可能会去屏幕右下角的Wamp的控制台，去加载php的openssl扩展，或者在php.ini中去掉 extension=php_openssl.dll 这一行开头的注释，然后重启server，结果发现还是不行。</span><br><span class=\"line\"></span><br><span class=\"line\">正确的做法是在php的安装目录比如说C:\\wamp\\bin\\php\\php5.3.3\\中，找到找个目录下的php.ini文件，然后去掉 extension=php_openssl.dll 这一行开头的注释，之后就可以顺利安装Composer了。</span><br><span class=\"line\"></span><br><span class=\"line\">你可以发现上面出现了两个php.ini，是的Wamp在Apache和在CLI(命令行)模式下使用了不同的php.ini文件，当你在WAMP的控制台去启用php_openssl这个扩展，是启用的Apache的，而非CLI。而修改php安装目录中的php.ini配置文件，则可以启用CLI模式下的openssl。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Win7下运行php-Composer出现SSL报错的问题没有安装CA证书导致的！！！http-my-oschina-net-yearnfar-blog-346727\"><a href=\"#Win7下运行php-Composer出现SSL报错的问题没有安装CA证书导致的！！！http-my-oschina-net-yearnfar-blog-346727\" class=\"headerlink\" title=\"Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！http://my.oschina.net/yearnfar/blog/346727\"></a>Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！<a href=\"http://my.oschina.net/yearnfar/blog/346727\" target=\"_blank\" rel=\"noopener\">http://my.oschina.net/yearnfar/blog/346727</a></h3><p>CA证书下载地址：<a href=\"http://curl.haxx.se/docs/caextract.html\" target=\"_blank\" rel=\"noopener\">http://curl.haxx.se/docs/caextract.html</a></p>\n<p>然后修改php.ini文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl.cafile= D:/wamp/php/verify/cacert.pem</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、zend-studio-10破解-汉化，参考文档\"><a href=\"#一、zend-studio-10破解-汉化，参考文档\" class=\"headerlink\" title=\"一、zend studio 10破解/汉化，参考文档\"></a>一、zend studio 10破解/汉化，参考文档</h2><p><a href=\"http://blog.csdn.net/qq1355541448/article/details/16807429\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/qq1355541448/article/details/16807429</a></p>\n<h2 id=\"二、安装Composer\"><a href=\"#二、安装Composer\" class=\"headerlink\" title=\"二、安装Composer\"></a>二、安装Composer</h2><p>去到官网下载<a href=\"https://getcomposer.org/download/\" target=\"_blank\" rel=\"noopener\">https://getcomposer.org/download/</a></p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/17120759_Znd7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/17120800_gpew.png\" alt=\"image\" title=\"image\"></a></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"windows下Composer因php-openssl扩展缺失而安装失败。\"><a href=\"#windows下Composer因php-openssl扩展缺失而安装失败。\" class=\"headerlink\" title=\"windows下Composer因php_openssl扩展缺失而安装失败。\"></a>windows下Composer因php_openssl扩展缺失而安装失败。</h3><p>Composer( <a href=\"https://getcomposer.org/\" target=\"_blank\" rel=\"noopener\">https://getcomposer.org/</a> )是PHP下的一个依赖管理工具。你可以在你的项目中声明你所需要用到的类库，然后Composer会在项目中为你安装它们。如果你了解Node的 npm 或者Ruby的 Bundler ，就理解它是做什么的了，但是，它不是包管理器。</p>\n<p>在Windows的Wamp环境下安装Composer(注：Composer要求PHP版本在5.3.2+)，你可能会遇到这种安装失败的情况：出错信息是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;The openssl extension is missing, which will reduce the security and stability of Composer. If possible you should enable it or recompile php with --with-openssl&quot; ，大意就是你的PHP缺少openssl扩展。</span><br><span class=\"line\"></span><br><span class=\"line\">你可能会去屏幕右下角的Wamp的控制台，去加载php的openssl扩展，或者在php.ini中去掉 extension=php_openssl.dll 这一行开头的注释，然后重启server，结果发现还是不行。</span><br><span class=\"line\"></span><br><span class=\"line\">正确的做法是在php的安装目录比如说C:\\wamp\\bin\\php\\php5.3.3\\中，找到找个目录下的php.ini文件，然后去掉 extension=php_openssl.dll 这一行开头的注释，之后就可以顺利安装Composer了。</span><br><span class=\"line\"></span><br><span class=\"line\">你可以发现上面出现了两个php.ini，是的Wamp在Apache和在CLI(命令行)模式下使用了不同的php.ini文件，当你在WAMP的控制台去启用php_openssl这个扩展，是启用的Apache的，而非CLI。而修改php安装目录中的php.ini配置文件，则可以启用CLI模式下的openssl。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Win7下运行php-Composer出现SSL报错的问题没有安装CA证书导致的！！！http-my-oschina-net-yearnfar-blog-346727\"><a href=\"#Win7下运行php-Composer出现SSL报错的问题没有安装CA证书导致的！！！http-my-oschina-net-yearnfar-blog-346727\" class=\"headerlink\" title=\"Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！http://my.oschina.net/yearnfar/blog/346727\"></a>Win7下运行php Composer出现SSL报错的问题没有安装CA证书导致的！！！<a href=\"http://my.oschina.net/yearnfar/blog/346727\" target=\"_blank\" rel=\"noopener\">http://my.oschina.net/yearnfar/blog/346727</a></h3><p>CA证书下载地址：<a href=\"http://curl.haxx.se/docs/caextract.html\" target=\"_blank\" rel=\"noopener\">http://curl.haxx.se/docs/caextract.html</a></p>\n<p>然后修改php.ini文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl.cafile= D:/wamp/php/verify/cacert.pem</span><br></pre></td></tr></table></figure>"},{"title":"UML介绍","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2018-05-18T13:14:00.000Z","_content":"### 什么是UML\nUML是Unified Modeling Language（统一建模语言）的简称。UML是对软件密集型系统中的制品进行可视化、详述、构造和文档化的语言。制品{Artifact}是指软件开发过程中产生的各种各样的产物，如模型、源代码、测试用例等。\n\n### UML建模可以达到以下目的\n- 使用模型可以更好地理解问题\n- 使用模型可以加强人员之间的沟通\n- 使用模型可以更早地发现错误或疏漏的地方\n- 使用模型可以获得设计结果\n- 模型为最后的代码提供依据\n\n### UML的历史\n#### 第一阶段：OO方法学家的联合行动\n- 1995.10：G.Booch 与J.Rumbaugh联合（推出Unified Method 0.8）\n- 1996.6：I.Jacobson加入（推出UML0.9[Unified Modeling Language]）--各家主要的面向对象方法家将其各自的方法统一为UML，但不称统一建模方法，而称统一建模语言，最根本的原因在于UML只是统一的概念与表示法，没有统一过程。\n\n#### 第二阶段：公司的联合行动\n- 1996：成立了UML伙伴组织，12家公司加入。\n- 1997.1：推出UML1.0，另外5家公司加盟。\n- 1997.9：形成UML1.1，提交OMG作为建模语言规范提案。\n- 1997.11：UML1.1被OMG正式采纳。\n\n#### 第三阶段：OMG主持下的修订\n- 1997~2002：OMG成立UML修订任务组主持UML的修订，先后产生UML1.2、UML1.3、UML1.4、UML1.5等版本。\n\n#### 第四阶段：UML的重大修订——UML2\n- 1999：开始酝酿，旨在产生比UML1有显著改进的新版本。\n- 2000~2001：由OMG陆续发不了4个提案需求（RFP）[征集提案，择优采纳]。\n- 2002年之后先后形成4个UML2.0规范，在OMG的组织下进行修订，产生了UML2.1~2.4一系列版本。\n\n#### 第五阶段：提交到ISO申请成为国际标准\n- 2005年以后UML2的4个规范陆续进入ISO的标准化日程，目前UML基础结构、UML上层结构、OCL已被ISO正式采纳，成为建模语言国际标准。\n\n### UML的主要特点\n- 统一的标准。\n- 面向对象。UML是支持面向对象软件开发的建模语言。\n- 可视化、表现能力强。\n- 独立于过程，UML不依赖于特定的软件开发过程。\n- 概念明确，建模表示法简洁，图形结构清晰，容易掌握和使用。\n\n### UML的应用领域\nUML具有很广泛的应用领域，其中最常用的是为软件系统建模，主要领域有：企业信息系统、银行金融系统、电信、交通、国防、航空、零售领域、科学计算、分布式的基于Web的服务。UML还可以用来描述其他非软件系统，比如一个机构的组成和机构的工作流程等等。\n\n### UML中的视图\nUML中的视图包括用例视图（Use Case View）、逻辑视图（Logical View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）等，\n\n这5个视图被称作”4+1”视图.如下图所示：\n![](/image/uml_view.jpg)\n- 逻辑视图:逻辑视图关注功能，不仅包括用户可见的功能，还包括为实现用户功能而必须提供的\"辅助功能模块\"；它们可能是逻辑层、功能模块等。\n- 开发视图:开发视图关注程序包，不仅包括要编写的源程序，还包括可以直接使用的第三方SDK和现成框架、类库，以及开发的系统将运行于其上的系统软件或中间件。\n- 处理视图:处理视图关注进程、线程、对象等运行时概念，以及相关的并发、同步、通信等问题。\n- 物理视图:物理视图关注\"目标程序及其依赖的运行库和系统软件\"最终如何安装或部署到物理机器，以及如何部署机器和网络来配合软件系统的可靠性、可伸缩性等要求。\n\n>- 物理视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而物理视图重视目标程序的静态位置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。\n- 物理视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而物理视图重视目标程序的静态位置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。\n- 处理视图和开发视图的关系：开发视图一般偏重程序包在编译时期的静态依赖关系，而这些程序运行起来之后会表现为对象、线程、进程，处理视图比较关注的正是这些运行时单元的交互问题。\n\n### UML定义了5类，10种模型图\n1. 用例图（Use Case Diagram）： 展示系统外部的各类执行者与系统提供的各种用例之间的关系\n1. 静态图\n  1. 类图（Class diagram）：展示系统中类的静态结构(类是指具有相同属性和行为的对象，类图用来描述系统中各种类之间的静态结构)\n  1. 对象图（Object diagram）：是类图的一种实例化图(对象图是对类图的一种实例化)\n  1. 包图（Package diagram）：是一种分组机制。在UML1.1版本中，包图不再看作一种独立的模型图)\n1. 行为图\n  1. 状态图（State diagram）：描述一类对象具有的所有可能的状态及其转移关系(它展示对象所具有的所有可能的状态以及特定事件发生时状态的转移情况)\n  1. 活动图（Activity Diagrams）：展示系统中各种活动的执行流程(各种活动的执行顺序、执行流程)\n1. 交互图\n  1. 顺序图（Sequence Diagram）：展示对象之间的一种动态协作关系(一组对象组成，随时间推移对象之间交换消息的过程，突出时间关系)\n  1. 合作图Collaboration diagram：从另一个角度展示对象之间的动态协作关系(对象间动态协作关系，突出消息收发关系)\n1. 实现图\n  1. 构件图（Component Diagram）：展示程序代码的物理结构(描述程序代码的组织结构，各种构件之间的依赖关系)\n  1. 配置图（Configuration diagram）：展示软件在硬件环境中(特别是在分布式及网络环境中)的配置关系(系统中硬件和软件的物理配置情况和系统体系结构)\n\n### UML建模工具\n市面上UML建模工具很多，比较流行的有Rational Rose ，Microsoft Visio、Enterprise Architect 、Visual UML等。《UML建模-面向对象设计》系列文章使用的UML建模工具是Enterprise Architect 7.0，此工具还是比较好用的。\n","source":"_posts/uml/01 UML介绍.md","raw":"---\ntitle: UML介绍\nauthor: JsonYe\ntags:\n- uml\ncategories:\n- UML\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-05-18 21:14:00   \n---\n### 什么是UML\nUML是Unified Modeling Language（统一建模语言）的简称。UML是对软件密集型系统中的制品进行可视化、详述、构造和文档化的语言。制品{Artifact}是指软件开发过程中产生的各种各样的产物，如模型、源代码、测试用例等。\n\n### UML建模可以达到以下目的\n- 使用模型可以更好地理解问题\n- 使用模型可以加强人员之间的沟通\n- 使用模型可以更早地发现错误或疏漏的地方\n- 使用模型可以获得设计结果\n- 模型为最后的代码提供依据\n\n### UML的历史\n#### 第一阶段：OO方法学家的联合行动\n- 1995.10：G.Booch 与J.Rumbaugh联合（推出Unified Method 0.8）\n- 1996.6：I.Jacobson加入（推出UML0.9[Unified Modeling Language]）--各家主要的面向对象方法家将其各自的方法统一为UML，但不称统一建模方法，而称统一建模语言，最根本的原因在于UML只是统一的概念与表示法，没有统一过程。\n\n#### 第二阶段：公司的联合行动\n- 1996：成立了UML伙伴组织，12家公司加入。\n- 1997.1：推出UML1.0，另外5家公司加盟。\n- 1997.9：形成UML1.1，提交OMG作为建模语言规范提案。\n- 1997.11：UML1.1被OMG正式采纳。\n\n#### 第三阶段：OMG主持下的修订\n- 1997~2002：OMG成立UML修订任务组主持UML的修订，先后产生UML1.2、UML1.3、UML1.4、UML1.5等版本。\n\n#### 第四阶段：UML的重大修订——UML2\n- 1999：开始酝酿，旨在产生比UML1有显著改进的新版本。\n- 2000~2001：由OMG陆续发不了4个提案需求（RFP）[征集提案，择优采纳]。\n- 2002年之后先后形成4个UML2.0规范，在OMG的组织下进行修订，产生了UML2.1~2.4一系列版本。\n\n#### 第五阶段：提交到ISO申请成为国际标准\n- 2005年以后UML2的4个规范陆续进入ISO的标准化日程，目前UML基础结构、UML上层结构、OCL已被ISO正式采纳，成为建模语言国际标准。\n\n### UML的主要特点\n- 统一的标准。\n- 面向对象。UML是支持面向对象软件开发的建模语言。\n- 可视化、表现能力强。\n- 独立于过程，UML不依赖于特定的软件开发过程。\n- 概念明确，建模表示法简洁，图形结构清晰，容易掌握和使用。\n\n### UML的应用领域\nUML具有很广泛的应用领域，其中最常用的是为软件系统建模，主要领域有：企业信息系统、银行金融系统、电信、交通、国防、航空、零售领域、科学计算、分布式的基于Web的服务。UML还可以用来描述其他非软件系统，比如一个机构的组成和机构的工作流程等等。\n\n### UML中的视图\nUML中的视图包括用例视图（Use Case View）、逻辑视图（Logical View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）等，\n\n这5个视图被称作”4+1”视图.如下图所示：\n![](/image/uml_view.jpg)\n- 逻辑视图:逻辑视图关注功能，不仅包括用户可见的功能，还包括为实现用户功能而必须提供的\"辅助功能模块\"；它们可能是逻辑层、功能模块等。\n- 开发视图:开发视图关注程序包，不仅包括要编写的源程序，还包括可以直接使用的第三方SDK和现成框架、类库，以及开发的系统将运行于其上的系统软件或中间件。\n- 处理视图:处理视图关注进程、线程、对象等运行时概念，以及相关的并发、同步、通信等问题。\n- 物理视图:物理视图关注\"目标程序及其依赖的运行库和系统软件\"最终如何安装或部署到物理机器，以及如何部署机器和网络来配合软件系统的可靠性、可伸缩性等要求。\n\n>- 物理视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而物理视图重视目标程序的静态位置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。\n- 物理视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而物理视图重视目标程序的静态位置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。\n- 处理视图和开发视图的关系：开发视图一般偏重程序包在编译时期的静态依赖关系，而这些程序运行起来之后会表现为对象、线程、进程，处理视图比较关注的正是这些运行时单元的交互问题。\n\n### UML定义了5类，10种模型图\n1. 用例图（Use Case Diagram）： 展示系统外部的各类执行者与系统提供的各种用例之间的关系\n1. 静态图\n  1. 类图（Class diagram）：展示系统中类的静态结构(类是指具有相同属性和行为的对象，类图用来描述系统中各种类之间的静态结构)\n  1. 对象图（Object diagram）：是类图的一种实例化图(对象图是对类图的一种实例化)\n  1. 包图（Package diagram）：是一种分组机制。在UML1.1版本中，包图不再看作一种独立的模型图)\n1. 行为图\n  1. 状态图（State diagram）：描述一类对象具有的所有可能的状态及其转移关系(它展示对象所具有的所有可能的状态以及特定事件发生时状态的转移情况)\n  1. 活动图（Activity Diagrams）：展示系统中各种活动的执行流程(各种活动的执行顺序、执行流程)\n1. 交互图\n  1. 顺序图（Sequence Diagram）：展示对象之间的一种动态协作关系(一组对象组成，随时间推移对象之间交换消息的过程，突出时间关系)\n  1. 合作图Collaboration diagram：从另一个角度展示对象之间的动态协作关系(对象间动态协作关系，突出消息收发关系)\n1. 实现图\n  1. 构件图（Component Diagram）：展示程序代码的物理结构(描述程序代码的组织结构，各种构件之间的依赖关系)\n  1. 配置图（Configuration diagram）：展示软件在硬件环境中(特别是在分布式及网络环境中)的配置关系(系统中硬件和软件的物理配置情况和系统体系结构)\n\n### UML建模工具\n市面上UML建模工具很多，比较流行的有Rational Rose ，Microsoft Visio、Enterprise Architect 、Visual UML等。《UML建模-面向对象设计》系列文章使用的UML建模工具是Enterprise Architect 7.0，此工具还是比较好用的。\n","slug":"uml/01 UML介绍","published":1,"updated":"2019-10-02T12:05:08.987Z","layout":"post","photos":[],"link":"","_id":"ck19bvaz2001p00wk2ld2xfwt","content":"<h3 id=\"什么是UML\"><a href=\"#什么是UML\" class=\"headerlink\" title=\"什么是UML\"></a>什么是UML</h3><p>UML是Unified Modeling Language（统一建模语言）的简称。UML是对软件密集型系统中的制品进行可视化、详述、构造和文档化的语言。制品{Artifact}是指软件开发过程中产生的各种各样的产物，如模型、源代码、测试用例等。</p>\n<h3 id=\"UML建模可以达到以下目的\"><a href=\"#UML建模可以达到以下目的\" class=\"headerlink\" title=\"UML建模可以达到以下目的\"></a>UML建模可以达到以下目的</h3><ul>\n<li>使用模型可以更好地理解问题</li>\n<li>使用模型可以加强人员之间的沟通</li>\n<li>使用模型可以更早地发现错误或疏漏的地方</li>\n<li>使用模型可以获得设计结果</li>\n<li>模型为最后的代码提供依据</li>\n</ul>\n<h3 id=\"UML的历史\"><a href=\"#UML的历史\" class=\"headerlink\" title=\"UML的历史\"></a>UML的历史</h3><h4 id=\"第一阶段：OO方法学家的联合行动\"><a href=\"#第一阶段：OO方法学家的联合行动\" class=\"headerlink\" title=\"第一阶段：OO方法学家的联合行动\"></a>第一阶段：OO方法学家的联合行动</h4><ul>\n<li>1995.10：G.Booch 与J.Rumbaugh联合（推出Unified Method 0.8）</li>\n<li>1996.6：I.Jacobson加入（推出UML0.9[Unified Modeling Language]）–各家主要的面向对象方法家将其各自的方法统一为UML，但不称统一建模方法，而称统一建模语言，最根本的原因在于UML只是统一的概念与表示法，没有统一过程。</li>\n</ul>\n<h4 id=\"第二阶段：公司的联合行动\"><a href=\"#第二阶段：公司的联合行动\" class=\"headerlink\" title=\"第二阶段：公司的联合行动\"></a>第二阶段：公司的联合行动</h4><ul>\n<li>1996：成立了UML伙伴组织，12家公司加入。</li>\n<li>1997.1：推出UML1.0，另外5家公司加盟。</li>\n<li>1997.9：形成UML1.1，提交OMG作为建模语言规范提案。</li>\n<li>1997.11：UML1.1被OMG正式采纳。</li>\n</ul>\n<h4 id=\"第三阶段：OMG主持下的修订\"><a href=\"#第三阶段：OMG主持下的修订\" class=\"headerlink\" title=\"第三阶段：OMG主持下的修订\"></a>第三阶段：OMG主持下的修订</h4><ul>\n<li>1997~2002：OMG成立UML修订任务组主持UML的修订，先后产生UML1.2、UML1.3、UML1.4、UML1.5等版本。</li>\n</ul>\n<h4 id=\"第四阶段：UML的重大修订——UML2\"><a href=\"#第四阶段：UML的重大修订——UML2\" class=\"headerlink\" title=\"第四阶段：UML的重大修订——UML2\"></a>第四阶段：UML的重大修订——UML2</h4><ul>\n<li>1999：开始酝酿，旨在产生比UML1有显著改进的新版本。</li>\n<li>2000~2001：由OMG陆续发不了4个提案需求（RFP）[征集提案，择优采纳]。</li>\n<li>2002年之后先后形成4个UML2.0规范，在OMG的组织下进行修订，产生了UML2.1~2.4一系列版本。</li>\n</ul>\n<h4 id=\"第五阶段：提交到ISO申请成为国际标准\"><a href=\"#第五阶段：提交到ISO申请成为国际标准\" class=\"headerlink\" title=\"第五阶段：提交到ISO申请成为国际标准\"></a>第五阶段：提交到ISO申请成为国际标准</h4><ul>\n<li>2005年以后UML2的4个规范陆续进入ISO的标准化日程，目前UML基础结构、UML上层结构、OCL已被ISO正式采纳，成为建模语言国际标准。</li>\n</ul>\n<h3 id=\"UML的主要特点\"><a href=\"#UML的主要特点\" class=\"headerlink\" title=\"UML的主要特点\"></a>UML的主要特点</h3><ul>\n<li>统一的标准。</li>\n<li>面向对象。UML是支持面向对象软件开发的建模语言。</li>\n<li>可视化、表现能力强。</li>\n<li>独立于过程，UML不依赖于特定的软件开发过程。</li>\n<li>概念明确，建模表示法简洁，图形结构清晰，容易掌握和使用。</li>\n</ul>\n<h3 id=\"UML的应用领域\"><a href=\"#UML的应用领域\" class=\"headerlink\" title=\"UML的应用领域\"></a>UML的应用领域</h3><p>UML具有很广泛的应用领域，其中最常用的是为软件系统建模，主要领域有：企业信息系统、银行金融系统、电信、交通、国防、航空、零售领域、科学计算、分布式的基于Web的服务。UML还可以用来描述其他非软件系统，比如一个机构的组成和机构的工作流程等等。</p>\n<h3 id=\"UML中的视图\"><a href=\"#UML中的视图\" class=\"headerlink\" title=\"UML中的视图\"></a>UML中的视图</h3><p>UML中的视图包括用例视图（Use Case View）、逻辑视图（Logical View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）等，</p>\n<p>这5个视图被称作”4+1”视图.如下图所示：<br><img src=\"/image/uml_view.jpg\" alt></p>\n<ul>\n<li>逻辑视图:逻辑视图关注功能，不仅包括用户可见的功能，还包括为实现用户功能而必须提供的”辅助功能模块”；它们可能是逻辑层、功能模块等。</li>\n<li>开发视图:开发视图关注程序包，不仅包括要编写的源程序，还包括可以直接使用的第三方SDK和现成框架、类库，以及开发的系统将运行于其上的系统软件或中间件。</li>\n<li>处理视图:处理视图关注进程、线程、对象等运行时概念，以及相关的并发、同步、通信等问题。</li>\n<li>物理视图:物理视图关注”目标程序及其依赖的运行库和系统软件”最终如何安装或部署到物理机器，以及如何部署机器和网络来配合软件系统的可靠性、可伸缩性等要求。</li>\n</ul>\n<blockquote>\n<ul>\n<li>物理视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而物理视图重视目标程序的静态位置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。</li>\n<li>物理视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而物理视图重视目标程序的静态位置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。</li>\n<li>处理视图和开发视图的关系：开发视图一般偏重程序包在编译时期的静态依赖关系，而这些程序运行起来之后会表现为对象、线程、进程，处理视图比较关注的正是这些运行时单元的交互问题。</li>\n</ul>\n</blockquote>\n<h3 id=\"UML定义了5类，10种模型图\"><a href=\"#UML定义了5类，10种模型图\" class=\"headerlink\" title=\"UML定义了5类，10种模型图\"></a>UML定义了5类，10种模型图</h3><ol>\n<li>用例图（Use Case Diagram）： 展示系统外部的各类执行者与系统提供的各种用例之间的关系</li>\n<li>静态图<ol>\n<li>类图（Class diagram）：展示系统中类的静态结构(类是指具有相同属性和行为的对象，类图用来描述系统中各种类之间的静态结构)</li>\n<li>对象图（Object diagram）：是类图的一种实例化图(对象图是对类图的一种实例化)</li>\n<li>包图（Package diagram）：是一种分组机制。在UML1.1版本中，包图不再看作一种独立的模型图)</li>\n</ol>\n</li>\n<li>行为图<ol>\n<li>状态图（State diagram）：描述一类对象具有的所有可能的状态及其转移关系(它展示对象所具有的所有可能的状态以及特定事件发生时状态的转移情况)</li>\n<li>活动图（Activity Diagrams）：展示系统中各种活动的执行流程(各种活动的执行顺序、执行流程)</li>\n</ol>\n</li>\n<li>交互图<ol>\n<li>顺序图（Sequence Diagram）：展示对象之间的一种动态协作关系(一组对象组成，随时间推移对象之间交换消息的过程，突出时间关系)</li>\n<li>合作图Collaboration diagram：从另一个角度展示对象之间的动态协作关系(对象间动态协作关系，突出消息收发关系)</li>\n</ol>\n</li>\n<li>实现图<ol>\n<li>构件图（Component Diagram）：展示程序代码的物理结构(描述程序代码的组织结构，各种构件之间的依赖关系)</li>\n<li>配置图（Configuration diagram）：展示软件在硬件环境中(特别是在分布式及网络环境中)的配置关系(系统中硬件和软件的物理配置情况和系统体系结构)</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"UML建模工具\"><a href=\"#UML建模工具\" class=\"headerlink\" title=\"UML建模工具\"></a>UML建模工具</h3><p>市面上UML建模工具很多，比较流行的有Rational Rose ，Microsoft Visio、Enterprise Architect 、Visual UML等。《UML建模-面向对象设计》系列文章使用的UML建模工具是Enterprise Architect 7.0，此工具还是比较好用的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是UML\"><a href=\"#什么是UML\" class=\"headerlink\" title=\"什么是UML\"></a>什么是UML</h3><p>UML是Unified Modeling Language（统一建模语言）的简称。UML是对软件密集型系统中的制品进行可视化、详述、构造和文档化的语言。制品{Artifact}是指软件开发过程中产生的各种各样的产物，如模型、源代码、测试用例等。</p>\n<h3 id=\"UML建模可以达到以下目的\"><a href=\"#UML建模可以达到以下目的\" class=\"headerlink\" title=\"UML建模可以达到以下目的\"></a>UML建模可以达到以下目的</h3><ul>\n<li>使用模型可以更好地理解问题</li>\n<li>使用模型可以加强人员之间的沟通</li>\n<li>使用模型可以更早地发现错误或疏漏的地方</li>\n<li>使用模型可以获得设计结果</li>\n<li>模型为最后的代码提供依据</li>\n</ul>\n<h3 id=\"UML的历史\"><a href=\"#UML的历史\" class=\"headerlink\" title=\"UML的历史\"></a>UML的历史</h3><h4 id=\"第一阶段：OO方法学家的联合行动\"><a href=\"#第一阶段：OO方法学家的联合行动\" class=\"headerlink\" title=\"第一阶段：OO方法学家的联合行动\"></a>第一阶段：OO方法学家的联合行动</h4><ul>\n<li>1995.10：G.Booch 与J.Rumbaugh联合（推出Unified Method 0.8）</li>\n<li>1996.6：I.Jacobson加入（推出UML0.9[Unified Modeling Language]）–各家主要的面向对象方法家将其各自的方法统一为UML，但不称统一建模方法，而称统一建模语言，最根本的原因在于UML只是统一的概念与表示法，没有统一过程。</li>\n</ul>\n<h4 id=\"第二阶段：公司的联合行动\"><a href=\"#第二阶段：公司的联合行动\" class=\"headerlink\" title=\"第二阶段：公司的联合行动\"></a>第二阶段：公司的联合行动</h4><ul>\n<li>1996：成立了UML伙伴组织，12家公司加入。</li>\n<li>1997.1：推出UML1.0，另外5家公司加盟。</li>\n<li>1997.9：形成UML1.1，提交OMG作为建模语言规范提案。</li>\n<li>1997.11：UML1.1被OMG正式采纳。</li>\n</ul>\n<h4 id=\"第三阶段：OMG主持下的修订\"><a href=\"#第三阶段：OMG主持下的修订\" class=\"headerlink\" title=\"第三阶段：OMG主持下的修订\"></a>第三阶段：OMG主持下的修订</h4><ul>\n<li>1997~2002：OMG成立UML修订任务组主持UML的修订，先后产生UML1.2、UML1.3、UML1.4、UML1.5等版本。</li>\n</ul>\n<h4 id=\"第四阶段：UML的重大修订——UML2\"><a href=\"#第四阶段：UML的重大修订——UML2\" class=\"headerlink\" title=\"第四阶段：UML的重大修订——UML2\"></a>第四阶段：UML的重大修订——UML2</h4><ul>\n<li>1999：开始酝酿，旨在产生比UML1有显著改进的新版本。</li>\n<li>2000~2001：由OMG陆续发不了4个提案需求（RFP）[征集提案，择优采纳]。</li>\n<li>2002年之后先后形成4个UML2.0规范，在OMG的组织下进行修订，产生了UML2.1~2.4一系列版本。</li>\n</ul>\n<h4 id=\"第五阶段：提交到ISO申请成为国际标准\"><a href=\"#第五阶段：提交到ISO申请成为国际标准\" class=\"headerlink\" title=\"第五阶段：提交到ISO申请成为国际标准\"></a>第五阶段：提交到ISO申请成为国际标准</h4><ul>\n<li>2005年以后UML2的4个规范陆续进入ISO的标准化日程，目前UML基础结构、UML上层结构、OCL已被ISO正式采纳，成为建模语言国际标准。</li>\n</ul>\n<h3 id=\"UML的主要特点\"><a href=\"#UML的主要特点\" class=\"headerlink\" title=\"UML的主要特点\"></a>UML的主要特点</h3><ul>\n<li>统一的标准。</li>\n<li>面向对象。UML是支持面向对象软件开发的建模语言。</li>\n<li>可视化、表现能力强。</li>\n<li>独立于过程，UML不依赖于特定的软件开发过程。</li>\n<li>概念明确，建模表示法简洁，图形结构清晰，容易掌握和使用。</li>\n</ul>\n<h3 id=\"UML的应用领域\"><a href=\"#UML的应用领域\" class=\"headerlink\" title=\"UML的应用领域\"></a>UML的应用领域</h3><p>UML具有很广泛的应用领域，其中最常用的是为软件系统建模，主要领域有：企业信息系统、银行金融系统、电信、交通、国防、航空、零售领域、科学计算、分布式的基于Web的服务。UML还可以用来描述其他非软件系统，比如一个机构的组成和机构的工作流程等等。</p>\n<h3 id=\"UML中的视图\"><a href=\"#UML中的视图\" class=\"headerlink\" title=\"UML中的视图\"></a>UML中的视图</h3><p>UML中的视图包括用例视图（Use Case View）、逻辑视图（Logical View）、实现视图（Implementation View）、进程视图（Process View）、部署视图（Deployment View）等，</p>\n<p>这5个视图被称作”4+1”视图.如下图所示：<br><img src=\"/image/uml_view.jpg\" alt></p>\n<ul>\n<li>逻辑视图:逻辑视图关注功能，不仅包括用户可见的功能，还包括为实现用户功能而必须提供的”辅助功能模块”；它们可能是逻辑层、功能模块等。</li>\n<li>开发视图:开发视图关注程序包，不仅包括要编写的源程序，还包括可以直接使用的第三方SDK和现成框架、类库，以及开发的系统将运行于其上的系统软件或中间件。</li>\n<li>处理视图:处理视图关注进程、线程、对象等运行时概念，以及相关的并发、同步、通信等问题。</li>\n<li>物理视图:物理视图关注”目标程序及其依赖的运行库和系统软件”最终如何安装或部署到物理机器，以及如何部署机器和网络来配合软件系统的可靠性、可伸缩性等要求。</li>\n</ul>\n<blockquote>\n<ul>\n<li>物理视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而物理视图重视目标程序的静态位置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。</li>\n<li>物理视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而物理视图重视目标程序的静态位置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。</li>\n<li>处理视图和开发视图的关系：开发视图一般偏重程序包在编译时期的静态依赖关系，而这些程序运行起来之后会表现为对象、线程、进程，处理视图比较关注的正是这些运行时单元的交互问题。</li>\n</ul>\n</blockquote>\n<h3 id=\"UML定义了5类，10种模型图\"><a href=\"#UML定义了5类，10种模型图\" class=\"headerlink\" title=\"UML定义了5类，10种模型图\"></a>UML定义了5类，10种模型图</h3><ol>\n<li>用例图（Use Case Diagram）： 展示系统外部的各类执行者与系统提供的各种用例之间的关系</li>\n<li>静态图<ol>\n<li>类图（Class diagram）：展示系统中类的静态结构(类是指具有相同属性和行为的对象，类图用来描述系统中各种类之间的静态结构)</li>\n<li>对象图（Object diagram）：是类图的一种实例化图(对象图是对类图的一种实例化)</li>\n<li>包图（Package diagram）：是一种分组机制。在UML1.1版本中，包图不再看作一种独立的模型图)</li>\n</ol>\n</li>\n<li>行为图<ol>\n<li>状态图（State diagram）：描述一类对象具有的所有可能的状态及其转移关系(它展示对象所具有的所有可能的状态以及特定事件发生时状态的转移情况)</li>\n<li>活动图（Activity Diagrams）：展示系统中各种活动的执行流程(各种活动的执行顺序、执行流程)</li>\n</ol>\n</li>\n<li>交互图<ol>\n<li>顺序图（Sequence Diagram）：展示对象之间的一种动态协作关系(一组对象组成，随时间推移对象之间交换消息的过程，突出时间关系)</li>\n<li>合作图Collaboration diagram：从另一个角度展示对象之间的动态协作关系(对象间动态协作关系，突出消息收发关系)</li>\n</ol>\n</li>\n<li>实现图<ol>\n<li>构件图（Component Diagram）：展示程序代码的物理结构(描述程序代码的组织结构，各种构件之间的依赖关系)</li>\n<li>配置图（Configuration diagram）：展示软件在硬件环境中(特别是在分布式及网络环境中)的配置关系(系统中硬件和软件的物理配置情况和系统体系结构)</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"UML建模工具\"><a href=\"#UML建模工具\" class=\"headerlink\" title=\"UML建模工具\"></a>UML建模工具</h3><p>市面上UML建模工具很多，比较流行的有Rational Rose ，Microsoft Visio、Enterprise Architect 、Visual UML等。《UML建模-面向对象设计》系列文章使用的UML建模工具是Enterprise Architect 7.0，此工具还是比较好用的。</p>\n"},{"title":"UML-用例图","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2018-05-19T13:24:00.000Z","_content":"## 用例图（Use Case)\n主要用来描述“用户、需求、系统功能单元”之间的关系。它展示了一个外部用户能够观察到的系统功能模型图。\n\n### 主要元素\n#### 1. 参与者(Actor)\n> 表示与您的应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。\n![](image/actor.png)\n\n#### 2. 用例(Use Case)\n> 用例就是外部可见的系统功能，对系统提供的服务进行描述。用椭圆表示。\n![](image/usecase.png)\n\n#### 3. 子系统(Subsystem)\n> 用来展示系统的一部分功能，这部分功能联系紧密。\n![](image/uc/subsystem.png)\n\n#### 4. 关系\n> 用例图中涉及的关系有：关联、泛化、包含、扩展。\n\n关系类型|说明|箭头指向\n--|--|--\n关联|参与者与用例的关系|消息接收方\n泛化|参与者之间或者用例之间的关系|父用例\n包括| 用例之间的关系|分解出来的功能用例\n扩展|用例之间的关系|基础用例\n`依赖-VS2010的用例模型图中，添加了依赖关系`\n##### 关联(Association)\n表示参与者与用例之间的通信，任何一方都可发送或接受消息。\n![](image/uc/Association.png)Â\n##### 泛化(Inheritance)\n就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。\n![](image/uc/Inheritance.png)\n##### 包含(Include)\n包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。\n![](image/uc/Include.png)\n##### 扩展(Extend)\n扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。\n![](image/uc/Extend.png)\n##### 依赖(Dependency)\n以上4种关系，是UML定义的标准关系。但VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示，表示源用例依赖于目标用例。\n![](image/uc/Dependency.png)\n\n#### 5. 项目(Artifact)\n`VS2010中引入了“项目”这样一个元素`\n用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用Excel都比用例图强，以便让开发人员能够在用例图中链接一个普通文档。\n![](image/uc/Artifact.png)\n\n#### 6. 注释(Comment)\n![](image/uc/Comment.png)\n\n### 包含(include)、扩展(extend)、泛化(Inheritance) 的区别\n- 条件性：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的；\n- 直接性：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。\n- 对extend而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。\n- 对Inheritance而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；\n\n### 如何画Use Case 用例视图\n本人使用的工具是 `Start UML`\n#### 1. 新建工程\n    [file]->[New]\n#### 2. 新建Use Case Diagram\n![](image/uc/edit_add.png)\n#### 3. 从左侧Toolbox中选择相关的对象，放到中部编辑区\n![](image/uc/edit_drow.png)\n\n可以参考灵动生活的[设计阶段如何画用例视图（Use-Case View）](http://www.cnblogs.com/ywqu/archive/2009/12/03/1616232.html#_Toc247614719)\n\n### 示例：图书管理系统的UC\n#### 需求描述\n该系统是一套图书管理系统（主要是模仿学校当前的图书系统设置的），主要的服务人员为读者、图书管理员和系统管理员。\n- 读者：\n  1. 办理图书借阅卡\n  2. 查询图书  （可分为查询已借图书和查询可借图书，这个关系可以理解成泛化）\n  3. 借阅图书    \n  4. 预约图书    \n  5. 还书\n  6. 续借图书\n- 图书管理员：\n  1. 借书\n  2. 还书\n  3. 管理图书信息，包括：\n    - 统计缺失的书\n    - 订购新书\n    - 入库新书（增加图书记录）\n    - 更新/删除图书记录\n  4. 收罚金，撤销违规记录\n- 系统管理员：系统维护\n  - 日志维护\n  - 权限维护\n  - 用户管理\n  - 数据库维护\n\n#### 实际作图\n![](image/uc/图书管理系统.jpg)\n","source":"_posts/uml/02 用例图（Use Case）.md","raw":"---\ntitle: UML-用例图\nauthor: JsonYe\ntags:\n- uml\n- 用例图\ncategories:\n- UML\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-05-19 21:24:00   \n---\n## 用例图（Use Case)\n主要用来描述“用户、需求、系统功能单元”之间的关系。它展示了一个外部用户能够观察到的系统功能模型图。\n\n### 主要元素\n#### 1. 参与者(Actor)\n> 表示与您的应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。\n![](image/actor.png)\n\n#### 2. 用例(Use Case)\n> 用例就是外部可见的系统功能，对系统提供的服务进行描述。用椭圆表示。\n![](image/usecase.png)\n\n#### 3. 子系统(Subsystem)\n> 用来展示系统的一部分功能，这部分功能联系紧密。\n![](image/uc/subsystem.png)\n\n#### 4. 关系\n> 用例图中涉及的关系有：关联、泛化、包含、扩展。\n\n关系类型|说明|箭头指向\n--|--|--\n关联|参与者与用例的关系|消息接收方\n泛化|参与者之间或者用例之间的关系|父用例\n包括| 用例之间的关系|分解出来的功能用例\n扩展|用例之间的关系|基础用例\n`依赖-VS2010的用例模型图中，添加了依赖关系`\n##### 关联(Association)\n表示参与者与用例之间的通信，任何一方都可发送或接受消息。\n![](image/uc/Association.png)Â\n##### 泛化(Inheritance)\n就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。\n![](image/uc/Inheritance.png)\n##### 包含(Include)\n包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。\n![](image/uc/Include.png)\n##### 扩展(Extend)\n扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。\n![](image/uc/Extend.png)\n##### 依赖(Dependency)\n以上4种关系，是UML定义的标准关系。但VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示，表示源用例依赖于目标用例。\n![](image/uc/Dependency.png)\n\n#### 5. 项目(Artifact)\n`VS2010中引入了“项目”这样一个元素`\n用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用Excel都比用例图强，以便让开发人员能够在用例图中链接一个普通文档。\n![](image/uc/Artifact.png)\n\n#### 6. 注释(Comment)\n![](image/uc/Comment.png)\n\n### 包含(include)、扩展(extend)、泛化(Inheritance) 的区别\n- 条件性：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的；\n- 直接性：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。\n- 对extend而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。\n- 对Inheritance而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；\n\n### 如何画Use Case 用例视图\n本人使用的工具是 `Start UML`\n#### 1. 新建工程\n    [file]->[New]\n#### 2. 新建Use Case Diagram\n![](image/uc/edit_add.png)\n#### 3. 从左侧Toolbox中选择相关的对象，放到中部编辑区\n![](image/uc/edit_drow.png)\n\n可以参考灵动生活的[设计阶段如何画用例视图（Use-Case View）](http://www.cnblogs.com/ywqu/archive/2009/12/03/1616232.html#_Toc247614719)\n\n### 示例：图书管理系统的UC\n#### 需求描述\n该系统是一套图书管理系统（主要是模仿学校当前的图书系统设置的），主要的服务人员为读者、图书管理员和系统管理员。\n- 读者：\n  1. 办理图书借阅卡\n  2. 查询图书  （可分为查询已借图书和查询可借图书，这个关系可以理解成泛化）\n  3. 借阅图书    \n  4. 预约图书    \n  5. 还书\n  6. 续借图书\n- 图书管理员：\n  1. 借书\n  2. 还书\n  3. 管理图书信息，包括：\n    - 统计缺失的书\n    - 订购新书\n    - 入库新书（增加图书记录）\n    - 更新/删除图书记录\n  4. 收罚金，撤销违规记录\n- 系统管理员：系统维护\n  - 日志维护\n  - 权限维护\n  - 用户管理\n  - 数据库维护\n\n#### 实际作图\n![](image/uc/图书管理系统.jpg)\n","slug":"uml/02 用例图（Use Case）","published":1,"updated":"2019-10-02T13:48:21.942Z","layout":"post","photos":[],"link":"","_id":"ck19bvaz9001t00wkkj13xmwp","content":"<h2 id=\"用例图（Use-Case\"><a href=\"#用例图（Use-Case\" class=\"headerlink\" title=\"用例图（Use Case)\"></a>用例图（Use Case)</h2><p>主要用来描述“用户、需求、系统功能单元”之间的关系。它展示了一个外部用户能够观察到的系统功能模型图。</p>\n<h3 id=\"主要元素\"><a href=\"#主要元素\" class=\"headerlink\" title=\"主要元素\"></a>主要元素</h3><h4 id=\"1-参与者-Actor\"><a href=\"#1-参与者-Actor\" class=\"headerlink\" title=\"1. 参与者(Actor)\"></a>1. 参与者(Actor)</h4><blockquote>\n<p>表示与您的应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。<br><img src=\"image/actor.png\" alt></p>\n</blockquote>\n<h4 id=\"2-用例-Use-Case\"><a href=\"#2-用例-Use-Case\" class=\"headerlink\" title=\"2. 用例(Use Case)\"></a>2. 用例(Use Case)</h4><blockquote>\n<p>用例就是外部可见的系统功能，对系统提供的服务进行描述。用椭圆表示。<br><img src=\"image/usecase.png\" alt></p>\n</blockquote>\n<h4 id=\"3-子系统-Subsystem\"><a href=\"#3-子系统-Subsystem\" class=\"headerlink\" title=\"3. 子系统(Subsystem)\"></a>3. 子系统(Subsystem)</h4><blockquote>\n<p>用来展示系统的一部分功能，这部分功能联系紧密。<br><img src=\"image/uc/subsystem.png\" alt></p>\n</blockquote>\n<h4 id=\"4-关系\"><a href=\"#4-关系\" class=\"headerlink\" title=\"4. 关系\"></a>4. 关系</h4><blockquote>\n<p>用例图中涉及的关系有：关联、泛化、包含、扩展。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>关系类型</th>\n<th>说明</th>\n<th>箭头指向</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>关联</td>\n<td>参与者与用例的关系</td>\n<td>消息接收方</td>\n</tr>\n<tr>\n<td>泛化</td>\n<td>参与者之间或者用例之间的关系</td>\n<td>父用例</td>\n</tr>\n<tr>\n<td>包括</td>\n<td>用例之间的关系</td>\n<td>分解出来的功能用例</td>\n</tr>\n<tr>\n<td>扩展</td>\n<td>用例之间的关系</td>\n<td>基础用例</td>\n</tr>\n<tr>\n<td><code>依赖-VS2010的用例模型图中，添加了依赖关系</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 关联(Association)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>表示参与者与用例之间的通信，任何一方都可发送或接受消息。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Association.png\" alt>Â</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 泛化(Inheritance)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Inheritance.png\" alt></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 包含(Include)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Include.png\" alt></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 扩展(Extend)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Extend.png\" alt></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 依赖(Dependency)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>以上4种关系，是UML定义的标准关系。但VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示，表示源用例依赖于目标用例。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Dependency.png\" alt></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"5-项目-Artifact\"><a href=\"#5-项目-Artifact\" class=\"headerlink\" title=\"5. 项目(Artifact)\"></a>5. 项目(Artifact)</h4><p><code>VS2010中引入了“项目”这样一个元素</code><br>用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用Excel都比用例图强，以便让开发人员能够在用例图中链接一个普通文档。<br><img src=\"image/uc/Artifact.png\" alt></p>\n<h4 id=\"6-注释-Comment\"><a href=\"#6-注释-Comment\" class=\"headerlink\" title=\"6. 注释(Comment)\"></a>6. 注释(Comment)</h4><p><img src=\"image/uc/Comment.png\" alt></p>\n<h3 id=\"包含-include-、扩展-extend-、泛化-Inheritance-的区别\"><a href=\"#包含-include-、扩展-extend-、泛化-Inheritance-的区别\" class=\"headerlink\" title=\"包含(include)、扩展(extend)、泛化(Inheritance) 的区别\"></a>包含(include)、扩展(extend)、泛化(Inheritance) 的区别</h3><ul>\n<li>条件性：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的；</li>\n<li>直接性：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。</li>\n<li>对extend而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。</li>\n<li>对Inheritance而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；</li>\n</ul>\n<h3 id=\"如何画Use-Case-用例视图\"><a href=\"#如何画Use-Case-用例视图\" class=\"headerlink\" title=\"如何画Use Case 用例视图\"></a>如何画Use Case 用例视图</h3><p>本人使用的工具是 <code>Start UML</code></p>\n<h4 id=\"1-新建工程\"><a href=\"#1-新建工程\" class=\"headerlink\" title=\"1. 新建工程\"></a>1. 新建工程</h4><pre><code>[file]-&gt;[New]</code></pre><h4 id=\"2-新建Use-Case-Diagram\"><a href=\"#2-新建Use-Case-Diagram\" class=\"headerlink\" title=\"2. 新建Use Case Diagram\"></a>2. 新建Use Case Diagram</h4><p><img src=\"image/uc/edit_add.png\" alt></p>\n<h4 id=\"3-从左侧Toolbox中选择相关的对象，放到中部编辑区\"><a href=\"#3-从左侧Toolbox中选择相关的对象，放到中部编辑区\" class=\"headerlink\" title=\"3. 从左侧Toolbox中选择相关的对象，放到中部编辑区\"></a>3. 从左侧Toolbox中选择相关的对象，放到中部编辑区</h4><p><img src=\"image/uc/edit_drow.png\" alt></p>\n<p>可以参考灵动生活的<a href=\"http://www.cnblogs.com/ywqu/archive/2009/12/03/1616232.html#_Toc247614719\" target=\"_blank\" rel=\"noopener\">设计阶段如何画用例视图（Use-Case View）</a></p>\n<h3 id=\"示例：图书管理系统的UC\"><a href=\"#示例：图书管理系统的UC\" class=\"headerlink\" title=\"示例：图书管理系统的UC\"></a>示例：图书管理系统的UC</h3><h4 id=\"需求描述\"><a href=\"#需求描述\" class=\"headerlink\" title=\"需求描述\"></a>需求描述</h4><p>该系统是一套图书管理系统（主要是模仿学校当前的图书系统设置的），主要的服务人员为读者、图书管理员和系统管理员。</p>\n<ul>\n<li>读者：<ol>\n<li>办理图书借阅卡</li>\n<li>查询图书  （可分为查询已借图书和查询可借图书，这个关系可以理解成泛化）</li>\n<li>借阅图书    </li>\n<li>预约图书    </li>\n<li>还书</li>\n<li>续借图书</li>\n</ol>\n</li>\n<li>图书管理员：<ol>\n<li>借书</li>\n<li>还书</li>\n<li>管理图书信息，包括：<ul>\n<li>统计缺失的书</li>\n<li>订购新书</li>\n<li>入库新书（增加图书记录）</li>\n<li>更新/删除图书记录</li>\n</ul>\n</li>\n<li>收罚金，撤销违规记录</li>\n</ol>\n</li>\n<li>系统管理员：系统维护<ul>\n<li>日志维护</li>\n<li>权限维护</li>\n<li>用户管理</li>\n<li>数据库维护</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"实际作图\"><a href=\"#实际作图\" class=\"headerlink\" title=\"实际作图\"></a>实际作图</h4><p><img src=\"image/uc/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"用例图（Use-Case\"><a href=\"#用例图（Use-Case\" class=\"headerlink\" title=\"用例图（Use Case)\"></a>用例图（Use Case)</h2><p>主要用来描述“用户、需求、系统功能单元”之间的关系。它展示了一个外部用户能够观察到的系统功能模型图。</p>\n<h3 id=\"主要元素\"><a href=\"#主要元素\" class=\"headerlink\" title=\"主要元素\"></a>主要元素</h3><h4 id=\"1-参与者-Actor\"><a href=\"#1-参与者-Actor\" class=\"headerlink\" title=\"1. 参与者(Actor)\"></a>1. 参与者(Actor)</h4><blockquote>\n<p>表示与您的应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。<br><img src=\"image/actor.png\" alt></p>\n</blockquote>\n<h4 id=\"2-用例-Use-Case\"><a href=\"#2-用例-Use-Case\" class=\"headerlink\" title=\"2. 用例(Use Case)\"></a>2. 用例(Use Case)</h4><blockquote>\n<p>用例就是外部可见的系统功能，对系统提供的服务进行描述。用椭圆表示。<br><img src=\"image/usecase.png\" alt></p>\n</blockquote>\n<h4 id=\"3-子系统-Subsystem\"><a href=\"#3-子系统-Subsystem\" class=\"headerlink\" title=\"3. 子系统(Subsystem)\"></a>3. 子系统(Subsystem)</h4><blockquote>\n<p>用来展示系统的一部分功能，这部分功能联系紧密。<br><img src=\"image/uc/subsystem.png\" alt></p>\n</blockquote>\n<h4 id=\"4-关系\"><a href=\"#4-关系\" class=\"headerlink\" title=\"4. 关系\"></a>4. 关系</h4><blockquote>\n<p>用例图中涉及的关系有：关联、泛化、包含、扩展。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>关系类型</th>\n<th>说明</th>\n<th>箭头指向</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>关联</td>\n<td>参与者与用例的关系</td>\n<td>消息接收方</td>\n</tr>\n<tr>\n<td>泛化</td>\n<td>参与者之间或者用例之间的关系</td>\n<td>父用例</td>\n</tr>\n<tr>\n<td>包括</td>\n<td>用例之间的关系</td>\n<td>分解出来的功能用例</td>\n</tr>\n<tr>\n<td>扩展</td>\n<td>用例之间的关系</td>\n<td>基础用例</td>\n</tr>\n<tr>\n<td><code>依赖-VS2010的用例模型图中，添加了依赖关系</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 关联(Association)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>表示参与者与用例之间的通信，任何一方都可发送或接受消息。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Association.png\" alt>Â</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 泛化(Inheritance)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Inheritance.png\" alt></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 包含(Include)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Include.png\" alt></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 扩展(Extend)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Extend.png\" alt></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>##### 依赖(Dependency)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>以上4种关系，是UML定义的标准关系。但VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示，表示源用例依赖于目标用例。</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><img src=\"image/uc/Dependency.png\" alt></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"5-项目-Artifact\"><a href=\"#5-项目-Artifact\" class=\"headerlink\" title=\"5. 项目(Artifact)\"></a>5. 项目(Artifact)</h4><p><code>VS2010中引入了“项目”这样一个元素</code><br>用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用Excel都比用例图强，以便让开发人员能够在用例图中链接一个普通文档。<br><img src=\"image/uc/Artifact.png\" alt></p>\n<h4 id=\"6-注释-Comment\"><a href=\"#6-注释-Comment\" class=\"headerlink\" title=\"6. 注释(Comment)\"></a>6. 注释(Comment)</h4><p><img src=\"image/uc/Comment.png\" alt></p>\n<h3 id=\"包含-include-、扩展-extend-、泛化-Inheritance-的区别\"><a href=\"#包含-include-、扩展-extend-、泛化-Inheritance-的区别\" class=\"headerlink\" title=\"包含(include)、扩展(extend)、泛化(Inheritance) 的区别\"></a>包含(include)、扩展(extend)、泛化(Inheritance) 的区别</h3><ul>\n<li>条件性：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的；</li>\n<li>直接性：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。</li>\n<li>对extend而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。</li>\n<li>对Inheritance而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；</li>\n</ul>\n<h3 id=\"如何画Use-Case-用例视图\"><a href=\"#如何画Use-Case-用例视图\" class=\"headerlink\" title=\"如何画Use Case 用例视图\"></a>如何画Use Case 用例视图</h3><p>本人使用的工具是 <code>Start UML</code></p>\n<h4 id=\"1-新建工程\"><a href=\"#1-新建工程\" class=\"headerlink\" title=\"1. 新建工程\"></a>1. 新建工程</h4><pre><code>[file]-&gt;[New]</code></pre><h4 id=\"2-新建Use-Case-Diagram\"><a href=\"#2-新建Use-Case-Diagram\" class=\"headerlink\" title=\"2. 新建Use Case Diagram\"></a>2. 新建Use Case Diagram</h4><p><img src=\"image/uc/edit_add.png\" alt></p>\n<h4 id=\"3-从左侧Toolbox中选择相关的对象，放到中部编辑区\"><a href=\"#3-从左侧Toolbox中选择相关的对象，放到中部编辑区\" class=\"headerlink\" title=\"3. 从左侧Toolbox中选择相关的对象，放到中部编辑区\"></a>3. 从左侧Toolbox中选择相关的对象，放到中部编辑区</h4><p><img src=\"image/uc/edit_drow.png\" alt></p>\n<p>可以参考灵动生活的<a href=\"http://www.cnblogs.com/ywqu/archive/2009/12/03/1616232.html#_Toc247614719\" target=\"_blank\" rel=\"noopener\">设计阶段如何画用例视图（Use-Case View）</a></p>\n<h3 id=\"示例：图书管理系统的UC\"><a href=\"#示例：图书管理系统的UC\" class=\"headerlink\" title=\"示例：图书管理系统的UC\"></a>示例：图书管理系统的UC</h3><h4 id=\"需求描述\"><a href=\"#需求描述\" class=\"headerlink\" title=\"需求描述\"></a>需求描述</h4><p>该系统是一套图书管理系统（主要是模仿学校当前的图书系统设置的），主要的服务人员为读者、图书管理员和系统管理员。</p>\n<ul>\n<li>读者：<ol>\n<li>办理图书借阅卡</li>\n<li>查询图书  （可分为查询已借图书和查询可借图书，这个关系可以理解成泛化）</li>\n<li>借阅图书    </li>\n<li>预约图书    </li>\n<li>还书</li>\n<li>续借图书</li>\n</ol>\n</li>\n<li>图书管理员：<ol>\n<li>借书</li>\n<li>还书</li>\n<li>管理图书信息，包括：<ul>\n<li>统计缺失的书</li>\n<li>订购新书</li>\n<li>入库新书（增加图书记录）</li>\n<li>更新/删除图书记录</li>\n</ul>\n</li>\n<li>收罚金，撤销违规记录</li>\n</ol>\n</li>\n<li>系统管理员：系统维护<ul>\n<li>日志维护</li>\n<li>权限维护</li>\n<li>用户管理</li>\n<li>数据库维护</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"实际作图\"><a href=\"#实际作图\" class=\"headerlink\" title=\"实际作图\"></a>实际作图</h4><p><img src=\"image/uc/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.jpg\" alt></p>\n"},{"title":"UML-状态图","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2018-05-22T12:14:00.000Z","_content":"### UML建模之状态图（Statechart Diagram）\n#### 简介（Brief introduction）\n>状态图（Statechart Diagram）主要用于描述一个对象在其生存期间的动态行为，表现为一个对象所经历的状态序列，引起状态转移的事件（Event），以及因状态转移而伴随的动作（Action）。一般可以用状态机对一个对象的生命周期建模，状态图用于显示状态机（State Machine Diagram），重点在与描述状态图的控制流。\n\n- 状态机\n>我们理解为记录下给定时刻状态的机器，根据不同的输入对每个给定的变化而改变其状态或引发一个动作。\n在UML中，状态机由对象的各个状态和连接这些状态的转换组成，是展示状态与状态转换的图。\n状态图本质上就是一个状态机或是状态机的特殊情况。由表示状态的节点和表示状态之间转换的带箭头的直线组成。\n\n#### 状态图元素（State Diagram Elements）\n包括以下内容\n- 状态名：区分状态的名称\n- 内部活动\n- 内部装换\n- 入口和出口动作\n- 嵌套状态\n  - 简单状态：语义上不可分割、对象保持一定属性值，没有子结构\n  - 组成状态：\n    - 内部嵌套子状态的状体\n    - 初始\n    - 终止\n    - 顺序：多个子状态之间是互斥的、不能同时存在\n    - 并发：可能有两个或多个并发的子状态\n- 历史状态：伪状态，说明组成状态曾经有的子状态\n\n\n1. 状态名（States）\n> 指在对象的生命周期中的某个条件或者状况，在此期间对象将满足某些条件、执行某些活动活活等待某些事件。所有对象都有状态，状态是对象执行了一系列活动的结果，当某个事件发生后，对象的状态将发生变化。\n\n  - 状态用圆角矩形表示\n  - 初态和终态（Initial and Final States）初态用实心圆点表示，终态用圆形内嵌圆点表示。\n\n\n\n2. 转移（Transitions）\n>是两个状态之间的一种关系，表示对象将在源状态（Source State）中执行一定的动作，并在某个特定事件发生而且某个特定的警界条件满足时进入目标状态（Target State）\n\n  - 事件标记（Trigger）：是转移的诱因，可以是一个信号，事件、条件变化（a change in some condition）和时间表达式。\n  - 警界条件（Guard Condition）：当警界条件满足时，事件才会引发转移（Transition）。\n  - 结果（Effect）：对象状态转移后的结果。\n\n  包括以下内容\n  - 源状态：激活转换之前所处的状态\n  - 目标状态：转换完成后对象所处的状态\n  - 动作：简短的计算处理过程或一组可执行的语句\n  - 监护条件：布尔表达式\n  - 事件触发器：引起愿状态的事件\n\n3. 事件/动作（State Actions）\n>是一个可执行的原子操作,也就是说动作是不可中断的，其执行时间是可忽略不计的。\n\n  包括以下内容\n  - Signal\n  - Call\n  - Change\n  - Time\n\n4. 自身转移（Self-Transitions）\n>状态可以有返回自身状态的转移，称之为自身转移（Self-Transitions）\n\n5. 组合状态（Compound States）\n>嵌套在另外一个状态中的状态称之为子状态（sub-state）,一个含有子状态的状态被称作组合状态（Compound States）. 如下图，【Check PIN】是组合状态，【Enter PIN】是子状态。\n\n6. 进入节点（Entry Point）\n>如下图所示，由于一些原因并不会执行初始化（initialization），而是直接通过一个节点进入状态【Ready】，则此节点称之为进入节点（Entry Point）<br>\n![](image/Statechart/进入节点.png)\n\n7. 退出节点（Exit Point）\n>![](image/Statechart/退出节点.png)\n\n8. 历史状态（History States）\n>  历史状态是一个伪状态（Pseudostate）,其目的是记住从组合状态中退出时所处的子状态，当再次进入组合状态，可直接进入这个子状态，而不是再次从组合状态的初态开始。<br>\n![](image/Statechart/历史状态.png)<br>\n在上图的状态图中，正常的状态顺序是:【Washing】- >【Rinsing】->【Spinning】。<br>\n如果是从状态【Rinsing】突然停电（Power Cut）退出，,洗衣机停止工作进入状态【Power Off】，当电力恢复时直接进入状态【Running】。\n\n9. 并发区域（Concurrent Regions）\n>  状态图可以分为区域，而区域又包括退出或者当前执行的子状态。说明组合状态在某一时刻可以同时达到多个子状态。如下图刹车系统，同时进入前刹车【Applying Front Brakes】状态和后刹车【Applying Rear Brakes】状态。<br>\n>![](image/Statechart/并发区域.png)\n\n#### 状态图的作用：\n1. 清晰描述状态之间的转换顺序，通过转换顺序可以清晰看出事件的执行顺序\n2. 清晰的事件顺序有利于程序员在开发程序时避免出现事件错序的情况\n3. 清晰地描述了状态转换时所必须触发德尔事件、监护条件和动作等影响转换的因素，有利于程序员汇总非法事件的进入\n4. 通过判断更好地描述工作流因为不同的条件发生的分支\n\n#### 状态图练习\n![](image/Statechart/状态图练习.png)<br>\n##### 订单成立状态主要有：\n- 订单成立\n- 订单取消（Guard:会员订单-缴款期限已过期）\n- 备货中（Guard:已付款、订单成立、库存量足够）\n- 出货中（Effect:扣除商品可接单量及移除购物车中的购买资料）\n- 出货确认（Guard:实际配达日及发票代码、号码均不为空值）\n- 出货完毕（Guard:实际配达日不为空）\n- 出货失败\n- 订单成立（Guard:出货完毕，已付款、鉴赏期结束日期 小于等于 [系统日期]）\n\n##### 分析：\n1. 购物车生成订单进入状态【订单成立】\n2. 系统检测订单已经付款并且库存量足够，则进入状态【备货中】\n3. 物流发货，进入状态【发货中】，状态转移为【发货中】后，需要做的操作有“扣除商品可接单量及移除购物车中的购买资料”\n4. 发货完毕后，状态分为【出货确认】和状态【出货失败】，如果状态是【出货失败】，则【结束】，如果状态为【出货确认】，则进入下一步。\n5. 配货人员填写实际配达日期，进入状态【出货完毕】。\n6. 如果”已付款、鉴赏期结束日期 小于等于 [系统日期]”,则【订单成立】。\n\n##### 参考资料\n[http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html](http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html)\n","source":"_posts/uml/05 状态图(Statechart Diagram).md","raw":"---\ntitle: UML-状态图\nauthor: JsonYe\ntags:\n- uml\n- 状态图\ncategories:\n- UML\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-05-22 20:14:00   \n---\n### UML建模之状态图（Statechart Diagram）\n#### 简介（Brief introduction）\n>状态图（Statechart Diagram）主要用于描述一个对象在其生存期间的动态行为，表现为一个对象所经历的状态序列，引起状态转移的事件（Event），以及因状态转移而伴随的动作（Action）。一般可以用状态机对一个对象的生命周期建模，状态图用于显示状态机（State Machine Diagram），重点在与描述状态图的控制流。\n\n- 状态机\n>我们理解为记录下给定时刻状态的机器，根据不同的输入对每个给定的变化而改变其状态或引发一个动作。\n在UML中，状态机由对象的各个状态和连接这些状态的转换组成，是展示状态与状态转换的图。\n状态图本质上就是一个状态机或是状态机的特殊情况。由表示状态的节点和表示状态之间转换的带箭头的直线组成。\n\n#### 状态图元素（State Diagram Elements）\n包括以下内容\n- 状态名：区分状态的名称\n- 内部活动\n- 内部装换\n- 入口和出口动作\n- 嵌套状态\n  - 简单状态：语义上不可分割、对象保持一定属性值，没有子结构\n  - 组成状态：\n    - 内部嵌套子状态的状体\n    - 初始\n    - 终止\n    - 顺序：多个子状态之间是互斥的、不能同时存在\n    - 并发：可能有两个或多个并发的子状态\n- 历史状态：伪状态，说明组成状态曾经有的子状态\n\n\n1. 状态名（States）\n> 指在对象的生命周期中的某个条件或者状况，在此期间对象将满足某些条件、执行某些活动活活等待某些事件。所有对象都有状态，状态是对象执行了一系列活动的结果，当某个事件发生后，对象的状态将发生变化。\n\n  - 状态用圆角矩形表示\n  - 初态和终态（Initial and Final States）初态用实心圆点表示，终态用圆形内嵌圆点表示。\n\n\n\n2. 转移（Transitions）\n>是两个状态之间的一种关系，表示对象将在源状态（Source State）中执行一定的动作，并在某个特定事件发生而且某个特定的警界条件满足时进入目标状态（Target State）\n\n  - 事件标记（Trigger）：是转移的诱因，可以是一个信号，事件、条件变化（a change in some condition）和时间表达式。\n  - 警界条件（Guard Condition）：当警界条件满足时，事件才会引发转移（Transition）。\n  - 结果（Effect）：对象状态转移后的结果。\n\n  包括以下内容\n  - 源状态：激活转换之前所处的状态\n  - 目标状态：转换完成后对象所处的状态\n  - 动作：简短的计算处理过程或一组可执行的语句\n  - 监护条件：布尔表达式\n  - 事件触发器：引起愿状态的事件\n\n3. 事件/动作（State Actions）\n>是一个可执行的原子操作,也就是说动作是不可中断的，其执行时间是可忽略不计的。\n\n  包括以下内容\n  - Signal\n  - Call\n  - Change\n  - Time\n\n4. 自身转移（Self-Transitions）\n>状态可以有返回自身状态的转移，称之为自身转移（Self-Transitions）\n\n5. 组合状态（Compound States）\n>嵌套在另外一个状态中的状态称之为子状态（sub-state）,一个含有子状态的状态被称作组合状态（Compound States）. 如下图，【Check PIN】是组合状态，【Enter PIN】是子状态。\n\n6. 进入节点（Entry Point）\n>如下图所示，由于一些原因并不会执行初始化（initialization），而是直接通过一个节点进入状态【Ready】，则此节点称之为进入节点（Entry Point）<br>\n![](image/Statechart/进入节点.png)\n\n7. 退出节点（Exit Point）\n>![](image/Statechart/退出节点.png)\n\n8. 历史状态（History States）\n>  历史状态是一个伪状态（Pseudostate）,其目的是记住从组合状态中退出时所处的子状态，当再次进入组合状态，可直接进入这个子状态，而不是再次从组合状态的初态开始。<br>\n![](image/Statechart/历史状态.png)<br>\n在上图的状态图中，正常的状态顺序是:【Washing】- >【Rinsing】->【Spinning】。<br>\n如果是从状态【Rinsing】突然停电（Power Cut）退出，,洗衣机停止工作进入状态【Power Off】，当电力恢复时直接进入状态【Running】。\n\n9. 并发区域（Concurrent Regions）\n>  状态图可以分为区域，而区域又包括退出或者当前执行的子状态。说明组合状态在某一时刻可以同时达到多个子状态。如下图刹车系统，同时进入前刹车【Applying Front Brakes】状态和后刹车【Applying Rear Brakes】状态。<br>\n>![](image/Statechart/并发区域.png)\n\n#### 状态图的作用：\n1. 清晰描述状态之间的转换顺序，通过转换顺序可以清晰看出事件的执行顺序\n2. 清晰的事件顺序有利于程序员在开发程序时避免出现事件错序的情况\n3. 清晰地描述了状态转换时所必须触发德尔事件、监护条件和动作等影响转换的因素，有利于程序员汇总非法事件的进入\n4. 通过判断更好地描述工作流因为不同的条件发生的分支\n\n#### 状态图练习\n![](image/Statechart/状态图练习.png)<br>\n##### 订单成立状态主要有：\n- 订单成立\n- 订单取消（Guard:会员订单-缴款期限已过期）\n- 备货中（Guard:已付款、订单成立、库存量足够）\n- 出货中（Effect:扣除商品可接单量及移除购物车中的购买资料）\n- 出货确认（Guard:实际配达日及发票代码、号码均不为空值）\n- 出货完毕（Guard:实际配达日不为空）\n- 出货失败\n- 订单成立（Guard:出货完毕，已付款、鉴赏期结束日期 小于等于 [系统日期]）\n\n##### 分析：\n1. 购物车生成订单进入状态【订单成立】\n2. 系统检测订单已经付款并且库存量足够，则进入状态【备货中】\n3. 物流发货，进入状态【发货中】，状态转移为【发货中】后，需要做的操作有“扣除商品可接单量及移除购物车中的购买资料”\n4. 发货完毕后，状态分为【出货确认】和状态【出货失败】，如果状态是【出货失败】，则【结束】，如果状态为【出货确认】，则进入下一步。\n5. 配货人员填写实际配达日期，进入状态【出货完毕】。\n6. 如果”已付款、鉴赏期结束日期 小于等于 [系统日期]”,则【订单成立】。\n\n##### 参考资料\n[http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html](http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html)\n","slug":"uml/05 状态图(Statechart Diagram)","published":1,"updated":"2019-10-02T13:48:51.136Z","layout":"post","photos":[],"link":"","_id":"ck19bvazc001u00wkff04myyn","content":"<h3 id=\"UML建模之状态图（Statechart-Diagram）\"><a href=\"#UML建模之状态图（Statechart-Diagram）\" class=\"headerlink\" title=\"UML建模之状态图（Statechart Diagram）\"></a>UML建模之状态图（Statechart Diagram）</h3><h4 id=\"简介（Brief-introduction）\"><a href=\"#简介（Brief-introduction）\" class=\"headerlink\" title=\"简介（Brief introduction）\"></a>简介（Brief introduction）</h4><blockquote>\n<p>状态图（Statechart Diagram）主要用于描述一个对象在其生存期间的动态行为，表现为一个对象所经历的状态序列，引起状态转移的事件（Event），以及因状态转移而伴随的动作（Action）。一般可以用状态机对一个对象的生命周期建模，状态图用于显示状态机（State Machine Diagram），重点在与描述状态图的控制流。</p>\n</blockquote>\n<ul>\n<li>状态机<blockquote>\n<p>我们理解为记录下给定时刻状态的机器，根据不同的输入对每个给定的变化而改变其状态或引发一个动作。<br>在UML中，状态机由对象的各个状态和连接这些状态的转换组成，是展示状态与状态转换的图。<br>状态图本质上就是一个状态机或是状态机的特殊情况。由表示状态的节点和表示状态之间转换的带箭头的直线组成。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"状态图元素（State-Diagram-Elements）\"><a href=\"#状态图元素（State-Diagram-Elements）\" class=\"headerlink\" title=\"状态图元素（State Diagram Elements）\"></a>状态图元素（State Diagram Elements）</h4><p>包括以下内容</p>\n<ul>\n<li>状态名：区分状态的名称</li>\n<li>内部活动</li>\n<li>内部装换</li>\n<li>入口和出口动作</li>\n<li>嵌套状态<ul>\n<li>简单状态：语义上不可分割、对象保持一定属性值，没有子结构</li>\n<li>组成状态：<ul>\n<li>内部嵌套子状态的状体</li>\n<li>初始</li>\n<li>终止</li>\n<li>顺序：多个子状态之间是互斥的、不能同时存在</li>\n<li>并发：可能有两个或多个并发的子状态</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>历史状态：伪状态，说明组成状态曾经有的子状态</li>\n</ul>\n<ol>\n<li><p>状态名（States）</p>\n<blockquote>\n<p>指在对象的生命周期中的某个条件或者状况，在此期间对象将满足某些条件、执行某些活动活活等待某些事件。所有对象都有状态，状态是对象执行了一系列活动的结果，当某个事件发生后，对象的状态将发生变化。</p>\n</blockquote>\n<ul>\n<li>状态用圆角矩形表示</li>\n<li>初态和终态（Initial and Final States）初态用实心圆点表示，终态用圆形内嵌圆点表示。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>转移（Transitions）</p>\n<blockquote>\n<p>是两个状态之间的一种关系，表示对象将在源状态（Source State）中执行一定的动作，并在某个特定事件发生而且某个特定的警界条件满足时进入目标状态（Target State）</p>\n</blockquote>\n<ul>\n<li>事件标记（Trigger）：是转移的诱因，可以是一个信号，事件、条件变化（a change in some condition）和时间表达式。</li>\n<li>警界条件（Guard Condition）：当警界条件满足时，事件才会引发转移（Transition）。</li>\n<li>结果（Effect）：对象状态转移后的结果。</li>\n</ul>\n<p>包括以下内容</p>\n<ul>\n<li>源状态：激活转换之前所处的状态</li>\n<li>目标状态：转换完成后对象所处的状态</li>\n<li>动作：简短的计算处理过程或一组可执行的语句</li>\n<li>监护条件：布尔表达式</li>\n<li>事件触发器：引起愿状态的事件</li>\n</ul>\n</li>\n<li><p>事件/动作（State Actions）</p>\n<blockquote>\n<p>是一个可执行的原子操作,也就是说动作是不可中断的，其执行时间是可忽略不计的。</p>\n</blockquote>\n<p>包括以下内容</p>\n<ul>\n<li>Signal</li>\n<li>Call</li>\n<li>Change</li>\n<li>Time</li>\n</ul>\n</li>\n<li><p>自身转移（Self-Transitions）</p>\n<blockquote>\n<p>状态可以有返回自身状态的转移，称之为自身转移（Self-Transitions）</p>\n</blockquote>\n</li>\n<li><p>组合状态（Compound States）</p>\n<blockquote>\n<p>嵌套在另外一个状态中的状态称之为子状态（sub-state）,一个含有子状态的状态被称作组合状态（Compound States）. 如下图，【Check PIN】是组合状态，【Enter PIN】是子状态。</p>\n</blockquote>\n</li>\n<li><p>进入节点（Entry Point）</p>\n<blockquote>\n<p>如下图所示，由于一些原因并不会执行初始化（initialization），而是直接通过一个节点进入状态【Ready】，则此节点称之为进入节点（Entry Point）<br><br><img src=\"image/Statechart/%E8%BF%9B%E5%85%A5%E8%8A%82%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>退出节点（Exit Point）</p>\n<blockquote>\n<p><img src=\"image/Statechart/%E9%80%80%E5%87%BA%E8%8A%82%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>历史状态（History States）</p>\n<blockquote>\n<p> 历史状态是一个伪状态（Pseudostate）,其目的是记住从组合状态中退出时所处的子状态，当再次进入组合状态，可直接进入这个子状态，而不是再次从组合状态的初态开始。<br><br><img src=\"image/Statechart/%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81.png\" alt><br><br>在上图的状态图中，正常的状态顺序是:【Washing】- &gt;【Rinsing】-&gt;【Spinning】。<br><br>如果是从状态【Rinsing】突然停电（Power Cut）退出，,洗衣机停止工作进入状态【Power Off】，当电力恢复时直接进入状态【Running】。</p>\n</blockquote>\n</li>\n<li><p>并发区域（Concurrent Regions）</p>\n<blockquote>\n<p> 状态图可以分为区域，而区域又包括退出或者当前执行的子状态。说明组合状态在某一时刻可以同时达到多个子状态。如下图刹车系统，同时进入前刹车【Applying Front Brakes】状态和后刹车【Applying Rear Brakes】状态。<br><br><img src=\"image/Statechart/%E5%B9%B6%E5%8F%91%E5%8C%BA%E5%9F%9F.png\" alt></p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"状态图的作用：\"><a href=\"#状态图的作用：\" class=\"headerlink\" title=\"状态图的作用：\"></a>状态图的作用：</h4><ol>\n<li>清晰描述状态之间的转换顺序，通过转换顺序可以清晰看出事件的执行顺序</li>\n<li>清晰的事件顺序有利于程序员在开发程序时避免出现事件错序的情况</li>\n<li>清晰地描述了状态转换时所必须触发德尔事件、监护条件和动作等影响转换的因素，有利于程序员汇总非法事件的进入</li>\n<li>通过判断更好地描述工作流因为不同的条件发生的分支</li>\n</ol>\n<h4 id=\"状态图练习\"><a href=\"#状态图练习\" class=\"headerlink\" title=\"状态图练习\"></a>状态图练习</h4><p><img src=\"image/Statechart/%E7%8A%B6%E6%80%81%E5%9B%BE%E7%BB%83%E4%B9%A0.png\" alt><br></p>\n<h5 id=\"订单成立状态主要有：\"><a href=\"#订单成立状态主要有：\" class=\"headerlink\" title=\"订单成立状态主要有：\"></a>订单成立状态主要有：</h5><ul>\n<li>订单成立</li>\n<li>订单取消（Guard:会员订单-缴款期限已过期）</li>\n<li>备货中（Guard:已付款、订单成立、库存量足够）</li>\n<li>出货中（Effect:扣除商品可接单量及移除购物车中的购买资料）</li>\n<li>出货确认（Guard:实际配达日及发票代码、号码均不为空值）</li>\n<li>出货完毕（Guard:实际配达日不为空）</li>\n<li>出货失败</li>\n<li>订单成立（Guard:出货完毕，已付款、鉴赏期结束日期 小于等于 [系统日期]）</li>\n</ul>\n<h5 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h5><ol>\n<li>购物车生成订单进入状态【订单成立】</li>\n<li>系统检测订单已经付款并且库存量足够，则进入状态【备货中】</li>\n<li>物流发货，进入状态【发货中】，状态转移为【发货中】后，需要做的操作有“扣除商品可接单量及移除购物车中的购买资料”</li>\n<li>发货完毕后，状态分为【出货确认】和状态【出货失败】，如果状态是【出货失败】，则【结束】，如果状态为【出货确认】，则进入下一步。</li>\n<li>配货人员填写实际配达日期，进入状态【出货完毕】。</li>\n<li>如果”已付款、鉴赏期结束日期 小于等于 [系统日期]”,则【订单成立】。</li>\n</ol>\n<h5 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h5><p><a href=\"http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"UML建模之状态图（Statechart-Diagram）\"><a href=\"#UML建模之状态图（Statechart-Diagram）\" class=\"headerlink\" title=\"UML建模之状态图（Statechart Diagram）\"></a>UML建模之状态图（Statechart Diagram）</h3><h4 id=\"简介（Brief-introduction）\"><a href=\"#简介（Brief-introduction）\" class=\"headerlink\" title=\"简介（Brief introduction）\"></a>简介（Brief introduction）</h4><blockquote>\n<p>状态图（Statechart Diagram）主要用于描述一个对象在其生存期间的动态行为，表现为一个对象所经历的状态序列，引起状态转移的事件（Event），以及因状态转移而伴随的动作（Action）。一般可以用状态机对一个对象的生命周期建模，状态图用于显示状态机（State Machine Diagram），重点在与描述状态图的控制流。</p>\n</blockquote>\n<ul>\n<li>状态机<blockquote>\n<p>我们理解为记录下给定时刻状态的机器，根据不同的输入对每个给定的变化而改变其状态或引发一个动作。<br>在UML中，状态机由对象的各个状态和连接这些状态的转换组成，是展示状态与状态转换的图。<br>状态图本质上就是一个状态机或是状态机的特殊情况。由表示状态的节点和表示状态之间转换的带箭头的直线组成。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"状态图元素（State-Diagram-Elements）\"><a href=\"#状态图元素（State-Diagram-Elements）\" class=\"headerlink\" title=\"状态图元素（State Diagram Elements）\"></a>状态图元素（State Diagram Elements）</h4><p>包括以下内容</p>\n<ul>\n<li>状态名：区分状态的名称</li>\n<li>内部活动</li>\n<li>内部装换</li>\n<li>入口和出口动作</li>\n<li>嵌套状态<ul>\n<li>简单状态：语义上不可分割、对象保持一定属性值，没有子结构</li>\n<li>组成状态：<ul>\n<li>内部嵌套子状态的状体</li>\n<li>初始</li>\n<li>终止</li>\n<li>顺序：多个子状态之间是互斥的、不能同时存在</li>\n<li>并发：可能有两个或多个并发的子状态</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>历史状态：伪状态，说明组成状态曾经有的子状态</li>\n</ul>\n<ol>\n<li><p>状态名（States）</p>\n<blockquote>\n<p>指在对象的生命周期中的某个条件或者状况，在此期间对象将满足某些条件、执行某些活动活活等待某些事件。所有对象都有状态，状态是对象执行了一系列活动的结果，当某个事件发生后，对象的状态将发生变化。</p>\n</blockquote>\n<ul>\n<li>状态用圆角矩形表示</li>\n<li>初态和终态（Initial and Final States）初态用实心圆点表示，终态用圆形内嵌圆点表示。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>转移（Transitions）</p>\n<blockquote>\n<p>是两个状态之间的一种关系，表示对象将在源状态（Source State）中执行一定的动作，并在某个特定事件发生而且某个特定的警界条件满足时进入目标状态（Target State）</p>\n</blockquote>\n<ul>\n<li>事件标记（Trigger）：是转移的诱因，可以是一个信号，事件、条件变化（a change in some condition）和时间表达式。</li>\n<li>警界条件（Guard Condition）：当警界条件满足时，事件才会引发转移（Transition）。</li>\n<li>结果（Effect）：对象状态转移后的结果。</li>\n</ul>\n<p>包括以下内容</p>\n<ul>\n<li>源状态：激活转换之前所处的状态</li>\n<li>目标状态：转换完成后对象所处的状态</li>\n<li>动作：简短的计算处理过程或一组可执行的语句</li>\n<li>监护条件：布尔表达式</li>\n<li>事件触发器：引起愿状态的事件</li>\n</ul>\n</li>\n<li><p>事件/动作（State Actions）</p>\n<blockquote>\n<p>是一个可执行的原子操作,也就是说动作是不可中断的，其执行时间是可忽略不计的。</p>\n</blockquote>\n<p>包括以下内容</p>\n<ul>\n<li>Signal</li>\n<li>Call</li>\n<li>Change</li>\n<li>Time</li>\n</ul>\n</li>\n<li><p>自身转移（Self-Transitions）</p>\n<blockquote>\n<p>状态可以有返回自身状态的转移，称之为自身转移（Self-Transitions）</p>\n</blockquote>\n</li>\n<li><p>组合状态（Compound States）</p>\n<blockquote>\n<p>嵌套在另外一个状态中的状态称之为子状态（sub-state）,一个含有子状态的状态被称作组合状态（Compound States）. 如下图，【Check PIN】是组合状态，【Enter PIN】是子状态。</p>\n</blockquote>\n</li>\n<li><p>进入节点（Entry Point）</p>\n<blockquote>\n<p>如下图所示，由于一些原因并不会执行初始化（initialization），而是直接通过一个节点进入状态【Ready】，则此节点称之为进入节点（Entry Point）<br><br><img src=\"image/Statechart/%E8%BF%9B%E5%85%A5%E8%8A%82%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>退出节点（Exit Point）</p>\n<blockquote>\n<p><img src=\"image/Statechart/%E9%80%80%E5%87%BA%E8%8A%82%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>历史状态（History States）</p>\n<blockquote>\n<p> 历史状态是一个伪状态（Pseudostate）,其目的是记住从组合状态中退出时所处的子状态，当再次进入组合状态，可直接进入这个子状态，而不是再次从组合状态的初态开始。<br><br><img src=\"image/Statechart/%E5%8E%86%E5%8F%B2%E7%8A%B6%E6%80%81.png\" alt><br><br>在上图的状态图中，正常的状态顺序是:【Washing】- &gt;【Rinsing】-&gt;【Spinning】。<br><br>如果是从状态【Rinsing】突然停电（Power Cut）退出，,洗衣机停止工作进入状态【Power Off】，当电力恢复时直接进入状态【Running】。</p>\n</blockquote>\n</li>\n<li><p>并发区域（Concurrent Regions）</p>\n<blockquote>\n<p> 状态图可以分为区域，而区域又包括退出或者当前执行的子状态。说明组合状态在某一时刻可以同时达到多个子状态。如下图刹车系统，同时进入前刹车【Applying Front Brakes】状态和后刹车【Applying Rear Brakes】状态。<br><br><img src=\"image/Statechart/%E5%B9%B6%E5%8F%91%E5%8C%BA%E5%9F%9F.png\" alt></p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"状态图的作用：\"><a href=\"#状态图的作用：\" class=\"headerlink\" title=\"状态图的作用：\"></a>状态图的作用：</h4><ol>\n<li>清晰描述状态之间的转换顺序，通过转换顺序可以清晰看出事件的执行顺序</li>\n<li>清晰的事件顺序有利于程序员在开发程序时避免出现事件错序的情况</li>\n<li>清晰地描述了状态转换时所必须触发德尔事件、监护条件和动作等影响转换的因素，有利于程序员汇总非法事件的进入</li>\n<li>通过判断更好地描述工作流因为不同的条件发生的分支</li>\n</ol>\n<h4 id=\"状态图练习\"><a href=\"#状态图练习\" class=\"headerlink\" title=\"状态图练习\"></a>状态图练习</h4><p><img src=\"image/Statechart/%E7%8A%B6%E6%80%81%E5%9B%BE%E7%BB%83%E4%B9%A0.png\" alt><br></p>\n<h5 id=\"订单成立状态主要有：\"><a href=\"#订单成立状态主要有：\" class=\"headerlink\" title=\"订单成立状态主要有：\"></a>订单成立状态主要有：</h5><ul>\n<li>订单成立</li>\n<li>订单取消（Guard:会员订单-缴款期限已过期）</li>\n<li>备货中（Guard:已付款、订单成立、库存量足够）</li>\n<li>出货中（Effect:扣除商品可接单量及移除购物车中的购买资料）</li>\n<li>出货确认（Guard:实际配达日及发票代码、号码均不为空值）</li>\n<li>出货完毕（Guard:实际配达日不为空）</li>\n<li>出货失败</li>\n<li>订单成立（Guard:出货完毕，已付款、鉴赏期结束日期 小于等于 [系统日期]）</li>\n</ul>\n<h5 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h5><ol>\n<li>购物车生成订单进入状态【订单成立】</li>\n<li>系统检测订单已经付款并且库存量足够，则进入状态【备货中】</li>\n<li>物流发货，进入状态【发货中】，状态转移为【发货中】后，需要做的操作有“扣除商品可接单量及移除购物车中的购买资料”</li>\n<li>发货完毕后，状态分为【出货确认】和状态【出货失败】，如果状态是【出货失败】，则【结束】，如果状态为【出货确认】，则进入下一步。</li>\n<li>配货人员填写实际配达日期，进入状态【出货完毕】。</li>\n<li>如果”已付款、鉴赏期结束日期 小于等于 [系统日期]”,则【订单成立】。</li>\n</ol>\n<h5 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h5><p><a href=\"http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/ywqu/archive/2009/12/17/1626043.html</a></p>\n"},{"title":"UML-部署图","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2018-05-23T13:14:00.000Z","_content":"### 部署图（Deployment Diagram)\n#### 部署图元素（Deployment Diagram Elements）\n> 部署图描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。一个系统模型只有一个部署图，部署图通常用来帮助理解分布式系统。\n\n#### 部署图元素（Deployment Diagram Elements）\n1. 结点（Node）\n>  结点是存在与运行时的代表计算机资源的物理元素，可以是硬件也可以是运行其上的软件系统，比如64主机、Windows server 2008操作系统、防火墙等。结点用三维盒装表示，如下图：<br>\n![](image/Deployment/结点.png)\n\n2. 结点实例（Node Instance）\n>结点实例名称格式{Node Instance : node}\n\n  与结点的区别在于名称有下划线和结点类型前面有冒号，冒号前面可以有示例名称也可以没有示例名称，如下图<br>\n  ![](image/Deployment/结点实例.png)\n\n3. 节点类型（Node Stereotypes）\n>结点类型有：«cdrom», «cd-rom», «computer», «disk array», «pc», «pc client», «pc server», «secure», «server», «storage», «unix server», «user pc»，并在结点的右上角用不同的图标表示，如下图\n\n4. 物件（Artifact）\n>  物件是软件开发过程中的产物，包括过程模型（比如用例图、设计图等等）、源代码、可执行程序、设计文档、测试报告、需求原型、用户手册等等。物件表示如下，带有关键字«artifact»和文档图标\n\n5. 连接（Association）\n>结点之间的连线表示系统之间进行交互的通信路径，这个通信路径称为连接（Association），如下图所示，连接中有网络协议。\n\n6. 结点容器（Node as Container）\n >一个结点可以包括其他的结点，比如组件或者物件，则称此结点为结点容器（Node as Container）。如下图所示，结点（Node）包容了物件（Artifact）。\n\n#### 参考文章\n[http://www.cnblogs.com/ywqu/archive/2009/12/21/1628545.html](http://www.cnblogs.com/ywqu/archive/2009/12/21/1628545.html)\n","source":"_posts/uml/06 部署图(Deployment Diagram).md","raw":"---\ntitle: UML-部署图\nauthor: JsonYe\ntags:\n- uml\n- 部署图\ncategories:\n- UML\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-05-23 21:14:00   \n---\n### 部署图（Deployment Diagram)\n#### 部署图元素（Deployment Diagram Elements）\n> 部署图描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。一个系统模型只有一个部署图，部署图通常用来帮助理解分布式系统。\n\n#### 部署图元素（Deployment Diagram Elements）\n1. 结点（Node）\n>  结点是存在与运行时的代表计算机资源的物理元素，可以是硬件也可以是运行其上的软件系统，比如64主机、Windows server 2008操作系统、防火墙等。结点用三维盒装表示，如下图：<br>\n![](image/Deployment/结点.png)\n\n2. 结点实例（Node Instance）\n>结点实例名称格式{Node Instance : node}\n\n  与结点的区别在于名称有下划线和结点类型前面有冒号，冒号前面可以有示例名称也可以没有示例名称，如下图<br>\n  ![](image/Deployment/结点实例.png)\n\n3. 节点类型（Node Stereotypes）\n>结点类型有：«cdrom», «cd-rom», «computer», «disk array», «pc», «pc client», «pc server», «secure», «server», «storage», «unix server», «user pc»，并在结点的右上角用不同的图标表示，如下图\n\n4. 物件（Artifact）\n>  物件是软件开发过程中的产物，包括过程模型（比如用例图、设计图等等）、源代码、可执行程序、设计文档、测试报告、需求原型、用户手册等等。物件表示如下，带有关键字«artifact»和文档图标\n\n5. 连接（Association）\n>结点之间的连线表示系统之间进行交互的通信路径，这个通信路径称为连接（Association），如下图所示，连接中有网络协议。\n\n6. 结点容器（Node as Container）\n >一个结点可以包括其他的结点，比如组件或者物件，则称此结点为结点容器（Node as Container）。如下图所示，结点（Node）包容了物件（Artifact）。\n\n#### 参考文章\n[http://www.cnblogs.com/ywqu/archive/2009/12/21/1628545.html](http://www.cnblogs.com/ywqu/archive/2009/12/21/1628545.html)\n","slug":"uml/06 部署图(Deployment Diagram)","published":1,"updated":"2019-10-02T13:48:59.103Z","layout":"post","photos":[],"link":"","_id":"ck19bvazi001y00wkay8518d7","content":"<h3 id=\"部署图（Deployment-Diagram\"><a href=\"#部署图（Deployment-Diagram\" class=\"headerlink\" title=\"部署图（Deployment Diagram)\"></a>部署图（Deployment Diagram)</h3><h4 id=\"部署图元素（Deployment-Diagram-Elements）\"><a href=\"#部署图元素（Deployment-Diagram-Elements）\" class=\"headerlink\" title=\"部署图元素（Deployment Diagram Elements）\"></a>部署图元素（Deployment Diagram Elements）</h4><blockquote>\n<p>部署图描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。一个系统模型只有一个部署图，部署图通常用来帮助理解分布式系统。</p>\n</blockquote>\n<h4 id=\"部署图元素（Deployment-Diagram-Elements）-1\"><a href=\"#部署图元素（Deployment-Diagram-Elements）-1\" class=\"headerlink\" title=\"部署图元素（Deployment Diagram Elements）\"></a>部署图元素（Deployment Diagram Elements）</h4><ol>\n<li><p>结点（Node）</p>\n<blockquote>\n<p> 结点是存在与运行时的代表计算机资源的物理元素，可以是硬件也可以是运行其上的软件系统，比如64主机、Windows server 2008操作系统、防火墙等。结点用三维盒装表示，如下图：<br><br><img src=\"image/Deployment/%E7%BB%93%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>结点实例（Node Instance）</p>\n<blockquote>\n<p>结点实例名称格式{Node Instance : node}</p>\n</blockquote>\n<p>与结点的区别在于名称有下划线和结点类型前面有冒号，冒号前面可以有示例名称也可以没有示例名称，如下图<br><br><img src=\"image/Deployment/%E7%BB%93%E7%82%B9%E5%AE%9E%E4%BE%8B.png\" alt></p>\n</li>\n<li><p>节点类型（Node Stereotypes）</p>\n<blockquote>\n<p>结点类型有：«cdrom», «cd-rom», «computer», «disk array», «pc», «pc client», «pc server», «secure», «server», «storage», «unix server», «user pc»，并在结点的右上角用不同的图标表示，如下图</p>\n</blockquote>\n</li>\n<li><p>物件（Artifact）</p>\n<blockquote>\n<p> 物件是软件开发过程中的产物，包括过程模型（比如用例图、设计图等等）、源代码、可执行程序、设计文档、测试报告、需求原型、用户手册等等。物件表示如下，带有关键字«artifact»和文档图标</p>\n</blockquote>\n</li>\n<li><p>连接（Association）</p>\n<blockquote>\n<p>结点之间的连线表示系统之间进行交互的通信路径，这个通信路径称为连接（Association），如下图所示，连接中有网络协议。</p>\n</blockquote>\n</li>\n<li><p>结点容器（Node as Container）</p>\n<blockquote>\n<p>一个结点可以包括其他的结点，比如组件或者物件，则称此结点为结点容器（Node as Container）。如下图所示，结点（Node）包容了物件（Artifact）。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.cnblogs.com/ywqu/archive/2009/12/21/1628545.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/ywqu/archive/2009/12/21/1628545.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"部署图（Deployment-Diagram\"><a href=\"#部署图（Deployment-Diagram\" class=\"headerlink\" title=\"部署图（Deployment Diagram)\"></a>部署图（Deployment Diagram)</h3><h4 id=\"部署图元素（Deployment-Diagram-Elements）\"><a href=\"#部署图元素（Deployment-Diagram-Elements）\" class=\"headerlink\" title=\"部署图元素（Deployment Diagram Elements）\"></a>部署图元素（Deployment Diagram Elements）</h4><blockquote>\n<p>部署图描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。一个系统模型只有一个部署图，部署图通常用来帮助理解分布式系统。</p>\n</blockquote>\n<h4 id=\"部署图元素（Deployment-Diagram-Elements）-1\"><a href=\"#部署图元素（Deployment-Diagram-Elements）-1\" class=\"headerlink\" title=\"部署图元素（Deployment Diagram Elements）\"></a>部署图元素（Deployment Diagram Elements）</h4><ol>\n<li><p>结点（Node）</p>\n<blockquote>\n<p> 结点是存在与运行时的代表计算机资源的物理元素，可以是硬件也可以是运行其上的软件系统，比如64主机、Windows server 2008操作系统、防火墙等。结点用三维盒装表示，如下图：<br><br><img src=\"image/Deployment/%E7%BB%93%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>结点实例（Node Instance）</p>\n<blockquote>\n<p>结点实例名称格式{Node Instance : node}</p>\n</blockquote>\n<p>与结点的区别在于名称有下划线和结点类型前面有冒号，冒号前面可以有示例名称也可以没有示例名称，如下图<br><br><img src=\"image/Deployment/%E7%BB%93%E7%82%B9%E5%AE%9E%E4%BE%8B.png\" alt></p>\n</li>\n<li><p>节点类型（Node Stereotypes）</p>\n<blockquote>\n<p>结点类型有：«cdrom», «cd-rom», «computer», «disk array», «pc», «pc client», «pc server», «secure», «server», «storage», «unix server», «user pc»，并在结点的右上角用不同的图标表示，如下图</p>\n</blockquote>\n</li>\n<li><p>物件（Artifact）</p>\n<blockquote>\n<p> 物件是软件开发过程中的产物，包括过程模型（比如用例图、设计图等等）、源代码、可执行程序、设计文档、测试报告、需求原型、用户手册等等。物件表示如下，带有关键字«artifact»和文档图标</p>\n</blockquote>\n</li>\n<li><p>连接（Association）</p>\n<blockquote>\n<p>结点之间的连线表示系统之间进行交互的通信路径，这个通信路径称为连接（Association），如下图所示，连接中有网络协议。</p>\n</blockquote>\n</li>\n<li><p>结点容器（Node as Container）</p>\n<blockquote>\n<p>一个结点可以包括其他的结点，比如组件或者物件，则称此结点为结点容器（Node as Container）。如下图所示，结点（Node）包容了物件（Artifact）。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.cnblogs.com/ywqu/archive/2009/12/21/1628545.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/ywqu/archive/2009/12/21/1628545.html</a></p>\n"},{"title":"UML-活动图","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2018-05-21T12:14:00.000Z","_content":"### 活动图（Activity Diagram）\n#### 简介\n>活动图是UML用于对系统的动态行为建模的另一种常用工具，它描述活动的顺序，展现从一个活动到另一个活动的控制流。活动图在本质上是一种流程图。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。\n\n#### 活动图的组成元素 Activity Diagram Element\n1. 活动状态图（Activity）\n>活动状态用于表达状态机中的非原子的运行，其特点如下\n\n  1. 活动状态可以分解成其他子活动或者动作状态。\n  2. 活动状态的内部活动可以用另一个活动图来表示。\n  3. 和动作状态不同，活动状态可以有入口动作和出口动作，也可以有内部转移。\n  4. 动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态。\nUML中活动状态和动作状态的图标相同，但是活动状态可以在图标中给出入口动作和出口动作等信息。\n\n2. 动作状态（Actions）\n>动作状态是指原子的，不可中断的动作，并在此动作完成后通过完成转换转向另一个状态。动作状态有如下\n\n  1. 动作状态是原子的，它是构造活动图的最小单位。\n  2. 动作状态是不可中断的。\n  3. 动作状态是瞬时的行为。\n  4. 动作状态可以有入转换，入转换既可以是动作流，也可以是对象流。动作状态至少有一条出转换，这条转换以内部的完成为起点，与外部事件无关。\n  5. 动作状态与状态图中的状态不同，它不能有入口动作和出口动作，更不能有内部转移。\n  6. 在一张活动图中，动作状态允许多处出现。\n\n3. 动作状态约束（Action Constraints）\n> 用来约束动作状态。如下图展示了动作状态的前置条件和后置条件<br>\n![](image/activity/动作状态约束.png)\n\n4. 动作流（Control Flow）\n>动作之间的转换称之为动作流，活动图的转换用带箭头的直线表示，箭头的方向指向转入的方向。<br>![](image/activity/动作流.png)\n\n5. 开始节点（Initial Node）\n>开始节点：表示成实心黑色圆点<br>\n![](image/activity/开始节点.png)\n\n6. 终止节点（Final Node）\n>分为活动终止节点（activity final nodes）和流程终止节点（flow final nodes）。\n\n  - 活动终止节点表示整个活动的结束<br>\n![](image/activity/活动终止.png)\n  - 而流程终止节点表示是子流程的结束。<br>\n![](image/activity/流程终止.png)\n7. 对象（Objects）\n8. 数据存储对象（DataStore）\n>使用关键字«datastore»<br>\n![](image/activity/数据存储.png)\n\n9. 对象流（Object Flows）\n>对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响。用活动图描述某个对象时，可以把涉及到的对象放置在活动图中并用一个依赖将其连接到进行创建、修改和撤销的动作状态或者活动状态上，对象的这种使用方法就构成了对象流。\n\n  对象流中的对象有以下特点：\n    1. 一个对象可以由多个动作操作。\n    2. 一个动作输出的对象可以作为另一个动作输入的对象。\n    3. 在活动图中，同一个对象可以多次出现，它的每一次出现表面该对象正处于对象生存期的不同时间点。\n\n  对象流用带有箭头的虚线表示。如果箭头是从动作状态出发指向对象，则表示动作对对象施加了一定的影响。施加的影响包括创建、修改和撤销等。如果箭头从对象指向动作状态，则表示该动作使用对象流所指向的对象。\n  状态图中的对象用矩形表示，矩形内是该对象的名称，名称下的方括号表明对象此时的状态。<br>\n\n  ![](image/activity/对象流.png)\n\n10. 分支与合并（Decision and Merge Nodes）\n>分支与合并用菱形表示<br>\n![](image/activity/分支和合并.png)\n\n11. 分叉与汇合（Fork and Join Nodes）\n>分为水平风向和垂直方向。<br>\n![](image/activity/分叉和汇合.png)\n\n  对象在运行时可能会存在两个或多个并发运行的控制流，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。分叉用于将动作流分为两个或多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。\n\n12. 异常处理（Exception Handler）\n>当受保护的活动发生异常时，触发异常处理节点。<br>\n![](image/activity/异常处理.png)\n\n13. 活动中断区域（Interruptible Activity Region）\n>活动中断区域围绕一些可被中断的动作状态图。比如下图，正常情况下【Process Order】顺序流转到【Close Order】，订单处理流程完毕；但在【Process Order】过称中，会发送【Cancel Order】请求，这时会流转到【Cancel Order】，从而订单处理流程结束<br>\n![](image/activity/活动中断区域.png)\n\n14. 泳道（Partition）\n>泳道将活动图中的活动划分为若干组，并把每一组指定给负责这组活动的业务组织，即对象。在活动图中，泳道区分了负责活动的对象，它明确地表示了哪些活动是由哪些对象进行的。在包含泳道的活动图中，每个活动只能明确地属于一个泳道。\n\n  泳道是用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道的上方可以给出泳道的名字或对象的名字，该对象负责泳道内的全部活动。泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。<br>\n  ![](image/activity/泳道.png)\n\n#### 示例【订单系统】\n![](image/activity/活动图样例.jpg)\n1.  泳道分为：会员泳道和系统泳道。会员选择商品并加入购物车，系统完成订单生成及其支付完毕。\n2.  开始节点：会员添加商品到购物车，点击【订单确认】，开始交于系统处理订单流程\n3.  结束节点：商品发送完毕和付款成功，订单处理流程结束\n4.  活动状态：产生订单、Check Credit Cart核对信用卡、Check Stock 核对库存量、Deliver Goods 发送商品、Process Credit Cart付款\n5.  分叉与汇合：【产生订单】份叉为检查库存量和会员支付金额是否足够，如果不足，取消订单，如过库存量和支付金额足够，发送商品和付款，最后汇合为订单完成。\n\n#### 参考日志\n[http://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html](http://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html)\n","source":"_posts/uml/04 活动图(Activity Diagram).md","raw":"---\ntitle: UML-活动图\nauthor: JsonYe\ntags:\n- uml\n- 活动图\ncategories:\n- UML\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-05-21 20:14:00   \n---\n### 活动图（Activity Diagram）\n#### 简介\n>活动图是UML用于对系统的动态行为建模的另一种常用工具，它描述活动的顺序，展现从一个活动到另一个活动的控制流。活动图在本质上是一种流程图。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。\n\n#### 活动图的组成元素 Activity Diagram Element\n1. 活动状态图（Activity）\n>活动状态用于表达状态机中的非原子的运行，其特点如下\n\n  1. 活动状态可以分解成其他子活动或者动作状态。\n  2. 活动状态的内部活动可以用另一个活动图来表示。\n  3. 和动作状态不同，活动状态可以有入口动作和出口动作，也可以有内部转移。\n  4. 动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态。\nUML中活动状态和动作状态的图标相同，但是活动状态可以在图标中给出入口动作和出口动作等信息。\n\n2. 动作状态（Actions）\n>动作状态是指原子的，不可中断的动作，并在此动作完成后通过完成转换转向另一个状态。动作状态有如下\n\n  1. 动作状态是原子的，它是构造活动图的最小单位。\n  2. 动作状态是不可中断的。\n  3. 动作状态是瞬时的行为。\n  4. 动作状态可以有入转换，入转换既可以是动作流，也可以是对象流。动作状态至少有一条出转换，这条转换以内部的完成为起点，与外部事件无关。\n  5. 动作状态与状态图中的状态不同，它不能有入口动作和出口动作，更不能有内部转移。\n  6. 在一张活动图中，动作状态允许多处出现。\n\n3. 动作状态约束（Action Constraints）\n> 用来约束动作状态。如下图展示了动作状态的前置条件和后置条件<br>\n![](image/activity/动作状态约束.png)\n\n4. 动作流（Control Flow）\n>动作之间的转换称之为动作流，活动图的转换用带箭头的直线表示，箭头的方向指向转入的方向。<br>![](image/activity/动作流.png)\n\n5. 开始节点（Initial Node）\n>开始节点：表示成实心黑色圆点<br>\n![](image/activity/开始节点.png)\n\n6. 终止节点（Final Node）\n>分为活动终止节点（activity final nodes）和流程终止节点（flow final nodes）。\n\n  - 活动终止节点表示整个活动的结束<br>\n![](image/activity/活动终止.png)\n  - 而流程终止节点表示是子流程的结束。<br>\n![](image/activity/流程终止.png)\n7. 对象（Objects）\n8. 数据存储对象（DataStore）\n>使用关键字«datastore»<br>\n![](image/activity/数据存储.png)\n\n9. 对象流（Object Flows）\n>对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响。用活动图描述某个对象时，可以把涉及到的对象放置在活动图中并用一个依赖将其连接到进行创建、修改和撤销的动作状态或者活动状态上，对象的这种使用方法就构成了对象流。\n\n  对象流中的对象有以下特点：\n    1. 一个对象可以由多个动作操作。\n    2. 一个动作输出的对象可以作为另一个动作输入的对象。\n    3. 在活动图中，同一个对象可以多次出现，它的每一次出现表面该对象正处于对象生存期的不同时间点。\n\n  对象流用带有箭头的虚线表示。如果箭头是从动作状态出发指向对象，则表示动作对对象施加了一定的影响。施加的影响包括创建、修改和撤销等。如果箭头从对象指向动作状态，则表示该动作使用对象流所指向的对象。\n  状态图中的对象用矩形表示，矩形内是该对象的名称，名称下的方括号表明对象此时的状态。<br>\n\n  ![](image/activity/对象流.png)\n\n10. 分支与合并（Decision and Merge Nodes）\n>分支与合并用菱形表示<br>\n![](image/activity/分支和合并.png)\n\n11. 分叉与汇合（Fork and Join Nodes）\n>分为水平风向和垂直方向。<br>\n![](image/activity/分叉和汇合.png)\n\n  对象在运行时可能会存在两个或多个并发运行的控制流，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。分叉用于将动作流分为两个或多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。\n\n12. 异常处理（Exception Handler）\n>当受保护的活动发生异常时，触发异常处理节点。<br>\n![](image/activity/异常处理.png)\n\n13. 活动中断区域（Interruptible Activity Region）\n>活动中断区域围绕一些可被中断的动作状态图。比如下图，正常情况下【Process Order】顺序流转到【Close Order】，订单处理流程完毕；但在【Process Order】过称中，会发送【Cancel Order】请求，这时会流转到【Cancel Order】，从而订单处理流程结束<br>\n![](image/activity/活动中断区域.png)\n\n14. 泳道（Partition）\n>泳道将活动图中的活动划分为若干组，并把每一组指定给负责这组活动的业务组织，即对象。在活动图中，泳道区分了负责活动的对象，它明确地表示了哪些活动是由哪些对象进行的。在包含泳道的活动图中，每个活动只能明确地属于一个泳道。\n\n  泳道是用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道的上方可以给出泳道的名字或对象的名字，该对象负责泳道内的全部活动。泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。<br>\n  ![](image/activity/泳道.png)\n\n#### 示例【订单系统】\n![](image/activity/活动图样例.jpg)\n1.  泳道分为：会员泳道和系统泳道。会员选择商品并加入购物车，系统完成订单生成及其支付完毕。\n2.  开始节点：会员添加商品到购物车，点击【订单确认】，开始交于系统处理订单流程\n3.  结束节点：商品发送完毕和付款成功，订单处理流程结束\n4.  活动状态：产生订单、Check Credit Cart核对信用卡、Check Stock 核对库存量、Deliver Goods 发送商品、Process Credit Cart付款\n5.  分叉与汇合：【产生订单】份叉为检查库存量和会员支付金额是否足够，如果不足，取消订单，如过库存量和支付金额足够，发送商品和付款，最后汇合为订单完成。\n\n#### 参考日志\n[http://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html](http://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html)\n","slug":"uml/04 活动图(Activity Diagram)","published":1,"updated":"2019-10-02T13:48:41.137Z","layout":"post","photos":[],"link":"","_id":"ck19bvazm002100wkw7ayedcs","content":"<h3 id=\"活动图（Activity-Diagram）\"><a href=\"#活动图（Activity-Diagram）\" class=\"headerlink\" title=\"活动图（Activity Diagram）\"></a>活动图（Activity Diagram）</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>活动图是UML用于对系统的动态行为建模的另一种常用工具，它描述活动的顺序，展现从一个活动到另一个活动的控制流。活动图在本质上是一种流程图。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。</p>\n</blockquote>\n<h4 id=\"活动图的组成元素-Activity-Diagram-Element\"><a href=\"#活动图的组成元素-Activity-Diagram-Element\" class=\"headerlink\" title=\"活动图的组成元素 Activity Diagram Element\"></a>活动图的组成元素 Activity Diagram Element</h4><ol>\n<li><p>活动状态图（Activity）</p>\n<blockquote>\n<p>活动状态用于表达状态机中的非原子的运行，其特点如下</p>\n</blockquote>\n<ol>\n<li>活动状态可以分解成其他子活动或者动作状态。</li>\n<li>活动状态的内部活动可以用另一个活动图来表示。</li>\n<li>和动作状态不同，活动状态可以有入口动作和出口动作，也可以有内部转移。</li>\n<li>动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态。<br>UML中活动状态和动作状态的图标相同，但是活动状态可以在图标中给出入口动作和出口动作等信息。</li>\n</ol>\n</li>\n<li><p>动作状态（Actions）</p>\n<blockquote>\n<p>动作状态是指原子的，不可中断的动作，并在此动作完成后通过完成转换转向另一个状态。动作状态有如下</p>\n</blockquote>\n<ol>\n<li>动作状态是原子的，它是构造活动图的最小单位。</li>\n<li>动作状态是不可中断的。</li>\n<li>动作状态是瞬时的行为。</li>\n<li>动作状态可以有入转换，入转换既可以是动作流，也可以是对象流。动作状态至少有一条出转换，这条转换以内部的完成为起点，与外部事件无关。</li>\n<li>动作状态与状态图中的状态不同，它不能有入口动作和出口动作，更不能有内部转移。</li>\n<li>在一张活动图中，动作状态允许多处出现。</li>\n</ol>\n</li>\n<li><p>动作状态约束（Action Constraints）</p>\n<blockquote>\n<p>用来约束动作状态。如下图展示了动作状态的前置条件和后置条件<br><br><img src=\"image/activity/%E5%8A%A8%E4%BD%9C%E7%8A%B6%E6%80%81%E7%BA%A6%E6%9D%9F.png\" alt></p>\n</blockquote>\n</li>\n<li><p>动作流（Control Flow）</p>\n<blockquote>\n<p>动作之间的转换称之为动作流，活动图的转换用带箭头的直线表示，箭头的方向指向转入的方向。<br><img src=\"image/activity/%E5%8A%A8%E4%BD%9C%E6%B5%81.png\" alt></p>\n</blockquote>\n</li>\n<li><p>开始节点（Initial Node）</p>\n<blockquote>\n<p>开始节点：表示成实心黑色圆点<br><br><img src=\"image/activity/%E5%BC%80%E5%A7%8B%E8%8A%82%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>终止节点（Final Node）</p>\n<blockquote>\n<p>分为活动终止节点（activity final nodes）和流程终止节点（flow final nodes）。</p>\n</blockquote>\n<ul>\n<li>活动终止节点表示整个活动的结束<br><br><img src=\"image/activity/%E6%B4%BB%E5%8A%A8%E7%BB%88%E6%AD%A2.png\" alt></li>\n<li>而流程终止节点表示是子流程的结束。<br><br><img src=\"image/activity/%E6%B5%81%E7%A8%8B%E7%BB%88%E6%AD%A2.png\" alt></li>\n</ul>\n</li>\n<li><p>对象（Objects）</p>\n</li>\n<li><p>数据存储对象（DataStore）</p>\n<blockquote>\n<p>使用关键字«datastore»<br><br><img src=\"image/activity/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.png\" alt></p>\n</blockquote>\n</li>\n<li><p>对象流（Object Flows）</p>\n<blockquote>\n<p>对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响。用活动图描述某个对象时，可以把涉及到的对象放置在活动图中并用一个依赖将其连接到进行创建、修改和撤销的动作状态或者活动状态上，对象的这种使用方法就构成了对象流。</p>\n</blockquote>\n<p>对象流中的对象有以下特点：</p>\n<ol>\n<li>一个对象可以由多个动作操作。</li>\n<li>一个动作输出的对象可以作为另一个动作输入的对象。</li>\n<li>在活动图中，同一个对象可以多次出现，它的每一次出现表面该对象正处于对象生存期的不同时间点。</li>\n</ol>\n<p>对象流用带有箭头的虚线表示。如果箭头是从动作状态出发指向对象，则表示动作对对象施加了一定的影响。施加的影响包括创建、修改和撤销等。如果箭头从对象指向动作状态，则表示该动作使用对象流所指向的对象。<br>状态图中的对象用矩形表示，矩形内是该对象的名称，名称下的方括号表明对象此时的状态。<br></p>\n<p><img src=\"image/activity/%E5%AF%B9%E8%B1%A1%E6%B5%81.png\" alt></p>\n</li>\n<li><p>分支与合并（Decision and Merge Nodes）</p>\n<blockquote>\n<p>分支与合并用菱形表示<br><br><img src=\"image/activity/%E5%88%86%E6%94%AF%E5%92%8C%E5%90%88%E5%B9%B6.png\" alt></p>\n</blockquote>\n</li>\n<li><p>分叉与汇合（Fork and Join Nodes）</p>\n<blockquote>\n<p>分为水平风向和垂直方向。<br><br><img src=\"image/activity/%E5%88%86%E5%8F%89%E5%92%8C%E6%B1%87%E5%90%88.png\" alt></p>\n</blockquote>\n<p>对象在运行时可能会存在两个或多个并发运行的控制流，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。分叉用于将动作流分为两个或多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。</p>\n</li>\n<li><p>异常处理（Exception Handler）</p>\n<blockquote>\n<p>当受保护的活动发生异常时，触发异常处理节点。<br><br><img src=\"image/activity/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.png\" alt></p>\n</blockquote>\n</li>\n<li><p>活动中断区域（Interruptible Activity Region）</p>\n<blockquote>\n<p>活动中断区域围绕一些可被中断的动作状态图。比如下图，正常情况下【Process Order】顺序流转到【Close Order】，订单处理流程完毕；但在【Process Order】过称中，会发送【Cancel Order】请求，这时会流转到【Cancel Order】，从而订单处理流程结束<br><br><img src=\"image/activity/%E6%B4%BB%E5%8A%A8%E4%B8%AD%E6%96%AD%E5%8C%BA%E5%9F%9F.png\" alt></p>\n</blockquote>\n</li>\n<li><p>泳道（Partition）</p>\n<blockquote>\n<p>泳道将活动图中的活动划分为若干组，并把每一组指定给负责这组活动的业务组织，即对象。在活动图中，泳道区分了负责活动的对象，它明确地表示了哪些活动是由哪些对象进行的。在包含泳道的活动图中，每个活动只能明确地属于一个泳道。</p>\n</blockquote>\n<p>泳道是用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道的上方可以给出泳道的名字或对象的名字，该对象负责泳道内的全部活动。泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。<br><br><img src=\"image/activity/%E6%B3%B3%E9%81%93.png\" alt></p>\n</li>\n</ol>\n<h4 id=\"示例【订单系统】\"><a href=\"#示例【订单系统】\" class=\"headerlink\" title=\"示例【订单系统】\"></a>示例【订单系统】</h4><p><img src=\"image/activity/%E6%B4%BB%E5%8A%A8%E5%9B%BE%E6%A0%B7%E4%BE%8B.jpg\" alt></p>\n<ol>\n<li>泳道分为：会员泳道和系统泳道。会员选择商品并加入购物车，系统完成订单生成及其支付完毕。</li>\n<li>开始节点：会员添加商品到购物车，点击【订单确认】，开始交于系统处理订单流程</li>\n<li>结束节点：商品发送完毕和付款成功，订单处理流程结束</li>\n<li>活动状态：产生订单、Check Credit Cart核对信用卡、Check Stock 核对库存量、Deliver Goods 发送商品、Process Credit Cart付款</li>\n<li>分叉与汇合：【产生订单】份叉为检查库存量和会员支付金额是否足够，如果不足，取消订单，如过库存量和支付金额足够，发送商品和付款，最后汇合为订单完成。</li>\n</ol>\n<h4 id=\"参考日志\"><a href=\"#参考日志\" class=\"headerlink\" title=\"参考日志\"></a>参考日志</h4><p><a href=\"http://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"活动图（Activity-Diagram）\"><a href=\"#活动图（Activity-Diagram）\" class=\"headerlink\" title=\"活动图（Activity Diagram）\"></a>活动图（Activity Diagram）</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>活动图是UML用于对系统的动态行为建模的另一种常用工具，它描述活动的顺序，展现从一个活动到另一个活动的控制流。活动图在本质上是一种流程图。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。</p>\n</blockquote>\n<h4 id=\"活动图的组成元素-Activity-Diagram-Element\"><a href=\"#活动图的组成元素-Activity-Diagram-Element\" class=\"headerlink\" title=\"活动图的组成元素 Activity Diagram Element\"></a>活动图的组成元素 Activity Diagram Element</h4><ol>\n<li><p>活动状态图（Activity）</p>\n<blockquote>\n<p>活动状态用于表达状态机中的非原子的运行，其特点如下</p>\n</blockquote>\n<ol>\n<li>活动状态可以分解成其他子活动或者动作状态。</li>\n<li>活动状态的内部活动可以用另一个活动图来表示。</li>\n<li>和动作状态不同，活动状态可以有入口动作和出口动作，也可以有内部转移。</li>\n<li>动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态。<br>UML中活动状态和动作状态的图标相同，但是活动状态可以在图标中给出入口动作和出口动作等信息。</li>\n</ol>\n</li>\n<li><p>动作状态（Actions）</p>\n<blockquote>\n<p>动作状态是指原子的，不可中断的动作，并在此动作完成后通过完成转换转向另一个状态。动作状态有如下</p>\n</blockquote>\n<ol>\n<li>动作状态是原子的，它是构造活动图的最小单位。</li>\n<li>动作状态是不可中断的。</li>\n<li>动作状态是瞬时的行为。</li>\n<li>动作状态可以有入转换，入转换既可以是动作流，也可以是对象流。动作状态至少有一条出转换，这条转换以内部的完成为起点，与外部事件无关。</li>\n<li>动作状态与状态图中的状态不同，它不能有入口动作和出口动作，更不能有内部转移。</li>\n<li>在一张活动图中，动作状态允许多处出现。</li>\n</ol>\n</li>\n<li><p>动作状态约束（Action Constraints）</p>\n<blockquote>\n<p>用来约束动作状态。如下图展示了动作状态的前置条件和后置条件<br><br><img src=\"image/activity/%E5%8A%A8%E4%BD%9C%E7%8A%B6%E6%80%81%E7%BA%A6%E6%9D%9F.png\" alt></p>\n</blockquote>\n</li>\n<li><p>动作流（Control Flow）</p>\n<blockquote>\n<p>动作之间的转换称之为动作流，活动图的转换用带箭头的直线表示，箭头的方向指向转入的方向。<br><img src=\"image/activity/%E5%8A%A8%E4%BD%9C%E6%B5%81.png\" alt></p>\n</blockquote>\n</li>\n<li><p>开始节点（Initial Node）</p>\n<blockquote>\n<p>开始节点：表示成实心黑色圆点<br><br><img src=\"image/activity/%E5%BC%80%E5%A7%8B%E8%8A%82%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>终止节点（Final Node）</p>\n<blockquote>\n<p>分为活动终止节点（activity final nodes）和流程终止节点（flow final nodes）。</p>\n</blockquote>\n<ul>\n<li>活动终止节点表示整个活动的结束<br><br><img src=\"image/activity/%E6%B4%BB%E5%8A%A8%E7%BB%88%E6%AD%A2.png\" alt></li>\n<li>而流程终止节点表示是子流程的结束。<br><br><img src=\"image/activity/%E6%B5%81%E7%A8%8B%E7%BB%88%E6%AD%A2.png\" alt></li>\n</ul>\n</li>\n<li><p>对象（Objects）</p>\n</li>\n<li><p>数据存储对象（DataStore）</p>\n<blockquote>\n<p>使用关键字«datastore»<br><br><img src=\"image/activity/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.png\" alt></p>\n</blockquote>\n</li>\n<li><p>对象流（Object Flows）</p>\n<blockquote>\n<p>对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或动作对对象的影响。用活动图描述某个对象时，可以把涉及到的对象放置在活动图中并用一个依赖将其连接到进行创建、修改和撤销的动作状态或者活动状态上，对象的这种使用方法就构成了对象流。</p>\n</blockquote>\n<p>对象流中的对象有以下特点：</p>\n<ol>\n<li>一个对象可以由多个动作操作。</li>\n<li>一个动作输出的对象可以作为另一个动作输入的对象。</li>\n<li>在活动图中，同一个对象可以多次出现，它的每一次出现表面该对象正处于对象生存期的不同时间点。</li>\n</ol>\n<p>对象流用带有箭头的虚线表示。如果箭头是从动作状态出发指向对象，则表示动作对对象施加了一定的影响。施加的影响包括创建、修改和撤销等。如果箭头从对象指向动作状态，则表示该动作使用对象流所指向的对象。<br>状态图中的对象用矩形表示，矩形内是该对象的名称，名称下的方括号表明对象此时的状态。<br></p>\n<p><img src=\"image/activity/%E5%AF%B9%E8%B1%A1%E6%B5%81.png\" alt></p>\n</li>\n<li><p>分支与合并（Decision and Merge Nodes）</p>\n<blockquote>\n<p>分支与合并用菱形表示<br><br><img src=\"image/activity/%E5%88%86%E6%94%AF%E5%92%8C%E5%90%88%E5%B9%B6.png\" alt></p>\n</blockquote>\n</li>\n<li><p>分叉与汇合（Fork and Join Nodes）</p>\n<blockquote>\n<p>分为水平风向和垂直方向。<br><br><img src=\"image/activity/%E5%88%86%E5%8F%89%E5%92%8C%E6%B1%87%E5%90%88.png\" alt></p>\n</blockquote>\n<p>对象在运行时可能会存在两个或多个并发运行的控制流，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。分叉用于将动作流分为两个或多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。</p>\n</li>\n<li><p>异常处理（Exception Handler）</p>\n<blockquote>\n<p>当受保护的活动发生异常时，触发异常处理节点。<br><br><img src=\"image/activity/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.png\" alt></p>\n</blockquote>\n</li>\n<li><p>活动中断区域（Interruptible Activity Region）</p>\n<blockquote>\n<p>活动中断区域围绕一些可被中断的动作状态图。比如下图，正常情况下【Process Order】顺序流转到【Close Order】，订单处理流程完毕；但在【Process Order】过称中，会发送【Cancel Order】请求，这时会流转到【Cancel Order】，从而订单处理流程结束<br><br><img src=\"image/activity/%E6%B4%BB%E5%8A%A8%E4%B8%AD%E6%96%AD%E5%8C%BA%E5%9F%9F.png\" alt></p>\n</blockquote>\n</li>\n<li><p>泳道（Partition）</p>\n<blockquote>\n<p>泳道将活动图中的活动划分为若干组，并把每一组指定给负责这组活动的业务组织，即对象。在活动图中，泳道区分了负责活动的对象，它明确地表示了哪些活动是由哪些对象进行的。在包含泳道的活动图中，每个活动只能明确地属于一个泳道。</p>\n</blockquote>\n<p>泳道是用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道的上方可以给出泳道的名字或对象的名字，该对象负责泳道内的全部活动。泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。<br><br><img src=\"image/activity/%E6%B3%B3%E9%81%93.png\" alt></p>\n</li>\n</ol>\n<h4 id=\"示例【订单系统】\"><a href=\"#示例【订单系统】\" class=\"headerlink\" title=\"示例【订单系统】\"></a>示例【订单系统】</h4><p><img src=\"image/activity/%E6%B4%BB%E5%8A%A8%E5%9B%BE%E6%A0%B7%E4%BE%8B.jpg\" alt></p>\n<ol>\n<li>泳道分为：会员泳道和系统泳道。会员选择商品并加入购物车，系统完成订单生成及其支付完毕。</li>\n<li>开始节点：会员添加商品到购物车，点击【订单确认】，开始交于系统处理订单流程</li>\n<li>结束节点：商品发送完毕和付款成功，订单处理流程结束</li>\n<li>活动状态：产生订单、Check Credit Cart核对信用卡、Check Stock 核对库存量、Deliver Goods 发送商品、Process Credit Cart付款</li>\n<li>分叉与汇合：【产生订单】份叉为检查库存量和会员支付金额是否足够，如果不足，取消订单，如过库存量和支付金额足够，发送商品和付款，最后汇合为订单完成。</li>\n</ol>\n<h4 id=\"参考日志\"><a href=\"#参考日志\" class=\"headerlink\" title=\"参考日志\"></a>参考日志</h4><p><a href=\"http://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html</a></p>\n"},{"title":"UML-时序图","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2018-05-24T13:24:00.000Z","_content":"### 时序图（Sequence Diagram）\n#### 简介\n>时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。时序图中包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。\n\n#### 时序图元素（Sequence Diagram Elements）\n- 角色（Actor）\n>系统角色，可以是人、及其甚至其他的系统或者子系统。\n\n- 对象（Object）\n>对象包括三种命名方式：\n  - 第一种方式包括对象名和类名；\n  - 第二中方式只显示类名不显示对象名，即表示他是一个匿名对象；\n  - 第三种方式只显示对象名不显示类明。\n\n- 生命线（Lifeline）\n>生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间，如下图<br>\n![](image/Sequence/生命线.png)\n\n-  控制焦点（Focus of Control）\n>控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示，如下图。<br>\n![](image/Sequence/控制焦点.png)\n\n-  消息（Message）\n>消息一般分为\n  - 同步消息（Synchronous Message）<br>\n  消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。\n  - 异步消息（Asynchronous Message）<br>\n  消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。\n  - 返回消息（Return Message）<br>\n  返回消息表示从过程调用返回<br>\n![](image/Sequence/消息.png)\n\n- 自关联消息（Self-Message）\n>示方法的自身调用以及一个对象内的一个方法调用另外一个方法。<br>\n![](image/Sequence/自关联消息.png)\n\n#### 时序图的作用\n1. 确认和丰富一个使用语境的逻辑表达。\n2. 细化用例，将用例表达的需求进一步精细表达。\n3. 有效地描述个各类的职责一级各类具有相应的原因。\n\n### 协作图\n>在一定的语境中一组对象一级实现某些行为的对象间的相互作用。协作图就是表现对象协作关系的图。\n\n#### 作用\n1. 确认和丰富一个使用语境的逻辑表达。\n2. 显示对象机器交互关系的空间组织结构\n3. 表现一个类操作的实现\n\n#### 协作图的组成\n由对象、消息和；链等构成。对象和消息的概念与时序图中的概念相同。主要的特点是链。\n- 链：两个或多个对象之间的独立连接，是对象引用元组，是关联的实例。\n- 链的表示形式：一个或多个相连的线或弧。\n\n### 时序图和协作图的对比\n> 时序图和序列图表示的信息一样，只是方法不同，可通过适当的方式进行转化。\n\n  不同点：\n  - 协作图明确了角色的关系，通过协作图角色来限定协作中的对象或链。\n  - 协作图不将时间作为单独的维来表示，必须使用顺序号来判断信息的顺序以及并行线程。\n  - 序列图和协作图都表示对象间的交互作用，序列图侧重时间顺序，协作图侧重对象间的关系，时间顺序可以从对象流经的顺序编号中获得。\n  - 序列图被用于表示方案，而协作图被用于过程的详细设计。\n","source":"_posts/uml/07 时序图(Sequence Diagram).md","raw":"---\ntitle: UML-时序图\nauthor: JsonYe\ntags:\n- uml\n- 时序图\ncategories:\n- UML\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-05-24 21:24:00   \n---\n### 时序图（Sequence Diagram）\n#### 简介\n>时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。时序图中包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。\n\n#### 时序图元素（Sequence Diagram Elements）\n- 角色（Actor）\n>系统角色，可以是人、及其甚至其他的系统或者子系统。\n\n- 对象（Object）\n>对象包括三种命名方式：\n  - 第一种方式包括对象名和类名；\n  - 第二中方式只显示类名不显示对象名，即表示他是一个匿名对象；\n  - 第三种方式只显示对象名不显示类明。\n\n- 生命线（Lifeline）\n>生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间，如下图<br>\n![](image/Sequence/生命线.png)\n\n-  控制焦点（Focus of Control）\n>控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示，如下图。<br>\n![](image/Sequence/控制焦点.png)\n\n-  消息（Message）\n>消息一般分为\n  - 同步消息（Synchronous Message）<br>\n  消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。\n  - 异步消息（Asynchronous Message）<br>\n  消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。\n  - 返回消息（Return Message）<br>\n  返回消息表示从过程调用返回<br>\n![](image/Sequence/消息.png)\n\n- 自关联消息（Self-Message）\n>示方法的自身调用以及一个对象内的一个方法调用另外一个方法。<br>\n![](image/Sequence/自关联消息.png)\n\n#### 时序图的作用\n1. 确认和丰富一个使用语境的逻辑表达。\n2. 细化用例，将用例表达的需求进一步精细表达。\n3. 有效地描述个各类的职责一级各类具有相应的原因。\n\n### 协作图\n>在一定的语境中一组对象一级实现某些行为的对象间的相互作用。协作图就是表现对象协作关系的图。\n\n#### 作用\n1. 确认和丰富一个使用语境的逻辑表达。\n2. 显示对象机器交互关系的空间组织结构\n3. 表现一个类操作的实现\n\n#### 协作图的组成\n由对象、消息和；链等构成。对象和消息的概念与时序图中的概念相同。主要的特点是链。\n- 链：两个或多个对象之间的独立连接，是对象引用元组，是关联的实例。\n- 链的表示形式：一个或多个相连的线或弧。\n\n### 时序图和协作图的对比\n> 时序图和序列图表示的信息一样，只是方法不同，可通过适当的方式进行转化。\n\n  不同点：\n  - 协作图明确了角色的关系，通过协作图角色来限定协作中的对象或链。\n  - 协作图不将时间作为单独的维来表示，必须使用顺序号来判断信息的顺序以及并行线程。\n  - 序列图和协作图都表示对象间的交互作用，序列图侧重时间顺序，协作图侧重对象间的关系，时间顺序可以从对象流经的顺序编号中获得。\n  - 序列图被用于表示方案，而协作图被用于过程的详细设计。\n","slug":"uml/07 时序图(Sequence Diagram)","published":1,"updated":"2019-10-02T13:49:06.828Z","layout":"post","photos":[],"link":"","_id":"ck19bvazs002500wke0dpexgi","content":"<h3 id=\"时序图（Sequence-Diagram）\"><a href=\"#时序图（Sequence-Diagram）\" class=\"headerlink\" title=\"时序图（Sequence Diagram）\"></a>时序图（Sequence Diagram）</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。时序图中包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。</p>\n</blockquote>\n<h4 id=\"时序图元素（Sequence-Diagram-Elements）\"><a href=\"#时序图元素（Sequence-Diagram-Elements）\" class=\"headerlink\" title=\"时序图元素（Sequence Diagram Elements）\"></a>时序图元素（Sequence Diagram Elements）</h4><ul>\n<li><p>角色（Actor）</p>\n<blockquote>\n<p>系统角色，可以是人、及其甚至其他的系统或者子系统。</p>\n</blockquote>\n</li>\n<li><p>对象（Object）</p>\n<blockquote>\n<p>对象包括三种命名方式：</p>\n<ul>\n<li>第一种方式包括对象名和类名；</li>\n<li>第二中方式只显示类名不显示对象名，即表示他是一个匿名对象；</li>\n<li>第三种方式只显示对象名不显示类明。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>生命线（Lifeline）</p>\n<blockquote>\n<p>生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间，如下图<br><br><img src=\"image/Sequence/%E7%94%9F%E5%91%BD%E7%BA%BF.png\" alt></p>\n</blockquote>\n</li>\n<li><p>控制焦点（Focus of Control）</p>\n<blockquote>\n<p>控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示，如下图。<br><br><img src=\"image/Sequence/%E6%8E%A7%E5%88%B6%E7%84%A6%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>消息（Message）</p>\n<blockquote>\n<p>消息一般分为</p>\n<ul>\n<li>同步消息（Synchronous Message）<br><br>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。</li>\n<li>异步消息（Asynchronous Message）<br><br>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。</li>\n<li>返回消息（Return Message）<br><br>返回消息表示从过程调用返回<br><br><img src=\"image/Sequence/%E6%B6%88%E6%81%AF.png\" alt></li>\n</ul>\n</blockquote>\n</li>\n<li><p>自关联消息（Self-Message）</p>\n<blockquote>\n<p>示方法的自身调用以及一个对象内的一个方法调用另外一个方法。<br><br><img src=\"image/Sequence/%E8%87%AA%E5%85%B3%E8%81%94%E6%B6%88%E6%81%AF.png\" alt></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"时序图的作用\"><a href=\"#时序图的作用\" class=\"headerlink\" title=\"时序图的作用\"></a>时序图的作用</h4><ol>\n<li>确认和丰富一个使用语境的逻辑表达。</li>\n<li>细化用例，将用例表达的需求进一步精细表达。</li>\n<li>有效地描述个各类的职责一级各类具有相应的原因。</li>\n</ol>\n<h3 id=\"协作图\"><a href=\"#协作图\" class=\"headerlink\" title=\"协作图\"></a>协作图</h3><blockquote>\n<p>在一定的语境中一组对象一级实现某些行为的对象间的相互作用。协作图就是表现对象协作关系的图。</p>\n</blockquote>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><ol>\n<li>确认和丰富一个使用语境的逻辑表达。</li>\n<li>显示对象机器交互关系的空间组织结构</li>\n<li>表现一个类操作的实现</li>\n</ol>\n<h4 id=\"协作图的组成\"><a href=\"#协作图的组成\" class=\"headerlink\" title=\"协作图的组成\"></a>协作图的组成</h4><p>由对象、消息和；链等构成。对象和消息的概念与时序图中的概念相同。主要的特点是链。</p>\n<ul>\n<li>链：两个或多个对象之间的独立连接，是对象引用元组，是关联的实例。</li>\n<li>链的表示形式：一个或多个相连的线或弧。</li>\n</ul>\n<h3 id=\"时序图和协作图的对比\"><a href=\"#时序图和协作图的对比\" class=\"headerlink\" title=\"时序图和协作图的对比\"></a>时序图和协作图的对比</h3><blockquote>\n<p>时序图和序列图表示的信息一样，只是方法不同，可通过适当的方式进行转化。</p>\n</blockquote>\n<p>  不同点：</p>\n<ul>\n<li>协作图明确了角色的关系，通过协作图角色来限定协作中的对象或链。</li>\n<li>协作图不将时间作为单独的维来表示，必须使用顺序号来判断信息的顺序以及并行线程。</li>\n<li>序列图和协作图都表示对象间的交互作用，序列图侧重时间顺序，协作图侧重对象间的关系，时间顺序可以从对象流经的顺序编号中获得。</li>\n<li>序列图被用于表示方案，而协作图被用于过程的详细设计。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"时序图（Sequence-Diagram）\"><a href=\"#时序图（Sequence-Diagram）\" class=\"headerlink\" title=\"时序图（Sequence Diagram）\"></a>时序图（Sequence Diagram）</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。时序图中包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。</p>\n</blockquote>\n<h4 id=\"时序图元素（Sequence-Diagram-Elements）\"><a href=\"#时序图元素（Sequence-Diagram-Elements）\" class=\"headerlink\" title=\"时序图元素（Sequence Diagram Elements）\"></a>时序图元素（Sequence Diagram Elements）</h4><ul>\n<li><p>角色（Actor）</p>\n<blockquote>\n<p>系统角色，可以是人、及其甚至其他的系统或者子系统。</p>\n</blockquote>\n</li>\n<li><p>对象（Object）</p>\n<blockquote>\n<p>对象包括三种命名方式：</p>\n<ul>\n<li>第一种方式包括对象名和类名；</li>\n<li>第二中方式只显示类名不显示对象名，即表示他是一个匿名对象；</li>\n<li>第三种方式只显示对象名不显示类明。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>生命线（Lifeline）</p>\n<blockquote>\n<p>生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间，如下图<br><br><img src=\"image/Sequence/%E7%94%9F%E5%91%BD%E7%BA%BF.png\" alt></p>\n</blockquote>\n</li>\n<li><p>控制焦点（Focus of Control）</p>\n<blockquote>\n<p>控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示，如下图。<br><br><img src=\"image/Sequence/%E6%8E%A7%E5%88%B6%E7%84%A6%E7%82%B9.png\" alt></p>\n</blockquote>\n</li>\n<li><p>消息（Message）</p>\n<blockquote>\n<p>消息一般分为</p>\n<ul>\n<li>同步消息（Synchronous Message）<br><br>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。</li>\n<li>异步消息（Asynchronous Message）<br><br>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。</li>\n<li>返回消息（Return Message）<br><br>返回消息表示从过程调用返回<br><br><img src=\"image/Sequence/%E6%B6%88%E6%81%AF.png\" alt></li>\n</ul>\n</blockquote>\n</li>\n<li><p>自关联消息（Self-Message）</p>\n<blockquote>\n<p>示方法的自身调用以及一个对象内的一个方法调用另外一个方法。<br><br><img src=\"image/Sequence/%E8%87%AA%E5%85%B3%E8%81%94%E6%B6%88%E6%81%AF.png\" alt></p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"时序图的作用\"><a href=\"#时序图的作用\" class=\"headerlink\" title=\"时序图的作用\"></a>时序图的作用</h4><ol>\n<li>确认和丰富一个使用语境的逻辑表达。</li>\n<li>细化用例，将用例表达的需求进一步精细表达。</li>\n<li>有效地描述个各类的职责一级各类具有相应的原因。</li>\n</ol>\n<h3 id=\"协作图\"><a href=\"#协作图\" class=\"headerlink\" title=\"协作图\"></a>协作图</h3><blockquote>\n<p>在一定的语境中一组对象一级实现某些行为的对象间的相互作用。协作图就是表现对象协作关系的图。</p>\n</blockquote>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><ol>\n<li>确认和丰富一个使用语境的逻辑表达。</li>\n<li>显示对象机器交互关系的空间组织结构</li>\n<li>表现一个类操作的实现</li>\n</ol>\n<h4 id=\"协作图的组成\"><a href=\"#协作图的组成\" class=\"headerlink\" title=\"协作图的组成\"></a>协作图的组成</h4><p>由对象、消息和；链等构成。对象和消息的概念与时序图中的概念相同。主要的特点是链。</p>\n<ul>\n<li>链：两个或多个对象之间的独立连接，是对象引用元组，是关联的实例。</li>\n<li>链的表示形式：一个或多个相连的线或弧。</li>\n</ul>\n<h3 id=\"时序图和协作图的对比\"><a href=\"#时序图和协作图的对比\" class=\"headerlink\" title=\"时序图和协作图的对比\"></a>时序图和协作图的对比</h3><blockquote>\n<p>时序图和序列图表示的信息一样，只是方法不同，可通过适当的方式进行转化。</p>\n</blockquote>\n<p>  不同点：</p>\n<ul>\n<li>协作图明确了角色的关系，通过协作图角色来限定协作中的对象或链。</li>\n<li>协作图不将时间作为单独的维来表示，必须使用顺序号来判断信息的顺序以及并行线程。</li>\n<li>序列图和协作图都表示对象间的交互作用，序列图侧重时间顺序，协作图侧重对象间的关系，时间顺序可以从对象流经的顺序编号中获得。</li>\n<li>序列图被用于表示方案，而协作图被用于过程的详细设计。</li>\n</ul>\n"},{"title":"Win8(X64)下MySQL5.6版本安装及配置","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-04-16T08:59:00.000Z","_content":"\n### 步骤1：双击MySQL安装程序\n\n官方网站http://dev.mysql.com/downloads/下载该软件\n\n### 步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:\n\n> Developer Default 默认安装类型\n> \n> Server only 仅作为服务器\n> \n> Client only 仅作为客户端\n> \n> Full 完全安装类型\n> \n> Custom 用户自定义安装类型\n> \n> 根据自己的情况选择安装，我们这里以自定义安装为例：\n> \n> [![image](http://static.oschina.net/uploads/img/201504/16165918_xBtP.png \"image\")](http://static.oschina.net/uploads/img/201504/16165918_FGf6.png)\n\n### 步骤3：选择安装内容及安装目录：\n\n> [![image](http://static.oschina.net/uploads/img/201504/16165918_xZtq.png \"image\")](http://static.oschina.net/uploads/img/201504/16165918_0GLM.png) [![image](http://static.oschina.net/uploads/img/201504/16165919_WpTX.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_YIKU.png) [![image](http://static.oschina.net/uploads/img/201504/16165919_0DmF.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_vrIa.png)\n\n### 步骤4：选择类型\n\n> Developer Machine(开发机器)，个人用桌面工作站，占用最少的系统资源\n> \n> Server Machine（服务器），MySQL服务器可以同其它应用程序一起运行，例如FTP、email和web服务器。MySQL服务器配置成使用适当比例的系统资源。\n> \n> Dedicated MySQL Server Machine（专用MySQL服务器）：该选项代表只运行MySQL服务的服务器。假定运行没有运行其它应用程序。MySQL服务器配置成使用所有可用系统资源。\n\n根据自己情况选择即可，一般WEB服务器选择第二个，Server Machine即可！个人电脑安装选择第一个，Developer Machine比较好。\n\n[![image](http://static.oschina.net/uploads/img/201504/16165920_8GEz.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_d9x7.png)\n\n### 步骤5：配置密码\n\n[![image](http://static.oschina.net/uploads/img/201504/16165920_c01w.png \"image\")](http://static.oschina.net/uploads/img/201504/16165920_a2cR.png)\n\n对应的界面中，我们需要设置root用户的密码，在“MySQL Root password”(输入新密码)和“Repeat Password”（确认）两个编辑框内输入期望的密码。也可以单击下面的【Add User】按钮另行添加新的用户。(**注:Current Root Password:为空；如果输入密码了在后面安装会报错**)\n\n### 步骤6：**设置Windows Service Name<可默认>，此名为启动数据库服务名，要记住。**\n\n[![image](http://static.oschina.net/uploads/img/201504/16165921_A9pr.png \"image\")](http://static.oschina.net/uploads/img/201504/16165921_kz1L.png)\n\n### 步骤7：验证服务：\n\n在开始菜单栏->**附件->**右键命令提示符->以管理员身份运行:\n\n```\nnet start MySQL56 为启动数据库服务命令；\n```\n\n```\nnet stop MySQL56  为停止数据库服务命令。\n```\n\n[![image](http://static.oschina.net/uploads/img/201504/16165921_qsYm.png \"image\")](http://static.oschina.net/uploads/img/201504/16165921_IAgd.png)\n\n### 步骤8：连接测试：\n\n进入bin目录，执行mysql -u root -p 回车输入密码\n\n```\nD:\\>cd D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin\nD:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin>mysql -u root -p\nEnter password: ****** Welcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 1 Server version: 5.6.24-log MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n```","source":"_posts/mysql/Win8(X64)下MySQL5.6版本安装及配置.md","raw":"title: Win8(X64)下MySQL5.6版本安装及配置\nauthor: JsonYe\ntags:\n  - mysql\n  - 数据库\ncategories:\n  - IDE \ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-04-16 16:59:00\n---\n\n### 步骤1：双击MySQL安装程序\n\n官方网站http://dev.mysql.com/downloads/下载该软件\n\n### 步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:\n\n> Developer Default 默认安装类型\n> \n> Server only 仅作为服务器\n> \n> Client only 仅作为客户端\n> \n> Full 完全安装类型\n> \n> Custom 用户自定义安装类型\n> \n> 根据自己的情况选择安装，我们这里以自定义安装为例：\n> \n> [![image](http://static.oschina.net/uploads/img/201504/16165918_xBtP.png \"image\")](http://static.oschina.net/uploads/img/201504/16165918_FGf6.png)\n\n### 步骤3：选择安装内容及安装目录：\n\n> [![image](http://static.oschina.net/uploads/img/201504/16165918_xZtq.png \"image\")](http://static.oschina.net/uploads/img/201504/16165918_0GLM.png) [![image](http://static.oschina.net/uploads/img/201504/16165919_WpTX.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_YIKU.png) [![image](http://static.oschina.net/uploads/img/201504/16165919_0DmF.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_vrIa.png)\n\n### 步骤4：选择类型\n\n> Developer Machine(开发机器)，个人用桌面工作站，占用最少的系统资源\n> \n> Server Machine（服务器），MySQL服务器可以同其它应用程序一起运行，例如FTP、email和web服务器。MySQL服务器配置成使用适当比例的系统资源。\n> \n> Dedicated MySQL Server Machine（专用MySQL服务器）：该选项代表只运行MySQL服务的服务器。假定运行没有运行其它应用程序。MySQL服务器配置成使用所有可用系统资源。\n\n根据自己情况选择即可，一般WEB服务器选择第二个，Server Machine即可！个人电脑安装选择第一个，Developer Machine比较好。\n\n[![image](http://static.oschina.net/uploads/img/201504/16165920_8GEz.png \"image\")](http://static.oschina.net/uploads/img/201504/16165919_d9x7.png)\n\n### 步骤5：配置密码\n\n[![image](http://static.oschina.net/uploads/img/201504/16165920_c01w.png \"image\")](http://static.oschina.net/uploads/img/201504/16165920_a2cR.png)\n\n对应的界面中，我们需要设置root用户的密码，在“MySQL Root password”(输入新密码)和“Repeat Password”（确认）两个编辑框内输入期望的密码。也可以单击下面的【Add User】按钮另行添加新的用户。(**注:Current Root Password:为空；如果输入密码了在后面安装会报错**)\n\n### 步骤6：**设置Windows Service Name<可默认>，此名为启动数据库服务名，要记住。**\n\n[![image](http://static.oschina.net/uploads/img/201504/16165921_A9pr.png \"image\")](http://static.oschina.net/uploads/img/201504/16165921_kz1L.png)\n\n### 步骤7：验证服务：\n\n在开始菜单栏->**附件->**右键命令提示符->以管理员身份运行:\n\n```\nnet start MySQL56 为启动数据库服务命令；\n```\n\n```\nnet stop MySQL56  为停止数据库服务命令。\n```\n\n[![image](http://static.oschina.net/uploads/img/201504/16165921_qsYm.png \"image\")](http://static.oschina.net/uploads/img/201504/16165921_IAgd.png)\n\n### 步骤8：连接测试：\n\n进入bin目录，执行mysql -u root -p 回车输入密码\n\n```\nD:\\>cd D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin\nD:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin>mysql -u root -p\nEnter password: ****** Welcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 1 Server version: 5.6.24-log MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n```","slug":"mysql/Win8(X64)下MySQL5.6版本安装及配置","published":1,"updated":"2019-10-02T08:40:35.546Z","layout":"post","photos":[],"link":"","_id":"ck19bvazw002700wkqsrinajs","content":"<h3 id=\"步骤1：双击MySQL安装程序\"><a href=\"#步骤1：双击MySQL安装程序\" class=\"headerlink\" title=\"步骤1：双击MySQL安装程序\"></a>步骤1：双击MySQL安装程序</h3><p>官方网站<a href=\"http://dev.mysql.com/downloads/下载该软件\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/下载该软件</a></p>\n<h3 id=\"步骤2：“Install-MySQL-Products”-文字，会弹出的用户许可证协议窗口，安装类型设置窗口-安装类型界面各设置项含义\"><a href=\"#步骤2：“Install-MySQL-Products”-文字，会弹出的用户许可证协议窗口，安装类型设置窗口-安装类型界面各设置项含义\" class=\"headerlink\" title=\"步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:\"></a>步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:</h3><blockquote>\n<p>Developer Default 默认安装类型</p>\n<p>Server only 仅作为服务器</p>\n<p>Client only 仅作为客户端</p>\n<p>Full 完全安装类型</p>\n<p>Custom 用户自定义安装类型</p>\n<p>根据自己的情况选择安装，我们这里以自定义安装为例：</p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165918_FGf6.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165918_xBtP.png\" alt=\"image\" title=\"image\"></a></p>\n</blockquote>\n<h3 id=\"步骤3：选择安装内容及安装目录：\"><a href=\"#步骤3：选择安装内容及安装目录：\" class=\"headerlink\" title=\"步骤3：选择安装内容及安装目录：\"></a>步骤3：选择安装内容及安装目录：</h3><blockquote>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165918_0GLM.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165918_xZtq.png\" alt=\"image\" title=\"image\"></a> <a href=\"http://static.oschina.net/uploads/img/201504/16165919_YIKU.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165919_WpTX.png\" alt=\"image\" title=\"image\"></a> <a href=\"http://static.oschina.net/uploads/img/201504/16165919_vrIa.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165919_0DmF.png\" alt=\"image\" title=\"image\"></a></p>\n</blockquote>\n<h3 id=\"步骤4：选择类型\"><a href=\"#步骤4：选择类型\" class=\"headerlink\" title=\"步骤4：选择类型\"></a>步骤4：选择类型</h3><blockquote>\n<p>Developer Machine(开发机器)，个人用桌面工作站，占用最少的系统资源</p>\n<p>Server Machine（服务器），MySQL服务器可以同其它应用程序一起运行，例如FTP、email和web服务器。MySQL服务器配置成使用适当比例的系统资源。</p>\n<p>Dedicated MySQL Server Machine（专用MySQL服务器）：该选项代表只运行MySQL服务的服务器。假定运行没有运行其它应用程序。MySQL服务器配置成使用所有可用系统资源。</p>\n</blockquote>\n<p>根据自己情况选择即可，一般WEB服务器选择第二个，Server Machine即可！个人电脑安装选择第一个，Developer Machine比较好。</p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165919_d9x7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165920_8GEz.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤5：配置密码\"><a href=\"#步骤5：配置密码\" class=\"headerlink\" title=\"步骤5：配置密码\"></a>步骤5：配置密码</h3><p><a href=\"http://static.oschina.net/uploads/img/201504/16165920_a2cR.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165920_c01w.png\" alt=\"image\" title=\"image\"></a></p>\n<p>对应的界面中，我们需要设置root用户的密码，在“MySQL Root password”(输入新密码)和“Repeat Password”（确认）两个编辑框内输入期望的密码。也可以单击下面的【Add User】按钮另行添加新的用户。(<strong>注:Current Root Password:为空；如果输入密码了在后面安装会报错</strong>)</p>\n<h3 id=\"步骤6：设置Windows-Service-Name-lt-可默认-gt-，此名为启动数据库服务名，要记住。\"><a href=\"#步骤6：设置Windows-Service-Name-lt-可默认-gt-，此名为启动数据库服务名，要记住。\" class=\"headerlink\" title=\"步骤6：设置Windows Service Name&lt;可默认&gt;，此名为启动数据库服务名，要记住。\"></a>步骤6：<strong>设置Windows Service Name&lt;可默认&gt;，此名为启动数据库服务名，要记住。</strong></h3><p><a href=\"http://static.oschina.net/uploads/img/201504/16165921_kz1L.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165921_A9pr.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤7：验证服务：\"><a href=\"#步骤7：验证服务：\" class=\"headerlink\" title=\"步骤7：验证服务：\"></a>步骤7：验证服务：</h3><p>在开始菜单栏-&gt;<strong>附件-&gt;</strong>右键命令提示符-&gt;以管理员身份运行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net start MySQL56 为启动数据库服务命令；</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net stop MySQL56  为停止数据库服务命令。</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165921_IAgd.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165921_qsYm.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤8：连接测试：\"><a href=\"#步骤8：连接测试：\" class=\"headerlink\" title=\"步骤8：连接测试：\"></a>步骤8：连接测试：</h3><p>进入bin目录，执行mysql -u root -p 回车输入密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\&gt;cd D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin</span><br><span class=\"line\">D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password: ****** Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1 Server version: 5.6.24-log MySQL Community Server (GPL)</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\"></span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"步骤1：双击MySQL安装程序\"><a href=\"#步骤1：双击MySQL安装程序\" class=\"headerlink\" title=\"步骤1：双击MySQL安装程序\"></a>步骤1：双击MySQL安装程序</h3><p>官方网站<a href=\"http://dev.mysql.com/downloads/下载该软件\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/下载该软件</a></p>\n<h3 id=\"步骤2：“Install-MySQL-Products”-文字，会弹出的用户许可证协议窗口，安装类型设置窗口-安装类型界面各设置项含义\"><a href=\"#步骤2：“Install-MySQL-Products”-文字，会弹出的用户许可证协议窗口，安装类型设置窗口-安装类型界面各设置项含义\" class=\"headerlink\" title=\"步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:\"></a>步骤2：“Install MySQL Products” 文字，会弹出的用户许可证协议窗口，安装类型设置窗口,安装类型界面各设置项含义:</h3><blockquote>\n<p>Developer Default 默认安装类型</p>\n<p>Server only 仅作为服务器</p>\n<p>Client only 仅作为客户端</p>\n<p>Full 完全安装类型</p>\n<p>Custom 用户自定义安装类型</p>\n<p>根据自己的情况选择安装，我们这里以自定义安装为例：</p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165918_FGf6.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165918_xBtP.png\" alt=\"image\" title=\"image\"></a></p>\n</blockquote>\n<h3 id=\"步骤3：选择安装内容及安装目录：\"><a href=\"#步骤3：选择安装内容及安装目录：\" class=\"headerlink\" title=\"步骤3：选择安装内容及安装目录：\"></a>步骤3：选择安装内容及安装目录：</h3><blockquote>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165918_0GLM.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165918_xZtq.png\" alt=\"image\" title=\"image\"></a> <a href=\"http://static.oschina.net/uploads/img/201504/16165919_YIKU.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165919_WpTX.png\" alt=\"image\" title=\"image\"></a> <a href=\"http://static.oschina.net/uploads/img/201504/16165919_vrIa.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165919_0DmF.png\" alt=\"image\" title=\"image\"></a></p>\n</blockquote>\n<h3 id=\"步骤4：选择类型\"><a href=\"#步骤4：选择类型\" class=\"headerlink\" title=\"步骤4：选择类型\"></a>步骤4：选择类型</h3><blockquote>\n<p>Developer Machine(开发机器)，个人用桌面工作站，占用最少的系统资源</p>\n<p>Server Machine（服务器），MySQL服务器可以同其它应用程序一起运行，例如FTP、email和web服务器。MySQL服务器配置成使用适当比例的系统资源。</p>\n<p>Dedicated MySQL Server Machine（专用MySQL服务器）：该选项代表只运行MySQL服务的服务器。假定运行没有运行其它应用程序。MySQL服务器配置成使用所有可用系统资源。</p>\n</blockquote>\n<p>根据自己情况选择即可，一般WEB服务器选择第二个，Server Machine即可！个人电脑安装选择第一个，Developer Machine比较好。</p>\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165919_d9x7.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165920_8GEz.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤5：配置密码\"><a href=\"#步骤5：配置密码\" class=\"headerlink\" title=\"步骤5：配置密码\"></a>步骤5：配置密码</h3><p><a href=\"http://static.oschina.net/uploads/img/201504/16165920_a2cR.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165920_c01w.png\" alt=\"image\" title=\"image\"></a></p>\n<p>对应的界面中，我们需要设置root用户的密码，在“MySQL Root password”(输入新密码)和“Repeat Password”（确认）两个编辑框内输入期望的密码。也可以单击下面的【Add User】按钮另行添加新的用户。(<strong>注:Current Root Password:为空；如果输入密码了在后面安装会报错</strong>)</p>\n<h3 id=\"步骤6：设置Windows-Service-Name-lt-可默认-gt-，此名为启动数据库服务名，要记住。\"><a href=\"#步骤6：设置Windows-Service-Name-lt-可默认-gt-，此名为启动数据库服务名，要记住。\" class=\"headerlink\" title=\"步骤6：设置Windows Service Name&lt;可默认&gt;，此名为启动数据库服务名，要记住。\"></a>步骤6：<strong>设置Windows Service Name&lt;可默认&gt;，此名为启动数据库服务名，要记住。</strong></h3><p><a href=\"http://static.oschina.net/uploads/img/201504/16165921_kz1L.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165921_A9pr.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤7：验证服务：\"><a href=\"#步骤7：验证服务：\" class=\"headerlink\" title=\"步骤7：验证服务：\"></a>步骤7：验证服务：</h3><p>在开始菜单栏-&gt;<strong>附件-&gt;</strong>右键命令提示符-&gt;以管理员身份运行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net start MySQL56 为启动数据库服务命令；</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net stop MySQL56  为停止数据库服务命令。</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://static.oschina.net/uploads/img/201504/16165921_IAgd.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://static.oschina.net/uploads/img/201504/16165921_qsYm.png\" alt=\"image\" title=\"image\"></a></p>\n<h3 id=\"步骤8：连接测试：\"><a href=\"#步骤8：连接测试：\" class=\"headerlink\" title=\"步骤8：连接测试：\"></a>步骤8：连接测试：</h3><p>进入bin目录，执行mysql -u root -p 回车输入密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\&gt;cd D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin</span><br><span class=\"line\">D:\\Programs\\WAPM\\MySQL\\MySQL Server 5.6\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password: ****** Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1 Server version: 5.6.24-log MySQL Community Server (GPL)</span><br><span class=\"line\"></span><br><span class=\"line\">Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\"></span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\"></span><br><span class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure>"},{"title":"MySql常用信息函数","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2017-01-12T08:59:00.000Z","_content":"## 基本命令\n```sql\n-- 管理员登录\nmysql -uroot\n-- 查看当前服务器版本\nselect version();\n-- 查看当前使用的数据库\nselect database();\n-- 当前用户\nselect current_user();\nselect user();\n\n-- 查询当前日期、时间、日期+时间\nselect curdate(),curtime(),now();\nselect current_date(),current_time(),current_timestamp();\n\n-- 显示所有表\nshow tables;\n-- 显示所有库\nshow databases;\n-- 查看标准建库语句\nshow create database db_name;\n-- 查看标准建表语句\nshow create table tb_name;\n-- 查看表字段信息\nshow full columns from tname;\n-- 显示当前数据库服务器支持的存储引擎\nshow engines;\n-- 查询当前服务器所支持的字符集。\nshow charset;\n\n```\n\n## 存储引擎\n- MyISAM 不支持事务，速度快，引用最多的引擎\n- InnoDB 支持事务\n\n## 常见支持简体中文的字符集\n我国定制，支持中文简体、繁体 日文。\ngb2312 简体中文，只支持6763简体汉字\ngbk 简繁体支持\ngb18030 \n\nutf-8 美国制定，支持所有国家语言","source":"_posts/mysql/mysql常用信息函数.md","raw":"---\ntitle: MySql常用信息函数\nauthor: JsonYe\ntags:\n  - mysql\n  - 数据库\ncategories:\n  - MySql \ncopyright: true\ncomments: true\ntoc: true\ndate: 2017-01-12 16:59:00\n---\n## 基本命令\n```sql\n-- 管理员登录\nmysql -uroot\n-- 查看当前服务器版本\nselect version();\n-- 查看当前使用的数据库\nselect database();\n-- 当前用户\nselect current_user();\nselect user();\n\n-- 查询当前日期、时间、日期+时间\nselect curdate(),curtime(),now();\nselect current_date(),current_time(),current_timestamp();\n\n-- 显示所有表\nshow tables;\n-- 显示所有库\nshow databases;\n-- 查看标准建库语句\nshow create database db_name;\n-- 查看标准建表语句\nshow create table tb_name;\n-- 查看表字段信息\nshow full columns from tname;\n-- 显示当前数据库服务器支持的存储引擎\nshow engines;\n-- 查询当前服务器所支持的字符集。\nshow charset;\n\n```\n\n## 存储引擎\n- MyISAM 不支持事务，速度快，引用最多的引擎\n- InnoDB 支持事务\n\n## 常见支持简体中文的字符集\n我国定制，支持中文简体、繁体 日文。\ngb2312 简体中文，只支持6763简体汉字\ngbk 简繁体支持\ngb18030 \n\nutf-8 美国制定，支持所有国家语言","slug":"mysql/mysql常用信息函数","published":1,"updated":"2019-10-02T08:40:22.980Z","layout":"post","photos":[],"link":"","_id":"ck19bvb04002b00wktssq84qb","content":"<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 管理员登录</span></span><br><span class=\"line\">mysql -uroot</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前服务器版本</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">version</span>();</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前使用的数据库</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">database</span>();</span><br><span class=\"line\"><span class=\"comment\">-- 当前用户</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">current_user</span>();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">user</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询当前日期、时间、日期+时间</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">curdate</span>(),<span class=\"keyword\">curtime</span>(),<span class=\"keyword\">now</span>();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">current_date</span>(),<span class=\"keyword\">current_time</span>(),<span class=\"keyword\">current_timestamp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 显示所有表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 显示所有库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">databases</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 查看标准建库语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">database</span> db_name;</span><br><span class=\"line\"><span class=\"comment\">-- 查看标准建表语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> tb_name;</span><br><span class=\"line\"><span class=\"comment\">-- 查看表字段信息</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">full</span> <span class=\"keyword\">columns</span> <span class=\"keyword\">from</span> tname;</span><br><span class=\"line\"><span class=\"comment\">-- 显示当前数据库服务器支持的存储引擎</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 查询当前服务器所支持的字符集。</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">charset</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><ul>\n<li>MyISAM 不支持事务，速度快，引用最多的引擎</li>\n<li>InnoDB 支持事务</li>\n</ul>\n<h2 id=\"常见支持简体中文的字符集\"><a href=\"#常见支持简体中文的字符集\" class=\"headerlink\" title=\"常见支持简体中文的字符集\"></a>常见支持简体中文的字符集</h2><p>我国定制，支持中文简体、繁体 日文。<br>gb2312 简体中文，只支持6763简体汉字<br>gbk 简繁体支持<br>gb18030 </p>\n<p>utf-8 美国制定，支持所有国家语言</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 管理员登录</span></span><br><span class=\"line\">mysql -uroot</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前服务器版本</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">version</span>();</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前使用的数据库</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">database</span>();</span><br><span class=\"line\"><span class=\"comment\">-- 当前用户</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">current_user</span>();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">user</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询当前日期、时间、日期+时间</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">curdate</span>(),<span class=\"keyword\">curtime</span>(),<span class=\"keyword\">now</span>();</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">current_date</span>(),<span class=\"keyword\">current_time</span>(),<span class=\"keyword\">current_timestamp</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 显示所有表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">tables</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 显示所有库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">databases</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 查看标准建库语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">database</span> db_name;</span><br><span class=\"line\"><span class=\"comment\">-- 查看标准建表语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> tb_name;</span><br><span class=\"line\"><span class=\"comment\">-- 查看表字段信息</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">full</span> <span class=\"keyword\">columns</span> <span class=\"keyword\">from</span> tname;</span><br><span class=\"line\"><span class=\"comment\">-- 显示当前数据库服务器支持的存储引擎</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 查询当前服务器所支持的字符集。</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">charset</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h2><ul>\n<li>MyISAM 不支持事务，速度快，引用最多的引擎</li>\n<li>InnoDB 支持事务</li>\n</ul>\n<h2 id=\"常见支持简体中文的字符集\"><a href=\"#常见支持简体中文的字符集\" class=\"headerlink\" title=\"常见支持简体中文的字符集\"></a>常见支持简体中文的字符集</h2><p>我国定制，支持中文简体、繁体 日文。<br>gb2312 简体中文，只支持6763简体汉字<br>gbk 简繁体支持<br>gb18030 </p>\n<p>utf-8 美国制定，支持所有国家语言</p>\n"},{"title":"数据库表命令","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2017-01-12T10:59:00.000Z","_content":"## 数据表操作\n```\n-- 创建数据库\nCREATE DATABASE mydb\n\n-- 使用数据库\nUSE mydb\n\n-- 查看数据表\nSHOW TABLES\n\n-- 创建表\nCREATE TABLE pet (\n\tNAME VARCHAR(20),\n\townerr\tVARCHAR(20),\n\tspecies VARCHAR(20),\n\tsex CHAR(1),\n\tbirth DATE,\n\tdeath DATE);\n\n-- 显示表结构\nDESCRIBE pet;\n-- 改表的名字 \nALTER TABLE pet RENAME TO pet2; \nALTER TABLE pet2 RENAME TO pet; \n\n-- 约束：约束（主键Primary key、唯一性Unique、非空Not Null）\n-- 自动增张 auto_increment \n-- 外键Foreign key-----与reference table_name(col_name列名)配合使用，建表时单独使用 \n-- 删除多个表中有关联的数据----设置foreign key 为set null\n\n-- 删除表\nDROP TABLE IF EXISTS pet;\n\n-- 增加一个字段： \nALTER TABLE pet ADD COLUMN (phone VARCHAR(11)); \n\n-- 删除一个字段\nALTER TABLE pet DROP phone; \n\n-- 修改字段名称/类型\nALTER TABLE pet CHANGE phone tel VARCHAR(11)\nALTER TABLE pet CHANGE tel phone VARCHAR(11)\n\n-- 插入数据\nINSERT INTO pet VALUES\n\t('Fluffy','Harold','cat','f','1993-02-04',NULL),\n\t('Claws','Gwen','cat','m','1994-03-17',NULL),\n\t('Buffy','Harold','dog','f','1989-05-13',NULL),\n\t('Fang','Benny','dog','m','1990-08-27',NULL),\n\t('Bowser','Diane','dog','m','1979-08-31','1995-07-29'),\n\t('Chirpy','Gwen','bird','f','1998-09-11',NULL),\n\t('Whistler','Gwen','bird',' ','1997-12-09',NULL),\n\t('Puffball','Diane','hamster','f','1999-03-30',NULL),\n\t('Slim','Benny','snake','m','1996-04-29',NULL);\n-- 查询表数据\nSELECT * FROM pet\n-- 清空表数据\nDELETE FROM pet\n-- 此方法也会使表中的取号器(ID)从1开始\nTRUNCATE TABLE pet; \n\n-- 修改字段值\nUPDATE pet SET birth = '1989-08-31' WHERE NAME = 'Bowser'\nSELECT * FROM pet WHERE NAME = 'Bowser'\n```\n## 数据表查询\n### 基本查询\n```\n-- DISTINCT 检索出每个唯一的输出记录\nSELECT DISTINCT ownerr FROM pet\n\n-- 排序 order by，对于等同但大小写不同的列，并未定义其顺序，某一列，可以使用BINARY强制执行区分大小写的分类功能，如：ORDER BY BINARY col_name. \nSELECT NAME,ownerr,birth FROM pet ORDER BY birth\n-- 默认排序是升序，可以利用关键字进行控制。DESC(降序)、ASC(升序)\nSELECT NAME,ownerr,birth FROM pet ORDER BY birth ASC\n\n-- 多列进行排序\nSELECT NAME,ownerr,birth FROM pet ORDER BY ownerr,birth DESC\n```\n### 日期计算\n```\n-- YEAR()-提取日期的年部分，MONTH()-提取月份，DAYOFMONTH()-提取所在月份中的日\nSELECT birth, YEAR(birth),MONTH(birth),DAYOFMONTH(birth) FROM pet\n\n-- RIGHT(birth,5)-提取birth的右边5个字符,LEFT - 从左边开始取，MID - 从指定位置(包括)开始取指定长度\nSELECT RIGHT('1234567890',5),LEFT('1234567890',5),MID('1234567890',2,4)\n-- 提出已近死亡的\n-- 出生月份大于当前月份，年龄-1。\nSELECT \n  NAME,\n  birth,\n  CURDATE(),\n  (YEAR(CURDATE()) - YEAR(birth)) - (RIGHT(CURDATE(), 5) < RIGHT(birth, 5)) AS age \nFROM\n  pet WHERE death IS NULL  ORDER BY age\n  \n -- 查询已死亡的年龄\n SELECT \n  NAME,\n  birth,\n  death,\n  (YEAR(death) - YEAR(birth)) - (RIGHT(death, 5) < RIGHT(birth, 5)) AS age \nFROM\n  pet WHERE death IS NOT NULL ORDER BY age\n\n-- 查询下一个月谁过生日\nSELECT * FROM pet ORDER BY MONTH(birth)\nSELECT * FROM pet WHERE MONTH(birth) = MONTH(CURDATE()) + 1\nSELECT * FROM pet WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH))\n```\n### NULL值\n```\n-- NULL 值的判断，不能使用比较运算符，只能用 is null 或 is not null\nSELECT  1 = NULL, 1 > NULL, 1 < NULL,  1 IS NULL,  1 IS NOT NULL \n\n-- 0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1。\nSELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;\n```\n### 模糊匹配\n```\n-- MySQL提供标准的SQL模式匹配，以及一种基于象Unix实用程序如vi、grep和sed的扩展正则表达式模式匹配的格式。\n-- \"_\" 匹配任何单个字符；\"%\" 匹配任意数目字符(包括零字符)，SQL的模式默认是忽略大小写。关键字 LIKE 或 NOT LINK\n\n-- 查找以b开头的name\nSELECT * FROM pet WHERE NAME LIKE 'b%'\n-- 查找以'fy'结尾的名字\nSELECT * FROM pet WHERE NAME LIKE '%fy'\n-- 查找包含w的名字\nSELECT * FROM pet WHERE NAME LIKE '%w%'\n-- 查找正好是5个字符的名字\nSELECT * FROM pet WHERE NAME LIKE '_____'\nSELECT * FROM pet WHERE LENGTH(NAME) = 5\n\n-- MySQL提供的模式匹配的其它类型是使用扩展正则表达式。当你对这类模式进行匹配测试时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，它们是同义词)。 \n-- \".\" 匹配任何单个字符；\n-- \"[...]\" 匹配在方括号内的任何字符，为了命名字符的范围，使用一个“-”。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。\n-- \"*\" 匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的“x”字符，“[0-9]*”匹配任何数量的数字，而“.*”匹配任何数量的任何字符。\n-- 如果REGEXP模式与被测试值的任何地方匹配，模式就匹配(这不同于LIKE模式匹配，只有与整个值匹配，模式才匹配)。 \n-- 为了定位一个模式以便它必须匹配被测试值的开始或结尾，在模式开始处使用“^”或在模式的结尾用“$”。\n\n-- 查找以b开头的name\nSELECT * FROM pet WHERE NAME REGEXP '^b'\n-- 查找以'fy'结尾的名字\nSELECT * FROM pet WHERE NAME REGEXP 'fy$'\n-- 查找包含w的名字\nSELECT * FROM pet WHERE NAME REGEXP 'w'\n-- 查找正好是5个字符的名字\nSELECT * FROM pet WHERE NAME REGEXP '^.....$'\nSELECT * FROM pet WHERE NAME REGEXP '^.{5}$'\n```\n[正则表达式在线参考](http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/regexp.html)","source":"_posts/mysql/数据表命令.md","raw":"---\ntitle: 数据库表命令\nauthor: JsonYe\ntags:\n  - mysql\n  - 数据库\ncategories:\n  - MySql \ncopyright: true\ncomments: true\ntoc: true\ndate: 2017-01-12 18:59:00\n---\n## 数据表操作\n```\n-- 创建数据库\nCREATE DATABASE mydb\n\n-- 使用数据库\nUSE mydb\n\n-- 查看数据表\nSHOW TABLES\n\n-- 创建表\nCREATE TABLE pet (\n\tNAME VARCHAR(20),\n\townerr\tVARCHAR(20),\n\tspecies VARCHAR(20),\n\tsex CHAR(1),\n\tbirth DATE,\n\tdeath DATE);\n\n-- 显示表结构\nDESCRIBE pet;\n-- 改表的名字 \nALTER TABLE pet RENAME TO pet2; \nALTER TABLE pet2 RENAME TO pet; \n\n-- 约束：约束（主键Primary key、唯一性Unique、非空Not Null）\n-- 自动增张 auto_increment \n-- 外键Foreign key-----与reference table_name(col_name列名)配合使用，建表时单独使用 \n-- 删除多个表中有关联的数据----设置foreign key 为set null\n\n-- 删除表\nDROP TABLE IF EXISTS pet;\n\n-- 增加一个字段： \nALTER TABLE pet ADD COLUMN (phone VARCHAR(11)); \n\n-- 删除一个字段\nALTER TABLE pet DROP phone; \n\n-- 修改字段名称/类型\nALTER TABLE pet CHANGE phone tel VARCHAR(11)\nALTER TABLE pet CHANGE tel phone VARCHAR(11)\n\n-- 插入数据\nINSERT INTO pet VALUES\n\t('Fluffy','Harold','cat','f','1993-02-04',NULL),\n\t('Claws','Gwen','cat','m','1994-03-17',NULL),\n\t('Buffy','Harold','dog','f','1989-05-13',NULL),\n\t('Fang','Benny','dog','m','1990-08-27',NULL),\n\t('Bowser','Diane','dog','m','1979-08-31','1995-07-29'),\n\t('Chirpy','Gwen','bird','f','1998-09-11',NULL),\n\t('Whistler','Gwen','bird',' ','1997-12-09',NULL),\n\t('Puffball','Diane','hamster','f','1999-03-30',NULL),\n\t('Slim','Benny','snake','m','1996-04-29',NULL);\n-- 查询表数据\nSELECT * FROM pet\n-- 清空表数据\nDELETE FROM pet\n-- 此方法也会使表中的取号器(ID)从1开始\nTRUNCATE TABLE pet; \n\n-- 修改字段值\nUPDATE pet SET birth = '1989-08-31' WHERE NAME = 'Bowser'\nSELECT * FROM pet WHERE NAME = 'Bowser'\n```\n## 数据表查询\n### 基本查询\n```\n-- DISTINCT 检索出每个唯一的输出记录\nSELECT DISTINCT ownerr FROM pet\n\n-- 排序 order by，对于等同但大小写不同的列，并未定义其顺序，某一列，可以使用BINARY强制执行区分大小写的分类功能，如：ORDER BY BINARY col_name. \nSELECT NAME,ownerr,birth FROM pet ORDER BY birth\n-- 默认排序是升序，可以利用关键字进行控制。DESC(降序)、ASC(升序)\nSELECT NAME,ownerr,birth FROM pet ORDER BY birth ASC\n\n-- 多列进行排序\nSELECT NAME,ownerr,birth FROM pet ORDER BY ownerr,birth DESC\n```\n### 日期计算\n```\n-- YEAR()-提取日期的年部分，MONTH()-提取月份，DAYOFMONTH()-提取所在月份中的日\nSELECT birth, YEAR(birth),MONTH(birth),DAYOFMONTH(birth) FROM pet\n\n-- RIGHT(birth,5)-提取birth的右边5个字符,LEFT - 从左边开始取，MID - 从指定位置(包括)开始取指定长度\nSELECT RIGHT('1234567890',5),LEFT('1234567890',5),MID('1234567890',2,4)\n-- 提出已近死亡的\n-- 出生月份大于当前月份，年龄-1。\nSELECT \n  NAME,\n  birth,\n  CURDATE(),\n  (YEAR(CURDATE()) - YEAR(birth)) - (RIGHT(CURDATE(), 5) < RIGHT(birth, 5)) AS age \nFROM\n  pet WHERE death IS NULL  ORDER BY age\n  \n -- 查询已死亡的年龄\n SELECT \n  NAME,\n  birth,\n  death,\n  (YEAR(death) - YEAR(birth)) - (RIGHT(death, 5) < RIGHT(birth, 5)) AS age \nFROM\n  pet WHERE death IS NOT NULL ORDER BY age\n\n-- 查询下一个月谁过生日\nSELECT * FROM pet ORDER BY MONTH(birth)\nSELECT * FROM pet WHERE MONTH(birth) = MONTH(CURDATE()) + 1\nSELECT * FROM pet WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH))\n```\n### NULL值\n```\n-- NULL 值的判断，不能使用比较运算符，只能用 is null 或 is not null\nSELECT  1 = NULL, 1 > NULL, 1 < NULL,  1 IS NULL,  1 IS NOT NULL \n\n-- 0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1。\nSELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;\n```\n### 模糊匹配\n```\n-- MySQL提供标准的SQL模式匹配，以及一种基于象Unix实用程序如vi、grep和sed的扩展正则表达式模式匹配的格式。\n-- \"_\" 匹配任何单个字符；\"%\" 匹配任意数目字符(包括零字符)，SQL的模式默认是忽略大小写。关键字 LIKE 或 NOT LINK\n\n-- 查找以b开头的name\nSELECT * FROM pet WHERE NAME LIKE 'b%'\n-- 查找以'fy'结尾的名字\nSELECT * FROM pet WHERE NAME LIKE '%fy'\n-- 查找包含w的名字\nSELECT * FROM pet WHERE NAME LIKE '%w%'\n-- 查找正好是5个字符的名字\nSELECT * FROM pet WHERE NAME LIKE '_____'\nSELECT * FROM pet WHERE LENGTH(NAME) = 5\n\n-- MySQL提供的模式匹配的其它类型是使用扩展正则表达式。当你对这类模式进行匹配测试时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，它们是同义词)。 \n-- \".\" 匹配任何单个字符；\n-- \"[...]\" 匹配在方括号内的任何字符，为了命名字符的范围，使用一个“-”。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。\n-- \"*\" 匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的“x”字符，“[0-9]*”匹配任何数量的数字，而“.*”匹配任何数量的任何字符。\n-- 如果REGEXP模式与被测试值的任何地方匹配，模式就匹配(这不同于LIKE模式匹配，只有与整个值匹配，模式才匹配)。 \n-- 为了定位一个模式以便它必须匹配被测试值的开始或结尾，在模式开始处使用“^”或在模式的结尾用“$”。\n\n-- 查找以b开头的name\nSELECT * FROM pet WHERE NAME REGEXP '^b'\n-- 查找以'fy'结尾的名字\nSELECT * FROM pet WHERE NAME REGEXP 'fy$'\n-- 查找包含w的名字\nSELECT * FROM pet WHERE NAME REGEXP 'w'\n-- 查找正好是5个字符的名字\nSELECT * FROM pet WHERE NAME REGEXP '^.....$'\nSELECT * FROM pet WHERE NAME REGEXP '^.{5}$'\n```\n[正则表达式在线参考](http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/regexp.html)","slug":"mysql/数据表命令","published":1,"updated":"2019-10-02T08:46:10.954Z","layout":"post","photos":[],"link":"","_id":"ck19bvb08002d00wk5x75cj06","content":"<h2 id=\"数据表操作\"><a href=\"#数据表操作\" class=\"headerlink\" title=\"数据表操作\"></a>数据表操作</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 创建数据库</span><br><span class=\"line\">CREATE DATABASE mydb</span><br><span class=\"line\"></span><br><span class=\"line\">-- 使用数据库</span><br><span class=\"line\">USE mydb</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查看数据表</span><br><span class=\"line\">SHOW TABLES</span><br><span class=\"line\"></span><br><span class=\"line\">-- 创建表</span><br><span class=\"line\">CREATE TABLE pet (</span><br><span class=\"line\">\tNAME VARCHAR(20),</span><br><span class=\"line\">\townerr\tVARCHAR(20),</span><br><span class=\"line\">\tspecies VARCHAR(20),</span><br><span class=\"line\">\tsex CHAR(1),</span><br><span class=\"line\">\tbirth DATE,</span><br><span class=\"line\">\tdeath DATE);</span><br><span class=\"line\"></span><br><span class=\"line\">-- 显示表结构</span><br><span class=\"line\">DESCRIBE pet;</span><br><span class=\"line\">-- 改表的名字 </span><br><span class=\"line\">ALTER TABLE pet RENAME TO pet2; </span><br><span class=\"line\">ALTER TABLE pet2 RENAME TO pet; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 约束：约束（主键Primary key、唯一性Unique、非空Not Null）</span><br><span class=\"line\">-- 自动增张 auto_increment </span><br><span class=\"line\">-- 外键Foreign key-----与reference table_name(col_name列名)配合使用，建表时单独使用 </span><br><span class=\"line\">-- 删除多个表中有关联的数据----设置foreign key 为set null</span><br><span class=\"line\"></span><br><span class=\"line\">-- 删除表</span><br><span class=\"line\">DROP TABLE IF EXISTS pet;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 增加一个字段： </span><br><span class=\"line\">ALTER TABLE pet ADD COLUMN (phone VARCHAR(11)); </span><br><span class=\"line\"></span><br><span class=\"line\">-- 删除一个字段</span><br><span class=\"line\">ALTER TABLE pet DROP phone; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 修改字段名称/类型</span><br><span class=\"line\">ALTER TABLE pet CHANGE phone tel VARCHAR(11)</span><br><span class=\"line\">ALTER TABLE pet CHANGE tel phone VARCHAR(11)</span><br><span class=\"line\"></span><br><span class=\"line\">-- 插入数据</span><br><span class=\"line\">INSERT INTO pet VALUES</span><br><span class=\"line\">\t(&apos;Fluffy&apos;,&apos;Harold&apos;,&apos;cat&apos;,&apos;f&apos;,&apos;1993-02-04&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Claws&apos;,&apos;Gwen&apos;,&apos;cat&apos;,&apos;m&apos;,&apos;1994-03-17&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Buffy&apos;,&apos;Harold&apos;,&apos;dog&apos;,&apos;f&apos;,&apos;1989-05-13&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Fang&apos;,&apos;Benny&apos;,&apos;dog&apos;,&apos;m&apos;,&apos;1990-08-27&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Bowser&apos;,&apos;Diane&apos;,&apos;dog&apos;,&apos;m&apos;,&apos;1979-08-31&apos;,&apos;1995-07-29&apos;),</span><br><span class=\"line\">\t(&apos;Chirpy&apos;,&apos;Gwen&apos;,&apos;bird&apos;,&apos;f&apos;,&apos;1998-09-11&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Whistler&apos;,&apos;Gwen&apos;,&apos;bird&apos;,&apos; &apos;,&apos;1997-12-09&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Puffball&apos;,&apos;Diane&apos;,&apos;hamster&apos;,&apos;f&apos;,&apos;1999-03-30&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Slim&apos;,&apos;Benny&apos;,&apos;snake&apos;,&apos;m&apos;,&apos;1996-04-29&apos;,NULL);</span><br><span class=\"line\">-- 查询表数据</span><br><span class=\"line\">SELECT * FROM pet</span><br><span class=\"line\">-- 清空表数据</span><br><span class=\"line\">DELETE FROM pet</span><br><span class=\"line\">-- 此方法也会使表中的取号器(ID)从1开始</span><br><span class=\"line\">TRUNCATE TABLE pet; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 修改字段值</span><br><span class=\"line\">UPDATE pet SET birth = &apos;1989-08-31&apos; WHERE NAME = &apos;Bowser&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME = &apos;Bowser&apos;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据表查询\"><a href=\"#数据表查询\" class=\"headerlink\" title=\"数据表查询\"></a>数据表查询</h2><h3 id=\"基本查询\"><a href=\"#基本查询\" class=\"headerlink\" title=\"基本查询\"></a>基本查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- DISTINCT 检索出每个唯一的输出记录</span><br><span class=\"line\">SELECT DISTINCT ownerr FROM pet</span><br><span class=\"line\"></span><br><span class=\"line\">-- 排序 order by，对于等同但大小写不同的列，并未定义其顺序，某一列，可以使用BINARY强制执行区分大小写的分类功能，如：ORDER BY BINARY col_name. </span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY birth</span><br><span class=\"line\">-- 默认排序是升序，可以利用关键字进行控制。DESC(降序)、ASC(升序)</span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY birth ASC</span><br><span class=\"line\"></span><br><span class=\"line\">-- 多列进行排序</span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY ownerr,birth DESC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日期计算\"><a href=\"#日期计算\" class=\"headerlink\" title=\"日期计算\"></a>日期计算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- YEAR()-提取日期的年部分，MONTH()-提取月份，DAYOFMONTH()-提取所在月份中的日</span><br><span class=\"line\">SELECT birth, YEAR(birth),MONTH(birth),DAYOFMONTH(birth) FROM pet</span><br><span class=\"line\"></span><br><span class=\"line\">-- RIGHT(birth,5)-提取birth的右边5个字符,LEFT - 从左边开始取，MID - 从指定位置(包括)开始取指定长度</span><br><span class=\"line\">SELECT RIGHT(&apos;1234567890&apos;,5),LEFT(&apos;1234567890&apos;,5),MID(&apos;1234567890&apos;,2,4)</span><br><span class=\"line\">-- 提出已近死亡的</span><br><span class=\"line\">-- 出生月份大于当前月份，年龄-1。</span><br><span class=\"line\">SELECT </span><br><span class=\"line\">  NAME,</span><br><span class=\"line\">  birth,</span><br><span class=\"line\">  CURDATE(),</span><br><span class=\"line\">  (YEAR(CURDATE()) - YEAR(birth)) - (RIGHT(CURDATE(), 5) &lt; RIGHT(birth, 5)) AS age </span><br><span class=\"line\">FROM</span><br><span class=\"line\">  pet WHERE death IS NULL  ORDER BY age</span><br><span class=\"line\">  </span><br><span class=\"line\"> -- 查询已死亡的年龄</span><br><span class=\"line\"> SELECT </span><br><span class=\"line\">  NAME,</span><br><span class=\"line\">  birth,</span><br><span class=\"line\">  death,</span><br><span class=\"line\">  (YEAR(death) - YEAR(birth)) - (RIGHT(death, 5) &lt; RIGHT(birth, 5)) AS age </span><br><span class=\"line\">FROM</span><br><span class=\"line\">  pet WHERE death IS NOT NULL ORDER BY age</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查询下一个月谁过生日</span><br><span class=\"line\">SELECT * FROM pet ORDER BY MONTH(birth)</span><br><span class=\"line\">SELECT * FROM pet WHERE MONTH(birth) = MONTH(CURDATE()) + 1</span><br><span class=\"line\">SELECT * FROM pet WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NULL值\"><a href=\"#NULL值\" class=\"headerlink\" title=\"NULL值\"></a>NULL值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- NULL 值的判断，不能使用比较运算符，只能用 is null 或 is not null</span><br><span class=\"line\">SELECT  1 = NULL, 1 &gt; NULL, 1 &lt; NULL,  1 IS NULL,  1 IS NOT NULL </span><br><span class=\"line\"></span><br><span class=\"line\">-- 0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1。</span><br><span class=\"line\">SELECT 0 IS NULL, 0 IS NOT NULL, &apos;&apos; IS NULL, &apos;&apos; IS NOT NULL;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模糊匹配\"><a href=\"#模糊匹配\" class=\"headerlink\" title=\"模糊匹配\"></a>模糊匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- MySQL提供标准的SQL模式匹配，以及一种基于象Unix实用程序如vi、grep和sed的扩展正则表达式模式匹配的格式。</span><br><span class=\"line\">-- &quot;_&quot; 匹配任何单个字符；&quot;%&quot; 匹配任意数目字符(包括零字符)，SQL的模式默认是忽略大小写。关键字 LIKE 或 NOT LINK</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找以b开头的name</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;b%&apos;</span><br><span class=\"line\">-- 查找以&apos;fy&apos;结尾的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;%fy&apos;</span><br><span class=\"line\">-- 查找包含w的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;%w%&apos;</span><br><span class=\"line\">-- 查找正好是5个字符的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;_____&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE LENGTH(NAME) = 5</span><br><span class=\"line\"></span><br><span class=\"line\">-- MySQL提供的模式匹配的其它类型是使用扩展正则表达式。当你对这类模式进行匹配测试时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，它们是同义词)。 </span><br><span class=\"line\">-- &quot;.&quot; 匹配任何单个字符；</span><br><span class=\"line\">-- &quot;[...]&quot; 匹配在方括号内的任何字符，为了命名字符的范围，使用一个“-”。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</span><br><span class=\"line\">-- &quot;*&quot; 匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的“x”字符，“[0-9]*”匹配任何数量的数字，而“.*”匹配任何数量的任何字符。</span><br><span class=\"line\">-- 如果REGEXP模式与被测试值的任何地方匹配，模式就匹配(这不同于LIKE模式匹配，只有与整个值匹配，模式才匹配)。 </span><br><span class=\"line\">-- 为了定位一个模式以便它必须匹配被测试值的开始或结尾，在模式开始处使用“^”或在模式的结尾用“$”。</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找以b开头的name</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^b&apos;</span><br><span class=\"line\">-- 查找以&apos;fy&apos;结尾的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;fy$&apos;</span><br><span class=\"line\">-- 查找包含w的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;w&apos;</span><br><span class=\"line\">-- 查找正好是5个字符的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^.....$&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^.&#123;5&#125;$&apos;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/regexp.html\" target=\"_blank\" rel=\"noopener\">正则表达式在线参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据表操作\"><a href=\"#数据表操作\" class=\"headerlink\" title=\"数据表操作\"></a>数据表操作</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 创建数据库</span><br><span class=\"line\">CREATE DATABASE mydb</span><br><span class=\"line\"></span><br><span class=\"line\">-- 使用数据库</span><br><span class=\"line\">USE mydb</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查看数据表</span><br><span class=\"line\">SHOW TABLES</span><br><span class=\"line\"></span><br><span class=\"line\">-- 创建表</span><br><span class=\"line\">CREATE TABLE pet (</span><br><span class=\"line\">\tNAME VARCHAR(20),</span><br><span class=\"line\">\townerr\tVARCHAR(20),</span><br><span class=\"line\">\tspecies VARCHAR(20),</span><br><span class=\"line\">\tsex CHAR(1),</span><br><span class=\"line\">\tbirth DATE,</span><br><span class=\"line\">\tdeath DATE);</span><br><span class=\"line\"></span><br><span class=\"line\">-- 显示表结构</span><br><span class=\"line\">DESCRIBE pet;</span><br><span class=\"line\">-- 改表的名字 </span><br><span class=\"line\">ALTER TABLE pet RENAME TO pet2; </span><br><span class=\"line\">ALTER TABLE pet2 RENAME TO pet; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 约束：约束（主键Primary key、唯一性Unique、非空Not Null）</span><br><span class=\"line\">-- 自动增张 auto_increment </span><br><span class=\"line\">-- 外键Foreign key-----与reference table_name(col_name列名)配合使用，建表时单独使用 </span><br><span class=\"line\">-- 删除多个表中有关联的数据----设置foreign key 为set null</span><br><span class=\"line\"></span><br><span class=\"line\">-- 删除表</span><br><span class=\"line\">DROP TABLE IF EXISTS pet;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 增加一个字段： </span><br><span class=\"line\">ALTER TABLE pet ADD COLUMN (phone VARCHAR(11)); </span><br><span class=\"line\"></span><br><span class=\"line\">-- 删除一个字段</span><br><span class=\"line\">ALTER TABLE pet DROP phone; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 修改字段名称/类型</span><br><span class=\"line\">ALTER TABLE pet CHANGE phone tel VARCHAR(11)</span><br><span class=\"line\">ALTER TABLE pet CHANGE tel phone VARCHAR(11)</span><br><span class=\"line\"></span><br><span class=\"line\">-- 插入数据</span><br><span class=\"line\">INSERT INTO pet VALUES</span><br><span class=\"line\">\t(&apos;Fluffy&apos;,&apos;Harold&apos;,&apos;cat&apos;,&apos;f&apos;,&apos;1993-02-04&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Claws&apos;,&apos;Gwen&apos;,&apos;cat&apos;,&apos;m&apos;,&apos;1994-03-17&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Buffy&apos;,&apos;Harold&apos;,&apos;dog&apos;,&apos;f&apos;,&apos;1989-05-13&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Fang&apos;,&apos;Benny&apos;,&apos;dog&apos;,&apos;m&apos;,&apos;1990-08-27&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Bowser&apos;,&apos;Diane&apos;,&apos;dog&apos;,&apos;m&apos;,&apos;1979-08-31&apos;,&apos;1995-07-29&apos;),</span><br><span class=\"line\">\t(&apos;Chirpy&apos;,&apos;Gwen&apos;,&apos;bird&apos;,&apos;f&apos;,&apos;1998-09-11&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Whistler&apos;,&apos;Gwen&apos;,&apos;bird&apos;,&apos; &apos;,&apos;1997-12-09&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Puffball&apos;,&apos;Diane&apos;,&apos;hamster&apos;,&apos;f&apos;,&apos;1999-03-30&apos;,NULL),</span><br><span class=\"line\">\t(&apos;Slim&apos;,&apos;Benny&apos;,&apos;snake&apos;,&apos;m&apos;,&apos;1996-04-29&apos;,NULL);</span><br><span class=\"line\">-- 查询表数据</span><br><span class=\"line\">SELECT * FROM pet</span><br><span class=\"line\">-- 清空表数据</span><br><span class=\"line\">DELETE FROM pet</span><br><span class=\"line\">-- 此方法也会使表中的取号器(ID)从1开始</span><br><span class=\"line\">TRUNCATE TABLE pet; </span><br><span class=\"line\"></span><br><span class=\"line\">-- 修改字段值</span><br><span class=\"line\">UPDATE pet SET birth = &apos;1989-08-31&apos; WHERE NAME = &apos;Bowser&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME = &apos;Bowser&apos;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据表查询\"><a href=\"#数据表查询\" class=\"headerlink\" title=\"数据表查询\"></a>数据表查询</h2><h3 id=\"基本查询\"><a href=\"#基本查询\" class=\"headerlink\" title=\"基本查询\"></a>基本查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- DISTINCT 检索出每个唯一的输出记录</span><br><span class=\"line\">SELECT DISTINCT ownerr FROM pet</span><br><span class=\"line\"></span><br><span class=\"line\">-- 排序 order by，对于等同但大小写不同的列，并未定义其顺序，某一列，可以使用BINARY强制执行区分大小写的分类功能，如：ORDER BY BINARY col_name. </span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY birth</span><br><span class=\"line\">-- 默认排序是升序，可以利用关键字进行控制。DESC(降序)、ASC(升序)</span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY birth ASC</span><br><span class=\"line\"></span><br><span class=\"line\">-- 多列进行排序</span><br><span class=\"line\">SELECT NAME,ownerr,birth FROM pet ORDER BY ownerr,birth DESC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日期计算\"><a href=\"#日期计算\" class=\"headerlink\" title=\"日期计算\"></a>日期计算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- YEAR()-提取日期的年部分，MONTH()-提取月份，DAYOFMONTH()-提取所在月份中的日</span><br><span class=\"line\">SELECT birth, YEAR(birth),MONTH(birth),DAYOFMONTH(birth) FROM pet</span><br><span class=\"line\"></span><br><span class=\"line\">-- RIGHT(birth,5)-提取birth的右边5个字符,LEFT - 从左边开始取，MID - 从指定位置(包括)开始取指定长度</span><br><span class=\"line\">SELECT RIGHT(&apos;1234567890&apos;,5),LEFT(&apos;1234567890&apos;,5),MID(&apos;1234567890&apos;,2,4)</span><br><span class=\"line\">-- 提出已近死亡的</span><br><span class=\"line\">-- 出生月份大于当前月份，年龄-1。</span><br><span class=\"line\">SELECT </span><br><span class=\"line\">  NAME,</span><br><span class=\"line\">  birth,</span><br><span class=\"line\">  CURDATE(),</span><br><span class=\"line\">  (YEAR(CURDATE()) - YEAR(birth)) - (RIGHT(CURDATE(), 5) &lt; RIGHT(birth, 5)) AS age </span><br><span class=\"line\">FROM</span><br><span class=\"line\">  pet WHERE death IS NULL  ORDER BY age</span><br><span class=\"line\">  </span><br><span class=\"line\"> -- 查询已死亡的年龄</span><br><span class=\"line\"> SELECT </span><br><span class=\"line\">  NAME,</span><br><span class=\"line\">  birth,</span><br><span class=\"line\">  death,</span><br><span class=\"line\">  (YEAR(death) - YEAR(birth)) - (RIGHT(death, 5) &lt; RIGHT(birth, 5)) AS age </span><br><span class=\"line\">FROM</span><br><span class=\"line\">  pet WHERE death IS NOT NULL ORDER BY age</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查询下一个月谁过生日</span><br><span class=\"line\">SELECT * FROM pet ORDER BY MONTH(birth)</span><br><span class=\"line\">SELECT * FROM pet WHERE MONTH(birth) = MONTH(CURDATE()) + 1</span><br><span class=\"line\">SELECT * FROM pet WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NULL值\"><a href=\"#NULL值\" class=\"headerlink\" title=\"NULL值\"></a>NULL值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- NULL 值的判断，不能使用比较运算符，只能用 is null 或 is not null</span><br><span class=\"line\">SELECT  1 = NULL, 1 &gt; NULL, 1 &lt; NULL,  1 IS NULL,  1 IS NOT NULL </span><br><span class=\"line\"></span><br><span class=\"line\">-- 0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1。</span><br><span class=\"line\">SELECT 0 IS NULL, 0 IS NOT NULL, &apos;&apos; IS NULL, &apos;&apos; IS NOT NULL;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模糊匹配\"><a href=\"#模糊匹配\" class=\"headerlink\" title=\"模糊匹配\"></a>模糊匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- MySQL提供标准的SQL模式匹配，以及一种基于象Unix实用程序如vi、grep和sed的扩展正则表达式模式匹配的格式。</span><br><span class=\"line\">-- &quot;_&quot; 匹配任何单个字符；&quot;%&quot; 匹配任意数目字符(包括零字符)，SQL的模式默认是忽略大小写。关键字 LIKE 或 NOT LINK</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找以b开头的name</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;b%&apos;</span><br><span class=\"line\">-- 查找以&apos;fy&apos;结尾的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;%fy&apos;</span><br><span class=\"line\">-- 查找包含w的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;%w%&apos;</span><br><span class=\"line\">-- 查找正好是5个字符的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME LIKE &apos;_____&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE LENGTH(NAME) = 5</span><br><span class=\"line\"></span><br><span class=\"line\">-- MySQL提供的模式匹配的其它类型是使用扩展正则表达式。当你对这类模式进行匹配测试时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，它们是同义词)。 </span><br><span class=\"line\">-- &quot;.&quot; 匹配任何单个字符；</span><br><span class=\"line\">-- &quot;[...]&quot; 匹配在方括号内的任何字符，为了命名字符的范围，使用一个“-”。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</span><br><span class=\"line\">-- &quot;*&quot; 匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的“x”字符，“[0-9]*”匹配任何数量的数字，而“.*”匹配任何数量的任何字符。</span><br><span class=\"line\">-- 如果REGEXP模式与被测试值的任何地方匹配，模式就匹配(这不同于LIKE模式匹配，只有与整个值匹配，模式才匹配)。 </span><br><span class=\"line\">-- 为了定位一个模式以便它必须匹配被测试值的开始或结尾，在模式开始处使用“^”或在模式的结尾用“$”。</span><br><span class=\"line\"></span><br><span class=\"line\">-- 查找以b开头的name</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^b&apos;</span><br><span class=\"line\">-- 查找以&apos;fy&apos;结尾的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;fy$&apos;</span><br><span class=\"line\">-- 查找包含w的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;w&apos;</span><br><span class=\"line\">-- 查找正好是5个字符的名字</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^.....$&apos;</span><br><span class=\"line\">SELECT * FROM pet WHERE NAME REGEXP &apos;^.&#123;5&#125;$&apos;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/regexp.html\" target=\"_blank\" rel=\"noopener\">正则表达式在线参考</a></p>\n"},{"title":"Dart泛型","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-18T11:54:00.000Z","_content":"\n如果您查看基本数组类型List的API文档，您将看到该类型实际上是List<E>。<...>符号标记列表为泛型(或参数化)类型——具有形式类型参数的类型。根据约定，类型变量具有单字母名称，如E、T、S、K和V。\n## 为什么使用泛型\n泛型通常是类型安全所必需的，他们对于写出严谨高质量的代码是很有用的：\n\n- 适当地指定泛型类型可以生成更好的代码。\n- 您可以使用泛型来减少代码重复。\n\n如果您想要一个列表只包含字符串，您可以将它声明为list (读作“String of String”)。这样，您和其他程序员，以及您的工具就可以检测到将一个非字符串分配到列表中可能是一个错误。这里有一个例子:\n\n```Dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nnames.add(42); // Error\n```\n使用泛型的另一个原因是减少代码重复。泛型允许您在许多类型之间共享一个接口和实现，同时仍然利用静态分析。例如，假设您创建了一个用于缓存对象的接口:\n```dart\nabstract class ObjectCache {\n  Object getByKey(String key);\n  void setByKey(String key, Object value);\n}\n```\n您发现您想要这个接口的特定字符串版本，所以您创建了另一个接口:\n```dart\nabstract class StringCache {\n  String getByKey(String key);\n  void setByKey(String key, String value);\n}\n```\n如果稍后你想要获取这个接口的一个数字特征的版本。\n泛型类型可以省去创建所有这些接口的麻烦。相反，您可以创建一个具有类型参数的接口:\n```dart\nabstract class Cache<T> {\n  T getByKey(String key);\n  void setByKey(String key, T value);\n}\n```\n在这段代码中，T是替代类型。它是一个占位符，您可以将其视为开发人员稍后将定义的类型。\n\n## 使用集合字面量\nList和map字面量可以被参数化。参数化字面量和你已经认识的所有字面量一样，仅仅是在字面量的开始括号之前添加<type>(对于list类型来说)或者添加<keyType, valueType>（对于map类型来说）。\n```dart\nvar names = <String>['Seth', 'Kathy', 'Lars'];\nvar pages = <String, String>{\n  'index.html': 'Homepage',\n  'robots.txt': 'Hints for web robots',\n  'humans.txt': 'We are people, not machines'\n};\n```\n## 构造函数的参数化类型\n要在使用构造函数时指定一个或多个类型，请将类型放在类名后面的尖括号(<…>)中。例如:\n```dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nvar nameSet = Set<String>.from(names);\n```\n下面的代码创建了一个具有整数键和视图类型值的map映射:\n```dart\nvar views = Map<int, View>();\n```\n## 泛型集合及其包含的类型\nDart通用类型被具体化，这意味着它们在运行时携带它们的类型信息。例如，您可以测试集合的类型:\n```dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nprint(names is List<String>); // true\n```\n> 注意:相反，Java中的泛型使用擦除，这意味着泛型类型参数在运行时被删除。在Java中，您可以测试一个对象是否是一个列表，但不能测试它是否是List。\n\n## 限制参数化类型\n在实现泛型类型时，您可能希望限制其参数的类型。你可以使用extends。\n```dart\nclass Foo<T extends SomeBaseClass> {\n  // Implementation goes here...\n  String toString() => \"Instance of 'Foo<$T>'\";\n}\n\nclass Extender extends SomeBaseClass {...}\n```\n可以使用SomeBaseClass 或它的任何子类作为泛型参数:\n```dart\nvar someBaseClassFoo = Foo<SomeBaseClass>();\nvar extenderFoo = Foo<Extender>();\n```\n也可以不指定泛型参数:\n```dart\nvar foo = Foo();\nprint(foo); // Instance of 'Foo<SomeBaseClass>'\n```\n指定任何非somebaseclass类型都会导致错误:\n```dart\nvar foo = Foo<Object>();\n```\n## 使用泛型方法\n最初，Dart仅仅在类中支持泛型。后来一种称为泛型方法的新语法允许在方法和函数中使用类型参数。\n```dart\nT first<T>(List<T> ts) {\n  // Do some initial work or error checking, then...\n  T tmp = ts[0];\n  // Do some additional checking or processing...\n  return tmp;\n}\n```\n在这里，first上的泛型参数(<T>)允许你在很多地方使用类型参数T：\n\n- 在函数的返回中返回类型(T)\n- 在参数的类型中使用(List<T>)\n- 在局部变量的类型中(T tmp)","source":"_posts/dart/08_泛型.md","raw":"---\ntitle: Dart泛型\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-18 19:54:00   \n---\n\n如果您查看基本数组类型List的API文档，您将看到该类型实际上是List<E>。<...>符号标记列表为泛型(或参数化)类型——具有形式类型参数的类型。根据约定，类型变量具有单字母名称，如E、T、S、K和V。\n## 为什么使用泛型\n泛型通常是类型安全所必需的，他们对于写出严谨高质量的代码是很有用的：\n\n- 适当地指定泛型类型可以生成更好的代码。\n- 您可以使用泛型来减少代码重复。\n\n如果您想要一个列表只包含字符串，您可以将它声明为list (读作“String of String”)。这样，您和其他程序员，以及您的工具就可以检测到将一个非字符串分配到列表中可能是一个错误。这里有一个例子:\n\n```Dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nnames.add(42); // Error\n```\n使用泛型的另一个原因是减少代码重复。泛型允许您在许多类型之间共享一个接口和实现，同时仍然利用静态分析。例如，假设您创建了一个用于缓存对象的接口:\n```dart\nabstract class ObjectCache {\n  Object getByKey(String key);\n  void setByKey(String key, Object value);\n}\n```\n您发现您想要这个接口的特定字符串版本，所以您创建了另一个接口:\n```dart\nabstract class StringCache {\n  String getByKey(String key);\n  void setByKey(String key, String value);\n}\n```\n如果稍后你想要获取这个接口的一个数字特征的版本。\n泛型类型可以省去创建所有这些接口的麻烦。相反，您可以创建一个具有类型参数的接口:\n```dart\nabstract class Cache<T> {\n  T getByKey(String key);\n  void setByKey(String key, T value);\n}\n```\n在这段代码中，T是替代类型。它是一个占位符，您可以将其视为开发人员稍后将定义的类型。\n\n## 使用集合字面量\nList和map字面量可以被参数化。参数化字面量和你已经认识的所有字面量一样，仅仅是在字面量的开始括号之前添加<type>(对于list类型来说)或者添加<keyType, valueType>（对于map类型来说）。\n```dart\nvar names = <String>['Seth', 'Kathy', 'Lars'];\nvar pages = <String, String>{\n  'index.html': 'Homepage',\n  'robots.txt': 'Hints for web robots',\n  'humans.txt': 'We are people, not machines'\n};\n```\n## 构造函数的参数化类型\n要在使用构造函数时指定一个或多个类型，请将类型放在类名后面的尖括号(<…>)中。例如:\n```dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nvar nameSet = Set<String>.from(names);\n```\n下面的代码创建了一个具有整数键和视图类型值的map映射:\n```dart\nvar views = Map<int, View>();\n```\n## 泛型集合及其包含的类型\nDart通用类型被具体化，这意味着它们在运行时携带它们的类型信息。例如，您可以测试集合的类型:\n```dart\nvar names = List<String>();\nnames.addAll(['Seth', 'Kathy', 'Lars']);\nprint(names is List<String>); // true\n```\n> 注意:相反，Java中的泛型使用擦除，这意味着泛型类型参数在运行时被删除。在Java中，您可以测试一个对象是否是一个列表，但不能测试它是否是List。\n\n## 限制参数化类型\n在实现泛型类型时，您可能希望限制其参数的类型。你可以使用extends。\n```dart\nclass Foo<T extends SomeBaseClass> {\n  // Implementation goes here...\n  String toString() => \"Instance of 'Foo<$T>'\";\n}\n\nclass Extender extends SomeBaseClass {...}\n```\n可以使用SomeBaseClass 或它的任何子类作为泛型参数:\n```dart\nvar someBaseClassFoo = Foo<SomeBaseClass>();\nvar extenderFoo = Foo<Extender>();\n```\n也可以不指定泛型参数:\n```dart\nvar foo = Foo();\nprint(foo); // Instance of 'Foo<SomeBaseClass>'\n```\n指定任何非somebaseclass类型都会导致错误:\n```dart\nvar foo = Foo<Object>();\n```\n## 使用泛型方法\n最初，Dart仅仅在类中支持泛型。后来一种称为泛型方法的新语法允许在方法和函数中使用类型参数。\n```dart\nT first<T>(List<T> ts) {\n  // Do some initial work or error checking, then...\n  T tmp = ts[0];\n  // Do some additional checking or processing...\n  return tmp;\n}\n```\n在这里，first上的泛型参数(<T>)允许你在很多地方使用类型参数T：\n\n- 在函数的返回中返回类型(T)\n- 在参数的类型中使用(List<T>)\n- 在局部变量的类型中(T tmp)","slug":"dart/08_泛型","published":1,"updated":"2019-10-02T09:26:28.196Z","layout":"post","photos":[],"link":"","_id":"ck19bvb0e002h00wkai62q4qa","content":"<p>如果您查看基本数组类型List的API文档，您将看到该类型实际上是List<e>。&lt;…&gt;符号标记列表为泛型(或参数化)类型——具有形式类型参数的类型。根据约定，类型变量具有单字母名称，如E、T、S、K和V。</e></p>\n<h2 id=\"为什么使用泛型\"><a href=\"#为什么使用泛型\" class=\"headerlink\" title=\"为什么使用泛型\"></a>为什么使用泛型</h2><p>泛型通常是类型安全所必需的，他们对于写出严谨高质量的代码是很有用的：</p>\n<ul>\n<li>适当地指定泛型类型可以生成更好的代码。</li>\n<li>您可以使用泛型来减少代码重复。</li>\n</ul>\n<p>如果您想要一个列表只包含字符串，您可以将它声明为list (读作“String of String”)。这样，您和其他程序员，以及您的工具就可以检测到将一个非字符串分配到列表中可能是一个错误。这里有一个例子:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\">names.add(<span class=\"number\">42</span>); <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<p>使用泛型的另一个原因是减少代码重复。泛型允许您在许多类型之间共享一个接口和实现，同时仍然利用静态分析。例如，假设您创建了一个用于缓存对象的接口:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span> getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, <span class=\"built_in\">Object</span> value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您发现您想要这个接口的特定字符串版本，所以您创建了另一个接口:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, <span class=\"built_in\">String</span> value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果稍后你想要获取这个接口的一个数字特征的版本。<br>泛型类型可以省去创建所有这些接口的麻烦。相反，您可以创建一个具有类型参数的接口:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  T getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, T value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这段代码中，T是替代类型。它是一个占位符，您可以将其视为开发人员稍后将定义的类型。</p>\n<h2 id=\"使用集合字面量\"><a href=\"#使用集合字面量\" class=\"headerlink\" title=\"使用集合字面量\"></a>使用集合字面量</h2><p>List和map字面量可以被参数化。参数化字面量和你已经认识的所有字面量一样，仅仅是在字面量的开始括号之前添加<type>(对于list类型来说)或者添加&lt;keyType, valueType&gt;（对于map类型来说）。</type></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = &lt;<span class=\"built_in\">String</span>&gt;[<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> pages = &lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;&#123;</span><br><span class=\"line\">  <span class=\"string\">'index.html'</span>: <span class=\"string\">'Homepage'</span>,</span><br><span class=\"line\">  <span class=\"string\">'robots.txt'</span>: <span class=\"string\">'Hints for web robots'</span>,</span><br><span class=\"line\">  <span class=\"string\">'humans.txt'</span>: <span class=\"string\">'We are people, not machines'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造函数的参数化类型\"><a href=\"#构造函数的参数化类型\" class=\"headerlink\" title=\"构造函数的参数化类型\"></a>构造函数的参数化类型</h2><p>要在使用构造函数时指定一个或多个类型，请将类型放在类名后面的尖括号(&lt;…&gt;)中。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> nameSet = <span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure>\n\n<p>下面的代码创建了一个具有整数键和视图类型值的map映射:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> views = <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">int</span>, View&gt;();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"泛型集合及其包含的类型\"><a href=\"#泛型集合及其包含的类型\" class=\"headerlink\" title=\"泛型集合及其包含的类型\"></a>泛型集合及其包含的类型</h2><p>Dart通用类型被具体化，这意味着它们在运行时携带它们的类型信息。例如，您可以测试集合的类型:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(names <span class=\"keyword\">is</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:相反，Java中的泛型使用擦除，这意味着泛型类型参数在运行时被删除。在Java中，您可以测试一个对象是否是一个列表，但不能测试它是否是List。</p>\n</blockquote>\n<h2 id=\"限制参数化类型\"><a href=\"#限制参数化类型\" class=\"headerlink\" title=\"限制参数化类型\"></a>限制参数化类型</h2><p>在实现泛型类型时，您可能希望限制其参数的类型。你可以使用extends。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Implementation goes here...</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> toString() =&gt; <span class=\"string\">\"Instance of 'Foo&lt;<span class=\"subst\">$T</span>&gt;'\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Extender</span> <span class=\"keyword\">extends</span> <span class=\"title\">SomeBaseClass</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以使用SomeBaseClass 或它的任何子类作为泛型参数:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class=\"line\"><span class=\"keyword\">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>也可以不指定泛型参数:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = Foo();</span><br><span class=\"line\"><span class=\"built_in\">print</span>(foo); <span class=\"comment\">// Instance of 'Foo&lt;SomeBaseClass&gt;'</span></span><br></pre></td></tr></table></figure>\n\n<p>指定任何非somebaseclass类型都会导致错误:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = Foo&lt;<span class=\"built_in\">Object</span>&gt;();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用泛型方法\"><a href=\"#使用泛型方法\" class=\"headerlink\" title=\"使用泛型方法\"></a>使用泛型方法</h2><p>最初，Dart仅仅在类中支持泛型。后来一种称为泛型方法的新语法允许在方法和函数中使用类型参数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T first&lt;T&gt;(<span class=\"built_in\">List</span>&lt;T&gt; ts) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do some initial work or error checking, then...</span></span><br><span class=\"line\">  T tmp = ts[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"comment\">// Do some additional checking or processing...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，first上的泛型参数(<t>)允许你在很多地方使用类型参数T：</t></p>\n<ul>\n<li>在函数的返回中返回类型(T)</li>\n<li>在参数的类型中使用(List<t>)</t></li>\n<li>在局部变量的类型中(T tmp)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>如果您查看基本数组类型List的API文档，您将看到该类型实际上是List<e>。&lt;…&gt;符号标记列表为泛型(或参数化)类型——具有形式类型参数的类型。根据约定，类型变量具有单字母名称，如E、T、S、K和V。</e></p>\n<h2 id=\"为什么使用泛型\"><a href=\"#为什么使用泛型\" class=\"headerlink\" title=\"为什么使用泛型\"></a>为什么使用泛型</h2><p>泛型通常是类型安全所必需的，他们对于写出严谨高质量的代码是很有用的：</p>\n<ul>\n<li>适当地指定泛型类型可以生成更好的代码。</li>\n<li>您可以使用泛型来减少代码重复。</li>\n</ul>\n<p>如果您想要一个列表只包含字符串，您可以将它声明为list (读作“String of String”)。这样，您和其他程序员，以及您的工具就可以检测到将一个非字符串分配到列表中可能是一个错误。这里有一个例子:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\">names.add(<span class=\"number\">42</span>); <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<p>使用泛型的另一个原因是减少代码重复。泛型允许您在许多类型之间共享一个接口和实现，同时仍然利用静态分析。例如，假设您创建了一个用于缓存对象的接口:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span> getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, <span class=\"built_in\">Object</span> value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您发现您想要这个接口的特定字符串版本，所以您创建了另一个接口:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, <span class=\"built_in\">String</span> value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果稍后你想要获取这个接口的一个数字特征的版本。<br>泛型类型可以省去创建所有这些接口的麻烦。相反，您可以创建一个具有类型参数的接口:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  T getByKey(<span class=\"built_in\">String</span> key);</span><br><span class=\"line\">  <span class=\"keyword\">void</span> setByKey(<span class=\"built_in\">String</span> key, T value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这段代码中，T是替代类型。它是一个占位符，您可以将其视为开发人员稍后将定义的类型。</p>\n<h2 id=\"使用集合字面量\"><a href=\"#使用集合字面量\" class=\"headerlink\" title=\"使用集合字面量\"></a>使用集合字面量</h2><p>List和map字面量可以被参数化。参数化字面量和你已经认识的所有字面量一样，仅仅是在字面量的开始括号之前添加<type>(对于list类型来说)或者添加&lt;keyType, valueType&gt;（对于map类型来说）。</type></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = &lt;<span class=\"built_in\">String</span>&gt;[<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> pages = &lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;&#123;</span><br><span class=\"line\">  <span class=\"string\">'index.html'</span>: <span class=\"string\">'Homepage'</span>,</span><br><span class=\"line\">  <span class=\"string\">'robots.txt'</span>: <span class=\"string\">'Hints for web robots'</span>,</span><br><span class=\"line\">  <span class=\"string\">'humans.txt'</span>: <span class=\"string\">'We are people, not machines'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造函数的参数化类型\"><a href=\"#构造函数的参数化类型\" class=\"headerlink\" title=\"构造函数的参数化类型\"></a>构造函数的参数化类型</h2><p>要在使用构造函数时指定一个或多个类型，请将类型放在类名后面的尖括号(&lt;…&gt;)中。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> nameSet = <span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure>\n\n<p>下面的代码创建了一个具有整数键和视图类型值的map映射:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> views = <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">int</span>, View&gt;();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"泛型集合及其包含的类型\"><a href=\"#泛型集合及其包含的类型\" class=\"headerlink\" title=\"泛型集合及其包含的类型\"></a>泛型集合及其包含的类型</h2><p>Dart通用类型被具体化，这意味着它们在运行时携带它们的类型信息。例如，您可以测试集合的类型:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;();</span><br><span class=\"line\">names.addAll([<span class=\"string\">'Seth'</span>, <span class=\"string\">'Kathy'</span>, <span class=\"string\">'Lars'</span>]);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(names <span class=\"keyword\">is</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt;); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:相反，Java中的泛型使用擦除，这意味着泛型类型参数在运行时被删除。在Java中，您可以测试一个对象是否是一个列表，但不能测试它是否是List。</p>\n</blockquote>\n<h2 id=\"限制参数化类型\"><a href=\"#限制参数化类型\" class=\"headerlink\" title=\"限制参数化类型\"></a>限制参数化类型</h2><p>在实现泛型类型时，您可能希望限制其参数的类型。你可以使用extends。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>&lt;<span class=\"title\">T</span> <span class=\"keyword\">extends</span> <span class=\"title\">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Implementation goes here...</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> toString() =&gt; <span class=\"string\">\"Instance of 'Foo&lt;<span class=\"subst\">$T</span>&gt;'\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Extender</span> <span class=\"keyword\">extends</span> <span class=\"title\">SomeBaseClass</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以使用SomeBaseClass 或它的任何子类作为泛型参数:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class=\"line\"><span class=\"keyword\">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>也可以不指定泛型参数:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = Foo();</span><br><span class=\"line\"><span class=\"built_in\">print</span>(foo); <span class=\"comment\">// Instance of 'Foo&lt;SomeBaseClass&gt;'</span></span><br></pre></td></tr></table></figure>\n\n<p>指定任何非somebaseclass类型都会导致错误:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = Foo&lt;<span class=\"built_in\">Object</span>&gt;();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用泛型方法\"><a href=\"#使用泛型方法\" class=\"headerlink\" title=\"使用泛型方法\"></a>使用泛型方法</h2><p>最初，Dart仅仅在类中支持泛型。后来一种称为泛型方法的新语法允许在方法和函数中使用类型参数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T first&lt;T&gt;(<span class=\"built_in\">List</span>&lt;T&gt; ts) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Do some initial work or error checking, then...</span></span><br><span class=\"line\">  T tmp = ts[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"comment\">// Do some additional checking or processing...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，first上的泛型参数(<t>)允许你在很多地方使用类型参数T：</t></p>\n<ul>\n<li>在函数的返回中返回类型(T)</li>\n<li>在参数的类型中使用(List<t>)</t></li>\n<li>在局部变量的类型中(T tmp)</li>\n</ul>\n"},{"title":"C语言指正|结构体|枚举","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-19T09:33:00.000Z","_content":"# 指针\n## 概述\n指针就是用来保存变量的地址的变量\n\n- 访问\n    1. 我们通过`&`来获取变量的地址。\n    2. `&`这个操作符只能指向变量或者是数组。\n    3. `&`是获取地址的操作符。\n    4. 使用`%p`来打印地址。\n\n- 本质\n    指针是一个4字节（或是8字节）的一个int的整数。换句话说也就一个int 型的变量\n- 指针变量\n    1. 指针变量是用来保存地址的。\n    2. 指针变量里保存的地址可以修改。\n    3. 指针变量可以指向特殊的数据类型。\n    4. 可以有多个指针变量里的值是相同的。\n\n- 一级指针的简单使用\n    指针访问内存可以通过`*`这个操作符去访问所指向的内存空间。\n\n## 指针的定义和初始化\n- type * identifier\n    1. 没有初始化的指针，称之为野指针。\n    2. 指针里面是一个随机的值。\n    3. 野指针有很大的风险。\n    4. 指针可以作为函数的参数和返回值。\n-   \n```\n// 声明一个int指针\nint *ptr;\n// 声明一个int值\nint val = 1;\n// 为指针分配一个int值的引用\nptr = &val;\n// 对指针进行取值，打印存储在指针地址中的内容\nint deref = *ptr;\nprintf(\"%d\\n\", deref);\n```\n第2行，我们通过`*`操作符声明了一个int指针。接着我们声明了一个int变量并赋值为1。然后我们用int变量的地址初始化我们的int指针。接下来对int指针取值，用变量的内存地址初始化int指针。最终，我们打印输出变量值，内容为1。\n\n第6行的`&val`是一个引用。在val变量声明并初始化内存之后，通过在变量名之前使用地址操作符`&`我们可以直接引用变量的内存地址。\n第8行，我们再一次使用`*`操作符来对该指针取值，可直接获得指针指向的内存地址中的数据。由于指针声明的类型是int，所以取到的值是指针指向的内存地址存储的int值。\n\n- void指针、NULL指针和未初始化指针\n一个指针可以被声明为void类型，比如void *x。一个指针可以被赋值为NULL。一个指针变量声明之后但没有被赋值，叫做未初始化指针。\n\n```\nint *uninit; \n// int指针未初始化\nint *nullptr = NULL; \n// 初始化为NULL\nvoid *vptr; \n// void指针未初始化\nint val = 1;\nint *iptr;\nint *castptr;\n \n// void类型可以存储任意类型的指针或引用\niptr = &val;\nvptr = iptr;\nprintf(\"iptr=%p, vptr=%p\\n\", iptr, vptr);\n \n// 通过显示转换，我们可以把一个void指针转成\n// int指针并进行取值\ncastptr = (int *)vptr;\nprintf(\"*castptr=%d\\n\", *castptr);\n \n// 打印null和未初始化指针\nprintf(\"uninit=%p, nullptr=%p\\n\", uninit, nullptr);\n// 不知道你会得到怎样的返回值，会是随机的垃圾地址吗？\n// printf(\"*nullptr=%d\\n\", nullptr);\n// 这里会产生一个段错误\n// printf(\"*nullptr=%d\\n\", nullptr);\n执行上面的代码，你会得到类似下面对应不同内存地址的输出。\n\niptr=0x7fff94b89c6c, vptr=0x7fff94b89c6c\n*castptr=1\nuninit=0x7fff94b89d50, nullptr=(nil)\n```\n\n第1行我们声明了一个未初始化int指针。所有的指针在赋值为NULL、一个引用（地址）或者另一个指针之前都是未被初始化的。第2行我们声明了一个NULL指针。第3行声明了一个void指针。第4行到第6行声明了一个int值和几个int指针。\n\n第9行到11行，我们为int指针赋值为一个引用并把int指针赋值为void指针。void指针可以保存各种其它指针类型。大多数时候它们被用来存储数据结构。可以注意到，第11行我们打印了int和void指针的地址。它们现在指向了同样的内存地址。所有的指针都存储了内存地址。它们的类型只在取值时起作用。\n\n第15到16行，我们把void指针转换为int指针castptr。请注意这里需要显示转换。虽然C语言并不要求显示地转换，但这样会增加代码的可读性。接着我们对castptr指针取值，值为1。\n\n第19行非常有意思，在这里打印未初始化指针和NULL指针。值得注意的是，未初始化指针是有内存地址的，而且是一个垃圾地址。不知道这个内存地址指向的值是什么。这就是为什么不要对未初始化指针取值的原因。最好的情况是你取到的是垃圾地址接下来你需要对程序进行调试，最坏的情况则会导致程序崩溃。\n>NULL指针被初始化为o。NULL是一个特殊的地址，用NULL赋值的指针指向的地址为0而不是随机的地址。只有当你准备使用这个地址时有效。不要对NULL地址取值，否则会产生段错误。\n\n- 指针和数组\n    - C语言的数组表示一段连续的内存空间，用来存储多个特定类型的对象。与之相反，指针用来存储单个内存地址。数组和指针不是同一种结构因此不可以互相转换。而数组变量指向了数组的第一个元素的内存地址。\n    - 一个数组变量是一个常量。即使指针变量指向同样的地址或者一个不同的数组，也不能把指针赋值给数组变量。也不可以将一个数组变量赋值给另一个数组。然而，可以把一个数组变量赋值给指针，这一点似乎让人感到费解。把数组变量赋值给指针时，实际上是把指向数组第一个元素的地址赋给指针。\n\n```\nint myarray[4] = {1,2,3,0};\nint *ptr = myarray;\nprintf(\"*ptr=%d\\n\", *ptr);\n \n// 数组变量是常量，不能做下面的赋值\n// myarray = ptr\n// myarray = myarray2\n// myarray = &myarray2[0]\n```\n第1行初始化了一个int数组，第2行用数组变量初始化了一个int指针。由于数组变量实际上是第一个元素的地址，因此我们可以把这个地址赋值给指针。这个赋值与int *ptr = &myarray[0]效果相同，显示地把数组的第一个元素地址赋值到了ptr引用。这里需要注意的是，这里指针需要和数组的元素类型保持一致，除非指针类型为void。\n\n- 指针与`结构体`\n就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。\n\n```\nstruct person {\n  int age;\n  char *name;\n};\nstruct person first;\nstruct person *ptr;\n \nfirst.age = 21;\nchar *fullname = \"full name\";\nfirst.name = fullname;\nptr = &first;\n \nprintf(\"age=%d, name=%s\\n\", first.age, ptr->name);\n```\n\n第1至6行声明了一个person结构体，一个变量指向了一个person结构体和指向person结构体的指针。第8行为age成员赋了一个int值。第9至10行我们声明了一个char指针并赋值给一个char数组并赋值给结构体name成员。第11行我们把一个person结构体引用赋值给结构体变量。\n\n第13行我们打印了结构体实例的age和name。这里需要注意两个不同的符号，’.’ 和 ‘->’ 。结构体实例可以通过使用 ‘.’ 符号访问age变量。对于结构体实例的指针，我们可以通过 ‘->’ 符号访问name变量。也可以同样通过(*ptr).name来访问name变量。\n\n# 结构体\n## 概述\n### 什么事结构体\n1. C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。\n2. 在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。\n3. 为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。\n\n### 结构体的定义\n1. 定义形式：结构体内部的元素，也就是组成成分，我们一般称为\"成员\"。\n结构体的一般定义形式为：\n```\nstruct　结构体名{     \n     类型名1　成员名1;     \n     类型名2　成员名2;     \n     ……     \n     类型名n　成员名n;     \n };\n```\n2. 先定义结构体类型，再定义变量。\n```\nstruct Student {\n     char *name;\n     int age;\n }; \n struct Student stu;\n```\n3. 定义和变量同时进行\n```\nstruct Student {\n    char *name;\n    int age;\n} stu;\n// 结构体变量名为stu\n```\n4. 直接定义结构体类型变量，省略类型名\n```\nstruct {\n    char *name;\n    int age;\n} stu;\n// 结构体变量名为stu\n```\n\n### 注意事项\n- 不可以在结构体本身进行递归定义\n- 可以包含别的结构体\n\n### 内存分配\n- 定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量。\n```\nstruct Student {\n     char *name;\n     int age;\n };\nstruct Student stu;\n// 第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。\n ```\n- 结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列。\n```\nstruct Student {\n     char *name; // 姓名\n     int age; // 年龄\n     float height; // 身高\n };\n// 在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。\n```\n\n### 结构体初始化\n- 将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。\n比如初始化Student结构体变量stu\n```\n struct Student {\n     char *name;\n     int age;\n }; \nstruct Student stu = {“NJ\", 27};\n```\n- 只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是错误的\n```\nstruct Student stu;\nstu = {“NJ\", 27};\n```\n\n### 操作结构体\n1. 一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名\n```\nstruct Student {\n     char *name;\n     int age;\n };\n struct Student stu;\n // 访问stu的age成员\n stu.age = 27;\n// 第9行对结构体的age成员进行了赋值。\".\"称为成员运算符，它在所有运算符中优先级最高\n```\n\n2. 如果某个成员也是结构体变量，可以连续使用成员运算符\".\"访问最低一级成员\n```\nstruct Date {\n       int year;\n       int month;\n       int day;\n  };\n  \n  struct Student {\n      char *name;\n      struct Date birthday;\n };\n \n struct Student stu;\n stu.birthday.year = 1986;\n stu.birthday.month = 9;\n stu.birthday.day = 10;\n```\n\n3. 相同类型的结构体变量之间可以进行整体赋值\n```\nstruct Student {\n      char *name;\n      int age;\n};  \nstruct Student stu1 = {“NJ”, 27};  \n// 将stu1直接赋值给stu2\nstruct Student stu2 = stu1; \nprintf(\"age is %d\", stu2.age);\n```\n\n4. 将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。\n\n5. 指向结构体的指针\n    每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量\n    - 结构体指针变量的定义形式：struct 结构体名称 *指针变量名\n    - 有了指向结构体的指针，那么就有3种访问结构体成员的方式\n    - 结构体变量名.成员名\n    - (*指针变量名).成员名\n    - 指针变量名->成员名\n\n# 枚举\n## 基本概念\n>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。\n\n### 定义\n1. 一般形式为：enum　枚举名　{枚举元素1,枚举元素2,……};\n```\nenum Season {\n\tspring, \n\tsummer, \n\tautumn, \n\tWinter\n}; \n```\n2. 先定义枚举类型，再定义枚举变量\n```\nenum Season {\n\tspring, \n\tsummer, \n\tautumn, \n\tWinter\n}; \n2.enum Season s;\n```\n3. 定义枚举类型的同时定义枚举变量\n```\nenum Season {\n\tspring, \n\tsummer,\n\tautumn,\n \twinter\n} s;\n```\n4. 省略枚举名称，直接定义枚举变量\n```\nenum{\n  spring,\n     summer,\n     autumn, \n     winter\n} s;\n```\n\n### 枚举使用的注意\n1. C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。\n2. 枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。\n```\nenum Season {spring, summer, autumn, winter};\n// 也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3\n```\n3. 也可以在定义枚举类型时改变枚举元素的值\n```\nenum season {spring, summer=3, autumn, winter};\n// 没有指定值的枚举元素，其值为前一元素加1。也就说spring的值为0，summer的值为3，autumn的值为4，winter的值为5\n```\n\n### 赋值\n- 可以给枚举变量赋枚举常量或者整型值\n```\nenum Season {spring, summer, autumn, winter} s;\ns = spring; // 等价于 s = 0;\ns = 3; // 等价于 s = winter;\n```\n\n### 遍历枚举元素\n```\nenum Season {spring, summer, autumn, winter} s;\n// 遍历枚举元素\nfor (s = spring; s <= winter; s++) {\n    printf(\"枚举元素：%d \\n\", s);\n}\n```\n","source":"_posts/c/C语言指针、结构体、枚举.md","raw":"---\ntitle: C语言指正|结构体|枚举\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-19 17:33:00   \n---\n# 指针\n## 概述\n指针就是用来保存变量的地址的变量\n\n- 访问\n    1. 我们通过`&`来获取变量的地址。\n    2. `&`这个操作符只能指向变量或者是数组。\n    3. `&`是获取地址的操作符。\n    4. 使用`%p`来打印地址。\n\n- 本质\n    指针是一个4字节（或是8字节）的一个int的整数。换句话说也就一个int 型的变量\n- 指针变量\n    1. 指针变量是用来保存地址的。\n    2. 指针变量里保存的地址可以修改。\n    3. 指针变量可以指向特殊的数据类型。\n    4. 可以有多个指针变量里的值是相同的。\n\n- 一级指针的简单使用\n    指针访问内存可以通过`*`这个操作符去访问所指向的内存空间。\n\n## 指针的定义和初始化\n- type * identifier\n    1. 没有初始化的指针，称之为野指针。\n    2. 指针里面是一个随机的值。\n    3. 野指针有很大的风险。\n    4. 指针可以作为函数的参数和返回值。\n-   \n```\n// 声明一个int指针\nint *ptr;\n// 声明一个int值\nint val = 1;\n// 为指针分配一个int值的引用\nptr = &val;\n// 对指针进行取值，打印存储在指针地址中的内容\nint deref = *ptr;\nprintf(\"%d\\n\", deref);\n```\n第2行，我们通过`*`操作符声明了一个int指针。接着我们声明了一个int变量并赋值为1。然后我们用int变量的地址初始化我们的int指针。接下来对int指针取值，用变量的内存地址初始化int指针。最终，我们打印输出变量值，内容为1。\n\n第6行的`&val`是一个引用。在val变量声明并初始化内存之后，通过在变量名之前使用地址操作符`&`我们可以直接引用变量的内存地址。\n第8行，我们再一次使用`*`操作符来对该指针取值，可直接获得指针指向的内存地址中的数据。由于指针声明的类型是int，所以取到的值是指针指向的内存地址存储的int值。\n\n- void指针、NULL指针和未初始化指针\n一个指针可以被声明为void类型，比如void *x。一个指针可以被赋值为NULL。一个指针变量声明之后但没有被赋值，叫做未初始化指针。\n\n```\nint *uninit; \n// int指针未初始化\nint *nullptr = NULL; \n// 初始化为NULL\nvoid *vptr; \n// void指针未初始化\nint val = 1;\nint *iptr;\nint *castptr;\n \n// void类型可以存储任意类型的指针或引用\niptr = &val;\nvptr = iptr;\nprintf(\"iptr=%p, vptr=%p\\n\", iptr, vptr);\n \n// 通过显示转换，我们可以把一个void指针转成\n// int指针并进行取值\ncastptr = (int *)vptr;\nprintf(\"*castptr=%d\\n\", *castptr);\n \n// 打印null和未初始化指针\nprintf(\"uninit=%p, nullptr=%p\\n\", uninit, nullptr);\n// 不知道你会得到怎样的返回值，会是随机的垃圾地址吗？\n// printf(\"*nullptr=%d\\n\", nullptr);\n// 这里会产生一个段错误\n// printf(\"*nullptr=%d\\n\", nullptr);\n执行上面的代码，你会得到类似下面对应不同内存地址的输出。\n\niptr=0x7fff94b89c6c, vptr=0x7fff94b89c6c\n*castptr=1\nuninit=0x7fff94b89d50, nullptr=(nil)\n```\n\n第1行我们声明了一个未初始化int指针。所有的指针在赋值为NULL、一个引用（地址）或者另一个指针之前都是未被初始化的。第2行我们声明了一个NULL指针。第3行声明了一个void指针。第4行到第6行声明了一个int值和几个int指针。\n\n第9行到11行，我们为int指针赋值为一个引用并把int指针赋值为void指针。void指针可以保存各种其它指针类型。大多数时候它们被用来存储数据结构。可以注意到，第11行我们打印了int和void指针的地址。它们现在指向了同样的内存地址。所有的指针都存储了内存地址。它们的类型只在取值时起作用。\n\n第15到16行，我们把void指针转换为int指针castptr。请注意这里需要显示转换。虽然C语言并不要求显示地转换，但这样会增加代码的可读性。接着我们对castptr指针取值，值为1。\n\n第19行非常有意思，在这里打印未初始化指针和NULL指针。值得注意的是，未初始化指针是有内存地址的，而且是一个垃圾地址。不知道这个内存地址指向的值是什么。这就是为什么不要对未初始化指针取值的原因。最好的情况是你取到的是垃圾地址接下来你需要对程序进行调试，最坏的情况则会导致程序崩溃。\n>NULL指针被初始化为o。NULL是一个特殊的地址，用NULL赋值的指针指向的地址为0而不是随机的地址。只有当你准备使用这个地址时有效。不要对NULL地址取值，否则会产生段错误。\n\n- 指针和数组\n    - C语言的数组表示一段连续的内存空间，用来存储多个特定类型的对象。与之相反，指针用来存储单个内存地址。数组和指针不是同一种结构因此不可以互相转换。而数组变量指向了数组的第一个元素的内存地址。\n    - 一个数组变量是一个常量。即使指针变量指向同样的地址或者一个不同的数组，也不能把指针赋值给数组变量。也不可以将一个数组变量赋值给另一个数组。然而，可以把一个数组变量赋值给指针，这一点似乎让人感到费解。把数组变量赋值给指针时，实际上是把指向数组第一个元素的地址赋给指针。\n\n```\nint myarray[4] = {1,2,3,0};\nint *ptr = myarray;\nprintf(\"*ptr=%d\\n\", *ptr);\n \n// 数组变量是常量，不能做下面的赋值\n// myarray = ptr\n// myarray = myarray2\n// myarray = &myarray2[0]\n```\n第1行初始化了一个int数组，第2行用数组变量初始化了一个int指针。由于数组变量实际上是第一个元素的地址，因此我们可以把这个地址赋值给指针。这个赋值与int *ptr = &myarray[0]效果相同，显示地把数组的第一个元素地址赋值到了ptr引用。这里需要注意的是，这里指针需要和数组的元素类型保持一致，除非指针类型为void。\n\n- 指针与`结构体`\n就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。\n\n```\nstruct person {\n  int age;\n  char *name;\n};\nstruct person first;\nstruct person *ptr;\n \nfirst.age = 21;\nchar *fullname = \"full name\";\nfirst.name = fullname;\nptr = &first;\n \nprintf(\"age=%d, name=%s\\n\", first.age, ptr->name);\n```\n\n第1至6行声明了一个person结构体，一个变量指向了一个person结构体和指向person结构体的指针。第8行为age成员赋了一个int值。第9至10行我们声明了一个char指针并赋值给一个char数组并赋值给结构体name成员。第11行我们把一个person结构体引用赋值给结构体变量。\n\n第13行我们打印了结构体实例的age和name。这里需要注意两个不同的符号，’.’ 和 ‘->’ 。结构体实例可以通过使用 ‘.’ 符号访问age变量。对于结构体实例的指针，我们可以通过 ‘->’ 符号访问name变量。也可以同样通过(*ptr).name来访问name变量。\n\n# 结构体\n## 概述\n### 什么事结构体\n1. C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。\n2. 在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。\n3. 为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。\n\n### 结构体的定义\n1. 定义形式：结构体内部的元素，也就是组成成分，我们一般称为\"成员\"。\n结构体的一般定义形式为：\n```\nstruct　结构体名{     \n     类型名1　成员名1;     \n     类型名2　成员名2;     \n     ……     \n     类型名n　成员名n;     \n };\n```\n2. 先定义结构体类型，再定义变量。\n```\nstruct Student {\n     char *name;\n     int age;\n }; \n struct Student stu;\n```\n3. 定义和变量同时进行\n```\nstruct Student {\n    char *name;\n    int age;\n} stu;\n// 结构体变量名为stu\n```\n4. 直接定义结构体类型变量，省略类型名\n```\nstruct {\n    char *name;\n    int age;\n} stu;\n// 结构体变量名为stu\n```\n\n### 注意事项\n- 不可以在结构体本身进行递归定义\n- 可以包含别的结构体\n\n### 内存分配\n- 定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量。\n```\nstruct Student {\n     char *name;\n     int age;\n };\nstruct Student stu;\n// 第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。\n ```\n- 结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列。\n```\nstruct Student {\n     char *name; // 姓名\n     int age; // 年龄\n     float height; // 身高\n };\n// 在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。\n```\n\n### 结构体初始化\n- 将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。\n比如初始化Student结构体变量stu\n```\n struct Student {\n     char *name;\n     int age;\n }; \nstruct Student stu = {“NJ\", 27};\n```\n- 只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是错误的\n```\nstruct Student stu;\nstu = {“NJ\", 27};\n```\n\n### 操作结构体\n1. 一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名\n```\nstruct Student {\n     char *name;\n     int age;\n };\n struct Student stu;\n // 访问stu的age成员\n stu.age = 27;\n// 第9行对结构体的age成员进行了赋值。\".\"称为成员运算符，它在所有运算符中优先级最高\n```\n\n2. 如果某个成员也是结构体变量，可以连续使用成员运算符\".\"访问最低一级成员\n```\nstruct Date {\n       int year;\n       int month;\n       int day;\n  };\n  \n  struct Student {\n      char *name;\n      struct Date birthday;\n };\n \n struct Student stu;\n stu.birthday.year = 1986;\n stu.birthday.month = 9;\n stu.birthday.day = 10;\n```\n\n3. 相同类型的结构体变量之间可以进行整体赋值\n```\nstruct Student {\n      char *name;\n      int age;\n};  \nstruct Student stu1 = {“NJ”, 27};  \n// 将stu1直接赋值给stu2\nstruct Student stu2 = stu1; \nprintf(\"age is %d\", stu2.age);\n```\n\n4. 将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。\n\n5. 指向结构体的指针\n    每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量\n    - 结构体指针变量的定义形式：struct 结构体名称 *指针变量名\n    - 有了指向结构体的指针，那么就有3种访问结构体成员的方式\n    - 结构体变量名.成员名\n    - (*指针变量名).成员名\n    - 指针变量名->成员名\n\n# 枚举\n## 基本概念\n>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。\n\n### 定义\n1. 一般形式为：enum　枚举名　{枚举元素1,枚举元素2,……};\n```\nenum Season {\n\tspring, \n\tsummer, \n\tautumn, \n\tWinter\n}; \n```\n2. 先定义枚举类型，再定义枚举变量\n```\nenum Season {\n\tspring, \n\tsummer, \n\tautumn, \n\tWinter\n}; \n2.enum Season s;\n```\n3. 定义枚举类型的同时定义枚举变量\n```\nenum Season {\n\tspring, \n\tsummer,\n\tautumn,\n \twinter\n} s;\n```\n4. 省略枚举名称，直接定义枚举变量\n```\nenum{\n  spring,\n     summer,\n     autumn, \n     winter\n} s;\n```\n\n### 枚举使用的注意\n1. C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。\n2. 枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。\n```\nenum Season {spring, summer, autumn, winter};\n// 也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3\n```\n3. 也可以在定义枚举类型时改变枚举元素的值\n```\nenum season {spring, summer=3, autumn, winter};\n// 没有指定值的枚举元素，其值为前一元素加1。也就说spring的值为0，summer的值为3，autumn的值为4，winter的值为5\n```\n\n### 赋值\n- 可以给枚举变量赋枚举常量或者整型值\n```\nenum Season {spring, summer, autumn, winter} s;\ns = spring; // 等价于 s = 0;\ns = 3; // 等价于 s = winter;\n```\n\n### 遍历枚举元素\n```\nenum Season {spring, summer, autumn, winter} s;\n// 遍历枚举元素\nfor (s = spring; s <= winter; s++) {\n    printf(\"枚举元素：%d \\n\", s);\n}\n```\n","slug":"c/C语言指针、结构体、枚举","published":1,"updated":"2019-10-02T09:00:32.102Z","layout":"post","photos":[],"link":"","_id":"ck19bvb0l002k00wk6dcwxcab","content":"<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>指针就是用来保存变量的地址的变量</p>\n<ul>\n<li><p>访问</p>\n<ol>\n<li>我们通过<code>&amp;</code>来获取变量的地址。</li>\n<li><code>&amp;</code>这个操作符只能指向变量或者是数组。</li>\n<li><code>&amp;</code>是获取地址的操作符。</li>\n<li>使用<code>%p</code>来打印地址。</li>\n</ol>\n</li>\n<li><p>本质<br>  指针是一个4字节（或是8字节）的一个int的整数。换句话说也就一个int 型的变量</p>\n</li>\n<li><p>指针变量</p>\n<ol>\n<li>指针变量是用来保存地址的。</li>\n<li>指针变量里保存的地址可以修改。</li>\n<li>指针变量可以指向特殊的数据类型。</li>\n<li>可以有多个指针变量里的值是相同的。</li>\n</ol>\n</li>\n<li><p>一级指针的简单使用<br>  指针访问内存可以通过<code>*</code>这个操作符去访问所指向的内存空间。</p>\n</li>\n</ul>\n<h2 id=\"指针的定义和初始化\"><a href=\"#指针的定义和初始化\" class=\"headerlink\" title=\"指针的定义和初始化\"></a>指针的定义和初始化</h2><ul>\n<li>type * identifier<ol>\n<li>没有初始化的指针，称之为野指针。</li>\n<li>指针里面是一个随机的值。</li>\n<li>野指针有很大的风险。</li>\n<li>指针可以作为函数的参数和返回值。</li>\n</ol>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明一个int指针</span><br><span class=\"line\">int *ptr;</span><br><span class=\"line\">// 声明一个int值</span><br><span class=\"line\">int val = 1;</span><br><span class=\"line\">// 为指针分配一个int值的引用</span><br><span class=\"line\">ptr = &amp;val;</span><br><span class=\"line\">// 对指针进行取值，打印存储在指针地址中的内容</span><br><span class=\"line\">int deref = *ptr;</span><br><span class=\"line\">printf(&quot;%d\\n&quot;, deref);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>第2行，我们通过<code>*</code>操作符声明了一个int指针。接着我们声明了一个int变量并赋值为1。然后我们用int变量的地址初始化我们的int指针。接下来对int指针取值，用变量的内存地址初始化int指针。最终，我们打印输出变量值，内容为1。</p>\n<p>第6行的<code>&amp;val</code>是一个引用。在val变量声明并初始化内存之后，通过在变量名之前使用地址操作符<code>&amp;</code>我们可以直接引用变量的内存地址。<br>第8行，我们再一次使用<code>*</code>操作符来对该指针取值，可直接获得指针指向的内存地址中的数据。由于指针声明的类型是int，所以取到的值是指针指向的内存地址存储的int值。</p>\n<ul>\n<li>void指针、NULL指针和未初始化指针<br>一个指针可以被声明为void类型，比如void *x。一个指针可以被赋值为NULL。一个指针变量声明之后但没有被赋值，叫做未初始化指针。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int *uninit; </span><br><span class=\"line\">// int指针未初始化</span><br><span class=\"line\">int *nullptr = NULL; </span><br><span class=\"line\">// 初始化为NULL</span><br><span class=\"line\">void *vptr; </span><br><span class=\"line\">// void指针未初始化</span><br><span class=\"line\">int val = 1;</span><br><span class=\"line\">int *iptr;</span><br><span class=\"line\">int *castptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">// void类型可以存储任意类型的指针或引用</span><br><span class=\"line\">iptr = &amp;val;</span><br><span class=\"line\">vptr = iptr;</span><br><span class=\"line\">printf(&quot;iptr=%p, vptr=%p\\n&quot;, iptr, vptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 通过显示转换，我们可以把一个void指针转成</span><br><span class=\"line\">// int指针并进行取值</span><br><span class=\"line\">castptr = (int *)vptr;</span><br><span class=\"line\">printf(&quot;*castptr=%d\\n&quot;, *castptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 打印null和未初始化指针</span><br><span class=\"line\">printf(&quot;uninit=%p, nullptr=%p\\n&quot;, uninit, nullptr);</span><br><span class=\"line\">// 不知道你会得到怎样的返回值，会是随机的垃圾地址吗？</span><br><span class=\"line\">// printf(&quot;*nullptr=%d\\n&quot;, nullptr);</span><br><span class=\"line\">// 这里会产生一个段错误</span><br><span class=\"line\">// printf(&quot;*nullptr=%d\\n&quot;, nullptr);</span><br><span class=\"line\">执行上面的代码，你会得到类似下面对应不同内存地址的输出。</span><br><span class=\"line\"></span><br><span class=\"line\">iptr=0x7fff94b89c6c, vptr=0x7fff94b89c6c</span><br><span class=\"line\">*castptr=1</span><br><span class=\"line\">uninit=0x7fff94b89d50, nullptr=(nil)</span><br></pre></td></tr></table></figure>\n\n<p>第1行我们声明了一个未初始化int指针。所有的指针在赋值为NULL、一个引用（地址）或者另一个指针之前都是未被初始化的。第2行我们声明了一个NULL指针。第3行声明了一个void指针。第4行到第6行声明了一个int值和几个int指针。</p>\n<p>第9行到11行，我们为int指针赋值为一个引用并把int指针赋值为void指针。void指针可以保存各种其它指针类型。大多数时候它们被用来存储数据结构。可以注意到，第11行我们打印了int和void指针的地址。它们现在指向了同样的内存地址。所有的指针都存储了内存地址。它们的类型只在取值时起作用。</p>\n<p>第15到16行，我们把void指针转换为int指针castptr。请注意这里需要显示转换。虽然C语言并不要求显示地转换，但这样会增加代码的可读性。接着我们对castptr指针取值，值为1。</p>\n<p>第19行非常有意思，在这里打印未初始化指针和NULL指针。值得注意的是，未初始化指针是有内存地址的，而且是一个垃圾地址。不知道这个内存地址指向的值是什么。这就是为什么不要对未初始化指针取值的原因。最好的情况是你取到的是垃圾地址接下来你需要对程序进行调试，最坏的情况则会导致程序崩溃。</p>\n<blockquote>\n<p>NULL指针被初始化为o。NULL是一个特殊的地址，用NULL赋值的指针指向的地址为0而不是随机的地址。只有当你准备使用这个地址时有效。不要对NULL地址取值，否则会产生段错误。</p>\n</blockquote>\n<ul>\n<li>指针和数组<ul>\n<li>C语言的数组表示一段连续的内存空间，用来存储多个特定类型的对象。与之相反，指针用来存储单个内存地址。数组和指针不是同一种结构因此不可以互相转换。而数组变量指向了数组的第一个元素的内存地址。</li>\n<li>一个数组变量是一个常量。即使指针变量指向同样的地址或者一个不同的数组，也不能把指针赋值给数组变量。也不可以将一个数组变量赋值给另一个数组。然而，可以把一个数组变量赋值给指针，这一点似乎让人感到费解。把数组变量赋值给指针时，实际上是把指向数组第一个元素的地址赋给指针。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int myarray[4] = &#123;1,2,3,0&#125;;</span><br><span class=\"line\">int *ptr = myarray;</span><br><span class=\"line\">printf(&quot;*ptr=%d\\n&quot;, *ptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 数组变量是常量，不能做下面的赋值</span><br><span class=\"line\">// myarray = ptr</span><br><span class=\"line\">// myarray = myarray2</span><br><span class=\"line\">// myarray = &amp;myarray2[0]</span><br></pre></td></tr></table></figure>\n\n<p>第1行初始化了一个int数组，第2行用数组变量初始化了一个int指针。由于数组变量实际上是第一个元素的地址，因此我们可以把这个地址赋值给指针。这个赋值与int *ptr = &amp;myarray[0]效果相同，显示地把数组的第一个元素地址赋值到了ptr引用。这里需要注意的是，这里指针需要和数组的元素类型保持一致，除非指针类型为void。</p>\n<ul>\n<li>指针与<code>结构体</code><br>就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct person &#123;</span><br><span class=\"line\">  int age;</span><br><span class=\"line\">  char *name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">struct person first;</span><br><span class=\"line\">struct person *ptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">first.age = 21;</span><br><span class=\"line\">char *fullname = &quot;full name&quot;;</span><br><span class=\"line\">first.name = fullname;</span><br><span class=\"line\">ptr = &amp;first;</span><br><span class=\"line\"> </span><br><span class=\"line\">printf(&quot;age=%d, name=%s\\n&quot;, first.age, ptr-&gt;name);</span><br></pre></td></tr></table></figure>\n\n<p>第1至6行声明了一个person结构体，一个变量指向了一个person结构体和指向person结构体的指针。第8行为age成员赋了一个int值。第9至10行我们声明了一个char指针并赋值给一个char数组并赋值给结构体name成员。第11行我们把一个person结构体引用赋值给结构体变量。</p>\n<p>第13行我们打印了结构体实例的age和name。这里需要注意两个不同的符号，’.’ 和 ‘-&gt;’ 。结构体实例可以通过使用 ‘.’ 符号访问age变量。对于结构体实例的指针，我们可以通过 ‘-&gt;’ 符号访问name变量。也可以同样通过(*ptr).name来访问name变量。</p>\n<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"什么事结构体\"><a href=\"#什么事结构体\" class=\"headerlink\" title=\"什么事结构体\"></a>什么事结构体</h3><ol>\n<li>C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。</li>\n<li>在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。</li>\n<li>为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。</li>\n</ol>\n<h3 id=\"结构体的定义\"><a href=\"#结构体的定义\" class=\"headerlink\" title=\"结构体的定义\"></a>结构体的定义</h3><ol>\n<li><p>定义形式：结构体内部的元素，也就是组成成分，我们一般称为”成员”。<br>结构体的一般定义形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct　结构体名&#123;     </span><br><span class=\"line\">     类型名1　成员名1;     </span><br><span class=\"line\">     类型名2　成员名2;     </span><br><span class=\"line\">     ……     </span><br><span class=\"line\">     类型名n　成员名n;     </span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先定义结构体类型，再定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> struct Student stu;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义和变量同时进行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">    char *name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125; stu;</span><br><span class=\"line\">// 结构体变量名为stu</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接定义结构体类型变量，省略类型名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123;</span><br><span class=\"line\">    char *name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125; stu;</span><br><span class=\"line\">// 结构体变量名为stu</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不可以在结构体本身进行递归定义</li>\n<li>可以包含别的结构体</li>\n</ul>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><ul>\n<li><p>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">struct Student stu;</span><br><span class=\"line\">// 第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name; // 姓名</span><br><span class=\"line\">     int age; // 年龄</span><br><span class=\"line\">     float height; // 身高</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">// 在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"结构体初始化\"><a href=\"#结构体初始化\" class=\"headerlink\" title=\"结构体初始化\"></a>结构体初始化</h3><ul>\n<li><p>将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。<br>比如初始化Student结构体变量stu</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\">struct Student stu = &#123;“NJ&quot;, 27&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是错误的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student stu;</span><br><span class=\"line\">stu = &#123;“NJ&quot;, 27&#125;;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"操作结构体\"><a href=\"#操作结构体\" class=\"headerlink\" title=\"操作结构体\"></a>操作结构体</h3><ol>\n<li><p>一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> struct Student stu;</span><br><span class=\"line\"> // 访问stu的age成员</span><br><span class=\"line\"> stu.age = 27;</span><br><span class=\"line\">// 第9行对结构体的age成员进行了赋值。&quot;.&quot;称为成员运算符，它在所有运算符中优先级最高</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Date &#123;</span><br><span class=\"line\">       int year;</span><br><span class=\"line\">       int month;</span><br><span class=\"line\">       int day;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  struct Student &#123;</span><br><span class=\"line\">      char *name;</span><br><span class=\"line\">      struct Date birthday;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"> struct Student stu;</span><br><span class=\"line\"> stu.birthday.year = 1986;</span><br><span class=\"line\"> stu.birthday.month = 9;</span><br><span class=\"line\"> stu.birthday.day = 10;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相同类型的结构体变量之间可以进行整体赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">      char *name;</span><br><span class=\"line\">      int age;</span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">struct Student stu1 = &#123;“NJ”, 27&#125;;  </span><br><span class=\"line\">// 将stu1直接赋值给stu2</span><br><span class=\"line\">struct Student stu2 = stu1; </span><br><span class=\"line\">printf(&quot;age is %d&quot;, stu2.age);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。</p>\n</li>\n<li><p>指向结构体的指针<br> 每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量</p>\n<ul>\n<li>结构体指针变量的定义形式：struct 结构体名称 *指针变量名</li>\n<li>有了指向结构体的指针，那么就有3种访问结构体成员的方式</li>\n<li>结构体变量名.成员名</li>\n<li>(*指针变量名).成员名</li>\n<li>指针变量名-&gt;成员名</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><blockquote>\n<p>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。</p>\n</blockquote>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ol>\n<li><p>一般形式为：enum　枚举名　{枚举元素1,枚举元素2,……};</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer, </span><br><span class=\"line\">\tautumn, </span><br><span class=\"line\">\tWinter</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先定义枚举类型，再定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer, </span><br><span class=\"line\">\tautumn, </span><br><span class=\"line\">\tWinter</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">2.enum Season s;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义枚举类型的同时定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer,</span><br><span class=\"line\">\tautumn,</span><br><span class=\"line\"> \twinter</span><br><span class=\"line\">&#125; s;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>省略枚举名称，直接定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum&#123;</span><br><span class=\"line\">  spring,</span><br><span class=\"line\">     summer,</span><br><span class=\"line\">     autumn, </span><br><span class=\"line\">     winter</span><br><span class=\"line\">&#125; s;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"枚举使用的注意\"><a href=\"#枚举使用的注意\" class=\"headerlink\" title=\"枚举使用的注意\"></a>枚举使用的注意</h3><ol>\n<li><p>C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。</p>\n</li>\n<li><p>枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125;;</span><br><span class=\"line\">// 也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>也可以在定义枚举类型时改变枚举元素的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum season &#123;spring, summer=3, autumn, winter&#125;;</span><br><span class=\"line\">// 没有指定值的枚举元素，其值为前一元素加1。也就说spring的值为0，summer的值为3，autumn的值为4，winter的值为5</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><ul>\n<li>可以给枚举变量赋枚举常量或者整型值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class=\"line\">s = spring; // 等价于 s = 0;</span><br><span class=\"line\">s = 3; // 等价于 s = winter;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍历枚举元素\"><a href=\"#遍历枚举元素\" class=\"headerlink\" title=\"遍历枚举元素\"></a>遍历枚举元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class=\"line\">// 遍历枚举元素</span><br><span class=\"line\">for (s = spring; s &lt;= winter; s++) &#123;</span><br><span class=\"line\">    printf(&quot;枚举元素：%d \\n&quot;, s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>指针就是用来保存变量的地址的变量</p>\n<ul>\n<li><p>访问</p>\n<ol>\n<li>我们通过<code>&amp;</code>来获取变量的地址。</li>\n<li><code>&amp;</code>这个操作符只能指向变量或者是数组。</li>\n<li><code>&amp;</code>是获取地址的操作符。</li>\n<li>使用<code>%p</code>来打印地址。</li>\n</ol>\n</li>\n<li><p>本质<br>  指针是一个4字节（或是8字节）的一个int的整数。换句话说也就一个int 型的变量</p>\n</li>\n<li><p>指针变量</p>\n<ol>\n<li>指针变量是用来保存地址的。</li>\n<li>指针变量里保存的地址可以修改。</li>\n<li>指针变量可以指向特殊的数据类型。</li>\n<li>可以有多个指针变量里的值是相同的。</li>\n</ol>\n</li>\n<li><p>一级指针的简单使用<br>  指针访问内存可以通过<code>*</code>这个操作符去访问所指向的内存空间。</p>\n</li>\n</ul>\n<h2 id=\"指针的定义和初始化\"><a href=\"#指针的定义和初始化\" class=\"headerlink\" title=\"指针的定义和初始化\"></a>指针的定义和初始化</h2><ul>\n<li>type * identifier<ol>\n<li>没有初始化的指针，称之为野指针。</li>\n<li>指针里面是一个随机的值。</li>\n<li>野指针有很大的风险。</li>\n<li>指针可以作为函数的参数和返回值。</li>\n</ol>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明一个int指针</span><br><span class=\"line\">int *ptr;</span><br><span class=\"line\">// 声明一个int值</span><br><span class=\"line\">int val = 1;</span><br><span class=\"line\">// 为指针分配一个int值的引用</span><br><span class=\"line\">ptr = &amp;val;</span><br><span class=\"line\">// 对指针进行取值，打印存储在指针地址中的内容</span><br><span class=\"line\">int deref = *ptr;</span><br><span class=\"line\">printf(&quot;%d\\n&quot;, deref);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>第2行，我们通过<code>*</code>操作符声明了一个int指针。接着我们声明了一个int变量并赋值为1。然后我们用int变量的地址初始化我们的int指针。接下来对int指针取值，用变量的内存地址初始化int指针。最终，我们打印输出变量值，内容为1。</p>\n<p>第6行的<code>&amp;val</code>是一个引用。在val变量声明并初始化内存之后，通过在变量名之前使用地址操作符<code>&amp;</code>我们可以直接引用变量的内存地址。<br>第8行，我们再一次使用<code>*</code>操作符来对该指针取值，可直接获得指针指向的内存地址中的数据。由于指针声明的类型是int，所以取到的值是指针指向的内存地址存储的int值。</p>\n<ul>\n<li>void指针、NULL指针和未初始化指针<br>一个指针可以被声明为void类型，比如void *x。一个指针可以被赋值为NULL。一个指针变量声明之后但没有被赋值，叫做未初始化指针。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int *uninit; </span><br><span class=\"line\">// int指针未初始化</span><br><span class=\"line\">int *nullptr = NULL; </span><br><span class=\"line\">// 初始化为NULL</span><br><span class=\"line\">void *vptr; </span><br><span class=\"line\">// void指针未初始化</span><br><span class=\"line\">int val = 1;</span><br><span class=\"line\">int *iptr;</span><br><span class=\"line\">int *castptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">// void类型可以存储任意类型的指针或引用</span><br><span class=\"line\">iptr = &amp;val;</span><br><span class=\"line\">vptr = iptr;</span><br><span class=\"line\">printf(&quot;iptr=%p, vptr=%p\\n&quot;, iptr, vptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 通过显示转换，我们可以把一个void指针转成</span><br><span class=\"line\">// int指针并进行取值</span><br><span class=\"line\">castptr = (int *)vptr;</span><br><span class=\"line\">printf(&quot;*castptr=%d\\n&quot;, *castptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 打印null和未初始化指针</span><br><span class=\"line\">printf(&quot;uninit=%p, nullptr=%p\\n&quot;, uninit, nullptr);</span><br><span class=\"line\">// 不知道你会得到怎样的返回值，会是随机的垃圾地址吗？</span><br><span class=\"line\">// printf(&quot;*nullptr=%d\\n&quot;, nullptr);</span><br><span class=\"line\">// 这里会产生一个段错误</span><br><span class=\"line\">// printf(&quot;*nullptr=%d\\n&quot;, nullptr);</span><br><span class=\"line\">执行上面的代码，你会得到类似下面对应不同内存地址的输出。</span><br><span class=\"line\"></span><br><span class=\"line\">iptr=0x7fff94b89c6c, vptr=0x7fff94b89c6c</span><br><span class=\"line\">*castptr=1</span><br><span class=\"line\">uninit=0x7fff94b89d50, nullptr=(nil)</span><br></pre></td></tr></table></figure>\n\n<p>第1行我们声明了一个未初始化int指针。所有的指针在赋值为NULL、一个引用（地址）或者另一个指针之前都是未被初始化的。第2行我们声明了一个NULL指针。第3行声明了一个void指针。第4行到第6行声明了一个int值和几个int指针。</p>\n<p>第9行到11行，我们为int指针赋值为一个引用并把int指针赋值为void指针。void指针可以保存各种其它指针类型。大多数时候它们被用来存储数据结构。可以注意到，第11行我们打印了int和void指针的地址。它们现在指向了同样的内存地址。所有的指针都存储了内存地址。它们的类型只在取值时起作用。</p>\n<p>第15到16行，我们把void指针转换为int指针castptr。请注意这里需要显示转换。虽然C语言并不要求显示地转换，但这样会增加代码的可读性。接着我们对castptr指针取值，值为1。</p>\n<p>第19行非常有意思，在这里打印未初始化指针和NULL指针。值得注意的是，未初始化指针是有内存地址的，而且是一个垃圾地址。不知道这个内存地址指向的值是什么。这就是为什么不要对未初始化指针取值的原因。最好的情况是你取到的是垃圾地址接下来你需要对程序进行调试，最坏的情况则会导致程序崩溃。</p>\n<blockquote>\n<p>NULL指针被初始化为o。NULL是一个特殊的地址，用NULL赋值的指针指向的地址为0而不是随机的地址。只有当你准备使用这个地址时有效。不要对NULL地址取值，否则会产生段错误。</p>\n</blockquote>\n<ul>\n<li>指针和数组<ul>\n<li>C语言的数组表示一段连续的内存空间，用来存储多个特定类型的对象。与之相反，指针用来存储单个内存地址。数组和指针不是同一种结构因此不可以互相转换。而数组变量指向了数组的第一个元素的内存地址。</li>\n<li>一个数组变量是一个常量。即使指针变量指向同样的地址或者一个不同的数组，也不能把指针赋值给数组变量。也不可以将一个数组变量赋值给另一个数组。然而，可以把一个数组变量赋值给指针，这一点似乎让人感到费解。把数组变量赋值给指针时，实际上是把指向数组第一个元素的地址赋给指针。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int myarray[4] = &#123;1,2,3,0&#125;;</span><br><span class=\"line\">int *ptr = myarray;</span><br><span class=\"line\">printf(&quot;*ptr=%d\\n&quot;, *ptr);</span><br><span class=\"line\"> </span><br><span class=\"line\">// 数组变量是常量，不能做下面的赋值</span><br><span class=\"line\">// myarray = ptr</span><br><span class=\"line\">// myarray = myarray2</span><br><span class=\"line\">// myarray = &amp;myarray2[0]</span><br></pre></td></tr></table></figure>\n\n<p>第1行初始化了一个int数组，第2行用数组变量初始化了一个int指针。由于数组变量实际上是第一个元素的地址，因此我们可以把这个地址赋值给指针。这个赋值与int *ptr = &amp;myarray[0]效果相同，显示地把数组的第一个元素地址赋值到了ptr引用。这里需要注意的是，这里指针需要和数组的元素类型保持一致，除非指针类型为void。</p>\n<ul>\n<li>指针与<code>结构体</code><br>就像数组一样，指向结构体的指针存储了结构体第一个元素的内存地址。与数组指针一样，结构体的指针必须声明和结构体类型保持一致，或者声明为void类型。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct person &#123;</span><br><span class=\"line\">  int age;</span><br><span class=\"line\">  char *name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">struct person first;</span><br><span class=\"line\">struct person *ptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">first.age = 21;</span><br><span class=\"line\">char *fullname = &quot;full name&quot;;</span><br><span class=\"line\">first.name = fullname;</span><br><span class=\"line\">ptr = &amp;first;</span><br><span class=\"line\"> </span><br><span class=\"line\">printf(&quot;age=%d, name=%s\\n&quot;, first.age, ptr-&gt;name);</span><br></pre></td></tr></table></figure>\n\n<p>第1至6行声明了一个person结构体，一个变量指向了一个person结构体和指向person结构体的指针。第8行为age成员赋了一个int值。第9至10行我们声明了一个char指针并赋值给一个char数组并赋值给结构体name成员。第11行我们把一个person结构体引用赋值给结构体变量。</p>\n<p>第13行我们打印了结构体实例的age和name。这里需要注意两个不同的符号，’.’ 和 ‘-&gt;’ 。结构体实例可以通过使用 ‘.’ 符号访问age变量。对于结构体实例的指针，我们可以通过 ‘-&gt;’ 符号访问name变量。也可以同样通过(*ptr).name来访问name变量。</p>\n<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"什么事结构体\"><a href=\"#什么事结构体\" class=\"headerlink\" title=\"什么事结构体\"></a>什么事结构体</h3><ol>\n<li>C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。</li>\n<li>在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。</li>\n<li>为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。</li>\n</ol>\n<h3 id=\"结构体的定义\"><a href=\"#结构体的定义\" class=\"headerlink\" title=\"结构体的定义\"></a>结构体的定义</h3><ol>\n<li><p>定义形式：结构体内部的元素，也就是组成成分，我们一般称为”成员”。<br>结构体的一般定义形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct　结构体名&#123;     </span><br><span class=\"line\">     类型名1　成员名1;     </span><br><span class=\"line\">     类型名2　成员名2;     </span><br><span class=\"line\">     ……     </span><br><span class=\"line\">     类型名n　成员名n;     </span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先定义结构体类型，再定义变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\"> struct Student stu;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义和变量同时进行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">    char *name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125; stu;</span><br><span class=\"line\">// 结构体变量名为stu</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接定义结构体类型变量，省略类型名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct &#123;</span><br><span class=\"line\">    char *name;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">&#125; stu;</span><br><span class=\"line\">// 结构体变量名为stu</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不可以在结构体本身进行递归定义</li>\n<li>可以包含别的结构体</li>\n</ul>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><ul>\n<li><p>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">struct Student stu;</span><br><span class=\"line\">// 第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name; // 姓名</span><br><span class=\"line\">     int age; // 年龄</span><br><span class=\"line\">     float height; // 身高</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\">// 在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"结构体初始化\"><a href=\"#结构体初始化\" class=\"headerlink\" title=\"结构体初始化\"></a>结构体初始化</h3><ul>\n<li><p>将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。<br>比如初始化Student结构体变量stu</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;; </span><br><span class=\"line\">struct Student stu = &#123;“NJ&quot;, 27&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是错误的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student stu;</span><br><span class=\"line\">stu = &#123;“NJ&quot;, 27&#125;;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"操作结构体\"><a href=\"#操作结构体\" class=\"headerlink\" title=\"操作结构体\"></a>操作结构体</h3><ol>\n<li><p>一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">     char *name;</span><br><span class=\"line\">     int age;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> struct Student stu;</span><br><span class=\"line\"> // 访问stu的age成员</span><br><span class=\"line\"> stu.age = 27;</span><br><span class=\"line\">// 第9行对结构体的age成员进行了赋值。&quot;.&quot;称为成员运算符，它在所有运算符中优先级最高</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Date &#123;</span><br><span class=\"line\">       int year;</span><br><span class=\"line\">       int month;</span><br><span class=\"line\">       int day;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  struct Student &#123;</span><br><span class=\"line\">      char *name;</span><br><span class=\"line\">      struct Date birthday;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"> struct Student stu;</span><br><span class=\"line\"> stu.birthday.year = 1986;</span><br><span class=\"line\"> stu.birthday.month = 9;</span><br><span class=\"line\"> stu.birthday.day = 10;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>相同类型的结构体变量之间可以进行整体赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Student &#123;</span><br><span class=\"line\">      char *name;</span><br><span class=\"line\">      int age;</span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">struct Student stu1 = &#123;“NJ”, 27&#125;;  </span><br><span class=\"line\">// 将stu1直接赋值给stu2</span><br><span class=\"line\">struct Student stu2 = stu1; </span><br><span class=\"line\">printf(&quot;age is %d&quot;, stu2.age);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。</p>\n</li>\n<li><p>指向结构体的指针<br> 每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量</p>\n<ul>\n<li>结构体指针变量的定义形式：struct 结构体名称 *指针变量名</li>\n<li>有了指向结构体的指针，那么就有3种访问结构体成员的方式</li>\n<li>结构体变量名.成员名</li>\n<li>(*指针变量名).成员名</li>\n<li>指针变量名-&gt;成员名</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><blockquote>\n<p>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。</p>\n</blockquote>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ol>\n<li><p>一般形式为：enum　枚举名　{枚举元素1,枚举元素2,……};</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer, </span><br><span class=\"line\">\tautumn, </span><br><span class=\"line\">\tWinter</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先定义枚举类型，再定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer, </span><br><span class=\"line\">\tautumn, </span><br><span class=\"line\">\tWinter</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">2.enum Season s;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义枚举类型的同时定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;</span><br><span class=\"line\">\tspring, </span><br><span class=\"line\">\tsummer,</span><br><span class=\"line\">\tautumn,</span><br><span class=\"line\"> \twinter</span><br><span class=\"line\">&#125; s;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>省略枚举名称，直接定义枚举变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum&#123;</span><br><span class=\"line\">  spring,</span><br><span class=\"line\">     summer,</span><br><span class=\"line\">     autumn, </span><br><span class=\"line\">     winter</span><br><span class=\"line\">&#125; s;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"枚举使用的注意\"><a href=\"#枚举使用的注意\" class=\"headerlink\" title=\"枚举使用的注意\"></a>枚举使用的注意</h3><ol>\n<li><p>C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。</p>\n</li>\n<li><p>枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125;;</span><br><span class=\"line\">// 也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>也可以在定义枚举类型时改变枚举元素的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum season &#123;spring, summer=3, autumn, winter&#125;;</span><br><span class=\"line\">// 没有指定值的枚举元素，其值为前一元素加1。也就说spring的值为0，summer的值为3，autumn的值为4，winter的值为5</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><ul>\n<li>可以给枚举变量赋枚举常量或者整型值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class=\"line\">s = spring; // 等价于 s = 0;</span><br><span class=\"line\">s = 3; // 等价于 s = winter;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"遍历枚举元素\"><a href=\"#遍历枚举元素\" class=\"headerlink\" title=\"遍历枚举元素\"></a>遍历枚举元素</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class=\"line\">// 遍历枚举元素</span><br><span class=\"line\">for (s = spring; s &lt;= winter; s++) &#123;</span><br><span class=\"line\">    printf(&quot;枚举元素：%d \\n&quot;, s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"C语言的预处理指令和关键字","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-12-20T13:24:00.000Z","_content":"## 预处理指令\n- C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译\n- 为了区分预处理指令和一般的C语句，所有预处理指令都以符号“#”开头，并且结尾不用分号\n- 预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件\n- C语言提供的预处理指令主要有：宏定义、文件包含、条件编译\n\n### 定义\n宏定义可以分为2种：\n\n1. 不带参数的宏定义 \n    - 定义格式：\n    ```\n    #define 宏名 字符串\n    // 比如  #define ABC 10\n    ```\n    - 作用：是在编译预处理时，将源程序中所有\"宏名\"替换成右边的\"字符串\"，常用来定义常量。\n    - 使用习惯与注意\n        1. 宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误\n        2. 对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。\n        3. 在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查\n        4. 宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令\n        5. 定义一个宏时可以引用已经定义的宏名\n    \n2. 带参数的宏定义\n    - 定义格式：\n    ```\n    #define 宏名(参数列表) 字符串\n    ```\n    - 作用：在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换.\n    - 使用注意：\n        1. 宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.\n        2. 带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。\n        3. 参数和计算结果都要用小括号括起来\n    - 与函数的区别：从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：\n        1. 宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题\n        2. 函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率\n        \n### 条件编译\n>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。\n \n- 格式  \n```   \n#if 条件1\n  ...code1...\n#elif 条件2\n  ...code2...\n#else\n  ...code3...\n#endif\n```\n\n- 注意\n>条件编译结束后，要在最后面加一个#endif，不然后果很严重。\n`#if` 和 `#elif`后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义。\n\n- 条件编译其它用法\n```\n#if defined()和#if !defined()的用法\n//#if defined(MAX)\n#if !defined(MAX)\n    ...code...\n#endif\n#ifdef 和 ifndef的用法\n //#ifdef MAX\n #ifndef MAX\n     ...code...\n #endif\n```\n## static/extern\n### static和extern关键字对函数的作用\n- 外部函数和内部函数\n    - 外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。C语言规定，不允许有同名的外部函数。\n    - 内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。C语言规定不同的源文件可以有同名的内部函数，并且互不干扰。\n- `extern`\n    - 在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。\n    - 在一个文件中要调用其他文件中的外部函数，则需要在当前文件中用extern声明该外部函数，然后就可以使用，这里的extern也可以省略。\n- `static`\n    - 在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。\n    - static也可以用来声明一个内部函数\n\n### static和extern关键字对全局变量的作用\n1. extern可以用来声明一个全局变量，但是不能用来定义变量\n2. 默认情况下，一个全局变量是可以供多个源文件共享的，也就说，多个源文件中同名的全局变量都代表着同一个变量\n3. 如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰\n\n### Static对局部变量的作用\n1. 用static修饰局部变量后会延长局部变量的生命周期，当执行到定义变量的那一行的时候分配存储空间，但是直到程序结束变量才会释放\n2. 尽管延长了变量的生命周期，但是没有改变变量的作用域\n    使用场合：当一个变量要被经常重复使用的时候就可以用static来修饰这个变量\n\n## typedef\n>可以使用typedef关键字为各种数据类型定义一个新名字(别名)，可以简化代码和提高阅读性。\n\n### typedef与指针\n```\ntypedef char *String;\nint main(int argc, const char * argv[]) {\n    // 相当于char *str = \"This is a string!\";\n    String str = \"This is a string!\";    \n    printf(\"%s\", str);   \n    return 0;\n }\n```\n\n### typedef与结构体\n```\n// 定义一个结构体\nstruct MyPoint {\n    float x;\n     float y;\n}; \nint main(int argc, const char * argv[]) {\n   // 定义结构体变量\n    struct MyPoint p;\n    p.x = 10.0f;\n    p.y = 20.0f;\n    retuen 0;    \n}\n```\n### 使用typedef给结构体起别名\n```\n// 定义一个结构体\nstruct MyPoint {\n   float x;\n   float y;\n};\n// 起别名\ntypedef struct MyPoint Point; \nint main(int argc, const char * argv[]) {\n  // 定义结构体变量\n  Point p;\n  p.x = 10.0f;\n  p.y = 20.0f;    \n  return 0;\n}\n```\n### typedef与指向结构体的指针\n```\n// 定义一个结构体并起别名\n typedef struct {\n    float x;\n    float y;\n } Point; \n // 起别名\n typedef Point *PP; \n int main(int argc, const char * argv[]) {\n    // 定义结构体变量\n    Point point = {10, 20};    \n    // 定义指针变量\n    PP p = &point;     \n    // 利用指针变量访问结构体成员\n    printf(\"x=%f，y=%f\", p->x, p->y);\n    return 0;\n}\n```\n### typedef与指向函数的指针\n```\n// 定义一个sum函数，计算a跟b的和\n  int sum(int a, int b) {\n      int c = a + b;\n      printf(\"%d + %d = %d\", a, b, c);\n      return c;\n  }  \n typedef int (*MySum)(int, int);\n int main(int argc, const char * argv[]) {\n     // 定义一个指向sum函数的指针变量p\n     // int (*p)(int, int) = sum;  \n     // 定义一个指向sum函数的指针变量p\n     MySum p = sum;   \n     // 利用指针变量p调用sum函数\n     (*p)(4, 5);\n     return 0;\n }\n```\n### typedef与#define\n```\ntypedef char *String1;//其别名\n#define String2 char *//宏定义，在代码中只是将(char *)替换称String\nint main(int argc, const char * argv[]) \n    String1 str1, str2;   // 实际是char *str1,char *str2\n    String2 str3, str4;   // 实际是char *str3,char str4\n    return 0;\n}\n```\n\n### 使用场合：\n - 给基本数据类型起别名\n - 给指针起别名\n - 给结构体起别名\n - 给枚举起别名\n - 给指向函数的指针起别名\n - 给指向结构体的指针起别名","source":"_posts/c/C语言的预处理指令和关键字.md","raw":"---\ntitle: C语言的预处理指令和关键字\nauthor: JsonYe\ntags:\n- c\ncategories:\n- C语言\ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-12-20 21:24:00   \n---\n## 预处理指令\n- C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译\n- 为了区分预处理指令和一般的C语句，所有预处理指令都以符号“#”开头，并且结尾不用分号\n- 预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件\n- C语言提供的预处理指令主要有：宏定义、文件包含、条件编译\n\n### 定义\n宏定义可以分为2种：\n\n1. 不带参数的宏定义 \n    - 定义格式：\n    ```\n    #define 宏名 字符串\n    // 比如  #define ABC 10\n    ```\n    - 作用：是在编译预处理时，将源程序中所有\"宏名\"替换成右边的\"字符串\"，常用来定义常量。\n    - 使用习惯与注意\n        1. 宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误\n        2. 对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。\n        3. 在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查\n        4. 宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令\n        5. 定义一个宏时可以引用已经定义的宏名\n    \n2. 带参数的宏定义\n    - 定义格式：\n    ```\n    #define 宏名(参数列表) 字符串\n    ```\n    - 作用：在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换.\n    - 使用注意：\n        1. 宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.\n        2. 带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。\n        3. 参数和计算结果都要用小括号括起来\n    - 与函数的区别：从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：\n        1. 宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题\n        2. 函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率\n        \n### 条件编译\n>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。\n \n- 格式  \n```   \n#if 条件1\n  ...code1...\n#elif 条件2\n  ...code2...\n#else\n  ...code3...\n#endif\n```\n\n- 注意\n>条件编译结束后，要在最后面加一个#endif，不然后果很严重。\n`#if` 和 `#elif`后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义。\n\n- 条件编译其它用法\n```\n#if defined()和#if !defined()的用法\n//#if defined(MAX)\n#if !defined(MAX)\n    ...code...\n#endif\n#ifdef 和 ifndef的用法\n //#ifdef MAX\n #ifndef MAX\n     ...code...\n #endif\n```\n## static/extern\n### static和extern关键字对函数的作用\n- 外部函数和内部函数\n    - 外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。C语言规定，不允许有同名的外部函数。\n    - 内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。C语言规定不同的源文件可以有同名的内部函数，并且互不干扰。\n- `extern`\n    - 在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。\n    - 在一个文件中要调用其他文件中的外部函数，则需要在当前文件中用extern声明该外部函数，然后就可以使用，这里的extern也可以省略。\n- `static`\n    - 在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。\n    - static也可以用来声明一个内部函数\n\n### static和extern关键字对全局变量的作用\n1. extern可以用来声明一个全局变量，但是不能用来定义变量\n2. 默认情况下，一个全局变量是可以供多个源文件共享的，也就说，多个源文件中同名的全局变量都代表着同一个变量\n3. 如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰\n\n### Static对局部变量的作用\n1. 用static修饰局部变量后会延长局部变量的生命周期，当执行到定义变量的那一行的时候分配存储空间，但是直到程序结束变量才会释放\n2. 尽管延长了变量的生命周期，但是没有改变变量的作用域\n    使用场合：当一个变量要被经常重复使用的时候就可以用static来修饰这个变量\n\n## typedef\n>可以使用typedef关键字为各种数据类型定义一个新名字(别名)，可以简化代码和提高阅读性。\n\n### typedef与指针\n```\ntypedef char *String;\nint main(int argc, const char * argv[]) {\n    // 相当于char *str = \"This is a string!\";\n    String str = \"This is a string!\";    \n    printf(\"%s\", str);   \n    return 0;\n }\n```\n\n### typedef与结构体\n```\n// 定义一个结构体\nstruct MyPoint {\n    float x;\n     float y;\n}; \nint main(int argc, const char * argv[]) {\n   // 定义结构体变量\n    struct MyPoint p;\n    p.x = 10.0f;\n    p.y = 20.0f;\n    retuen 0;    \n}\n```\n### 使用typedef给结构体起别名\n```\n// 定义一个结构体\nstruct MyPoint {\n   float x;\n   float y;\n};\n// 起别名\ntypedef struct MyPoint Point; \nint main(int argc, const char * argv[]) {\n  // 定义结构体变量\n  Point p;\n  p.x = 10.0f;\n  p.y = 20.0f;    \n  return 0;\n}\n```\n### typedef与指向结构体的指针\n```\n// 定义一个结构体并起别名\n typedef struct {\n    float x;\n    float y;\n } Point; \n // 起别名\n typedef Point *PP; \n int main(int argc, const char * argv[]) {\n    // 定义结构体变量\n    Point point = {10, 20};    \n    // 定义指针变量\n    PP p = &point;     \n    // 利用指针变量访问结构体成员\n    printf(\"x=%f，y=%f\", p->x, p->y);\n    return 0;\n}\n```\n### typedef与指向函数的指针\n```\n// 定义一个sum函数，计算a跟b的和\n  int sum(int a, int b) {\n      int c = a + b;\n      printf(\"%d + %d = %d\", a, b, c);\n      return c;\n  }  \n typedef int (*MySum)(int, int);\n int main(int argc, const char * argv[]) {\n     // 定义一个指向sum函数的指针变量p\n     // int (*p)(int, int) = sum;  \n     // 定义一个指向sum函数的指针变量p\n     MySum p = sum;   \n     // 利用指针变量p调用sum函数\n     (*p)(4, 5);\n     return 0;\n }\n```\n### typedef与#define\n```\ntypedef char *String1;//其别名\n#define String2 char *//宏定义，在代码中只是将(char *)替换称String\nint main(int argc, const char * argv[]) \n    String1 str1, str2;   // 实际是char *str1,char *str2\n    String2 str3, str4;   // 实际是char *str3,char str4\n    return 0;\n}\n```\n\n### 使用场合：\n - 给基本数据类型起别名\n - 给指针起别名\n - 给结构体起别名\n - 给枚举起别名\n - 给指向函数的指针起别名\n - 给指向结构体的指针起别名","slug":"c/C语言的预处理指令和关键字","published":1,"updated":"2019-10-02T09:03:08.980Z","layout":"post","photos":[],"link":"","_id":"ck19bvb0s002p00wkqwg0vr8q","content":"<h2 id=\"预处理指令\"><a href=\"#预处理指令\" class=\"headerlink\" title=\"预处理指令\"></a>预处理指令</h2><ul>\n<li>C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译</li>\n<li>为了区分预处理指令和一般的C语句，所有预处理指令都以符号“#”开头，并且结尾不用分号</li>\n<li>预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件</li>\n<li>C语言提供的预处理指令主要有：宏定义、文件包含、条件编译</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>宏定义可以分为2种：</p>\n<ol>\n<li><p>不带参数的宏定义 </p>\n<ul>\n<li><p>定义格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define 宏名 字符串</span><br><span class=\"line\">// 比如  #define ABC 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：是在编译预处理时，将源程序中所有”宏名”替换成右边的”字符串”，常用来定义常量。</p>\n</li>\n<li><p>使用习惯与注意</p>\n<ol>\n<li>宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误</li>\n<li>对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。</li>\n<li>在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查</li>\n<li>宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令</li>\n<li>定义一个宏时可以引用已经定义的宏名</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>带参数的宏定义</p>\n<ul>\n<li><p>定义格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define 宏名(参数列表) 字符串</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换.</p>\n</li>\n<li><p>使用注意：</p>\n<ol>\n<li>宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.</li>\n<li>带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。</li>\n<li>参数和计算结果都要用小括号括起来</li>\n</ol>\n</li>\n<li><p>与函数的区别：从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：</p>\n<ol>\n<li>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题</li>\n<li>函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h3><blockquote>\n<p>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。</p>\n</blockquote>\n<ul>\n<li><p>格式  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if 条件1</span><br><span class=\"line\">  ...code1...</span><br><span class=\"line\">#elif 条件2</span><br><span class=\"line\">  ...code2...</span><br><span class=\"line\">#else</span><br><span class=\"line\">  ...code3...</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意</p>\n<blockquote>\n<p>条件编译结束后，要在最后面加一个#endif，不然后果很严重。<br><code>#if</code> 和 <code>#elif</code>后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义。</p>\n</blockquote>\n</li>\n<li><p>条件编译其它用法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined()和#if !defined()的用法</span><br><span class=\"line\">//#if defined(MAX)</span><br><span class=\"line\">#if !defined(MAX)</span><br><span class=\"line\">    ...code...</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef 和 ifndef的用法</span><br><span class=\"line\"> //#ifdef MAX</span><br><span class=\"line\"> #ifndef MAX</span><br><span class=\"line\">     ...code...</span><br><span class=\"line\"> #endif</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"static-extern\"><a href=\"#static-extern\" class=\"headerlink\" title=\"static/extern\"></a>static/extern</h2><h3 id=\"static和extern关键字对函数的作用\"><a href=\"#static和extern关键字对函数的作用\" class=\"headerlink\" title=\"static和extern关键字对函数的作用\"></a>static和extern关键字对函数的作用</h3><ul>\n<li>外部函数和内部函数<ul>\n<li>外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。C语言规定，不允许有同名的外部函数。</li>\n<li>内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。C语言规定不同的源文件可以有同名的内部函数，并且互不干扰。</li>\n</ul>\n</li>\n<li><code>extern</code><ul>\n<li>在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。</li>\n<li>在一个文件中要调用其他文件中的外部函数，则需要在当前文件中用extern声明该外部函数，然后就可以使用，这里的extern也可以省略。</li>\n</ul>\n</li>\n<li><code>static</code><ul>\n<li>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。</li>\n<li>static也可以用来声明一个内部函数</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"static和extern关键字对全局变量的作用\"><a href=\"#static和extern关键字对全局变量的作用\" class=\"headerlink\" title=\"static和extern关键字对全局变量的作用\"></a>static和extern关键字对全局变量的作用</h3><ol>\n<li>extern可以用来声明一个全局变量，但是不能用来定义变量</li>\n<li>默认情况下，一个全局变量是可以供多个源文件共享的，也就说，多个源文件中同名的全局变量都代表着同一个变量</li>\n<li>如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</li>\n</ol>\n<h3 id=\"Static对局部变量的作用\"><a href=\"#Static对局部变量的作用\" class=\"headerlink\" title=\"Static对局部变量的作用\"></a>Static对局部变量的作用</h3><ol>\n<li>用static修饰局部变量后会延长局部变量的生命周期，当执行到定义变量的那一行的时候分配存储空间，但是直到程序结束变量才会释放</li>\n<li>尽管延长了变量的生命周期，但是没有改变变量的作用域<br> 使用场合：当一个变量要被经常重复使用的时候就可以用static来修饰这个变量</li>\n</ol>\n<h2 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h2><blockquote>\n<p>可以使用typedef关键字为各种数据类型定义一个新名字(别名)，可以简化代码和提高阅读性。</p>\n</blockquote>\n<h3 id=\"typedef与指针\"><a href=\"#typedef与指针\" class=\"headerlink\" title=\"typedef与指针\"></a>typedef与指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char *String;</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    // 相当于char *str = &quot;This is a string!&quot;;</span><br><span class=\"line\">    String str = &quot;This is a string!&quot;;    </span><br><span class=\"line\">    printf(&quot;%s&quot;, str);   </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与结构体\"><a href=\"#typedef与结构体\" class=\"headerlink\" title=\"typedef与结构体\"></a>typedef与结构体</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体</span><br><span class=\"line\">struct MyPoint &#123;</span><br><span class=\"line\">    float x;</span><br><span class=\"line\">     float y;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">   // 定义结构体变量</span><br><span class=\"line\">    struct MyPoint p;</span><br><span class=\"line\">    p.x = 10.0f;</span><br><span class=\"line\">    p.y = 20.0f;</span><br><span class=\"line\">    retuen 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用typedef给结构体起别名\"><a href=\"#使用typedef给结构体起别名\" class=\"headerlink\" title=\"使用typedef给结构体起别名\"></a>使用typedef给结构体起别名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体</span><br><span class=\"line\">struct MyPoint &#123;</span><br><span class=\"line\">   float x;</span><br><span class=\"line\">   float y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 起别名</span><br><span class=\"line\">typedef struct MyPoint Point; </span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">  // 定义结构体变量</span><br><span class=\"line\">  Point p;</span><br><span class=\"line\">  p.x = 10.0f;</span><br><span class=\"line\">  p.y = 20.0f;    </span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与指向结构体的指针\"><a href=\"#typedef与指向结构体的指针\" class=\"headerlink\" title=\"typedef与指向结构体的指针\"></a>typedef与指向结构体的指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体并起别名</span><br><span class=\"line\"> typedef struct &#123;</span><br><span class=\"line\">    float x;</span><br><span class=\"line\">    float y;</span><br><span class=\"line\"> &#125; Point; </span><br><span class=\"line\"> // 起别名</span><br><span class=\"line\"> typedef Point *PP; </span><br><span class=\"line\"> int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    // 定义结构体变量</span><br><span class=\"line\">    Point point = &#123;10, 20&#125;;    </span><br><span class=\"line\">    // 定义指针变量</span><br><span class=\"line\">    PP p = &amp;point;     </span><br><span class=\"line\">    // 利用指针变量访问结构体成员</span><br><span class=\"line\">    printf(&quot;x=%f，y=%f&quot;, p-&gt;x, p-&gt;y);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与指向函数的指针\"><a href=\"#typedef与指向函数的指针\" class=\"headerlink\" title=\"typedef与指向函数的指针\"></a>typedef与指向函数的指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个sum函数，计算a跟b的和</span><br><span class=\"line\">  int sum(int a, int b) &#123;</span><br><span class=\"line\">      int c = a + b;</span><br><span class=\"line\">      printf(&quot;%d + %d = %d&quot;, a, b, c);</span><br><span class=\"line\">      return c;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"> typedef int (*MySum)(int, int);</span><br><span class=\"line\"> int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">     // 定义一个指向sum函数的指针变量p</span><br><span class=\"line\">     // int (*p)(int, int) = sum;  </span><br><span class=\"line\">     // 定义一个指向sum函数的指针变量p</span><br><span class=\"line\">     MySum p = sum;   </span><br><span class=\"line\">     // 利用指针变量p调用sum函数</span><br><span class=\"line\">     (*p)(4, 5);</span><br><span class=\"line\">     return 0;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与-define\"><a href=\"#typedef与-define\" class=\"headerlink\" title=\"typedef与#define\"></a>typedef与#define</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char *String1;//其别名</span><br><span class=\"line\">#define String2 char *//宏定义，在代码中只是将(char *)替换称String</span><br><span class=\"line\">int main(int argc, const char * argv[]) </span><br><span class=\"line\">    String1 str1, str2;   // 实际是char *str1,char *str2</span><br><span class=\"line\">    String2 str3, str4;   // 实际是char *str3,char str4</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用场合：\"><a href=\"#使用场合：\" class=\"headerlink\" title=\"使用场合：\"></a>使用场合：</h3><ul>\n<li>给基本数据类型起别名</li>\n<li>给指针起别名</li>\n<li>给结构体起别名</li>\n<li>给枚举起别名</li>\n<li>给指向函数的指针起别名</li>\n<li>给指向结构体的指针起别名</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"预处理指令\"><a href=\"#预处理指令\" class=\"headerlink\" title=\"预处理指令\"></a>预处理指令</h2><ul>\n<li>C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译</li>\n<li>为了区分预处理指令和一般的C语句，所有预处理指令都以符号“#”开头，并且结尾不用分号</li>\n<li>预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件</li>\n<li>C语言提供的预处理指令主要有：宏定义、文件包含、条件编译</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>宏定义可以分为2种：</p>\n<ol>\n<li><p>不带参数的宏定义 </p>\n<ul>\n<li><p>定义格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define 宏名 字符串</span><br><span class=\"line\">// 比如  #define ABC 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：是在编译预处理时，将源程序中所有”宏名”替换成右边的”字符串”，常用来定义常量。</p>\n</li>\n<li><p>使用习惯与注意</p>\n<ol>\n<li>宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误</li>\n<li>对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。</li>\n<li>在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查</li>\n<li>宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令</li>\n<li>定义一个宏时可以引用已经定义的宏名</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>带参数的宏定义</p>\n<ul>\n<li><p>定义格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define 宏名(参数列表) 字符串</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>作用：在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换.</p>\n</li>\n<li><p>使用注意：</p>\n<ol>\n<li>宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.</li>\n<li>带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。</li>\n<li>参数和计算结果都要用小括号括起来</li>\n</ol>\n</li>\n<li><p>与函数的区别：从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：</p>\n<ol>\n<li>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题</li>\n<li>函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h3><blockquote>\n<p>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。</p>\n</blockquote>\n<ul>\n<li><p>格式  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if 条件1</span><br><span class=\"line\">  ...code1...</span><br><span class=\"line\">#elif 条件2</span><br><span class=\"line\">  ...code2...</span><br><span class=\"line\">#else</span><br><span class=\"line\">  ...code3...</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意</p>\n<blockquote>\n<p>条件编译结束后，要在最后面加一个#endif，不然后果很严重。<br><code>#if</code> 和 <code>#elif</code>后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义。</p>\n</blockquote>\n</li>\n<li><p>条件编译其它用法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined()和#if !defined()的用法</span><br><span class=\"line\">//#if defined(MAX)</span><br><span class=\"line\">#if !defined(MAX)</span><br><span class=\"line\">    ...code...</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#ifdef 和 ifndef的用法</span><br><span class=\"line\"> //#ifdef MAX</span><br><span class=\"line\"> #ifndef MAX</span><br><span class=\"line\">     ...code...</span><br><span class=\"line\"> #endif</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"static-extern\"><a href=\"#static-extern\" class=\"headerlink\" title=\"static/extern\"></a>static/extern</h2><h3 id=\"static和extern关键字对函数的作用\"><a href=\"#static和extern关键字对函数的作用\" class=\"headerlink\" title=\"static和extern关键字对函数的作用\"></a>static和extern关键字对函数的作用</h3><ul>\n<li>外部函数和内部函数<ul>\n<li>外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。C语言规定，不允许有同名的外部函数。</li>\n<li>内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。C语言规定不同的源文件可以有同名的内部函数，并且互不干扰。</li>\n</ul>\n</li>\n<li><code>extern</code><ul>\n<li>在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。</li>\n<li>在一个文件中要调用其他文件中的外部函数，则需要在当前文件中用extern声明该外部函数，然后就可以使用，这里的extern也可以省略。</li>\n</ul>\n</li>\n<li><code>static</code><ul>\n<li>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。</li>\n<li>static也可以用来声明一个内部函数</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"static和extern关键字对全局变量的作用\"><a href=\"#static和extern关键字对全局变量的作用\" class=\"headerlink\" title=\"static和extern关键字对全局变量的作用\"></a>static和extern关键字对全局变量的作用</h3><ol>\n<li>extern可以用来声明一个全局变量，但是不能用来定义变量</li>\n<li>默认情况下，一个全局变量是可以供多个源文件共享的，也就说，多个源文件中同名的全局变量都代表着同一个变量</li>\n<li>如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰</li>\n</ol>\n<h3 id=\"Static对局部变量的作用\"><a href=\"#Static对局部变量的作用\" class=\"headerlink\" title=\"Static对局部变量的作用\"></a>Static对局部变量的作用</h3><ol>\n<li>用static修饰局部变量后会延长局部变量的生命周期，当执行到定义变量的那一行的时候分配存储空间，但是直到程序结束变量才会释放</li>\n<li>尽管延长了变量的生命周期，但是没有改变变量的作用域<br> 使用场合：当一个变量要被经常重复使用的时候就可以用static来修饰这个变量</li>\n</ol>\n<h2 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h2><blockquote>\n<p>可以使用typedef关键字为各种数据类型定义一个新名字(别名)，可以简化代码和提高阅读性。</p>\n</blockquote>\n<h3 id=\"typedef与指针\"><a href=\"#typedef与指针\" class=\"headerlink\" title=\"typedef与指针\"></a>typedef与指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char *String;</span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    // 相当于char *str = &quot;This is a string!&quot;;</span><br><span class=\"line\">    String str = &quot;This is a string!&quot;;    </span><br><span class=\"line\">    printf(&quot;%s&quot;, str);   </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与结构体\"><a href=\"#typedef与结构体\" class=\"headerlink\" title=\"typedef与结构体\"></a>typedef与结构体</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体</span><br><span class=\"line\">struct MyPoint &#123;</span><br><span class=\"line\">    float x;</span><br><span class=\"line\">     float y;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">   // 定义结构体变量</span><br><span class=\"line\">    struct MyPoint p;</span><br><span class=\"line\">    p.x = 10.0f;</span><br><span class=\"line\">    p.y = 20.0f;</span><br><span class=\"line\">    retuen 0;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用typedef给结构体起别名\"><a href=\"#使用typedef给结构体起别名\" class=\"headerlink\" title=\"使用typedef给结构体起别名\"></a>使用typedef给结构体起别名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体</span><br><span class=\"line\">struct MyPoint &#123;</span><br><span class=\"line\">   float x;</span><br><span class=\"line\">   float y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 起别名</span><br><span class=\"line\">typedef struct MyPoint Point; </span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">  // 定义结构体变量</span><br><span class=\"line\">  Point p;</span><br><span class=\"line\">  p.x = 10.0f;</span><br><span class=\"line\">  p.y = 20.0f;    </span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与指向结构体的指针\"><a href=\"#typedef与指向结构体的指针\" class=\"headerlink\" title=\"typedef与指向结构体的指针\"></a>typedef与指向结构体的指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个结构体并起别名</span><br><span class=\"line\"> typedef struct &#123;</span><br><span class=\"line\">    float x;</span><br><span class=\"line\">    float y;</span><br><span class=\"line\"> &#125; Point; </span><br><span class=\"line\"> // 起别名</span><br><span class=\"line\"> typedef Point *PP; </span><br><span class=\"line\"> int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    // 定义结构体变量</span><br><span class=\"line\">    Point point = &#123;10, 20&#125;;    </span><br><span class=\"line\">    // 定义指针变量</span><br><span class=\"line\">    PP p = &amp;point;     </span><br><span class=\"line\">    // 利用指针变量访问结构体成员</span><br><span class=\"line\">    printf(&quot;x=%f，y=%f&quot;, p-&gt;x, p-&gt;y);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与指向函数的指针\"><a href=\"#typedef与指向函数的指针\" class=\"headerlink\" title=\"typedef与指向函数的指针\"></a>typedef与指向函数的指针</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个sum函数，计算a跟b的和</span><br><span class=\"line\">  int sum(int a, int b) &#123;</span><br><span class=\"line\">      int c = a + b;</span><br><span class=\"line\">      printf(&quot;%d + %d = %d&quot;, a, b, c);</span><br><span class=\"line\">      return c;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"> typedef int (*MySum)(int, int);</span><br><span class=\"line\"> int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">     // 定义一个指向sum函数的指针变量p</span><br><span class=\"line\">     // int (*p)(int, int) = sum;  </span><br><span class=\"line\">     // 定义一个指向sum函数的指针变量p</span><br><span class=\"line\">     MySum p = sum;   </span><br><span class=\"line\">     // 利用指针变量p调用sum函数</span><br><span class=\"line\">     (*p)(4, 5);</span><br><span class=\"line\">     return 0;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typedef与-define\"><a href=\"#typedef与-define\" class=\"headerlink\" title=\"typedef与#define\"></a>typedef与#define</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef char *String1;//其别名</span><br><span class=\"line\">#define String2 char *//宏定义，在代码中只是将(char *)替换称String</span><br><span class=\"line\">int main(int argc, const char * argv[]) </span><br><span class=\"line\">    String1 str1, str2;   // 实际是char *str1,char *str2</span><br><span class=\"line\">    String2 str3, str4;   // 实际是char *str3,char str4</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用场合：\"><a href=\"#使用场合：\" class=\"headerlink\" title=\"使用场合：\"></a>使用场合：</h3><ul>\n<li>给基本数据类型起别名</li>\n<li>给指针起别名</li>\n<li>给结构体起别名</li>\n<li>给枚举起别名</li>\n<li>给指向函数的指针起别名</li>\n<li>给指向结构体的指针起别名</li>\n</ul>\n"},{"title":"Dart初识","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-15T09:24:00.000Z","_content":"## Dart简介\nDart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。\n\nDart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system。\n\n## Hello Word\n```dart\nvoid main()\n{\n  print(\"Hello, world!\");\n}\n```\n## Dart语法规则\n- Dart中所有的变量包括数字、函数和null 都是对象，每一个 对象都是一个类的实例，他们都继承于Object\n- Dart是强类型语言，但是生明变量时也可以不指定类型，因为Dart可以自动推断，在上面的例子中，变量number就被自动推断为int类型\n- Dart支持泛型，如`List<int>`表示集合元素类型为整型、`List<dynamic>`表示元素类型为任何类型\n- Dart除了支持我们常见的静态函数(类直接调用)和普通函数(对象调用)外，同时也支持顶级函数如main() 和嵌套函数(函数里面的函数，也叫本地函数)\n- 与函数类似，Dart也支持顶级变量，同时支持静态变量和实例变量，实例变量也被叫做字段或属性\n和java不同，Dart没有public、protected、private权限修饰符，在Dart里以下划线`_`开头的标志符表示是私有的\n- Dart里面的标识符可以字母或下划线(_)开头，以字符和数字的任何组合。\n- 要注意区分表达式和语句的不同，如var a = 3 + 2; //整体是一个赋值语句，“=”右边部分即\"3 + 2\"是一个表达式。\n- Dart工具会向你发出两种类型的提醒：警告和错误。警告代表你的代码可能有问题，但是不会阻止程序的运行；错误分为编译错误和运行错误，前者会阻止程序的运行，后者则会在程序运行使抛出异常！\n\n## 关键字\n![](/img/keywords.png)\n> - 上面带有字样`1`的是内置标志符号，这些不能作为变量名。\n> - 带有上标`2`的单词是内置的标识符。为了简化将JavaScript代码移植到DART的任务，这些关键字在大多数地方都是有效的标识符，但它们不能用作类名或类型名称，也不能用作导入前缀。\n> - 带有`3`字样的是Dart2新增的用于支持异步的关键字，其他的都是保留字！\n\n## 变量\n### 变量声明有以下几种方式：\n```dart\nvar name = 'Bob'; //类型自动推断\ndynamic name = 'Bob';//dynamic表示变量类型不是单一的\nString name = 'Bob';//明确声明变量的类型\nint lineCount;//所有的变量包括数字类型，如果没有初始化，其默认值都是null\n```\n### const和final\n用法和其他语言类似,在声明变量的时候，除了var，还可以使用const和final,同时，在使用const和final的时候，可以省略var或者其他类型。\n\nconst和final定义的都是常量，值不能改变并且在声明的时候就必须初始化但是也有细微差别，简单来说\n- const定义的是编译时常量，只能用编译时常量来初始化\n- final定义的常量可以用变量来初始化\n```Dart\nfinal time = new DateTime.now(); //Ok\nconst time = new DateTime.now(); //Error，new DateTime.now()不是const常量\n```\nvar、final在左边定义变量的时候，并不关心右边是不是常量,但是如果右边用了const，那么不管左边如何，右边都必须是常量。\n```Dart\nconst list = const[1,2,3];//Ok\nconst list = [1,2,3];//Error\n\nfinal list = [1,2,3];//Ok\nfinal list = const[1,2,3];//Ok\nfinal list = const[new DateTime.now(),2,3];//Error,const右边必须是常量\n```\n\n## 数据类型\nDart中所有东西都是对象，包括数字、函数等\n它们都继承自Object，并且默认值都是null（包括数字）因此数字、字符串都可以调用各种方法\n\nDart有七种内置的数据类型:\n- numbers\n- strings\n- booleans\n- lists (也称为数组)\n- maps\n- runes (用于表示字符串中的Unicode字符)\n- symbols\n\n### numbers\n> Dart中Numbers有两种形式\n1. int\n> 整数值不大于64位，取决于平台。在DART VM上，值范围为 -2^63 to 2^63 - 1.编译为JavaScript的DART使用JavaScript数字，允许从-2^53到2^53-1之间的值。\n2. double\n> 64位(双精度)浮点数字\n\nint和double都是num的子类型，num包含基本操作符如+ - / *，同时也有众多的方法如abs() ceil() floor()等，int里面还有位操作符如>>,更多详细内容参见[dart:math](https://api.dartlang.org/stable/dart-math).\n\n```Dart\nvoid main()\n{\n  //Dart 语言本质上是动态类型语言，类型是可选的\n  //可以使用 var 声明变量，也可以使用类型来声明变量\n  //一个变量也可以被赋予不同类型的对象\n  //但大多数情况，我们不会去改变一个变量的类型\n\n  //字符串赋值的时候，可以使用单引号，也可以使用双引号\n  var str1 = \"Ok?\";\n\n  //如果使用的是双引号，可以内嵌单引号\n  //当然，如果使用的是单引号，可以内嵌双引号，否则需要“\\”转义\n  //String str2 = ‘It\\’s ok!’;\n  String str2 = \"It's ok!\";\n\n  //使用三个单引号或者双引号可以多行字符串赋值\n  var str3 = \"\"\"Dart Lang\n  Hello,World!\"\"\";\n\n  //在Dart中，相邻的字符串在编译的时候会自动连接\n  //这里发现一个问题，如果多个字符串相邻，中间的字符串不能为空，否则报错\n  //但是如果单引号和双引号相邻，即使是空值也不会报错，但相信没有人这么做\n  //var name = 'Wang''''Jianfei'; 报错\n  var name = 'Wang'' ''Jianfei';\n\n  //assert 是语言内置的断言函数，仅在检查模式下有效\n  //如果断言失败则程序立刻终止\n  assert(name == \"Wang Jianfei\");\n\n  //Dart中字符串不支持“+”操作符，如str1 + str2\n  //如果要链接字符串，除了上面诉说，相邻字符串自动连接外\n  //还可以使用“$”插入变量的值\n  print(\"Name：$name\");\n\n  //声明原始字符串，直接在字符串前加字符“r”\n  //可以避免“\\”的转义作用，在正则表达式里特别有用\n  print(r\"换行符：\\n\");\n\n  //Dart中数值是num，它有两个子类型：int 和 double\n  //int是任意长度的整数，double是双精度浮点数\n  var hex = 0xDEADBEEF;\n\n  //翻了半天的文档，才找打一个重要的函数：转换进制，英文太不过关了\n  //上面提到的字符串插值，还可以插入表达式：${}\n  print(\"整型转换为16进制：$hex —> 0x${hex.toRadixString(16).toUpperCase()}\");\n\n}\n```\n### Booleans\nDart是强布尔类型检查，只有当值是true是才为真，其他都是false，声明时用bool\n\n### Lists\n在 Dart　语言中，具有一系列相同类型的数据被称为 List 对象。\nDart List 对象类似JavaScript 语言的 array 对象。\n```Dart\nvar list = [1, 2, 3];//分析器自动推断list为List<int>,所以里面不能加入其他类型的元素\nprint(list.length);//3\nlist[1] = 11;\nprint(list.toString());//[1, 11, 3]\nvar constantList = const [1, 2, 3];\n// constantList[1] = 1; //因为前面的赋值使用了const 所以这句会报错.\nconstantList= [5];//这样可以\n```\n### Maps\nmap是一个包含key和value的对象，key不能重复\n```Dart\nvar gifts = {\n  // Key:    Value\n  'first': 'partridge',\n  'second': 'turtledoves',\n  'fifth': 'golden rings'\n};\n\nvar nobleGases = {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n\nvar gifts2 = new Map();\ngifts['first'] = 'partridge';\ngifts['second'] = 'turtledoves';\ngifts['fifth'] = 'golden rings';\n\nvar nobleGases2 = new Map();\nnobleGases[2] = 'helium';\nnobleGases[10] = 'neon';\nnobleGases[18] = 'argon';\n\n//获取value\nprint(gifts2['first']);// partridge;\nprint(gifts2.length);// 3\n```\n### Runes\nDart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符\n```Dart\nvar clapping = '\\u{1f44f}';\nprint(clapping);\nprint(clapping.codeUnits);\nprint(clapping.runes.toList());\n\nRunes input = new Runes(\n  '\\u2665  \\u{1f605}  \\u{1f60e}  \\u{1f47b}  \\u{1f596}  \\u{1f44d}');\nprint(new String.fromCharCodes(input));\n```\n### Symbols\nsymbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化.我们可能永远也不用不到Symbol\n```Dart\nprint(#s == new Symbol('s'));//true\n```\n","source":"_posts/dart/02_Dart初识.md","raw":"---\ntitle: Dart初识\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-15 17:24:00   \n---\n## Dart简介\nDart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。\n\nDart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system。\n\n## Hello Word\n```dart\nvoid main()\n{\n  print(\"Hello, world!\");\n}\n```\n## Dart语法规则\n- Dart中所有的变量包括数字、函数和null 都是对象，每一个 对象都是一个类的实例，他们都继承于Object\n- Dart是强类型语言，但是生明变量时也可以不指定类型，因为Dart可以自动推断，在上面的例子中，变量number就被自动推断为int类型\n- Dart支持泛型，如`List<int>`表示集合元素类型为整型、`List<dynamic>`表示元素类型为任何类型\n- Dart除了支持我们常见的静态函数(类直接调用)和普通函数(对象调用)外，同时也支持顶级函数如main() 和嵌套函数(函数里面的函数，也叫本地函数)\n- 与函数类似，Dart也支持顶级变量，同时支持静态变量和实例变量，实例变量也被叫做字段或属性\n和java不同，Dart没有public、protected、private权限修饰符，在Dart里以下划线`_`开头的标志符表示是私有的\n- Dart里面的标识符可以字母或下划线(_)开头，以字符和数字的任何组合。\n- 要注意区分表达式和语句的不同，如var a = 3 + 2; //整体是一个赋值语句，“=”右边部分即\"3 + 2\"是一个表达式。\n- Dart工具会向你发出两种类型的提醒：警告和错误。警告代表你的代码可能有问题，但是不会阻止程序的运行；错误分为编译错误和运行错误，前者会阻止程序的运行，后者则会在程序运行使抛出异常！\n\n## 关键字\n![](/img/keywords.png)\n> - 上面带有字样`1`的是内置标志符号，这些不能作为变量名。\n> - 带有上标`2`的单词是内置的标识符。为了简化将JavaScript代码移植到DART的任务，这些关键字在大多数地方都是有效的标识符，但它们不能用作类名或类型名称，也不能用作导入前缀。\n> - 带有`3`字样的是Dart2新增的用于支持异步的关键字，其他的都是保留字！\n\n## 变量\n### 变量声明有以下几种方式：\n```dart\nvar name = 'Bob'; //类型自动推断\ndynamic name = 'Bob';//dynamic表示变量类型不是单一的\nString name = 'Bob';//明确声明变量的类型\nint lineCount;//所有的变量包括数字类型，如果没有初始化，其默认值都是null\n```\n### const和final\n用法和其他语言类似,在声明变量的时候，除了var，还可以使用const和final,同时，在使用const和final的时候，可以省略var或者其他类型。\n\nconst和final定义的都是常量，值不能改变并且在声明的时候就必须初始化但是也有细微差别，简单来说\n- const定义的是编译时常量，只能用编译时常量来初始化\n- final定义的常量可以用变量来初始化\n```Dart\nfinal time = new DateTime.now(); //Ok\nconst time = new DateTime.now(); //Error，new DateTime.now()不是const常量\n```\nvar、final在左边定义变量的时候，并不关心右边是不是常量,但是如果右边用了const，那么不管左边如何，右边都必须是常量。\n```Dart\nconst list = const[1,2,3];//Ok\nconst list = [1,2,3];//Error\n\nfinal list = [1,2,3];//Ok\nfinal list = const[1,2,3];//Ok\nfinal list = const[new DateTime.now(),2,3];//Error,const右边必须是常量\n```\n\n## 数据类型\nDart中所有东西都是对象，包括数字、函数等\n它们都继承自Object，并且默认值都是null（包括数字）因此数字、字符串都可以调用各种方法\n\nDart有七种内置的数据类型:\n- numbers\n- strings\n- booleans\n- lists (也称为数组)\n- maps\n- runes (用于表示字符串中的Unicode字符)\n- symbols\n\n### numbers\n> Dart中Numbers有两种形式\n1. int\n> 整数值不大于64位，取决于平台。在DART VM上，值范围为 -2^63 to 2^63 - 1.编译为JavaScript的DART使用JavaScript数字，允许从-2^53到2^53-1之间的值。\n2. double\n> 64位(双精度)浮点数字\n\nint和double都是num的子类型，num包含基本操作符如+ - / *，同时也有众多的方法如abs() ceil() floor()等，int里面还有位操作符如>>,更多详细内容参见[dart:math](https://api.dartlang.org/stable/dart-math).\n\n```Dart\nvoid main()\n{\n  //Dart 语言本质上是动态类型语言，类型是可选的\n  //可以使用 var 声明变量，也可以使用类型来声明变量\n  //一个变量也可以被赋予不同类型的对象\n  //但大多数情况，我们不会去改变一个变量的类型\n\n  //字符串赋值的时候，可以使用单引号，也可以使用双引号\n  var str1 = \"Ok?\";\n\n  //如果使用的是双引号，可以内嵌单引号\n  //当然，如果使用的是单引号，可以内嵌双引号，否则需要“\\”转义\n  //String str2 = ‘It\\’s ok!’;\n  String str2 = \"It's ok!\";\n\n  //使用三个单引号或者双引号可以多行字符串赋值\n  var str3 = \"\"\"Dart Lang\n  Hello,World!\"\"\";\n\n  //在Dart中，相邻的字符串在编译的时候会自动连接\n  //这里发现一个问题，如果多个字符串相邻，中间的字符串不能为空，否则报错\n  //但是如果单引号和双引号相邻，即使是空值也不会报错，但相信没有人这么做\n  //var name = 'Wang''''Jianfei'; 报错\n  var name = 'Wang'' ''Jianfei';\n\n  //assert 是语言内置的断言函数，仅在检查模式下有效\n  //如果断言失败则程序立刻终止\n  assert(name == \"Wang Jianfei\");\n\n  //Dart中字符串不支持“+”操作符，如str1 + str2\n  //如果要链接字符串，除了上面诉说，相邻字符串自动连接外\n  //还可以使用“$”插入变量的值\n  print(\"Name：$name\");\n\n  //声明原始字符串，直接在字符串前加字符“r”\n  //可以避免“\\”的转义作用，在正则表达式里特别有用\n  print(r\"换行符：\\n\");\n\n  //Dart中数值是num，它有两个子类型：int 和 double\n  //int是任意长度的整数，double是双精度浮点数\n  var hex = 0xDEADBEEF;\n\n  //翻了半天的文档，才找打一个重要的函数：转换进制，英文太不过关了\n  //上面提到的字符串插值，还可以插入表达式：${}\n  print(\"整型转换为16进制：$hex —> 0x${hex.toRadixString(16).toUpperCase()}\");\n\n}\n```\n### Booleans\nDart是强布尔类型检查，只有当值是true是才为真，其他都是false，声明时用bool\n\n### Lists\n在 Dart　语言中，具有一系列相同类型的数据被称为 List 对象。\nDart List 对象类似JavaScript 语言的 array 对象。\n```Dart\nvar list = [1, 2, 3];//分析器自动推断list为List<int>,所以里面不能加入其他类型的元素\nprint(list.length);//3\nlist[1] = 11;\nprint(list.toString());//[1, 11, 3]\nvar constantList = const [1, 2, 3];\n// constantList[1] = 1; //因为前面的赋值使用了const 所以这句会报错.\nconstantList= [5];//这样可以\n```\n### Maps\nmap是一个包含key和value的对象，key不能重复\n```Dart\nvar gifts = {\n  // Key:    Value\n  'first': 'partridge',\n  'second': 'turtledoves',\n  'fifth': 'golden rings'\n};\n\nvar nobleGases = {\n  2: 'helium',\n  10: 'neon',\n  18: 'argon',\n};\n\nvar gifts2 = new Map();\ngifts['first'] = 'partridge';\ngifts['second'] = 'turtledoves';\ngifts['fifth'] = 'golden rings';\n\nvar nobleGases2 = new Map();\nnobleGases[2] = 'helium';\nnobleGases[10] = 'neon';\nnobleGases[18] = 'argon';\n\n//获取value\nprint(gifts2['first']);// partridge;\nprint(gifts2.length);// 3\n```\n### Runes\nDart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符\n```Dart\nvar clapping = '\\u{1f44f}';\nprint(clapping);\nprint(clapping.codeUnits);\nprint(clapping.runes.toList());\n\nRunes input = new Runes(\n  '\\u2665  \\u{1f605}  \\u{1f60e}  \\u{1f47b}  \\u{1f596}  \\u{1f44d}');\nprint(new String.fromCharCodes(input));\n```\n### Symbols\nsymbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化.我们可能永远也不用不到Symbol\n```Dart\nprint(#s == new Symbol('s'));//true\n```\n","slug":"dart/02_Dart初识","published":1,"updated":"2019-10-02T09:23:04.182Z","layout":"post","photos":[],"link":"","_id":"ck19bvb0x002s00wkuzun60m9","content":"<h2 id=\"Dart简介\"><a href=\"#Dart简介\" class=\"headerlink\" title=\"Dart简介\"></a>Dart简介</h2><p>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。</p>\n<p>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system。</p>\n<h2 id=\"Hello-Word\"><a href=\"#Hello-Word\" class=\"headerlink\" title=\"Hello Word\"></a>Hello Word</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello, world!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dart语法规则\"><a href=\"#Dart语法规则\" class=\"headerlink\" title=\"Dart语法规则\"></a>Dart语法规则</h2><ul>\n<li>Dart中所有的变量包括数字、函数和null 都是对象，每一个 对象都是一个类的实例，他们都继承于Object</li>\n<li>Dart是强类型语言，但是生明变量时也可以不指定类型，因为Dart可以自动推断，在上面的例子中，变量number就被自动推断为int类型</li>\n<li>Dart支持泛型，如<code>List&lt;int&gt;</code>表示集合元素类型为整型、<code>List&lt;dynamic&gt;</code>表示元素类型为任何类型</li>\n<li>Dart除了支持我们常见的静态函数(类直接调用)和普通函数(对象调用)外，同时也支持顶级函数如main() 和嵌套函数(函数里面的函数，也叫本地函数)</li>\n<li>与函数类似，Dart也支持顶级变量，同时支持静态变量和实例变量，实例变量也被叫做字段或属性<br>和java不同，Dart没有public、protected、private权限修饰符，在Dart里以下划线<code>_</code>开头的标志符表示是私有的</li>\n<li>Dart里面的标识符可以字母或下划线(_)开头，以字符和数字的任何组合。</li>\n<li>要注意区分表达式和语句的不同，如var a = 3 + 2; //整体是一个赋值语句，“=”右边部分即”3 + 2”是一个表达式。</li>\n<li>Dart工具会向你发出两种类型的提醒：警告和错误。警告代表你的代码可能有问题，但是不会阻止程序的运行；错误分为编译错误和运行错误，前者会阻止程序的运行，后者则会在程序运行使抛出异常！</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><p><img src=\"/img/keywords.png\" alt></p>\n<blockquote>\n<ul>\n<li>上面带有字样<code>1</code>的是内置标志符号，这些不能作为变量名。</li>\n<li>带有上标<code>2</code>的单词是内置的标识符。为了简化将JavaScript代码移植到DART的任务，这些关键字在大多数地方都是有效的标识符，但它们不能用作类名或类型名称，也不能用作导入前缀。</li>\n<li>带有<code>3</code>字样的是Dart2新增的用于支持异步的关键字，其他的都是保留字！</li>\n</ul>\n</blockquote>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"变量声明有以下几种方式：\"><a href=\"#变量声明有以下几种方式：\" class=\"headerlink\" title=\"变量声明有以下几种方式：\"></a>变量声明有以下几种方式：</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Bob'</span>; <span class=\"comment\">//类型自动推断</span></span><br><span class=\"line\"><span class=\"keyword\">dynamic</span> name = <span class=\"string\">'Bob'</span>;<span class=\"comment\">//dynamic表示变量类型不是单一的</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> name = <span class=\"string\">'Bob'</span>;<span class=\"comment\">//明确声明变量的类型</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> lineCount;<span class=\"comment\">//所有的变量包括数字类型，如果没有初始化，其默认值都是null</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"const和final\"><a href=\"#const和final\" class=\"headerlink\" title=\"const和final\"></a>const和final</h3><p>用法和其他语言类似,在声明变量的时候，除了var，还可以使用const和final,同时，在使用const和final的时候，可以省略var或者其他类型。</p>\n<p>const和final定义的都是常量，值不能改变并且在声明的时候就必须初始化但是也有细微差别，简单来说</p>\n<ul>\n<li>const定义的是编译时常量，只能用编译时常量来初始化</li>\n<li>final定义的常量可以用变量来初始化<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">DateTime</span>.now(); <span class=\"comment\">//Ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">DateTime</span>.now(); <span class=\"comment\">//Error，new DateTime.now()不是const常量</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>var、final在左边定义变量的时候，并不关心右边是不是常量,但是如果右边用了const，那么不管左边如何，右边都必须是常量。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> list = <span class=\"keyword\">const</span>[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Ok</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> list = <span class=\"keyword\">const</span>[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Ok</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> list = <span class=\"keyword\">const</span>[<span class=\"keyword\">new</span> <span class=\"built_in\">DateTime</span>.now(),<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Error,const右边必须是常量</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>Dart中所有东西都是对象，包括数字、函数等<br>它们都继承自Object，并且默认值都是null（包括数字）因此数字、字符串都可以调用各种方法</p>\n<p>Dart有七种内置的数据类型:</p>\n<ul>\n<li>numbers</li>\n<li>strings</li>\n<li>booleans</li>\n<li>lists (也称为数组)</li>\n<li>maps</li>\n<li>runes (用于表示字符串中的Unicode字符)</li>\n<li>symbols</li>\n</ul>\n<h3 id=\"numbers\"><a href=\"#numbers\" class=\"headerlink\" title=\"numbers\"></a>numbers</h3><blockquote>\n<p>Dart中Numbers有两种形式</p>\n<ol>\n<li>int<br>整数值不大于64位，取决于平台。在DART VM上，值范围为 -2^63 to 2^63 - 1.编译为JavaScript的DART使用JavaScript数字，允许从-2^53到2^53-1之间的值。</li>\n<li>double<br>64位(双精度)浮点数字</li>\n</ol>\n</blockquote>\n<p>int和double都是num的子类型，num包含基本操作符如+ - / *，同时也有众多的方法如abs() ceil() floor()等，int里面还有位操作符如&gt;&gt;,更多详细内容参见<a href=\"https://api.dartlang.org/stable/dart-math\" target=\"_blank\" rel=\"noopener\">dart:math</a>.</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">//Dart 语言本质上是动态类型语言，类型是可选的</span></span><br><span class=\"line\">  <span class=\"comment\">//可以使用 var 声明变量，也可以使用类型来声明变量</span></span><br><span class=\"line\">  <span class=\"comment\">//一个变量也可以被赋予不同类型的对象</span></span><br><span class=\"line\">  <span class=\"comment\">//但大多数情况，我们不会去改变一个变量的类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//字符串赋值的时候，可以使用单引号，也可以使用双引号</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> str1 = <span class=\"string\">\"Ok?\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果使用的是双引号，可以内嵌单引号</span></span><br><span class=\"line\">  <span class=\"comment\">//当然，如果使用的是单引号，可以内嵌双引号，否则需要“\\”转义</span></span><br><span class=\"line\">  <span class=\"comment\">//String str2 = ‘It\\’s ok!’;</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> str2 = <span class=\"string\">\"It's ok!\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//使用三个单引号或者双引号可以多行字符串赋值</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> str3 = <span class=\"string\">\"\"\"Dart Lang</span></span><br><span class=\"line\"><span class=\"string\">  Hello,World!\"\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//在Dart中，相邻的字符串在编译的时候会自动连接</span></span><br><span class=\"line\">  <span class=\"comment\">//这里发现一个问题，如果多个字符串相邻，中间的字符串不能为空，否则报错</span></span><br><span class=\"line\">  <span class=\"comment\">//但是如果单引号和双引号相邻，即使是空值也不会报错，但相信没有人这么做</span></span><br><span class=\"line\">  <span class=\"comment\">//var name = 'Wang''''Jianfei'; 报错</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'Wang'</span><span class=\"string\">' '</span><span class=\"string\">'Jianfei'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//assert 是语言内置的断言函数，仅在检查模式下有效</span></span><br><span class=\"line\">  <span class=\"comment\">//如果断言失败则程序立刻终止</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(name == <span class=\"string\">\"Wang Jianfei\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//Dart中字符串不支持“+”操作符，如str1 + str2</span></span><br><span class=\"line\">  <span class=\"comment\">//如果要链接字符串，除了上面诉说，相邻字符串自动连接外</span></span><br><span class=\"line\">  <span class=\"comment\">//还可以使用“$”插入变量的值</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"Name：<span class=\"subst\">$name</span>\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明原始字符串，直接在字符串前加字符“r”</span></span><br><span class=\"line\">  <span class=\"comment\">//可以避免“\\”的转义作用，在正则表达式里特别有用</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">r\"换行符：\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//Dart中数值是num，它有两个子类型：int 和 double</span></span><br><span class=\"line\">  <span class=\"comment\">//int是任意长度的整数，double是双精度浮点数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> hex = <span class=\"number\">0xDEADBEEF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//翻了半天的文档，才找打一个重要的函数：转换进制，英文太不过关了</span></span><br><span class=\"line\">  <span class=\"comment\">//上面提到的字符串插值，还可以插入表达式：$&#123;&#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"整型转换为16进制：<span class=\"subst\">$hex</span> —&gt; 0x<span class=\"subst\">$&#123;hex.toRadixString(<span class=\"number\">16</span>).toUpperCase()&#125;</span>\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Booleans\"><a href=\"#Booleans\" class=\"headerlink\" title=\"Booleans\"></a>Booleans</h3><p>Dart是强布尔类型检查，只有当值是true是才为真，其他都是false，声明时用bool</p>\n<h3 id=\"Lists\"><a href=\"#Lists\" class=\"headerlink\" title=\"Lists\"></a>Lists</h3><p>在 Dart　语言中，具有一系列相同类型的数据被称为 List 对象。<br>Dart List 对象类似JavaScript 语言的 array 对象。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];<span class=\"comment\">//分析器自动推断list为List&lt;int&gt;,所以里面不能加入其他类型的元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(list.length);<span class=\"comment\">//3</span></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">11</span>;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(list.toString());<span class=\"comment\">//[1, 11, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> constantList = <span class=\"keyword\">const</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">// constantList[1] = 1; //因为前面的赋值使用了const 所以这句会报错.</span></span><br><span class=\"line\">constantList= [<span class=\"number\">5</span>];<span class=\"comment\">//这样可以</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Maps\"><a href=\"#Maps\" class=\"headerlink\" title=\"Maps\"></a>Maps</h3><p>map是一个包含key和value的对象，key不能重复</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Key:    Value</span></span><br><span class=\"line\">  <span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>,</span><br><span class=\"line\">  <span class=\"string\">'second'</span>: <span class=\"string\">'turtledoves'</span>,</span><br><span class=\"line\">  <span class=\"string\">'fifth'</span>: <span class=\"string\">'golden rings'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nobleGases = &#123;</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'helium'</span>,</span><br><span class=\"line\">  <span class=\"number\">10</span>: <span class=\"string\">'neon'</span>,</span><br><span class=\"line\">  <span class=\"number\">18</span>: <span class=\"string\">'argon'</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> gifts2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">gifts[<span class=\"string\">'first'</span>] = <span class=\"string\">'partridge'</span>;</span><br><span class=\"line\">gifts[<span class=\"string\">'second'</span>] = <span class=\"string\">'turtledoves'</span>;</span><br><span class=\"line\">gifts[<span class=\"string\">'fifth'</span>] = <span class=\"string\">'golden rings'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nobleGases2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">nobleGases[<span class=\"number\">2</span>] = <span class=\"string\">'helium'</span>;</span><br><span class=\"line\">nobleGases[<span class=\"number\">10</span>] = <span class=\"string\">'neon'</span>;</span><br><span class=\"line\">nobleGases[<span class=\"number\">18</span>] = <span class=\"string\">'argon'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取value</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(gifts2[<span class=\"string\">'first'</span>]);<span class=\"comment\">// partridge;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(gifts2.length);<span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Runes\"><a href=\"#Runes\" class=\"headerlink\" title=\"Runes\"></a>Runes</h3><p>Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> clapping = <span class=\"string\">'\\u&#123;1f44f&#125;'</span>;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping.codeUnits);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping.runes.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">Runes input = <span class=\"keyword\">new</span> Runes(</span><br><span class=\"line\">  <span class=\"string\">'\\u2665  \\u&#123;1f605&#125;  \\u&#123;1f60e&#125;  \\u&#123;1f47b&#125;  \\u&#123;1f596&#125;  \\u&#123;1f44d&#125;'</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>.fromCharCodes(input));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbols\"><a href=\"#Symbols\" class=\"headerlink\" title=\"Symbols\"></a>Symbols</h3><p>symbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化.我们可能永远也不用不到Symbol</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(#s == <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">'s'</span>));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Dart简介\"><a href=\"#Dart简介\" class=\"headerlink\" title=\"Dart简介\"></a>Dart简介</h2><p>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。</p>\n<p>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system。</p>\n<h2 id=\"Hello-Word\"><a href=\"#Hello-Word\" class=\"headerlink\" title=\"Hello Word\"></a>Hello Word</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello, world!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dart语法规则\"><a href=\"#Dart语法规则\" class=\"headerlink\" title=\"Dart语法规则\"></a>Dart语法规则</h2><ul>\n<li>Dart中所有的变量包括数字、函数和null 都是对象，每一个 对象都是一个类的实例，他们都继承于Object</li>\n<li>Dart是强类型语言，但是生明变量时也可以不指定类型，因为Dart可以自动推断，在上面的例子中，变量number就被自动推断为int类型</li>\n<li>Dart支持泛型，如<code>List&lt;int&gt;</code>表示集合元素类型为整型、<code>List&lt;dynamic&gt;</code>表示元素类型为任何类型</li>\n<li>Dart除了支持我们常见的静态函数(类直接调用)和普通函数(对象调用)外，同时也支持顶级函数如main() 和嵌套函数(函数里面的函数，也叫本地函数)</li>\n<li>与函数类似，Dart也支持顶级变量，同时支持静态变量和实例变量，实例变量也被叫做字段或属性<br>和java不同，Dart没有public、protected、private权限修饰符，在Dart里以下划线<code>_</code>开头的标志符表示是私有的</li>\n<li>Dart里面的标识符可以字母或下划线(_)开头，以字符和数字的任何组合。</li>\n<li>要注意区分表达式和语句的不同，如var a = 3 + 2; //整体是一个赋值语句，“=”右边部分即”3 + 2”是一个表达式。</li>\n<li>Dart工具会向你发出两种类型的提醒：警告和错误。警告代表你的代码可能有问题，但是不会阻止程序的运行；错误分为编译错误和运行错误，前者会阻止程序的运行，后者则会在程序运行使抛出异常！</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><p><img src=\"/img/keywords.png\" alt></p>\n<blockquote>\n<ul>\n<li>上面带有字样<code>1</code>的是内置标志符号，这些不能作为变量名。</li>\n<li>带有上标<code>2</code>的单词是内置的标识符。为了简化将JavaScript代码移植到DART的任务，这些关键字在大多数地方都是有效的标识符，但它们不能用作类名或类型名称，也不能用作导入前缀。</li>\n<li>带有<code>3</code>字样的是Dart2新增的用于支持异步的关键字，其他的都是保留字！</li>\n</ul>\n</blockquote>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"变量声明有以下几种方式：\"><a href=\"#变量声明有以下几种方式：\" class=\"headerlink\" title=\"变量声明有以下几种方式：\"></a>变量声明有以下几种方式：</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Bob'</span>; <span class=\"comment\">//类型自动推断</span></span><br><span class=\"line\"><span class=\"keyword\">dynamic</span> name = <span class=\"string\">'Bob'</span>;<span class=\"comment\">//dynamic表示变量类型不是单一的</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> name = <span class=\"string\">'Bob'</span>;<span class=\"comment\">//明确声明变量的类型</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> lineCount;<span class=\"comment\">//所有的变量包括数字类型，如果没有初始化，其默认值都是null</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"const和final\"><a href=\"#const和final\" class=\"headerlink\" title=\"const和final\"></a>const和final</h3><p>用法和其他语言类似,在声明变量的时候，除了var，还可以使用const和final,同时，在使用const和final的时候，可以省略var或者其他类型。</p>\n<p>const和final定义的都是常量，值不能改变并且在声明的时候就必须初始化但是也有细微差别，简单来说</p>\n<ul>\n<li>const定义的是编译时常量，只能用编译时常量来初始化</li>\n<li>final定义的常量可以用变量来初始化<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">DateTime</span>.now(); <span class=\"comment\">//Ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> time = <span class=\"keyword\">new</span> <span class=\"built_in\">DateTime</span>.now(); <span class=\"comment\">//Error，new DateTime.now()不是const常量</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>var、final在左边定义变量的时候，并不关心右边是不是常量,但是如果右边用了const，那么不管左边如何，右边都必须是常量。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> list = <span class=\"keyword\">const</span>[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Ok</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> list = <span class=\"keyword\">const</span>[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Ok</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> list = <span class=\"keyword\">const</span>[<span class=\"keyword\">new</span> <span class=\"built_in\">DateTime</span>.now(),<span class=\"number\">2</span>,<span class=\"number\">3</span>];<span class=\"comment\">//Error,const右边必须是常量</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>Dart中所有东西都是对象，包括数字、函数等<br>它们都继承自Object，并且默认值都是null（包括数字）因此数字、字符串都可以调用各种方法</p>\n<p>Dart有七种内置的数据类型:</p>\n<ul>\n<li>numbers</li>\n<li>strings</li>\n<li>booleans</li>\n<li>lists (也称为数组)</li>\n<li>maps</li>\n<li>runes (用于表示字符串中的Unicode字符)</li>\n<li>symbols</li>\n</ul>\n<h3 id=\"numbers\"><a href=\"#numbers\" class=\"headerlink\" title=\"numbers\"></a>numbers</h3><blockquote>\n<p>Dart中Numbers有两种形式</p>\n<ol>\n<li>int<br>整数值不大于64位，取决于平台。在DART VM上，值范围为 -2^63 to 2^63 - 1.编译为JavaScript的DART使用JavaScript数字，允许从-2^53到2^53-1之间的值。</li>\n<li>double<br>64位(双精度)浮点数字</li>\n</ol>\n</blockquote>\n<p>int和double都是num的子类型，num包含基本操作符如+ - / *，同时也有众多的方法如abs() ceil() floor()等，int里面还有位操作符如&gt;&gt;,更多详细内容参见<a href=\"https://api.dartlang.org/stable/dart-math\" target=\"_blank\" rel=\"noopener\">dart:math</a>.</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">//Dart 语言本质上是动态类型语言，类型是可选的</span></span><br><span class=\"line\">  <span class=\"comment\">//可以使用 var 声明变量，也可以使用类型来声明变量</span></span><br><span class=\"line\">  <span class=\"comment\">//一个变量也可以被赋予不同类型的对象</span></span><br><span class=\"line\">  <span class=\"comment\">//但大多数情况，我们不会去改变一个变量的类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//字符串赋值的时候，可以使用单引号，也可以使用双引号</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> str1 = <span class=\"string\">\"Ok?\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果使用的是双引号，可以内嵌单引号</span></span><br><span class=\"line\">  <span class=\"comment\">//当然，如果使用的是单引号，可以内嵌双引号，否则需要“\\”转义</span></span><br><span class=\"line\">  <span class=\"comment\">//String str2 = ‘It\\’s ok!’;</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> str2 = <span class=\"string\">\"It's ok!\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//使用三个单引号或者双引号可以多行字符串赋值</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> str3 = <span class=\"string\">\"\"\"Dart Lang</span></span><br><span class=\"line\"><span class=\"string\">  Hello,World!\"\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//在Dart中，相邻的字符串在编译的时候会自动连接</span></span><br><span class=\"line\">  <span class=\"comment\">//这里发现一个问题，如果多个字符串相邻，中间的字符串不能为空，否则报错</span></span><br><span class=\"line\">  <span class=\"comment\">//但是如果单引号和双引号相邻，即使是空值也不会报错，但相信没有人这么做</span></span><br><span class=\"line\">  <span class=\"comment\">//var name = 'Wang''''Jianfei'; 报错</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'Wang'</span><span class=\"string\">' '</span><span class=\"string\">'Jianfei'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//assert 是语言内置的断言函数，仅在检查模式下有效</span></span><br><span class=\"line\">  <span class=\"comment\">//如果断言失败则程序立刻终止</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(name == <span class=\"string\">\"Wang Jianfei\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//Dart中字符串不支持“+”操作符，如str1 + str2</span></span><br><span class=\"line\">  <span class=\"comment\">//如果要链接字符串，除了上面诉说，相邻字符串自动连接外</span></span><br><span class=\"line\">  <span class=\"comment\">//还可以使用“$”插入变量的值</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"Name：<span class=\"subst\">$name</span>\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//声明原始字符串，直接在字符串前加字符“r”</span></span><br><span class=\"line\">  <span class=\"comment\">//可以避免“\\”的转义作用，在正则表达式里特别有用</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">r\"换行符：\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//Dart中数值是num，它有两个子类型：int 和 double</span></span><br><span class=\"line\">  <span class=\"comment\">//int是任意长度的整数，double是双精度浮点数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> hex = <span class=\"number\">0xDEADBEEF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//翻了半天的文档，才找打一个重要的函数：转换进制，英文太不过关了</span></span><br><span class=\"line\">  <span class=\"comment\">//上面提到的字符串插值，还可以插入表达式：$&#123;&#125;</span></span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">\"整型转换为16进制：<span class=\"subst\">$hex</span> —&gt; 0x<span class=\"subst\">$&#123;hex.toRadixString(<span class=\"number\">16</span>).toUpperCase()&#125;</span>\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Booleans\"><a href=\"#Booleans\" class=\"headerlink\" title=\"Booleans\"></a>Booleans</h3><p>Dart是强布尔类型检查，只有当值是true是才为真，其他都是false，声明时用bool</p>\n<h3 id=\"Lists\"><a href=\"#Lists\" class=\"headerlink\" title=\"Lists\"></a>Lists</h3><p>在 Dart　语言中，具有一系列相同类型的数据被称为 List 对象。<br>Dart List 对象类似JavaScript 语言的 array 对象。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];<span class=\"comment\">//分析器自动推断list为List&lt;int&gt;,所以里面不能加入其他类型的元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(list.length);<span class=\"comment\">//3</span></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">11</span>;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(list.toString());<span class=\"comment\">//[1, 11, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> constantList = <span class=\"keyword\">const</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">// constantList[1] = 1; //因为前面的赋值使用了const 所以这句会报错.</span></span><br><span class=\"line\">constantList= [<span class=\"number\">5</span>];<span class=\"comment\">//这样可以</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Maps\"><a href=\"#Maps\" class=\"headerlink\" title=\"Maps\"></a>Maps</h3><p>map是一个包含key和value的对象，key不能重复</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gifts = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Key:    Value</span></span><br><span class=\"line\">  <span class=\"string\">'first'</span>: <span class=\"string\">'partridge'</span>,</span><br><span class=\"line\">  <span class=\"string\">'second'</span>: <span class=\"string\">'turtledoves'</span>,</span><br><span class=\"line\">  <span class=\"string\">'fifth'</span>: <span class=\"string\">'golden rings'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nobleGases = &#123;</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">'helium'</span>,</span><br><span class=\"line\">  <span class=\"number\">10</span>: <span class=\"string\">'neon'</span>,</span><br><span class=\"line\">  <span class=\"number\">18</span>: <span class=\"string\">'argon'</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> gifts2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">gifts[<span class=\"string\">'first'</span>] = <span class=\"string\">'partridge'</span>;</span><br><span class=\"line\">gifts[<span class=\"string\">'second'</span>] = <span class=\"string\">'turtledoves'</span>;</span><br><span class=\"line\">gifts[<span class=\"string\">'fifth'</span>] = <span class=\"string\">'golden rings'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nobleGases2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">nobleGases[<span class=\"number\">2</span>] = <span class=\"string\">'helium'</span>;</span><br><span class=\"line\">nobleGases[<span class=\"number\">10</span>] = <span class=\"string\">'neon'</span>;</span><br><span class=\"line\">nobleGases[<span class=\"number\">18</span>] = <span class=\"string\">'argon'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取value</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(gifts2[<span class=\"string\">'first'</span>]);<span class=\"comment\">// partridge;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(gifts2.length);<span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Runes\"><a href=\"#Runes\" class=\"headerlink\" title=\"Runes\"></a>Runes</h3><p>Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> clapping = <span class=\"string\">'\\u&#123;1f44f&#125;'</span>;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping.codeUnits);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(clapping.runes.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">Runes input = <span class=\"keyword\">new</span> Runes(</span><br><span class=\"line\">  <span class=\"string\">'\\u2665  \\u&#123;1f605&#125;  \\u&#123;1f60e&#125;  \\u&#123;1f47b&#125;  \\u&#123;1f596&#125;  \\u&#123;1f44d&#125;'</span>);</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>.fromCharCodes(input));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbols\"><a href=\"#Symbols\" class=\"headerlink\" title=\"Symbols\"></a>Symbols</h3><p>symbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化.我们可能永远也不用不到Symbol</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(#s == <span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">'s'</span>));<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Git远程操作详解","author":"JsonYe","comments":1,"toc":true,"date":"2016-01-11T08:22:00.000Z","_content":"Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。\n```\ngit clone\n\ngit remote\n\ngit fetch\n\ngit pull\n\ngit push\n```\n本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。\n\n## 一、git clone\n\n远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。\n\n```\n git clone <版本库的网址>\n```\n\n比如，克隆jQuery的版本库。\n\n```\ngit clone https://github.com/jquery/jquery.git\n```\n\n该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。\n\n```\ngit clone <版本库的网址> <本地目录名>\n```\n\ngit clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。\n\n```\n git clone http[s]://example.com/path/to/repo.git/\n git clone ssh://example.com/path/to/repo.git/\n git clone git://example.com/path/to/repo.git/\n git clone /opt/git/project.git \n git clone file:///opt/git/project.git\n git clone ftp[s]://example.com/path/to/repo.git/\n git clone rsync://example.com/path/to/repo.git/\n```\n\nSSH协议还有另一种写法。\n\n```\n git clone [user@]example.com:path/to/repo.git/\n```\n\n通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。\n\n## 二、git remote\n\n为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。\n\n不带选项的时候，git remote命令列出所有远程主机。\n\n```\ngit remote\norigin\n```\n\n使用-v选项，可以参看远程主机的网址。\n\n```\n git remote -v\norigin  git@github.com:jquery/jquery.git (fetch)\norigin  git@github.com:jquery/jquery.git (push)\n```\n\n上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。\n\n克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。\n\n```\n git clone -o jQuery https://github.com/jquery/jquery.git\n git remote\njQuery\n```\n\n上面命令表示，克隆的时候，指定远程主机叫做jQuery。\n\n```\ngit remote show命令加上主机名，可以查看该主机的详细信息。\n git remote show <主机名>\ngit remote add命令用于添加远程主机。\n git remote add <主机名> <网址>\ngit remote rm命令用于删除远程主机。\n git remote rm <主机名>\ngit remote rename命令用于远程主机的改名。\n git remote rename <原主机名> <新主机名>\n```\n\n## 三、git fetch\n\n一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。\n\n```\n git fetch <远程主机名>\n```\n\n上面命令将某个远程主机的更新，全部取回本地。\n\ngit fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。\n\n默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。\n\n```\n git fetch <远程主机名> <分支名>\n```\n\n比如，取回origin主机的master分支。\n\n```\n git fetch origin master\n```\n\n所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如origin主机的master，就要用origin/master读取。\n\ngit branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。\n\n```\n git branch -r\norigin/master\n git branch -a\n* master\n  remotes/origin/master\n```\n\n上面命令表示，本地主机的当前分支是master，远程分支是origin/master。\n\n取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。\n\n```\n git checkout -b newBrach origin/master\n```\n\n上面命令表示，在origin/master的基础上，创建一个新分支。\n\n此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。\n\n```\n git merge origin/master\n```\n\n\\# 或者\n\n```\n git rebase origin/master\n```\n\n上面命令表示在当前分支上，合并origin/master。\n\n## 四、git pull\n\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。\n\n```\n git pull <远程主机名> <远程分支名>:<本地分支名>\n```\n\n比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。\n\n```\n git pull origin next:master\n```\n\n如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\n\n```\n git pull origin next\n```\n\n上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。\n\n```\n git fetch origin\n git merge origin/next\n```\n\n在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动\"追踪\"origin/master分支。\n\nGit也允许手动建立追踪关系。\n\n```\ngit branch --set-upstream master origin/next\n```\n\n上面命令指定master分支追踪origin/next分支。\n\n如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。\n\n```\n git pull origin\n```\n\n上面命令表示，本地的当前分支自动与对应的origin主机\"追踪分支\"（remote-tracking branch）进行合并。\n\n如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n\n```\n git pull\n```\n\n上面命令表示，当前分支自动与唯一一个追踪分支进行合并。\n\n如果合并需要采用rebase模式，可以使用--rebase选项。\n\n```\n git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n```\n\n如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。\n\n但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。\n\n```\n git pull -p\n# 等同于下面的命令\n git fetch --prune origin \n git fetch -p\n```\n\n## 五、git push\n\ngit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。\n\n```\n git push <远程主机名> <本地分支名>:<远程分支名>\n```\n\n注意，分支推送顺序的写法是<来源地>:<目的地>，所以git pull是<远程分支>:<本地分支>，而git push是<本地分支>:<远程分支>。\n\n如果省略远程分支名，则表示将本地分支推送与之存在\"追踪关系\"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。\n\n```\n git push origin master\n```\n\n上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。\n\n如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\n\n```\n git push origin :master\n```\n\n\\# 等同于\n\n```\n git push origin --delete master\n```\n\n上面命令表示删除origin主机的master分支。\n\n如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n\n```\n git push origin\n```\n\n上面命令表示，将当前分支推送到origin主机的对应分支。\n\n如果当前分支只有一个追踪分支，那么主机名都可以省略。\n\n```\n git push\n```\n\n如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。\n\n```\n git push -u origin master\n```\n\n上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。\n\n不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。\n\n```\n git config --global push.default matching\n```\n\n或者\n\n```\n git config --global push.default simple\n```\n\n还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。\n\n```\n git push --all origin\n```\n\n上面命令表示，将所有本地分支都推送到origin主机。\n\n如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。\n\n```\n git push --force origin\n```\n\n上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。\n\n最后，git push不会推送标签（tag），除非使用--tags选项。\n\n```\n git push origin --tags\n```\n\n（完）","source":"_posts/git/Git远程操作详解.md","raw":"---\ntitle: 'Git远程操作详解'\nauthor: JsonYe\ntags:\n  - git\ncategories:\n  - IDE \ncomments: true\ntoc: true\ndate:  2016-01-11 16:22:00\n---\nGit有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。\n```\ngit clone\n\ngit remote\n\ngit fetch\n\ngit pull\n\ngit push\n```\n本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。\n\n## 一、git clone\n\n远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。\n\n```\n git clone <版本库的网址>\n```\n\n比如，克隆jQuery的版本库。\n\n```\ngit clone https://github.com/jquery/jquery.git\n```\n\n该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。\n\n```\ngit clone <版本库的网址> <本地目录名>\n```\n\ngit clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。\n\n```\n git clone http[s]://example.com/path/to/repo.git/\n git clone ssh://example.com/path/to/repo.git/\n git clone git://example.com/path/to/repo.git/\n git clone /opt/git/project.git \n git clone file:///opt/git/project.git\n git clone ftp[s]://example.com/path/to/repo.git/\n git clone rsync://example.com/path/to/repo.git/\n```\n\nSSH协议还有另一种写法。\n\n```\n git clone [user@]example.com:path/to/repo.git/\n```\n\n通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。\n\n## 二、git remote\n\n为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。\n\n不带选项的时候，git remote命令列出所有远程主机。\n\n```\ngit remote\norigin\n```\n\n使用-v选项，可以参看远程主机的网址。\n\n```\n git remote -v\norigin  git@github.com:jquery/jquery.git (fetch)\norigin  git@github.com:jquery/jquery.git (push)\n```\n\n上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。\n\n克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。\n\n```\n git clone -o jQuery https://github.com/jquery/jquery.git\n git remote\njQuery\n```\n\n上面命令表示，克隆的时候，指定远程主机叫做jQuery。\n\n```\ngit remote show命令加上主机名，可以查看该主机的详细信息。\n git remote show <主机名>\ngit remote add命令用于添加远程主机。\n git remote add <主机名> <网址>\ngit remote rm命令用于删除远程主机。\n git remote rm <主机名>\ngit remote rename命令用于远程主机的改名。\n git remote rename <原主机名> <新主机名>\n```\n\n## 三、git fetch\n\n一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。\n\n```\n git fetch <远程主机名>\n```\n\n上面命令将某个远程主机的更新，全部取回本地。\n\ngit fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。\n\n默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。\n\n```\n git fetch <远程主机名> <分支名>\n```\n\n比如，取回origin主机的master分支。\n\n```\n git fetch origin master\n```\n\n所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如origin主机的master，就要用origin/master读取。\n\ngit branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。\n\n```\n git branch -r\norigin/master\n git branch -a\n* master\n  remotes/origin/master\n```\n\n上面命令表示，本地主机的当前分支是master，远程分支是origin/master。\n\n取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。\n\n```\n git checkout -b newBrach origin/master\n```\n\n上面命令表示，在origin/master的基础上，创建一个新分支。\n\n此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。\n\n```\n git merge origin/master\n```\n\n\\# 或者\n\n```\n git rebase origin/master\n```\n\n上面命令表示在当前分支上，合并origin/master。\n\n## 四、git pull\n\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。\n\n```\n git pull <远程主机名> <远程分支名>:<本地分支名>\n```\n\n比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。\n\n```\n git pull origin next:master\n```\n\n如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\n\n```\n git pull origin next\n```\n\n上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。\n\n```\n git fetch origin\n git merge origin/next\n```\n\n在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动\"追踪\"origin/master分支。\n\nGit也允许手动建立追踪关系。\n\n```\ngit branch --set-upstream master origin/next\n```\n\n上面命令指定master分支追踪origin/next分支。\n\n如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。\n\n```\n git pull origin\n```\n\n上面命令表示，本地的当前分支自动与对应的origin主机\"追踪分支\"（remote-tracking branch）进行合并。\n\n如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n\n```\n git pull\n```\n\n上面命令表示，当前分支自动与唯一一个追踪分支进行合并。\n\n如果合并需要采用rebase模式，可以使用--rebase选项。\n\n```\n git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n```\n\n如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。\n\n但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。\n\n```\n git pull -p\n# 等同于下面的命令\n git fetch --prune origin \n git fetch -p\n```\n\n## 五、git push\n\ngit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。\n\n```\n git push <远程主机名> <本地分支名>:<远程分支名>\n```\n\n注意，分支推送顺序的写法是<来源地>:<目的地>，所以git pull是<远程分支>:<本地分支>，而git push是<本地分支>:<远程分支>。\n\n如果省略远程分支名，则表示将本地分支推送与之存在\"追踪关系\"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。\n\n```\n git push origin master\n```\n\n上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。\n\n如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\n\n```\n git push origin :master\n```\n\n\\# 等同于\n\n```\n git push origin --delete master\n```\n\n上面命令表示删除origin主机的master分支。\n\n如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n\n```\n git push origin\n```\n\n上面命令表示，将当前分支推送到origin主机的对应分支。\n\n如果当前分支只有一个追踪分支，那么主机名都可以省略。\n\n```\n git push\n```\n\n如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。\n\n```\n git push -u origin master\n```\n\n上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。\n\n不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。\n\n```\n git config --global push.default matching\n```\n\n或者\n\n```\n git config --global push.default simple\n```\n\n还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。\n\n```\n git push --all origin\n```\n\n上面命令表示，将所有本地分支都推送到origin主机。\n\n如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。\n\n```\n git push --force origin\n```\n\n上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。\n\n最后，git push不会推送标签（tag），除非使用--tags选项。\n\n```\n git push origin --tags\n```\n\n（完）","slug":"git/Git远程操作详解","published":1,"updated":"2019-10-02T08:42:18.966Z","layout":"post","photos":[],"link":"","_id":"ck19bvb2w004100wkhxol74pj","content":"<p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone</span><br><span class=\"line\"></span><br><span class=\"line\">git remote</span><br><span class=\"line\"></span><br><span class=\"line\">git fetch</span><br><span class=\"line\"></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p>\n<h2 id=\"一、git-clone\"><a href=\"#一、git-clone\" class=\"headerlink\" title=\"一、git clone\"></a>一、git clone</h2><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，克隆jQuery的版本库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>\n\n<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone http[s]://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone ssh://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone git://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone /opt/git/project.git </span><br><span class=\"line\"> git clone file:///opt/git/project.git</span><br><span class=\"line\"> git clone ftp[s]://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone rsync://example.com/path/to/repo.git/</span><br></pre></td></tr></table></figure>\n\n<p>SSH协议还有另一种写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone [user@]example.com:path/to/repo.git/</span><br></pre></td></tr></table></figure>\n\n<p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p>\n<h2 id=\"二、git-remote\"><a href=\"#二、git-remote\" class=\"headerlink\" title=\"二、git remote\"></a>二、git remote</h2><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。</p>\n<p>不带选项的时候，git remote命令列出所有远程主机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote</span><br><span class=\"line\">origin</span><br></pre></td></tr></table></figure>\n\n<p>使用-v选项，可以参看远程主机的网址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git remote -v</span><br><span class=\"line\">origin  git@github.com:jquery/jquery.git (fetch)</span><br><span class=\"line\">origin  git@github.com:jquery/jquery.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>\n<p>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone -o jQuery https://github.com/jquery/jquery.git</span><br><span class=\"line\"> git remote</span><br><span class=\"line\">jQuery</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show命令加上主机名，可以查看该主机的详细信息。</span><br><span class=\"line\"> git remote show &lt;主机名&gt;</span><br><span class=\"line\">git remote add命令用于添加远程主机。</span><br><span class=\"line\"> git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class=\"line\">git remote rm命令用于删除远程主机。</span><br><span class=\"line\"> git remote rm &lt;主机名&gt;</span><br><span class=\"line\">git remote rename命令用于远程主机的改名。</span><br><span class=\"line\"> git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、git-fetch\"><a href=\"#三、git-fetch\" class=\"headerlink\" title=\"三、git fetch\"></a>三、git fetch</h2><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面命令将某个远程主机的更新，全部取回本地。</p>\n<p>git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>\n<p>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，取回origin主机的master分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch origin master</span><br></pre></td></tr></table></figure>\n\n<p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。</p>\n<p>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git branch -r</span><br><span class=\"line\">origin/master</span><br><span class=\"line\"> git branch -a</span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，本地主机的当前分支是master，远程分支是origin/master。</p>\n<p>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，在origin/master的基础上，创建一个新分支。</p>\n<p>此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git merge origin/master</span><br></pre></td></tr></table></figure>\n\n<p># 或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git rebase origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示在当前分支上，合并origin/master。</p>\n<h2 id=\"四、git-pull\"><a href=\"#四、git-pull\" class=\"headerlink\" title=\"四、git pull\"></a>四、git pull</h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin next:master</span><br></pre></td></tr></table></figure>\n\n<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin next</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch origin</span><br><span class=\"line\"> git merge origin/next</span><br></pre></td></tr></table></figure>\n\n<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。</p>\n<p>Git也允许手动建立追踪关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream master origin/next</span><br></pre></td></tr></table></figure>\n\n<p>上面命令指定master分支追踪origin/next分支。</p>\n<p>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。</p>\n<p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>\n<p>如果合并需要采用rebase模式，可以使用–rebase选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。</p>\n<p>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull -p</span><br><span class=\"line\"># 等同于下面的命令</span><br><span class=\"line\"> git fetch --prune origin </span><br><span class=\"line\"> git fetch -p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、git-push\"><a href=\"#五、git-push\" class=\"headerlink\" title=\"五、git push\"></a>五、git push</h2><p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>\n<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p>\n<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin :master</span><br></pre></td></tr></table></figure>\n\n<p># 等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin --delete master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示删除origin主机的master分支。</p>\n<p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将当前分支推送到origin主机的对应分支。</p>\n<p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push</span><br></pre></td></tr></table></figure>\n\n<p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p>\n<p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global push.default matching</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global push.default simple</span><br></pre></td></tr></table></figure>\n\n<p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push --all origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将所有本地分支都推送到origin主机。</p>\n<p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push --force origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。</p>\n<p>最后，git push不会推送标签（tag），除非使用–tags选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<p>（完）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone</span><br><span class=\"line\"></span><br><span class=\"line\">git remote</span><br><span class=\"line\"></span><br><span class=\"line\">git fetch</span><br><span class=\"line\"></span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。</p>\n<h2 id=\"一、git-clone\"><a href=\"#一、git-clone\" class=\"headerlink\" title=\"一、git clone\"></a>一、git clone</h2><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，克隆jQuery的版本库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>\n\n<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone http[s]://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone ssh://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone git://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone /opt/git/project.git </span><br><span class=\"line\"> git clone file:///opt/git/project.git</span><br><span class=\"line\"> git clone ftp[s]://example.com/path/to/repo.git/</span><br><span class=\"line\"> git clone rsync://example.com/path/to/repo.git/</span><br></pre></td></tr></table></figure>\n\n<p>SSH协议还有另一种写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone [user@]example.com:path/to/repo.git/</span><br></pre></td></tr></table></figure>\n\n<p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。</p>\n<h2 id=\"二、git-remote\"><a href=\"#二、git-remote\" class=\"headerlink\" title=\"二、git remote\"></a>二、git remote</h2><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。</p>\n<p>不带选项的时候，git remote命令列出所有远程主机。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote</span><br><span class=\"line\">origin</span><br></pre></td></tr></table></figure>\n\n<p>使用-v选项，可以参看远程主机的网址。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git remote -v</span><br><span class=\"line\">origin  git@github.com:jquery/jquery.git (fetch)</span><br><span class=\"line\">origin  git@github.com:jquery/jquery.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>\n<p>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git clone -o jQuery https://github.com/jquery/jquery.git</span><br><span class=\"line\"> git remote</span><br><span class=\"line\">jQuery</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show命令加上主机名，可以查看该主机的详细信息。</span><br><span class=\"line\"> git remote show &lt;主机名&gt;</span><br><span class=\"line\">git remote add命令用于添加远程主机。</span><br><span class=\"line\"> git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class=\"line\">git remote rm命令用于删除远程主机。</span><br><span class=\"line\"> git remote rm &lt;主机名&gt;</span><br><span class=\"line\">git remote rename命令用于远程主机的改名。</span><br><span class=\"line\"> git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、git-fetch\"><a href=\"#三、git-fetch\" class=\"headerlink\" title=\"三、git fetch\"></a>三、git fetch</h2><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面命令将某个远程主机的更新，全部取回本地。</p>\n<p>git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>\n<p>默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，取回origin主机的master分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch origin master</span><br></pre></td></tr></table></figure>\n\n<p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。</p>\n<p>git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git branch -r</span><br><span class=\"line\">origin/master</span><br><span class=\"line\"> git branch -a</span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes/origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，本地主机的当前分支是master，远程分支是origin/master。</p>\n<p>取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，在origin/master的基础上，创建一个新分支。</p>\n<p>此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git merge origin/master</span><br></pre></td></tr></table></figure>\n\n<p># 或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git rebase origin/master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示在当前分支上，合并origin/master。</p>\n<h2 id=\"四、git-pull\"><a href=\"#四、git-pull\" class=\"headerlink\" title=\"四、git pull\"></a>四、git pull</h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin next:master</span><br></pre></td></tr></table></figure>\n\n<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin next</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git fetch origin</span><br><span class=\"line\"> git merge origin/next</span><br></pre></td></tr></table></figure>\n\n<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。</p>\n<p>Git也允许手动建立追踪关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream master origin/next</span><br></pre></td></tr></table></figure>\n\n<p>上面命令指定master分支追踪origin/next分支。</p>\n<p>如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。</p>\n<p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>\n<p>如果合并需要采用rebase模式，可以使用–rebase选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。</p>\n<p>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git pull -p</span><br><span class=\"line\"># 等同于下面的命令</span><br><span class=\"line\"> git fetch --prune origin </span><br><span class=\"line\"> git fetch -p</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、git-push\"><a href=\"#五、git-push\" class=\"headerlink\" title=\"五、git push\"></a>五、git push</h2><p>git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>\n<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p>\n<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin :master</span><br></pre></td></tr></table></figure>\n\n<p># 等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin --delete master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示删除origin主机的master分支。</p>\n<p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将当前分支推送到origin主机的对应分支。</p>\n<p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push</span><br></pre></td></tr></table></figure>\n\n<p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p>\n<p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global push.default matching</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git config --global push.default simple</span><br></pre></td></tr></table></figure>\n\n<p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push --all origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令表示，将所有本地分支都推送到origin主机。</p>\n<p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push --force origin</span><br></pre></td></tr></table></figure>\n\n<p>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。</p>\n<p>最后，git push不会推送标签（tag），除非使用–tags选项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<p>（完）</p>\n"},{"title":"UML-静态图","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2018-05-20T13:14:00.000Z","_content":"## 静态图\n包括类图、对象图、包图\n### 类图（Class diagram）\n#### 简介\n类是对象的集合，展示了对象的结构以及与系统的交互行为。类主要有属性（Attribute）和方法（Method）构成,属性代表对象的状态，如果属性被保存到数据库，此称之为“持久化”；方法代表对象的操作行为，类具有继承关系，可以继承于父类，也可以与其他的Class进行交互。\n类图展示了系统的逻辑结构，类和接口的关系。\n\n#### 类的构成\n类主要有属性和方法构成。比如商品属性有：名称、价格、高度、宽度等；商品的方法有：计算税率，获得商品的评价等等。\n- `+`表示public\n- `#`表示protected\n- `—`表示private\n- `~`表示package\n\n#### 类图的元素\n>在类图中一共包含了以下几种模型元素，分别是：类（Class）、接口（Interface）、依赖（Dependency）关系、泛化（Generalization）关系、关联（Association）关系、聚合关系（Aggregation）、组合关系（Composition）和实现（Realization）关系。\n\n1. 类（Class)\n>在面向对象（OO) 编程中，类是对现实世界中一组具有相同特征的物体的抽象。\n\n2. 接口（Interface）\n>接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。在UML中，接口使用一个带有名称的小圆圈来进行表示。\n\n3. 关联(Association)\n> 两个相对独立的对象，当一个对象的实例与另外一个对象的特定实例存在固定关系时，这两个对象之间就存在关联关系。\n\n  1. 单向关联\n>A1->A2: 表示A1认识A2，A1知道A2的存在，A1可以调用A2中的方法和属性<br>\n场景：订单和商品，订单中包括商品，但是商品并不了解订单的存在。<br>\n![](image/class_diagram/单向关联.png)\n\n  2. 双向关联\n>B1-B2: 表示B1认识B2，B1知道B2的存在，B1可以调用B2中的方法和属性；同样B2也知道B1的存在，B2也可以调用B1的方法和属性。<br>\n场景：订单和客户，订单属于客户，客户拥有一些特定的订单<br>\n![](image/class_diagram/双向关联.png)\n\n  3. 自身关联\n>同一个类对象之间的关联<br>\n场景：组织结构的层次关系<br>\n![类与类之间自身关联图](image/class_diagram/自身关联.png)\n\n  4. 多维关联(N-ary Association)\n>多个对象之间存在关联<br>\n场景：公司雇用员工，同时公司需要支付工资给员工<br>\n![多维关联](image/class_diagram/多维关联.png)\n\n  5. 泛化(Generalization)\n>类与类的继承关系，类与接口的实现关系。<br>\n场景：父与子、动物与人、植物与树、系统使用者与B2C会员和B2E会员的关系<br>\n![泛化](image/class_diagram/泛化.png)\n![继承](image/class_diagram/继承.png)\n\n  6. 依赖(Dependency)\n>类A要完成某个功能必须引用类B，则A与B存在依赖关系，依赖关系是弱的关联关系。C#不建议双相依赖，也就是相互引用<br>\n场景：本来人与电脑没有关系的，但由于偶然的机会，人需要用电脑写程序，这时候人就依赖于电脑。<br/>\n![](image/class_diagram/依赖.png)\n\n  7. 聚合(Aggregation)\n>当对象A被加入到对象B中，成为对象B的组成部分时，对象B和对象A之间为聚合关系。聚合是关联关系的一种，是较强的关联关系，强调的是整体与部分之间的关系。<br/>\n场景：商品和他的规格、样式就是聚合关系。<br/>\n![](image/class_diagram/聚合.png)\n\n  8. 组合（Composite）\n>对象A包含对象B，对象B离开对象A没有实际意义。是一种更强的关联关系。人包含手，手离开人的躯体就失去了它应有的作用。<br>\n场景： Window窗体由滑动条slider、头部Header 和工作区Panel组合而成。<br>\n![](image/class_diagram/组合.png)\n\n  9. 实现（Realization）\n  >一般来讲实现关系是针对类与接口之间的关系而言的。在UML类图中，实现关系用空心三角形+虚线来表示。\n\n\n#### StartUML实现画图\nstartUML连线含义<br>![](image/class_diagram/startUML连线.png)<br>\n作图参考[使用StarUML创建类图](http://www.flyne.org/article/379)\n\n\n#### 练习\n![](image/class_diagram/类图练习.jpg)\n\n### 对象图（Object Diagram）\n#### 简介\n>对象图(Object Diagram)描述的是参与交互的各个对象在交互过程中某一时刻的状态。对象图可以被看作是类图在某一时刻的实例。\n\n在UML中，对象图使用的是与类图相同的符号和关系，因为对象就是类的实例。\n#### 构成\n>对象图中包含对象（Object）和链（Link），对象是类的特定实例，链是类之间关系的实例。和类图一样，对象图对系统的静态设计或静态进程视图建模，对象图更注重现实或原型实例，这种视图主要支持系统的功能需求，对象图描述了静态的数据结构。\n\n#### 用途\n- 捕获示例和连接\n- 在分析和设计阶段创建\n- 捕获交互的静态部分\n- 举例说明数据/对象结构\n- 详细描述瞬间图\n- 工分析人士、设计人员和代码实现人员开发和使用\n\n\n#### 类图和对象图的区别\n类图|对象图\n--|--\n类具有3个分栏，名称、特性、行为|对象只有两个分栏：名称、特性\n名称栏只有类名|名称形式为“对象名：类名”，匿名对象的名称形式\":类名\"\n特征栏包含所有特性|特征栏之定义了特征的当前值，以便用于测试用例或者例子中\n类中列出了操作|不包含操作\n使用关联连接，关联使用名称、角色、多重性以及约束特征定义。类带白哦的是对象分类，所以必须说明可以参与关联的对象数目|对象使用链接连、链拥有名称、角色，但是没有多重性。对象代表的是单独的实体，所有的链都是一对一，因此不涉及多重性。\n\n#### 样例\n![](image/class_diagram/对象图.png)\n\n### 包图（Package Diagram）\n#### 简介\n>包图（Package Diagram）由包和包之间的关系构成，对维护和控制系统总体结构很重要。系统建模中，有大量的类、接口、组件、节点和图，有必要将这些元素进行分组，把语义相近并倾向一起变化的元素组织起来加入同一包，这样方便理解和处理整个模型。设计良好的包是高内聚、低耦合的，并且对其内容的访问具有严密的控制。\n\n#### 包名\n>每个包都必须有一个区别于其他包的名字。模型包的名字是一个字符串，可以分为简单名和路径名。\n\n- 简单名：指包仅含一个简单的名称。\n- 路径名：指以包位于的外围包的名字作为前缀。\n\n#### 拥有的元素\n- 包可以拥有类、接口、组件、节点、协作、用例图，甚至还可以包含其他的包\n- 包构成一个命名空间，这意味着一个模型包内各个包类建模元素不可以具有相同的名字，不同\n- 如果包被撤销，其中的元素也要被撤销。\n\n#### 包的可见性\n>包并不是独立存在的，包内的元素必然会和外部的类存在关系。而好的软件模型中的各个包应该做到高内聚、低耦合，为了做到这一点，就需要对包内的元素加以控制，使得某些元素能被外界访问，其他元素对外界不可见。这就是包内元素的可见性控制。\n\n包的可见性分为3种：\n1. 公有访问（Public）：包内的元素可以被任何引入此包的其他包内的元素访问。公有访问用前缀于内含元素名字的加号（+）表示。\n2. 保护访问（Protect）：此元素能被该模型包在继承关系上后继模式包的内含元素访问。保护访问用前缀于内含元素名字的（#）号表示。      \n3. 私有访问（Private）：表示此元素可以被属于用一包的内含元素访问。私有访问用前缀于内含元素名字的减号（—）表示。\n\n#### 引入与输出\n- 引入（Import）：允许一个包中的元素可以单向访问另一个包中的元素。\n- 输出（Export）：包中具有公有访问权限的内含元素。\n\n#### 标准元素\n构造型|用途\n--|--\n虚包（facade)|描述一个只引用其他包元素的包\n框架(framework)|描述一个主要有模式组成的包\n桩（stud）|描述一个作为另一个包的公共内容代理的包\n子系统(subsustem)|描述一个表示正在建模中的整个系统的一个独立部分的包\n系统(system)|描述一个表示正在建模中的整个系统的包\n\n#### 包之间的关系\n>包与包之间有两种关系：\n\n1. 引入和访问依赖：用于在一个包引入另一个包输出的元素。\n2. 泛化：和类的泛化关系类似，包间的泛化关系遵循替代原则，特殊包可以应用到一般包被使用的任何地方。\n\n#### 包图建模技术\n- 建立包图的具体做法：\n  1. 分析系统模型元素（通常是对象类），把概念上或语义上相近的模型元素纳入一个包。\n  2. 对于每一个包，对其模型元素标出其可见性。\n  3. 确定包与包之间的依赖关系，特别是输入依赖。\n  4. 确定包与包之间的泛化关系，确定包元素的多重性和重载。\n  5. 绘制包图\n  6. 包图精化\n\n#### 样例\n![](image/class_diagram/包图.png)\n","source":"_posts/uml/03 静态图.md","raw":"---\ntitle: UML-静态图\nauthor: JsonYe\ntags:\n- uml\n- 静态图\ncategories:\n- UML\ncopyright: true\ncomments: true\ntoc: true\ndate: 2018-05-20 21:14:00   \n---\n## 静态图\n包括类图、对象图、包图\n### 类图（Class diagram）\n#### 简介\n类是对象的集合，展示了对象的结构以及与系统的交互行为。类主要有属性（Attribute）和方法（Method）构成,属性代表对象的状态，如果属性被保存到数据库，此称之为“持久化”；方法代表对象的操作行为，类具有继承关系，可以继承于父类，也可以与其他的Class进行交互。\n类图展示了系统的逻辑结构，类和接口的关系。\n\n#### 类的构成\n类主要有属性和方法构成。比如商品属性有：名称、价格、高度、宽度等；商品的方法有：计算税率，获得商品的评价等等。\n- `+`表示public\n- `#`表示protected\n- `—`表示private\n- `~`表示package\n\n#### 类图的元素\n>在类图中一共包含了以下几种模型元素，分别是：类（Class）、接口（Interface）、依赖（Dependency）关系、泛化（Generalization）关系、关联（Association）关系、聚合关系（Aggregation）、组合关系（Composition）和实现（Realization）关系。\n\n1. 类（Class)\n>在面向对象（OO) 编程中，类是对现实世界中一组具有相同特征的物体的抽象。\n\n2. 接口（Interface）\n>接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。在UML中，接口使用一个带有名称的小圆圈来进行表示。\n\n3. 关联(Association)\n> 两个相对独立的对象，当一个对象的实例与另外一个对象的特定实例存在固定关系时，这两个对象之间就存在关联关系。\n\n  1. 单向关联\n>A1->A2: 表示A1认识A2，A1知道A2的存在，A1可以调用A2中的方法和属性<br>\n场景：订单和商品，订单中包括商品，但是商品并不了解订单的存在。<br>\n![](image/class_diagram/单向关联.png)\n\n  2. 双向关联\n>B1-B2: 表示B1认识B2，B1知道B2的存在，B1可以调用B2中的方法和属性；同样B2也知道B1的存在，B2也可以调用B1的方法和属性。<br>\n场景：订单和客户，订单属于客户，客户拥有一些特定的订单<br>\n![](image/class_diagram/双向关联.png)\n\n  3. 自身关联\n>同一个类对象之间的关联<br>\n场景：组织结构的层次关系<br>\n![类与类之间自身关联图](image/class_diagram/自身关联.png)\n\n  4. 多维关联(N-ary Association)\n>多个对象之间存在关联<br>\n场景：公司雇用员工，同时公司需要支付工资给员工<br>\n![多维关联](image/class_diagram/多维关联.png)\n\n  5. 泛化(Generalization)\n>类与类的继承关系，类与接口的实现关系。<br>\n场景：父与子、动物与人、植物与树、系统使用者与B2C会员和B2E会员的关系<br>\n![泛化](image/class_diagram/泛化.png)\n![继承](image/class_diagram/继承.png)\n\n  6. 依赖(Dependency)\n>类A要完成某个功能必须引用类B，则A与B存在依赖关系，依赖关系是弱的关联关系。C#不建议双相依赖，也就是相互引用<br>\n场景：本来人与电脑没有关系的，但由于偶然的机会，人需要用电脑写程序，这时候人就依赖于电脑。<br/>\n![](image/class_diagram/依赖.png)\n\n  7. 聚合(Aggregation)\n>当对象A被加入到对象B中，成为对象B的组成部分时，对象B和对象A之间为聚合关系。聚合是关联关系的一种，是较强的关联关系，强调的是整体与部分之间的关系。<br/>\n场景：商品和他的规格、样式就是聚合关系。<br/>\n![](image/class_diagram/聚合.png)\n\n  8. 组合（Composite）\n>对象A包含对象B，对象B离开对象A没有实际意义。是一种更强的关联关系。人包含手，手离开人的躯体就失去了它应有的作用。<br>\n场景： Window窗体由滑动条slider、头部Header 和工作区Panel组合而成。<br>\n![](image/class_diagram/组合.png)\n\n  9. 实现（Realization）\n  >一般来讲实现关系是针对类与接口之间的关系而言的。在UML类图中，实现关系用空心三角形+虚线来表示。\n\n\n#### StartUML实现画图\nstartUML连线含义<br>![](image/class_diagram/startUML连线.png)<br>\n作图参考[使用StarUML创建类图](http://www.flyne.org/article/379)\n\n\n#### 练习\n![](image/class_diagram/类图练习.jpg)\n\n### 对象图（Object Diagram）\n#### 简介\n>对象图(Object Diagram)描述的是参与交互的各个对象在交互过程中某一时刻的状态。对象图可以被看作是类图在某一时刻的实例。\n\n在UML中，对象图使用的是与类图相同的符号和关系，因为对象就是类的实例。\n#### 构成\n>对象图中包含对象（Object）和链（Link），对象是类的特定实例，链是类之间关系的实例。和类图一样，对象图对系统的静态设计或静态进程视图建模，对象图更注重现实或原型实例，这种视图主要支持系统的功能需求，对象图描述了静态的数据结构。\n\n#### 用途\n- 捕获示例和连接\n- 在分析和设计阶段创建\n- 捕获交互的静态部分\n- 举例说明数据/对象结构\n- 详细描述瞬间图\n- 工分析人士、设计人员和代码实现人员开发和使用\n\n\n#### 类图和对象图的区别\n类图|对象图\n--|--\n类具有3个分栏，名称、特性、行为|对象只有两个分栏：名称、特性\n名称栏只有类名|名称形式为“对象名：类名”，匿名对象的名称形式\":类名\"\n特征栏包含所有特性|特征栏之定义了特征的当前值，以便用于测试用例或者例子中\n类中列出了操作|不包含操作\n使用关联连接，关联使用名称、角色、多重性以及约束特征定义。类带白哦的是对象分类，所以必须说明可以参与关联的对象数目|对象使用链接连、链拥有名称、角色，但是没有多重性。对象代表的是单独的实体，所有的链都是一对一，因此不涉及多重性。\n\n#### 样例\n![](image/class_diagram/对象图.png)\n\n### 包图（Package Diagram）\n#### 简介\n>包图（Package Diagram）由包和包之间的关系构成，对维护和控制系统总体结构很重要。系统建模中，有大量的类、接口、组件、节点和图，有必要将这些元素进行分组，把语义相近并倾向一起变化的元素组织起来加入同一包，这样方便理解和处理整个模型。设计良好的包是高内聚、低耦合的，并且对其内容的访问具有严密的控制。\n\n#### 包名\n>每个包都必须有一个区别于其他包的名字。模型包的名字是一个字符串，可以分为简单名和路径名。\n\n- 简单名：指包仅含一个简单的名称。\n- 路径名：指以包位于的外围包的名字作为前缀。\n\n#### 拥有的元素\n- 包可以拥有类、接口、组件、节点、协作、用例图，甚至还可以包含其他的包\n- 包构成一个命名空间，这意味着一个模型包内各个包类建模元素不可以具有相同的名字，不同\n- 如果包被撤销，其中的元素也要被撤销。\n\n#### 包的可见性\n>包并不是独立存在的，包内的元素必然会和外部的类存在关系。而好的软件模型中的各个包应该做到高内聚、低耦合，为了做到这一点，就需要对包内的元素加以控制，使得某些元素能被外界访问，其他元素对外界不可见。这就是包内元素的可见性控制。\n\n包的可见性分为3种：\n1. 公有访问（Public）：包内的元素可以被任何引入此包的其他包内的元素访问。公有访问用前缀于内含元素名字的加号（+）表示。\n2. 保护访问（Protect）：此元素能被该模型包在继承关系上后继模式包的内含元素访问。保护访问用前缀于内含元素名字的（#）号表示。      \n3. 私有访问（Private）：表示此元素可以被属于用一包的内含元素访问。私有访问用前缀于内含元素名字的减号（—）表示。\n\n#### 引入与输出\n- 引入（Import）：允许一个包中的元素可以单向访问另一个包中的元素。\n- 输出（Export）：包中具有公有访问权限的内含元素。\n\n#### 标准元素\n构造型|用途\n--|--\n虚包（facade)|描述一个只引用其他包元素的包\n框架(framework)|描述一个主要有模式组成的包\n桩（stud）|描述一个作为另一个包的公共内容代理的包\n子系统(subsustem)|描述一个表示正在建模中的整个系统的一个独立部分的包\n系统(system)|描述一个表示正在建模中的整个系统的包\n\n#### 包之间的关系\n>包与包之间有两种关系：\n\n1. 引入和访问依赖：用于在一个包引入另一个包输出的元素。\n2. 泛化：和类的泛化关系类似，包间的泛化关系遵循替代原则，特殊包可以应用到一般包被使用的任何地方。\n\n#### 包图建模技术\n- 建立包图的具体做法：\n  1. 分析系统模型元素（通常是对象类），把概念上或语义上相近的模型元素纳入一个包。\n  2. 对于每一个包，对其模型元素标出其可见性。\n  3. 确定包与包之间的依赖关系，特别是输入依赖。\n  4. 确定包与包之间的泛化关系，确定包元素的多重性和重载。\n  5. 绘制包图\n  6. 包图精化\n\n#### 样例\n![](image/class_diagram/包图.png)\n","slug":"uml/03 静态图","published":1,"updated":"2019-10-02T13:48:32.727Z","layout":"post","photos":[],"link":"","_id":"ck19bvb2y004200wk1jx8bg99","content":"<h2 id=\"静态图\"><a href=\"#静态图\" class=\"headerlink\" title=\"静态图\"></a>静态图</h2><p>包括类图、对象图、包图</p>\n<h3 id=\"类图（Class-diagram）\"><a href=\"#类图（Class-diagram）\" class=\"headerlink\" title=\"类图（Class diagram）\"></a>类图（Class diagram）</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>类是对象的集合，展示了对象的结构以及与系统的交互行为。类主要有属性（Attribute）和方法（Method）构成,属性代表对象的状态，如果属性被保存到数据库，此称之为“持久化”；方法代表对象的操作行为，类具有继承关系，可以继承于父类，也可以与其他的Class进行交互。<br>类图展示了系统的逻辑结构，类和接口的关系。</p>\n<h4 id=\"类的构成\"><a href=\"#类的构成\" class=\"headerlink\" title=\"类的构成\"></a>类的构成</h4><p>类主要有属性和方法构成。比如商品属性有：名称、价格、高度、宽度等；商品的方法有：计算税率，获得商品的评价等等。</p>\n<ul>\n<li><code>+</code>表示public</li>\n<li><code>#</code>表示protected</li>\n<li><code>—</code>表示private</li>\n<li><code>~</code>表示package</li>\n</ul>\n<h4 id=\"类图的元素\"><a href=\"#类图的元素\" class=\"headerlink\" title=\"类图的元素\"></a>类图的元素</h4><blockquote>\n<p>在类图中一共包含了以下几种模型元素，分别是：类（Class）、接口（Interface）、依赖（Dependency）关系、泛化（Generalization）关系、关联（Association）关系、聚合关系（Aggregation）、组合关系（Composition）和实现（Realization）关系。</p>\n</blockquote>\n<ol>\n<li><p>类（Class)</p>\n<blockquote>\n<p>在面向对象（OO) 编程中，类是对现实世界中一组具有相同特征的物体的抽象。</p>\n</blockquote>\n</li>\n<li><p>接口（Interface）</p>\n<blockquote>\n<p>接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。在UML中，接口使用一个带有名称的小圆圈来进行表示。</p>\n</blockquote>\n</li>\n<li><p>关联(Association)</p>\n<blockquote>\n<p>两个相对独立的对象，当一个对象的实例与另外一个对象的特定实例存在固定关系时，这两个对象之间就存在关联关系。</p>\n</blockquote>\n<ol>\n<li><p>单向关联</p>\n<blockquote>\n<p>A1-&gt;A2: 表示A1认识A2，A1知道A2的存在，A1可以调用A2中的方法和属性<br><br>场景：订单和商品，订单中包括商品，但是商品并不了解订单的存在。<br><br><img src=\"image/class_diagram/%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94.png\" alt></p>\n</blockquote>\n</li>\n<li><p>双向关联</p>\n<blockquote>\n<p>B1-B2: 表示B1认识B2，B1知道B2的存在，B1可以调用B2中的方法和属性；同样B2也知道B1的存在，B2也可以调用B1的方法和属性。<br><br>场景：订单和客户，订单属于客户，客户拥有一些特定的订单<br><br><img src=\"image/class_diagram/%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94.png\" alt></p>\n</blockquote>\n</li>\n<li><p>自身关联</p>\n<blockquote>\n<p>同一个类对象之间的关联<br><br>场景：组织结构的层次关系<br><br><img src=\"image/class_diagram/%E8%87%AA%E8%BA%AB%E5%85%B3%E8%81%94.png\" alt=\"类与类之间自身关联图\"></p>\n</blockquote>\n</li>\n<li><p>多维关联(N-ary Association)</p>\n<blockquote>\n<p>多个对象之间存在关联<br><br>场景：公司雇用员工，同时公司需要支付工资给员工<br><br><img src=\"image/class_diagram/%E5%A4%9A%E7%BB%B4%E5%85%B3%E8%81%94.png\" alt=\"多维关联\"></p>\n</blockquote>\n</li>\n<li><p>泛化(Generalization)</p>\n<blockquote>\n<p>类与类的继承关系，类与接口的实现关系。<br><br>场景：父与子、动物与人、植物与树、系统使用者与B2C会员和B2E会员的关系<br><br><img src=\"image/class_diagram/%E6%B3%9B%E5%8C%96.png\" alt=\"泛化\"><br><img src=\"image/class_diagram/%E7%BB%A7%E6%89%BF.png\" alt=\"继承\"></p>\n</blockquote>\n</li>\n<li><p>依赖(Dependency)</p>\n<blockquote>\n<p>类A要完成某个功能必须引用类B，则A与B存在依赖关系，依赖关系是弱的关联关系。C#不建议双相依赖，也就是相互引用<br><br>场景：本来人与电脑没有关系的，但由于偶然的机会，人需要用电脑写程序，这时候人就依赖于电脑。<br><br><img src=\"image/class_diagram/%E4%BE%9D%E8%B5%96.png\" alt></p>\n</blockquote>\n</li>\n<li><p>聚合(Aggregation)</p>\n<blockquote>\n<p>当对象A被加入到对象B中，成为对象B的组成部分时，对象B和对象A之间为聚合关系。聚合是关联关系的一种，是较强的关联关系，强调的是整体与部分之间的关系。<br><br>场景：商品和他的规格、样式就是聚合关系。<br><br><img src=\"image/class_diagram/%E8%81%9A%E5%90%88.png\" alt></p>\n</blockquote>\n</li>\n<li><p>组合（Composite）</p>\n<blockquote>\n<p>对象A包含对象B，对象B离开对象A没有实际意义。是一种更强的关联关系。人包含手，手离开人的躯体就失去了它应有的作用。<br><br>场景： Window窗体由滑动条slider、头部Header 和工作区Panel组合而成。<br><br><img src=\"image/class_diagram/%E7%BB%84%E5%90%88.png\" alt></p>\n</blockquote>\n</li>\n<li><p>实现（Realization）</p>\n<blockquote>\n<p>一般来讲实现关系是针对类与接口之间的关系而言的。在UML类图中，实现关系用空心三角形+虚线来表示。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"StartUML实现画图\"><a href=\"#StartUML实现画图\" class=\"headerlink\" title=\"StartUML实现画图\"></a>StartUML实现画图</h4><p>startUML连线含义<br><img src=\"image/class_diagram/startUML%E8%BF%9E%E7%BA%BF.png\" alt><br><br>作图参考<a href=\"http://www.flyne.org/article/379\" target=\"_blank\" rel=\"noopener\">使用StarUML创建类图</a></p>\n<h4 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p><img src=\"image/class_diagram/%E7%B1%BB%E5%9B%BE%E7%BB%83%E4%B9%A0.jpg\" alt></p>\n<h3 id=\"对象图（Object-Diagram）\"><a href=\"#对象图（Object-Diagram）\" class=\"headerlink\" title=\"对象图（Object Diagram）\"></a>对象图（Object Diagram）</h3><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>对象图(Object Diagram)描述的是参与交互的各个对象在交互过程中某一时刻的状态。对象图可以被看作是类图在某一时刻的实例。</p>\n</blockquote>\n<p>在UML中，对象图使用的是与类图相同的符号和关系，因为对象就是类的实例。</p>\n<h4 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h4><blockquote>\n<p>对象图中包含对象（Object）和链（Link），对象是类的特定实例，链是类之间关系的实例。和类图一样，对象图对系统的静态设计或静态进程视图建模，对象图更注重现实或原型实例，这种视图主要支持系统的功能需求，对象图描述了静态的数据结构。</p>\n</blockquote>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><ul>\n<li>捕获示例和连接</li>\n<li>在分析和设计阶段创建</li>\n<li>捕获交互的静态部分</li>\n<li>举例说明数据/对象结构</li>\n<li>详细描述瞬间图</li>\n<li>工分析人士、设计人员和代码实现人员开发和使用</li>\n</ul>\n<h4 id=\"类图和对象图的区别\"><a href=\"#类图和对象图的区别\" class=\"headerlink\" title=\"类图和对象图的区别\"></a>类图和对象图的区别</h4><table>\n<thead>\n<tr>\n<th>类图</th>\n<th>对象图</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类具有3个分栏，名称、特性、行为</td>\n<td>对象只有两个分栏：名称、特性</td>\n</tr>\n<tr>\n<td>名称栏只有类名</td>\n<td>名称形式为“对象名：类名”，匿名对象的名称形式”:类名”</td>\n</tr>\n<tr>\n<td>特征栏包含所有特性</td>\n<td>特征栏之定义了特征的当前值，以便用于测试用例或者例子中</td>\n</tr>\n<tr>\n<td>类中列出了操作</td>\n<td>不包含操作</td>\n</tr>\n<tr>\n<td>使用关联连接，关联使用名称、角色、多重性以及约束特征定义。类带白哦的是对象分类，所以必须说明可以参与关联的对象数目</td>\n<td>对象使用链接连、链拥有名称、角色，但是没有多重性。对象代表的是单独的实体，所有的链都是一对一，因此不涉及多重性。</td>\n</tr>\n</tbody></table>\n<h4 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h4><p><img src=\"image/class_diagram/%E5%AF%B9%E8%B1%A1%E5%9B%BE.png\" alt></p>\n<h3 id=\"包图（Package-Diagram）\"><a href=\"#包图（Package-Diagram）\" class=\"headerlink\" title=\"包图（Package Diagram）\"></a>包图（Package Diagram）</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>包图（Package Diagram）由包和包之间的关系构成，对维护和控制系统总体结构很重要。系统建模中，有大量的类、接口、组件、节点和图，有必要将这些元素进行分组，把语义相近并倾向一起变化的元素组织起来加入同一包，这样方便理解和处理整个模型。设计良好的包是高内聚、低耦合的，并且对其内容的访问具有严密的控制。</p>\n</blockquote>\n<h4 id=\"包名\"><a href=\"#包名\" class=\"headerlink\" title=\"包名\"></a>包名</h4><blockquote>\n<p>每个包都必须有一个区别于其他包的名字。模型包的名字是一个字符串，可以分为简单名和路径名。</p>\n</blockquote>\n<ul>\n<li>简单名：指包仅含一个简单的名称。</li>\n<li>路径名：指以包位于的外围包的名字作为前缀。</li>\n</ul>\n<h4 id=\"拥有的元素\"><a href=\"#拥有的元素\" class=\"headerlink\" title=\"拥有的元素\"></a>拥有的元素</h4><ul>\n<li>包可以拥有类、接口、组件、节点、协作、用例图，甚至还可以包含其他的包</li>\n<li>包构成一个命名空间，这意味着一个模型包内各个包类建模元素不可以具有相同的名字，不同</li>\n<li>如果包被撤销，其中的元素也要被撤销。</li>\n</ul>\n<h4 id=\"包的可见性\"><a href=\"#包的可见性\" class=\"headerlink\" title=\"包的可见性\"></a>包的可见性</h4><blockquote>\n<p>包并不是独立存在的，包内的元素必然会和外部的类存在关系。而好的软件模型中的各个包应该做到高内聚、低耦合，为了做到这一点，就需要对包内的元素加以控制，使得某些元素能被外界访问，其他元素对外界不可见。这就是包内元素的可见性控制。</p>\n</blockquote>\n<p>包的可见性分为3种：</p>\n<ol>\n<li>公有访问（Public）：包内的元素可以被任何引入此包的其他包内的元素访问。公有访问用前缀于内含元素名字的加号（+）表示。</li>\n<li>保护访问（Protect）：此元素能被该模型包在继承关系上后继模式包的内含元素访问。保护访问用前缀于内含元素名字的（#）号表示。      </li>\n<li>私有访问（Private）：表示此元素可以被属于用一包的内含元素访问。私有访问用前缀于内含元素名字的减号（—）表示。</li>\n</ol>\n<h4 id=\"引入与输出\"><a href=\"#引入与输出\" class=\"headerlink\" title=\"引入与输出\"></a>引入与输出</h4><ul>\n<li>引入（Import）：允许一个包中的元素可以单向访问另一个包中的元素。</li>\n<li>输出（Export）：包中具有公有访问权限的内含元素。</li>\n</ul>\n<h4 id=\"标准元素\"><a href=\"#标准元素\" class=\"headerlink\" title=\"标准元素\"></a>标准元素</h4><table>\n<thead>\n<tr>\n<th>构造型</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>虚包（facade)</td>\n<td>描述一个只引用其他包元素的包</td>\n</tr>\n<tr>\n<td>框架(framework)</td>\n<td>描述一个主要有模式组成的包</td>\n</tr>\n<tr>\n<td>桩（stud）</td>\n<td>描述一个作为另一个包的公共内容代理的包</td>\n</tr>\n<tr>\n<td>子系统(subsustem)</td>\n<td>描述一个表示正在建模中的整个系统的一个独立部分的包</td>\n</tr>\n<tr>\n<td>系统(system)</td>\n<td>描述一个表示正在建模中的整个系统的包</td>\n</tr>\n</tbody></table>\n<h4 id=\"包之间的关系\"><a href=\"#包之间的关系\" class=\"headerlink\" title=\"包之间的关系\"></a>包之间的关系</h4><blockquote>\n<p>包与包之间有两种关系：</p>\n</blockquote>\n<ol>\n<li>引入和访问依赖：用于在一个包引入另一个包输出的元素。</li>\n<li>泛化：和类的泛化关系类似，包间的泛化关系遵循替代原则，特殊包可以应用到一般包被使用的任何地方。</li>\n</ol>\n<h4 id=\"包图建模技术\"><a href=\"#包图建模技术\" class=\"headerlink\" title=\"包图建模技术\"></a>包图建模技术</h4><ul>\n<li>建立包图的具体做法：<ol>\n<li>分析系统模型元素（通常是对象类），把概念上或语义上相近的模型元素纳入一个包。</li>\n<li>对于每一个包，对其模型元素标出其可见性。</li>\n<li>确定包与包之间的依赖关系，特别是输入依赖。</li>\n<li>确定包与包之间的泛化关系，确定包元素的多重性和重载。</li>\n<li>绘制包图</li>\n<li>包图精化</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"样例-1\"><a href=\"#样例-1\" class=\"headerlink\" title=\"样例\"></a>样例</h4><p><img src=\"image/class_diagram/%E5%8C%85%E5%9B%BE.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"静态图\"><a href=\"#静态图\" class=\"headerlink\" title=\"静态图\"></a>静态图</h2><p>包括类图、对象图、包图</p>\n<h3 id=\"类图（Class-diagram）\"><a href=\"#类图（Class-diagram）\" class=\"headerlink\" title=\"类图（Class diagram）\"></a>类图（Class diagram）</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>类是对象的集合，展示了对象的结构以及与系统的交互行为。类主要有属性（Attribute）和方法（Method）构成,属性代表对象的状态，如果属性被保存到数据库，此称之为“持久化”；方法代表对象的操作行为，类具有继承关系，可以继承于父类，也可以与其他的Class进行交互。<br>类图展示了系统的逻辑结构，类和接口的关系。</p>\n<h4 id=\"类的构成\"><a href=\"#类的构成\" class=\"headerlink\" title=\"类的构成\"></a>类的构成</h4><p>类主要有属性和方法构成。比如商品属性有：名称、价格、高度、宽度等；商品的方法有：计算税率，获得商品的评价等等。</p>\n<ul>\n<li><code>+</code>表示public</li>\n<li><code>#</code>表示protected</li>\n<li><code>—</code>表示private</li>\n<li><code>~</code>表示package</li>\n</ul>\n<h4 id=\"类图的元素\"><a href=\"#类图的元素\" class=\"headerlink\" title=\"类图的元素\"></a>类图的元素</h4><blockquote>\n<p>在类图中一共包含了以下几种模型元素，分别是：类（Class）、接口（Interface）、依赖（Dependency）关系、泛化（Generalization）关系、关联（Association）关系、聚合关系（Aggregation）、组合关系（Composition）和实现（Realization）关系。</p>\n</blockquote>\n<ol>\n<li><p>类（Class)</p>\n<blockquote>\n<p>在面向对象（OO) 编程中，类是对现实世界中一组具有相同特征的物体的抽象。</p>\n</blockquote>\n</li>\n<li><p>接口（Interface）</p>\n<blockquote>\n<p>接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。在UML中，接口使用一个带有名称的小圆圈来进行表示。</p>\n</blockquote>\n</li>\n<li><p>关联(Association)</p>\n<blockquote>\n<p>两个相对独立的对象，当一个对象的实例与另外一个对象的特定实例存在固定关系时，这两个对象之间就存在关联关系。</p>\n</blockquote>\n<ol>\n<li><p>单向关联</p>\n<blockquote>\n<p>A1-&gt;A2: 表示A1认识A2，A1知道A2的存在，A1可以调用A2中的方法和属性<br><br>场景：订单和商品，订单中包括商品，但是商品并不了解订单的存在。<br><br><img src=\"image/class_diagram/%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94.png\" alt></p>\n</blockquote>\n</li>\n<li><p>双向关联</p>\n<blockquote>\n<p>B1-B2: 表示B1认识B2，B1知道B2的存在，B1可以调用B2中的方法和属性；同样B2也知道B1的存在，B2也可以调用B1的方法和属性。<br><br>场景：订单和客户，订单属于客户，客户拥有一些特定的订单<br><br><img src=\"image/class_diagram/%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94.png\" alt></p>\n</blockquote>\n</li>\n<li><p>自身关联</p>\n<blockquote>\n<p>同一个类对象之间的关联<br><br>场景：组织结构的层次关系<br><br><img src=\"image/class_diagram/%E8%87%AA%E8%BA%AB%E5%85%B3%E8%81%94.png\" alt=\"类与类之间自身关联图\"></p>\n</blockquote>\n</li>\n<li><p>多维关联(N-ary Association)</p>\n<blockquote>\n<p>多个对象之间存在关联<br><br>场景：公司雇用员工，同时公司需要支付工资给员工<br><br><img src=\"image/class_diagram/%E5%A4%9A%E7%BB%B4%E5%85%B3%E8%81%94.png\" alt=\"多维关联\"></p>\n</blockquote>\n</li>\n<li><p>泛化(Generalization)</p>\n<blockquote>\n<p>类与类的继承关系，类与接口的实现关系。<br><br>场景：父与子、动物与人、植物与树、系统使用者与B2C会员和B2E会员的关系<br><br><img src=\"image/class_diagram/%E6%B3%9B%E5%8C%96.png\" alt=\"泛化\"><br><img src=\"image/class_diagram/%E7%BB%A7%E6%89%BF.png\" alt=\"继承\"></p>\n</blockquote>\n</li>\n<li><p>依赖(Dependency)</p>\n<blockquote>\n<p>类A要完成某个功能必须引用类B，则A与B存在依赖关系，依赖关系是弱的关联关系。C#不建议双相依赖，也就是相互引用<br><br>场景：本来人与电脑没有关系的，但由于偶然的机会，人需要用电脑写程序，这时候人就依赖于电脑。<br><br><img src=\"image/class_diagram/%E4%BE%9D%E8%B5%96.png\" alt></p>\n</blockquote>\n</li>\n<li><p>聚合(Aggregation)</p>\n<blockquote>\n<p>当对象A被加入到对象B中，成为对象B的组成部分时，对象B和对象A之间为聚合关系。聚合是关联关系的一种，是较强的关联关系，强调的是整体与部分之间的关系。<br><br>场景：商品和他的规格、样式就是聚合关系。<br><br><img src=\"image/class_diagram/%E8%81%9A%E5%90%88.png\" alt></p>\n</blockquote>\n</li>\n<li><p>组合（Composite）</p>\n<blockquote>\n<p>对象A包含对象B，对象B离开对象A没有实际意义。是一种更强的关联关系。人包含手，手离开人的躯体就失去了它应有的作用。<br><br>场景： Window窗体由滑动条slider、头部Header 和工作区Panel组合而成。<br><br><img src=\"image/class_diagram/%E7%BB%84%E5%90%88.png\" alt></p>\n</blockquote>\n</li>\n<li><p>实现（Realization）</p>\n<blockquote>\n<p>一般来讲实现关系是针对类与接口之间的关系而言的。在UML类图中，实现关系用空心三角形+虚线来表示。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"StartUML实现画图\"><a href=\"#StartUML实现画图\" class=\"headerlink\" title=\"StartUML实现画图\"></a>StartUML实现画图</h4><p>startUML连线含义<br><img src=\"image/class_diagram/startUML%E8%BF%9E%E7%BA%BF.png\" alt><br><br>作图参考<a href=\"http://www.flyne.org/article/379\" target=\"_blank\" rel=\"noopener\">使用StarUML创建类图</a></p>\n<h4 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p><img src=\"image/class_diagram/%E7%B1%BB%E5%9B%BE%E7%BB%83%E4%B9%A0.jpg\" alt></p>\n<h3 id=\"对象图（Object-Diagram）\"><a href=\"#对象图（Object-Diagram）\" class=\"headerlink\" title=\"对象图（Object Diagram）\"></a>对象图（Object Diagram）</h3><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>对象图(Object Diagram)描述的是参与交互的各个对象在交互过程中某一时刻的状态。对象图可以被看作是类图在某一时刻的实例。</p>\n</blockquote>\n<p>在UML中，对象图使用的是与类图相同的符号和关系，因为对象就是类的实例。</p>\n<h4 id=\"构成\"><a href=\"#构成\" class=\"headerlink\" title=\"构成\"></a>构成</h4><blockquote>\n<p>对象图中包含对象（Object）和链（Link），对象是类的特定实例，链是类之间关系的实例。和类图一样，对象图对系统的静态设计或静态进程视图建模，对象图更注重现实或原型实例，这种视图主要支持系统的功能需求，对象图描述了静态的数据结构。</p>\n</blockquote>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><ul>\n<li>捕获示例和连接</li>\n<li>在分析和设计阶段创建</li>\n<li>捕获交互的静态部分</li>\n<li>举例说明数据/对象结构</li>\n<li>详细描述瞬间图</li>\n<li>工分析人士、设计人员和代码实现人员开发和使用</li>\n</ul>\n<h4 id=\"类图和对象图的区别\"><a href=\"#类图和对象图的区别\" class=\"headerlink\" title=\"类图和对象图的区别\"></a>类图和对象图的区别</h4><table>\n<thead>\n<tr>\n<th>类图</th>\n<th>对象图</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类具有3个分栏，名称、特性、行为</td>\n<td>对象只有两个分栏：名称、特性</td>\n</tr>\n<tr>\n<td>名称栏只有类名</td>\n<td>名称形式为“对象名：类名”，匿名对象的名称形式”:类名”</td>\n</tr>\n<tr>\n<td>特征栏包含所有特性</td>\n<td>特征栏之定义了特征的当前值，以便用于测试用例或者例子中</td>\n</tr>\n<tr>\n<td>类中列出了操作</td>\n<td>不包含操作</td>\n</tr>\n<tr>\n<td>使用关联连接，关联使用名称、角色、多重性以及约束特征定义。类带白哦的是对象分类，所以必须说明可以参与关联的对象数目</td>\n<td>对象使用链接连、链拥有名称、角色，但是没有多重性。对象代表的是单独的实体，所有的链都是一对一，因此不涉及多重性。</td>\n</tr>\n</tbody></table>\n<h4 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h4><p><img src=\"image/class_diagram/%E5%AF%B9%E8%B1%A1%E5%9B%BE.png\" alt></p>\n<h3 id=\"包图（Package-Diagram）\"><a href=\"#包图（Package-Diagram）\" class=\"headerlink\" title=\"包图（Package Diagram）\"></a>包图（Package Diagram）</h3><h4 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>包图（Package Diagram）由包和包之间的关系构成，对维护和控制系统总体结构很重要。系统建模中，有大量的类、接口、组件、节点和图，有必要将这些元素进行分组，把语义相近并倾向一起变化的元素组织起来加入同一包，这样方便理解和处理整个模型。设计良好的包是高内聚、低耦合的，并且对其内容的访问具有严密的控制。</p>\n</blockquote>\n<h4 id=\"包名\"><a href=\"#包名\" class=\"headerlink\" title=\"包名\"></a>包名</h4><blockquote>\n<p>每个包都必须有一个区别于其他包的名字。模型包的名字是一个字符串，可以分为简单名和路径名。</p>\n</blockquote>\n<ul>\n<li>简单名：指包仅含一个简单的名称。</li>\n<li>路径名：指以包位于的外围包的名字作为前缀。</li>\n</ul>\n<h4 id=\"拥有的元素\"><a href=\"#拥有的元素\" class=\"headerlink\" title=\"拥有的元素\"></a>拥有的元素</h4><ul>\n<li>包可以拥有类、接口、组件、节点、协作、用例图，甚至还可以包含其他的包</li>\n<li>包构成一个命名空间，这意味着一个模型包内各个包类建模元素不可以具有相同的名字，不同</li>\n<li>如果包被撤销，其中的元素也要被撤销。</li>\n</ul>\n<h4 id=\"包的可见性\"><a href=\"#包的可见性\" class=\"headerlink\" title=\"包的可见性\"></a>包的可见性</h4><blockquote>\n<p>包并不是独立存在的，包内的元素必然会和外部的类存在关系。而好的软件模型中的各个包应该做到高内聚、低耦合，为了做到这一点，就需要对包内的元素加以控制，使得某些元素能被外界访问，其他元素对外界不可见。这就是包内元素的可见性控制。</p>\n</blockquote>\n<p>包的可见性分为3种：</p>\n<ol>\n<li>公有访问（Public）：包内的元素可以被任何引入此包的其他包内的元素访问。公有访问用前缀于内含元素名字的加号（+）表示。</li>\n<li>保护访问（Protect）：此元素能被该模型包在继承关系上后继模式包的内含元素访问。保护访问用前缀于内含元素名字的（#）号表示。      </li>\n<li>私有访问（Private）：表示此元素可以被属于用一包的内含元素访问。私有访问用前缀于内含元素名字的减号（—）表示。</li>\n</ol>\n<h4 id=\"引入与输出\"><a href=\"#引入与输出\" class=\"headerlink\" title=\"引入与输出\"></a>引入与输出</h4><ul>\n<li>引入（Import）：允许一个包中的元素可以单向访问另一个包中的元素。</li>\n<li>输出（Export）：包中具有公有访问权限的内含元素。</li>\n</ul>\n<h4 id=\"标准元素\"><a href=\"#标准元素\" class=\"headerlink\" title=\"标准元素\"></a>标准元素</h4><table>\n<thead>\n<tr>\n<th>构造型</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>虚包（facade)</td>\n<td>描述一个只引用其他包元素的包</td>\n</tr>\n<tr>\n<td>框架(framework)</td>\n<td>描述一个主要有模式组成的包</td>\n</tr>\n<tr>\n<td>桩（stud）</td>\n<td>描述一个作为另一个包的公共内容代理的包</td>\n</tr>\n<tr>\n<td>子系统(subsustem)</td>\n<td>描述一个表示正在建模中的整个系统的一个独立部分的包</td>\n</tr>\n<tr>\n<td>系统(system)</td>\n<td>描述一个表示正在建模中的整个系统的包</td>\n</tr>\n</tbody></table>\n<h4 id=\"包之间的关系\"><a href=\"#包之间的关系\" class=\"headerlink\" title=\"包之间的关系\"></a>包之间的关系</h4><blockquote>\n<p>包与包之间有两种关系：</p>\n</blockquote>\n<ol>\n<li>引入和访问依赖：用于在一个包引入另一个包输出的元素。</li>\n<li>泛化：和类的泛化关系类似，包间的泛化关系遵循替代原则，特殊包可以应用到一般包被使用的任何地方。</li>\n</ol>\n<h4 id=\"包图建模技术\"><a href=\"#包图建模技术\" class=\"headerlink\" title=\"包图建模技术\"></a>包图建模技术</h4><ul>\n<li>建立包图的具体做法：<ol>\n<li>分析系统模型元素（通常是对象类），把概念上或语义上相近的模型元素纳入一个包。</li>\n<li>对于每一个包，对其模型元素标出其可见性。</li>\n<li>确定包与包之间的依赖关系，特别是输入依赖。</li>\n<li>确定包与包之间的泛化关系，确定包元素的多重性和重载。</li>\n<li>绘制包图</li>\n<li>包图精化</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"样例-1\"><a href=\"#样例-1\" class=\"headerlink\" title=\"样例\"></a>样例</h4><p><img src=\"image/class_diagram/%E5%8C%85%E5%9B%BE.png\" alt></p>\n"},{"title":"Android应用的基本组件","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2015-04-29T09:35:00.000Z","_content":"\nAndroid系统中有著名的四大组件：Activity、Service、BroadcastReceiver、ContentProvider。一个商业的Android应用程序，通常由多个基本的组件联合组成。这四大组件，在使用的时候均需要在清单文件AndroidManifest.xml中进行注册，否则不予使用。本小节将对这些组件进行简单的介绍，使读者对Android应用开发的内容有一个大致的认识。\n\n## 活动（Activity）\n\n\nActivity是Android应用中，最直接与用户接触的组件，它负责加载View组件，使其展现给用户，并保持与用户的交互。所有的Activity组件均需要继承Activity类，这是一个Content的间接子类，包装了一些Activity的基本特性。\n\n\nView组件是所有UI组件、容器组件的基类，也就是说，它可以是一个布局容器，也可以是一个布局容器内的基本UI组件。View组件一般通过XML布局资源文件定义，同时Android系统也对这些View组件提供了对应的实现类。如果需要通过某个Activity把指定的View组件显示出来，调用Activity的setContentView()方法即可，它具有多个重载方法，可以传递一个XML资源ID或者View对象。\n\n例如：\n```java\nLinearLayout layout=new LinearLayout(this);\nsetContentView(layout)；\n```\n或者：\n```\nsetContentView(R.layout.main);\n```\n\nActivity为Android应用提供了一个用户界面，当一个Activity被开启之后，它具有自己的生命周期。Activity类也对这些生命周期提供了对应的方法，如果需要对Activity各个不同的生命周期做出响应，可以重写这些生命周期方法实现。对于大多数商业应用而言，整个系统中包含了多个Activity，在应用中逐步导航跳转开启这些Activity之后，会形成Activity的回退栈，当前显示并获得焦点的Activity位于这个回退栈的栈顶。\n\n## 服务（Service）\n\nService主要用于在后台完成一些无需向用户展示界面的功能实现。通常位于系统后台运行，它一般不需要与用户进行交互，因此Service组件没有用户界面展示给用户。Service主要用于完成一些类似于下载文件、播放音乐等无需用户界面与用户进行交互的功能。\n与Activity组件需要继承Activity类相似，Service组件同样需要继承Service类，Service类也是Context的间接子类，其中包装了一些Service的专有特性。一个Service被运行起来之后，它将具有自己独立的生命周期，Service类中对其各个不同的生命周期提供了对应的方法，开发人员可以通过在Service中重写Service类中这些生命周期方法，来响应Service各个生命周期的功能实现。\n\n## 广播接收器（BroadcastReceiver）\n\nBroadcastReceiver同样也是Android系统中的一个重要组件，BroadcastReceiver代表了一个广播接收器，用于接收系统中其它组件发送的广播，并对其进行响应或是拦截广播的继续传播。\n广播是一个系统级的消息，当系统环境发生改变的时候会发送一些广播供对应的程序进行接收响应，例如：接收到一条短信、开机、关机、插上充电器、插上耳机、充电完成等，均会发送一条广播供需要监听此类广播的应用进行响应。除了一些系统事件的广播，开发人员也可以自定义广播内容。但是大部分情况下，开发应用的时候主要用于接受系统广播并对其进行响应，很少需要发送自定义的广播。\n使用BroadcastReceiver组件接收广播非常的简单，只需要实现自己的BroadcastReceiver子类，并重写onReceive()方法，就能完成BroadcastReceiver，而对于这个BroadcastReceiver对什么广播感兴趣，则需要对其进行另行配置。\n\n## 内容提供者（ContentProvider）\nAndroid系统作为一个智能操作系统，它需要系统中运行的应用程序都必须是相互独立的，各自运行在自己的Dalvik VM实例中。在正常情况下，Android应用之间是不能进行实时的数据交换，而考虑到有些应用的数据需要对外进行共享，Android系统提供了一个标准的数据接口ContentProvider，通过应用提供的ContentProvider，可以在其它应用中对这个应用的暴露出来的数据进行增删改查。\n为应用程序暴露数据接口非常的简单，只需要继承ContentProvider类，并且实现insert()、delete()、update()、query()等方法，使外部应用可对本应用的数据进行增删改查。\n\n## 意图（Intent）\n\n虽然Intent并不是Android应用的组件，也无需专门在清单文件中配置，但是它对于Android应用的作用非常的大。除了ContentProvider之外，其它组件的启动，均需要通过Intent进行指定。Intent不仅可以明确指定一个Android组件进行启动，还可以提供一个标准的行为，再由Android系统配合意图过滤器来选定启动指定组件来完成任务。而Intent在开启对组件的过程中，进行各个组件间数据的传递。\n\n## 小结\n\n本章简要介绍了Android系统的发展史及其现状，并且介绍了Android系统的架构与Dalvik VM虚拟机，最后还简单介绍了Android开发中的四大组件。通过阅读本章，对Android的历史与现状、系统架构、基本组件有个大致的了解，这对本书接下来的内容理解非常有帮助。","source":"_posts/android/base/Android应用的基本组件.md","raw":"title: Android应用的基本组件\nauthor: JsonYe\ntags:\n  - Android\ncategories:\n  - Android基础  \ncopyright: true\ncomments: true\ntoc: true\ndate: 2015-04-29 17:35:00\n---\n\nAndroid系统中有著名的四大组件：Activity、Service、BroadcastReceiver、ContentProvider。一个商业的Android应用程序，通常由多个基本的组件联合组成。这四大组件，在使用的时候均需要在清单文件AndroidManifest.xml中进行注册，否则不予使用。本小节将对这些组件进行简单的介绍，使读者对Android应用开发的内容有一个大致的认识。\n\n## 活动（Activity）\n\n\nActivity是Android应用中，最直接与用户接触的组件，它负责加载View组件，使其展现给用户，并保持与用户的交互。所有的Activity组件均需要继承Activity类，这是一个Content的间接子类，包装了一些Activity的基本特性。\n\n\nView组件是所有UI组件、容器组件的基类，也就是说，它可以是一个布局容器，也可以是一个布局容器内的基本UI组件。View组件一般通过XML布局资源文件定义，同时Android系统也对这些View组件提供了对应的实现类。如果需要通过某个Activity把指定的View组件显示出来，调用Activity的setContentView()方法即可，它具有多个重载方法，可以传递一个XML资源ID或者View对象。\n\n例如：\n```java\nLinearLayout layout=new LinearLayout(this);\nsetContentView(layout)；\n```\n或者：\n```\nsetContentView(R.layout.main);\n```\n\nActivity为Android应用提供了一个用户界面，当一个Activity被开启之后，它具有自己的生命周期。Activity类也对这些生命周期提供了对应的方法，如果需要对Activity各个不同的生命周期做出响应，可以重写这些生命周期方法实现。对于大多数商业应用而言，整个系统中包含了多个Activity，在应用中逐步导航跳转开启这些Activity之后，会形成Activity的回退栈，当前显示并获得焦点的Activity位于这个回退栈的栈顶。\n\n## 服务（Service）\n\nService主要用于在后台完成一些无需向用户展示界面的功能实现。通常位于系统后台运行，它一般不需要与用户进行交互，因此Service组件没有用户界面展示给用户。Service主要用于完成一些类似于下载文件、播放音乐等无需用户界面与用户进行交互的功能。\n与Activity组件需要继承Activity类相似，Service组件同样需要继承Service类，Service类也是Context的间接子类，其中包装了一些Service的专有特性。一个Service被运行起来之后，它将具有自己独立的生命周期，Service类中对其各个不同的生命周期提供了对应的方法，开发人员可以通过在Service中重写Service类中这些生命周期方法，来响应Service各个生命周期的功能实现。\n\n## 广播接收器（BroadcastReceiver）\n\nBroadcastReceiver同样也是Android系统中的一个重要组件，BroadcastReceiver代表了一个广播接收器，用于接收系统中其它组件发送的广播，并对其进行响应或是拦截广播的继续传播。\n广播是一个系统级的消息，当系统环境发生改变的时候会发送一些广播供对应的程序进行接收响应，例如：接收到一条短信、开机、关机、插上充电器、插上耳机、充电完成等，均会发送一条广播供需要监听此类广播的应用进行响应。除了一些系统事件的广播，开发人员也可以自定义广播内容。但是大部分情况下，开发应用的时候主要用于接受系统广播并对其进行响应，很少需要发送自定义的广播。\n使用BroadcastReceiver组件接收广播非常的简单，只需要实现自己的BroadcastReceiver子类，并重写onReceive()方法，就能完成BroadcastReceiver，而对于这个BroadcastReceiver对什么广播感兴趣，则需要对其进行另行配置。\n\n## 内容提供者（ContentProvider）\nAndroid系统作为一个智能操作系统，它需要系统中运行的应用程序都必须是相互独立的，各自运行在自己的Dalvik VM实例中。在正常情况下，Android应用之间是不能进行实时的数据交换，而考虑到有些应用的数据需要对外进行共享，Android系统提供了一个标准的数据接口ContentProvider，通过应用提供的ContentProvider，可以在其它应用中对这个应用的暴露出来的数据进行增删改查。\n为应用程序暴露数据接口非常的简单，只需要继承ContentProvider类，并且实现insert()、delete()、update()、query()等方法，使外部应用可对本应用的数据进行增删改查。\n\n## 意图（Intent）\n\n虽然Intent并不是Android应用的组件，也无需专门在清单文件中配置，但是它对于Android应用的作用非常的大。除了ContentProvider之外，其它组件的启动，均需要通过Intent进行指定。Intent不仅可以明确指定一个Android组件进行启动，还可以提供一个标准的行为，再由Android系统配合意图过滤器来选定启动指定组件来完成任务。而Intent在开启对组件的过程中，进行各个组件间数据的传递。\n\n## 小结\n\n本章简要介绍了Android系统的发展史及其现状，并且介绍了Android系统的架构与Dalvik VM虚拟机，最后还简单介绍了Android开发中的四大组件。通过阅读本章，对Android的历史与现状、系统架构、基本组件有个大致的了解，这对本书接下来的内容理解非常有帮助。","slug":"android/base/Android应用的基本组件","published":1,"updated":"2019-10-02T08:41:02.792Z","layout":"post","photos":[],"link":"","_id":"ck19bvb31004400wktkxh8lag","content":"<p>Android系统中有著名的四大组件：Activity、Service、BroadcastReceiver、ContentProvider。一个商业的Android应用程序，通常由多个基本的组件联合组成。这四大组件，在使用的时候均需要在清单文件AndroidManifest.xml中进行注册，否则不予使用。本小节将对这些组件进行简单的介绍，使读者对Android应用开发的内容有一个大致的认识。</p>\n<h2 id=\"活动（Activity）\"><a href=\"#活动（Activity）\" class=\"headerlink\" title=\"活动（Activity）\"></a>活动（Activity）</h2><p>Activity是Android应用中，最直接与用户接触的组件，它负责加载View组件，使其展现给用户，并保持与用户的交互。所有的Activity组件均需要继承Activity类，这是一个Content的间接子类，包装了一些Activity的基本特性。</p>\n<p>View组件是所有UI组件、容器组件的基类，也就是说，它可以是一个布局容器，也可以是一个布局容器内的基本UI组件。View组件一般通过XML布局资源文件定义，同时Android系统也对这些View组件提供了对应的实现类。如果需要通过某个Activity把指定的View组件显示出来，调用Activity的setContentView()方法即可，它具有多个重载方法，可以传递一个XML资源ID或者View对象。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinearLayout layout=<span class=\"keyword\">new</span> LinearLayout(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">setContentView(layout)；</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContentView(R.layout.main);</span><br></pre></td></tr></table></figure>\n\n<p>Activity为Android应用提供了一个用户界面，当一个Activity被开启之后，它具有自己的生命周期。Activity类也对这些生命周期提供了对应的方法，如果需要对Activity各个不同的生命周期做出响应，可以重写这些生命周期方法实现。对于大多数商业应用而言，整个系统中包含了多个Activity，在应用中逐步导航跳转开启这些Activity之后，会形成Activity的回退栈，当前显示并获得焦点的Activity位于这个回退栈的栈顶。</p>\n<h2 id=\"服务（Service）\"><a href=\"#服务（Service）\" class=\"headerlink\" title=\"服务（Service）\"></a>服务（Service）</h2><p>Service主要用于在后台完成一些无需向用户展示界面的功能实现。通常位于系统后台运行，它一般不需要与用户进行交互，因此Service组件没有用户界面展示给用户。Service主要用于完成一些类似于下载文件、播放音乐等无需用户界面与用户进行交互的功能。<br>与Activity组件需要继承Activity类相似，Service组件同样需要继承Service类，Service类也是Context的间接子类，其中包装了一些Service的专有特性。一个Service被运行起来之后，它将具有自己独立的生命周期，Service类中对其各个不同的生命周期提供了对应的方法，开发人员可以通过在Service中重写Service类中这些生命周期方法，来响应Service各个生命周期的功能实现。</p>\n<h2 id=\"广播接收器（BroadcastReceiver）\"><a href=\"#广播接收器（BroadcastReceiver）\" class=\"headerlink\" title=\"广播接收器（BroadcastReceiver）\"></a>广播接收器（BroadcastReceiver）</h2><p>BroadcastReceiver同样也是Android系统中的一个重要组件，BroadcastReceiver代表了一个广播接收器，用于接收系统中其它组件发送的广播，并对其进行响应或是拦截广播的继续传播。<br>广播是一个系统级的消息，当系统环境发生改变的时候会发送一些广播供对应的程序进行接收响应，例如：接收到一条短信、开机、关机、插上充电器、插上耳机、充电完成等，均会发送一条广播供需要监听此类广播的应用进行响应。除了一些系统事件的广播，开发人员也可以自定义广播内容。但是大部分情况下，开发应用的时候主要用于接受系统广播并对其进行响应，很少需要发送自定义的广播。<br>使用BroadcastReceiver组件接收广播非常的简单，只需要实现自己的BroadcastReceiver子类，并重写onReceive()方法，就能完成BroadcastReceiver，而对于这个BroadcastReceiver对什么广播感兴趣，则需要对其进行另行配置。</p>\n<h2 id=\"内容提供者（ContentProvider）\"><a href=\"#内容提供者（ContentProvider）\" class=\"headerlink\" title=\"内容提供者（ContentProvider）\"></a>内容提供者（ContentProvider）</h2><p>Android系统作为一个智能操作系统，它需要系统中运行的应用程序都必须是相互独立的，各自运行在自己的Dalvik VM实例中。在正常情况下，Android应用之间是不能进行实时的数据交换，而考虑到有些应用的数据需要对外进行共享，Android系统提供了一个标准的数据接口ContentProvider，通过应用提供的ContentProvider，可以在其它应用中对这个应用的暴露出来的数据进行增删改查。<br>为应用程序暴露数据接口非常的简单，只需要继承ContentProvider类，并且实现insert()、delete()、update()、query()等方法，使外部应用可对本应用的数据进行增删改查。</p>\n<h2 id=\"意图（Intent）\"><a href=\"#意图（Intent）\" class=\"headerlink\" title=\"意图（Intent）\"></a>意图（Intent）</h2><p>虽然Intent并不是Android应用的组件，也无需专门在清单文件中配置，但是它对于Android应用的作用非常的大。除了ContentProvider之外，其它组件的启动，均需要通过Intent进行指定。Intent不仅可以明确指定一个Android组件进行启动，还可以提供一个标准的行为，再由Android系统配合意图过滤器来选定启动指定组件来完成任务。而Intent在开启对组件的过程中，进行各个组件间数据的传递。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本章简要介绍了Android系统的发展史及其现状，并且介绍了Android系统的架构与Dalvik VM虚拟机，最后还简单介绍了Android开发中的四大组件。通过阅读本章，对Android的历史与现状、系统架构、基本组件有个大致的了解，这对本书接下来的内容理解非常有帮助。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Android系统中有著名的四大组件：Activity、Service、BroadcastReceiver、ContentProvider。一个商业的Android应用程序，通常由多个基本的组件联合组成。这四大组件，在使用的时候均需要在清单文件AndroidManifest.xml中进行注册，否则不予使用。本小节将对这些组件进行简单的介绍，使读者对Android应用开发的内容有一个大致的认识。</p>\n<h2 id=\"活动（Activity）\"><a href=\"#活动（Activity）\" class=\"headerlink\" title=\"活动（Activity）\"></a>活动（Activity）</h2><p>Activity是Android应用中，最直接与用户接触的组件，它负责加载View组件，使其展现给用户，并保持与用户的交互。所有的Activity组件均需要继承Activity类，这是一个Content的间接子类，包装了一些Activity的基本特性。</p>\n<p>View组件是所有UI组件、容器组件的基类，也就是说，它可以是一个布局容器，也可以是一个布局容器内的基本UI组件。View组件一般通过XML布局资源文件定义，同时Android系统也对这些View组件提供了对应的实现类。如果需要通过某个Activity把指定的View组件显示出来，调用Activity的setContentView()方法即可，它具有多个重载方法，可以传递一个XML资源ID或者View对象。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinearLayout layout=<span class=\"keyword\">new</span> LinearLayout(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">setContentView(layout)；</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setContentView(R.layout.main);</span><br></pre></td></tr></table></figure>\n\n<p>Activity为Android应用提供了一个用户界面，当一个Activity被开启之后，它具有自己的生命周期。Activity类也对这些生命周期提供了对应的方法，如果需要对Activity各个不同的生命周期做出响应，可以重写这些生命周期方法实现。对于大多数商业应用而言，整个系统中包含了多个Activity，在应用中逐步导航跳转开启这些Activity之后，会形成Activity的回退栈，当前显示并获得焦点的Activity位于这个回退栈的栈顶。</p>\n<h2 id=\"服务（Service）\"><a href=\"#服务（Service）\" class=\"headerlink\" title=\"服务（Service）\"></a>服务（Service）</h2><p>Service主要用于在后台完成一些无需向用户展示界面的功能实现。通常位于系统后台运行，它一般不需要与用户进行交互，因此Service组件没有用户界面展示给用户。Service主要用于完成一些类似于下载文件、播放音乐等无需用户界面与用户进行交互的功能。<br>与Activity组件需要继承Activity类相似，Service组件同样需要继承Service类，Service类也是Context的间接子类，其中包装了一些Service的专有特性。一个Service被运行起来之后，它将具有自己独立的生命周期，Service类中对其各个不同的生命周期提供了对应的方法，开发人员可以通过在Service中重写Service类中这些生命周期方法，来响应Service各个生命周期的功能实现。</p>\n<h2 id=\"广播接收器（BroadcastReceiver）\"><a href=\"#广播接收器（BroadcastReceiver）\" class=\"headerlink\" title=\"广播接收器（BroadcastReceiver）\"></a>广播接收器（BroadcastReceiver）</h2><p>BroadcastReceiver同样也是Android系统中的一个重要组件，BroadcastReceiver代表了一个广播接收器，用于接收系统中其它组件发送的广播，并对其进行响应或是拦截广播的继续传播。<br>广播是一个系统级的消息，当系统环境发生改变的时候会发送一些广播供对应的程序进行接收响应，例如：接收到一条短信、开机、关机、插上充电器、插上耳机、充电完成等，均会发送一条广播供需要监听此类广播的应用进行响应。除了一些系统事件的广播，开发人员也可以自定义广播内容。但是大部分情况下，开发应用的时候主要用于接受系统广播并对其进行响应，很少需要发送自定义的广播。<br>使用BroadcastReceiver组件接收广播非常的简单，只需要实现自己的BroadcastReceiver子类，并重写onReceive()方法，就能完成BroadcastReceiver，而对于这个BroadcastReceiver对什么广播感兴趣，则需要对其进行另行配置。</p>\n<h2 id=\"内容提供者（ContentProvider）\"><a href=\"#内容提供者（ContentProvider）\" class=\"headerlink\" title=\"内容提供者（ContentProvider）\"></a>内容提供者（ContentProvider）</h2><p>Android系统作为一个智能操作系统，它需要系统中运行的应用程序都必须是相互独立的，各自运行在自己的Dalvik VM实例中。在正常情况下，Android应用之间是不能进行实时的数据交换，而考虑到有些应用的数据需要对外进行共享，Android系统提供了一个标准的数据接口ContentProvider，通过应用提供的ContentProvider，可以在其它应用中对这个应用的暴露出来的数据进行增删改查。<br>为应用程序暴露数据接口非常的简单，只需要继承ContentProvider类，并且实现insert()、delete()、update()、query()等方法，使外部应用可对本应用的数据进行增删改查。</p>\n<h2 id=\"意图（Intent）\"><a href=\"#意图（Intent）\" class=\"headerlink\" title=\"意图（Intent）\"></a>意图（Intent）</h2><p>虽然Intent并不是Android应用的组件，也无需专门在清单文件中配置，但是它对于Android应用的作用非常的大。除了ContentProvider之外，其它组件的启动，均需要通过Intent进行指定。Intent不仅可以明确指定一个Android组件进行启动，还可以提供一个标准的行为，再由Android系统配合意图过滤器来选定启动指定组件来完成任务。而Intent在开启对组件的过程中，进行各个组件间数据的传递。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本章简要介绍了Android系统的发展史及其现状，并且介绍了Android系统的架构与Dalvik VM虚拟机，最后还简单介绍了Android开发中的四大组件。通过阅读本章，对Android的历史与现状、系统架构、基本组件有个大致的了解，这对本书接下来的内容理解非常有帮助。</p>\n"},{"title":"第一个Flutter应用","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-19T04:14:00.000Z","_content":"## 使用 package\n在这一步中，你将开始使用一个名为 english_words 的开源软件包，其中包含数千个最常用的英文单词以及一些实用功能。\n\n你可以 在 [pub.dartlang.org](https://pub.dartlang.org/flutter/) 上找到 english_words 软件包以及其他许多开源软件包。\n\n1. pubspec 文件管理 Flutter 应用程序的 assets（资源，如图片、package等）。 在pubspec.yaml 中，将 english_words（3.1.0或更高版本）添加到依赖项列表，如下面高亮显示的行：\n```dart\ndependencies:\n  flutter:\n    sdk: flutter\n\n  cupertino_icons: ^0.1.0\n  english_words: ^3.1.0   # 新增了这一行\n```\n2. 在Android Studio 的编辑器视图中查看 pubspec 时，单击右上角的 `Packages get`，这会将依赖包安装到您的项目。您可以在控制台中看到以下内容：\n\n```shell\nflutter packages get\nRunning \"flutter packages get\" in startup_namer...\nProcess finished with exit code 0\n```\n3. 在 lib/main.dart 中引入，如下所示：\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:english_words/english_words.dart';  // 新增了这一行\n```\n在您输入时，Android Studio会为您提供有关库导入的建议。然后它将呈现灰色的导入字符串，让您知道导入的库截至目前尚未被使用。\n\n接下来，我们使用 English words 包生成文本来替换字符串\"Hello World\"：\n\n我们需要进行如下更改：\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:english_words/english_words.dart';\n\nvoid main() => runApp(new MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final wordPair = new WordPair.random(); // 新增了这一行\n    return new MaterialApp(\n      title: 'Welcome to Flutter',\n      home: new Scaffold(\n        appBar: new AppBar(\n          title: new Text('Welcome to Flutter'),\n        ),\n        body: new Center(    // 这里把之前的 \"const\" 换成了 \"new\".\n          //child: const Text('Hello World'),   // 我们不用这样的方式生成文字了\n          child: new Text(wordPair.asPascalCase),  // 这是新的文字生成方式\n        ),\n      ),\n    );\n  }\n}\n```\n> 提示：「大驼峰式命名法」也称为 upper camel case 或 Pascal case，表示字符串中的每个单词（包括第一个单词）都以大写字母开头。所以，uppercamelcase 会变成 UpperCamelCase。\n\n4. 如果你没有把 Center 前面的修饰词从 const 改成 new 的话，系统就会报错，因为这个时候它的子对象已经不是常量，那就不能再用 const 了，所以这里 Center 和 Text 都需要使用 new 创建新的实例。\n\n## 添加一个 Stateful widget\n\nStateless widgets 是不可变的，这意味着它们的属性不能改变——所有的值都是 final。\n\nStateful widgets 持有的状态可能在 widget 生命周期中发生变化，实现一个 stateful widget 至少需要两个类：1）一个 StatefulWidget 类；2）一个 State 类，StatefulWidget 类本身是不变的，但是 State 类在 widget 生命周期中始终存在。\n\n在这一步，你将添加一个 stateful widget（有状态的控件）—— RandomWords，它会创建自己的状态类 —— RandomWordsState，然后你需要将 RandomWords 内嵌到已有的无状态的 MyApp widget。\n\n1. 创建一个最简的 state 类，这个类可以在任意地方创建而不一定非要在 MyApp 里，我们的示例代码是放在 MyApp 类的最下面了：\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  // TODO Add build method\n}\n```\n> 注意一下 State<RandomWords> 的声明。这表明我们在使用专门用于 RandomWords 的 State 泛型类。应用的大部分逻辑和状态都在这里 —— 它会维护 RandomWords 控件的状态。这个类会保存代码生成的单词对，这个单词对列表会随着用户滑动而无限增长，另外还会保存用户喜爱的单词对（第二部分），也即当用户点击爱心图标的时候会从喜爱的列表中添加或者移除当前单词对。\n\nRandomWordsState 继承自 RandomWords，我们接下来会创建这个类。\n\n2. 添加有状态的 RandomWords widget 到 main.dart，RandomWords widget 除了创建 State 类之外几乎没有其他任何东西：\n```dart\nclass RandomWords extends StatefulWidget {\n  @override\n  RandomWordsState createState() => new RandomWordsState();\n}\n```\n在添加状态类后，IDE 会提示该类缺少 build 方法。接下来，您将添加一个基本的 build 方法，该方法通过将生成单词对的代码从 MyApp 移动到 RandomWordsState 来生成单词对。\n\n3. 将 build 方法添加到 RandomWordState 中，如下所示：\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  @override                                  // 新增代码片段 - 开始 ... \n  Widget build(BuildContext context) {\n    final WordPair wordPair = new WordPair.random();\n    return new Text(wordPair.asPascalCase);\n  }                                          // ... 新增的代码片段 - 结束\n}\n```\n4. 如下所示，删除 MyApp 里生成文字的代码：\n\n```dart\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final WordPair wordPair = new WordPair.random();  // 删掉本行\n    return new MaterialApp(\n      title: 'Welcome to Flutter',\n      home: new Scaffold(\n        appBar: new AppBar(\n          title: new Text('Welcome to Flutter'),\n        ),\n        body: new Center(\n          //child: new Text(wordPair.asPascalCase), // 修改本行内容 \n          child: new RandomWords(),                 // 修改成本行代码\n        ),\n      ),\n    );\n  }\n}\n```\n5. 热重载（Hot reload）当前的工程，应用应该像之前一样运行，每次热重载或保存应用程序时都会显示一个单词对。\n\n> 提示: 如果您尝试热重载，则可能会看到一条警告，考虑重新启动当前应用：\n>  ```shell\n>  Reloading...\n>  Not all changed program elements ran during view reassembly; consider restarting.\n>    ```\n>    因为重启应用之后就可以生效，故这可能是误报。\n\n## 创建一个无限滚动的 ListView\n在这一步中，您将扩展（继承）RandomWordsState 类，以生成并显示单词对列表。 当用户滚动时，ListView 中显示的列表将无限增长。 ListView 的 builder 工厂构造函数允许您按需建立一个懒加载的列表视图。\n\n1. 向 RandomWordsState 类中添加一个 _suggestions 列表以保存建议的单词对，同时，添加一个 biggerFont 变量来增大字体大小 Also, add a _biggerFont variable for making the font size larger.\n\n> 提示：在 Dart 语言中使用下划线前缀标识符，会强制其变成私有。\n\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  // 添加如下两行\n  final List<WordPair> _suggestions = <WordPair>[];\n  final TextStyle _biggerFont = const TextStyle(fontSize: 18.0); \n  ...\n}\n```\n接下来，我们将向 RandomWordsState 类添加一个 _buildSuggestions() 函数，此方法构建显示建议单词对的 ListView。\n\nListView 类提供了一个 builder 属性，itemBuilder 值是一个匿名回调函数， 接受两个参数- BuildContext 和行迭代器 i。迭代器从 0 开始， 每调用一次该函数，i 就会自增 1，对于每个建议的单词对都会执行一次。该模型允许建议的单词对列表在用户滚动时无限增长。\n\n2. 向 RandomWordsState 类添加 _buildSuggestions() 函数，内容如下：\n```dart\n  Widget _buildSuggestions() {\n    return new ListView.builder(\n      padding: const EdgeInsets.all(16.0),\n\n      // 对于每个建议的单词对都会调用一次 itemBuilder，\n      // 然后将单词对添加到 ListTile 行中\n      // 在偶数行，该函数会为单词对添加一个 ListTile row.\n      // 在奇数行，该函数会添加一个分割线的 widget，来分隔相邻的词对。\n      // 注意，在小屏幕上，分割线看起来可能比较吃力。\n\n      itemBuilder: (BuildContext _context, int i) {\n        // 在每一列之前，添加一个1像素高的分隔线widget\n        if (i.isOdd) {\n          return new Divider();\n        }\n\n        // 语法 \"i ~/ 2\" 表示i除以2，但返回值是整形（向下取整）\n        // 比如 i 为：1, 2, 3, 4, 5 时，结果为 0, 1, 1, 2, 2，\n        // 这可以计算出 ListView 中减去分隔线后的实际单词对数量\n        final int index = i ~/ 2;\n        // 如果是建议列表中最后一个单词对\n        if (index >= _suggestions.length) {\n        // ...接着再生成10个单词对，然后添加到建议列表\n          _suggestions.addAll(generateWordPairs().take(10));\n        }\n        return _buildRow(_suggestions[index]);\n      }\n    );\n  }\n```\n对于每一个单词对，_buildSuggestions 函数都会调用一次 _buildRow。 这个函数在 ListTile 中显示每个新词对，这使您在下一步中可以生成更漂亮的显示行，详见本 codelab 的第二部分。\n\n3. 在 RandomWordsState 中添加 _buildRow 函数 :\n```dart\n  Widget _buildRow(WordPair pair) {\n    return new ListTile(\n      title: new Text(\n        pair.asPascalCase,\n        style: _biggerFont,\n      ),\n    );\n  }\n```\n4. 更新 RandomWordsState 的 build 方法以使用 _buildSuggestions()，而不是直接调用单词生成库，代码更改后如下：（使用 Scaffold 类实现基础的 Material Design 布局）\n```dart\n  @override\n  Widget build(BuildContext context) {\n    //final wordPair = new WordPair.random(); // 删掉 ... \n    //return new Text(wordPair.asPascalCase); // ... 这两行\n\n    return new Scaffold (                   // 代码从这里... \n      appBar: new AppBar(\n        title: new Text('Startup Name Generator'),\n      ),\n      body: _buildSuggestions(),\n    );                                      // ... 添加到这里\n  }\n```\n5. 更新 MyApp 的 build 方法, changing the title, and changing the home to be a RandomWords widget.\n```dart\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n      title: 'Startup Name Generator',\n      home: new RandomWords(),\n    );\n  }\n```\n6. 重新启动你的项目工程应用，你应该看到一个单词对列表。尽可能地向下滚动，你将继续看到新的单词对。\n![](img/12_1.png)\n\n## 向列表中添加图标\n在这部分，我们将为每一行添加一个心形的（收藏）图标，下一步你将能够为这个图标加入点击收藏的功能。\n\n1. 添加一个 _saved Set（集合）到 RandomWordsState，这个集合存储用户喜欢（收藏）的单词对。 在这里，Set 比 List 更合适，因为 Set 中不允许重复的值。\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  final List<WordPair> _suggestions = <WordPair>[];\n  final Set<WordPair> _saved = new Set<WordPair>();   // 新增本行\n  final TextStyle _biggerFont = const TextStyle(fontSize: 18.0);\n  ...\n}\n```\n2. 在 _buildRow 方法中添加 alreadySaved 来检查确保单词对还没有添加到收藏夹中。\n```dart\nWidget _buildRow(WordPair pair) {\n  final bool alreadySaved = _saved.contains(pair);  // 新增本行\n  ...\n}\n```\n同时在 _buildRow() 中， 添加一个心形 ❤️ 图标到 ListTiles以启用收藏功能。接下来，你就可以给心形 ❤️ 图标添加交互能力了。\n\n3. 向列表添加图标，如下所示：\n```dart\nWidget _buildRow(WordPair pair) {\n  final bool alreadySaved = _saved.contains(pair);\n  return new ListTile(\n    title: new Text(\n      pair.asPascalCase,\n      style: _biggerFont,\n    ),\n    trailing: new Icon(   // 新增代码开始 ...\n      alreadySaved ? Icons.favorite : Icons.favorite_border,\n      color: alreadySaved ? Colors.red : null,\n    ),                    // ... 新增代码结束\n  );\n}\n```\n4. 热重载应用，你现在可以在每一行看到心形 ❤️图标️，但它们还没有交互。\n\n## 添加交互\n在这部分，我们将为刚刚的心形 ❤️图标增加交互，当用户点击列表中的条目，切换其\"收藏\"状态，并将该词对添加到或移除出\"收藏夹\"。\n\n为了做到这个，我们在 _buildRow 中让心形 ❤️图标变得可以点击。如果单词条目已经添加到收藏夹中， 再次点击它将其从收藏夹中删除。当心形 ❤️图标被点击时，函数调用 setState() 通知框架状态已经改变。\n\n1. 增加 onTap 方法，如下所示：\n```dart\nWidget _buildRow(WordPair pair) {\n  final alreadySaved = _saved.contains(pair);\n  return new ListTile(\n    title: new Text(\n      pair.asPascalCase,\n      style: _biggerFont,\n    ),\n    trailing: new Icon(\n      alreadySaved ? Icons.favorite : Icons.favorite_border,\n      color: alreadySaved ? Colors.red : null,\n    ),\n    onTap: () {      // 增加如下 9 行代码...\n      setState(() {\n        if (alreadySaved) {\n          _saved.remove(pair);\n        } else { \n          _saved.add(pair); \n        } \n      });\n    },               // ... 一直到这里\n  );\n}\n```\n> 提示: 在 Flutter 的响应式风格的框架中，调用 setState() 会为 State 对象触发 build() 方法，从而导致对 UI 的更新\n\n热重载应用，你就可以点击任何一行测试收藏或取消收藏功能，你的点击同时自带 Material Design 里的水波动画特效。\n\n![](img/12_2.png)\n\n## 导航到新页面\n\n在这一步中，您将添加一个显示收藏夹内容的新页面（在 Flutter 中称为路由［route］）。您将学习如何在主路由和新路由之间导航（切换页面）。\n\n在 Flutter 中，导航器管理应用程序的路由栈。将路由推入（push）到导航器的栈中，将会显示更新为该路由页面。 从导航器的栈中弹出（pop）路由，将显示返回到前一个路由。\n\n接下来，我们在 RandomWordsState 的 build 方法中为 AppBar 添加一个列表图标。当用户点击列表图标时，包含收藏夹的新路由页面入栈显示。\n\n1. 将该图标及其相应的操作添加到 build 方法中：\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  ...\n  @override\n  Widget build(BuildContext context) {\n    return new Scaffold(\n      appBar: new AppBar(\n        title: new Text('Startup Name Generator'),\n        actions: <Widget>[      // 新增代码开始 ...\n          new IconButton(icon: const Icon(Icons.list), onPressed: _pushSaved),\n        ],                      // ... 代码新增结束\n      ),\n      body: _buildSuggestions(),\n    );\n  }\n  ...\n}\n```\n> 提示: 某些 widget 属性需要单个 widget（child），而其它一些属性，如 action，需要一组widgets（children），用方括号 [] 表示。\n\n2. 在 RandomWordsState 这个类里添加 _pushSaved() 方法：\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  ...\n  // 新增代码开始\n  void _pushSaved() {\n  }\n  // 新增代码结束 \n}\n```\n3. 热重载应用，列表图标（）将会出现在导航栏中。现在点击它不会有任何反应，因为 _pushSaved 函数还是空的。\n\n接下来，（当用户点击导航栏中的列表图标时）我们会建立一个路由并将其推入到导航管理器栈中。此操作会切换页面以显示新路由，新页面的内容会在 MaterialPageRoute 的 builder 属性中构建，builder 是一个匿名函数。\n\n4. 添加 Navigator.push 调用，这会使路由入栈（以后路由入栈均指推入到导航管理器的栈）\n```dart\nvoid _pushSaved() {\n  Navigator.of(context).push(\n  );\n}\n```\n接下来，添加 MaterialPageRoute 及其 builder。 现在，添加生成 ListTile 行的代码，ListTile 的 divideTiles() 方法在每个 ListTile 之间添加 1 像素的分割线。 该 divided 变量持有最终的列表项，并通过 toList()方法非常方便的转换成列表显示。\n\n5. 添加如下所示的代码：\n```dart\nvoid _pushSaved() {\n  Navigator.of(context).push(\n    new MaterialPageRoute<void>(   // 新增如下20行代码 ...\n      builder: (BuildContext context) {\n        final Iterable<ListTile> tiles = _saved.map(\n          (WordPair pair) {\n            return new ListTile(\n              title: new Text(\n                pair.asPascalCase,\n                style: _biggerFont,\n              ),\n            );\n          },\n        );\n        final List<Widget> divided = ListTile\n          .divideTiles(\n            context: context,\n            tiles: tiles,\n          )\n          .toList();\n      },\n    ),                           // ... 新增代码结束\n  );\n}\n```\nbuilder 返回一个 Scaffold，其中包含名为\"Saved Suggestions\"的新路由的应用栏。新路由的body 由包含 ListTiles 行的 ListView 组成；每行之间通过一个分隔线分隔。\n\n6. 添加水平分隔符，如下代码所示：\n```dart\nvoid _pushSaved() {\n  Navigator.of(context).push(\n    new MaterialPageRoute<void>(\n      builder: (BuildContext context) {\n        final Iterable<ListTile> tiles = _saved.map(\n          (WordPair pair) {\n            return new ListTile(\n              title: new Text(\n                pair.asPascalCase,\n                style: _biggerFont,\n              ),\n            );\n          },\n        );\n        final List<Widget> divided = ListTile\n          .divideTiles(\n            context: context,\n            tiles: tiles,\n          )\n              .toList();\n\n        return new Scaffold(         // 新增 6 行代码开始 ...\n          appBar: new AppBar(\n            title: const Text('Saved Suggestions'),\n          ),\n          body: new ListView(children: divided),\n        );                           // ... 新增代码段结束.\n      },\n    ),\n  );\n}\n```\n7. 热重载应用程序，点击列表项收藏一些项，点击列表图标，在新的 route（路由）页面中显示收藏的内容。Navigator（导航器）会在应用栏中自动添加一个\"返回\"按钮，无需调用Navigator.pop，点击后退按钮就会返回到主页路由。\n\n![](img/12_3.png)\n\n## 修改主题\n这一部分，我们将会一起修改应用的主题。Flutter 里我们使用 theme 来控制你应用的外观和风格，你可以使用默认主题，该主题取决于物理设备或模拟器，也可以自定义主题以适应您的品牌。\n\n你可以通过配置 ThemeData 类轻松更改应用程序的主题，目前我们的应用程序使用默认主题，下面将更改 primaryColor 颜色为白色。\n\n1. 在 MyApp 这个类里修改颜色：\n```dart\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n      title: 'Startup Name Generator',\n      theme: new ThemeData(          // 新增代码开始... \n        primaryColor: Colors.white,\n      ),                             // ... 代码新增结束\n      home: new RandomWords(),\n    );\n  }\n}\n```\n2. 热重载应用。 你会发现，整个背景将会变为白色，包括 app bar（应用栏）。\n\n一个小练习，你可以看一下 [ThemeData](https://docs.flutter.io/flutter/material/ThemeData-class.html) 的文档，添加其他属性来更多改变 UI 样式。Material library 中的 Colors 类提供了许多可以使用的颜色常量， 你可以使用热重载来快速简单地尝试、实验。","source":"_posts/flutter/12_第一个Flutter应用.md","raw":"---\ntitle: 第一个Flutter应用\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-19 12:14:00   \n---\n## 使用 package\n在这一步中，你将开始使用一个名为 english_words 的开源软件包，其中包含数千个最常用的英文单词以及一些实用功能。\n\n你可以 在 [pub.dartlang.org](https://pub.dartlang.org/flutter/) 上找到 english_words 软件包以及其他许多开源软件包。\n\n1. pubspec 文件管理 Flutter 应用程序的 assets（资源，如图片、package等）。 在pubspec.yaml 中，将 english_words（3.1.0或更高版本）添加到依赖项列表，如下面高亮显示的行：\n```dart\ndependencies:\n  flutter:\n    sdk: flutter\n\n  cupertino_icons: ^0.1.0\n  english_words: ^3.1.0   # 新增了这一行\n```\n2. 在Android Studio 的编辑器视图中查看 pubspec 时，单击右上角的 `Packages get`，这会将依赖包安装到您的项目。您可以在控制台中看到以下内容：\n\n```shell\nflutter packages get\nRunning \"flutter packages get\" in startup_namer...\nProcess finished with exit code 0\n```\n3. 在 lib/main.dart 中引入，如下所示：\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:english_words/english_words.dart';  // 新增了这一行\n```\n在您输入时，Android Studio会为您提供有关库导入的建议。然后它将呈现灰色的导入字符串，让您知道导入的库截至目前尚未被使用。\n\n接下来，我们使用 English words 包生成文本来替换字符串\"Hello World\"：\n\n我们需要进行如下更改：\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:english_words/english_words.dart';\n\nvoid main() => runApp(new MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final wordPair = new WordPair.random(); // 新增了这一行\n    return new MaterialApp(\n      title: 'Welcome to Flutter',\n      home: new Scaffold(\n        appBar: new AppBar(\n          title: new Text('Welcome to Flutter'),\n        ),\n        body: new Center(    // 这里把之前的 \"const\" 换成了 \"new\".\n          //child: const Text('Hello World'),   // 我们不用这样的方式生成文字了\n          child: new Text(wordPair.asPascalCase),  // 这是新的文字生成方式\n        ),\n      ),\n    );\n  }\n}\n```\n> 提示：「大驼峰式命名法」也称为 upper camel case 或 Pascal case，表示字符串中的每个单词（包括第一个单词）都以大写字母开头。所以，uppercamelcase 会变成 UpperCamelCase。\n\n4. 如果你没有把 Center 前面的修饰词从 const 改成 new 的话，系统就会报错，因为这个时候它的子对象已经不是常量，那就不能再用 const 了，所以这里 Center 和 Text 都需要使用 new 创建新的实例。\n\n## 添加一个 Stateful widget\n\nStateless widgets 是不可变的，这意味着它们的属性不能改变——所有的值都是 final。\n\nStateful widgets 持有的状态可能在 widget 生命周期中发生变化，实现一个 stateful widget 至少需要两个类：1）一个 StatefulWidget 类；2）一个 State 类，StatefulWidget 类本身是不变的，但是 State 类在 widget 生命周期中始终存在。\n\n在这一步，你将添加一个 stateful widget（有状态的控件）—— RandomWords，它会创建自己的状态类 —— RandomWordsState，然后你需要将 RandomWords 内嵌到已有的无状态的 MyApp widget。\n\n1. 创建一个最简的 state 类，这个类可以在任意地方创建而不一定非要在 MyApp 里，我们的示例代码是放在 MyApp 类的最下面了：\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  // TODO Add build method\n}\n```\n> 注意一下 State<RandomWords> 的声明。这表明我们在使用专门用于 RandomWords 的 State 泛型类。应用的大部分逻辑和状态都在这里 —— 它会维护 RandomWords 控件的状态。这个类会保存代码生成的单词对，这个单词对列表会随着用户滑动而无限增长，另外还会保存用户喜爱的单词对（第二部分），也即当用户点击爱心图标的时候会从喜爱的列表中添加或者移除当前单词对。\n\nRandomWordsState 继承自 RandomWords，我们接下来会创建这个类。\n\n2. 添加有状态的 RandomWords widget 到 main.dart，RandomWords widget 除了创建 State 类之外几乎没有其他任何东西：\n```dart\nclass RandomWords extends StatefulWidget {\n  @override\n  RandomWordsState createState() => new RandomWordsState();\n}\n```\n在添加状态类后，IDE 会提示该类缺少 build 方法。接下来，您将添加一个基本的 build 方法，该方法通过将生成单词对的代码从 MyApp 移动到 RandomWordsState 来生成单词对。\n\n3. 将 build 方法添加到 RandomWordState 中，如下所示：\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  @override                                  // 新增代码片段 - 开始 ... \n  Widget build(BuildContext context) {\n    final WordPair wordPair = new WordPair.random();\n    return new Text(wordPair.asPascalCase);\n  }                                          // ... 新增的代码片段 - 结束\n}\n```\n4. 如下所示，删除 MyApp 里生成文字的代码：\n\n```dart\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final WordPair wordPair = new WordPair.random();  // 删掉本行\n    return new MaterialApp(\n      title: 'Welcome to Flutter',\n      home: new Scaffold(\n        appBar: new AppBar(\n          title: new Text('Welcome to Flutter'),\n        ),\n        body: new Center(\n          //child: new Text(wordPair.asPascalCase), // 修改本行内容 \n          child: new RandomWords(),                 // 修改成本行代码\n        ),\n      ),\n    );\n  }\n}\n```\n5. 热重载（Hot reload）当前的工程，应用应该像之前一样运行，每次热重载或保存应用程序时都会显示一个单词对。\n\n> 提示: 如果您尝试热重载，则可能会看到一条警告，考虑重新启动当前应用：\n>  ```shell\n>  Reloading...\n>  Not all changed program elements ran during view reassembly; consider restarting.\n>    ```\n>    因为重启应用之后就可以生效，故这可能是误报。\n\n## 创建一个无限滚动的 ListView\n在这一步中，您将扩展（继承）RandomWordsState 类，以生成并显示单词对列表。 当用户滚动时，ListView 中显示的列表将无限增长。 ListView 的 builder 工厂构造函数允许您按需建立一个懒加载的列表视图。\n\n1. 向 RandomWordsState 类中添加一个 _suggestions 列表以保存建议的单词对，同时，添加一个 biggerFont 变量来增大字体大小 Also, add a _biggerFont variable for making the font size larger.\n\n> 提示：在 Dart 语言中使用下划线前缀标识符，会强制其变成私有。\n\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  // 添加如下两行\n  final List<WordPair> _suggestions = <WordPair>[];\n  final TextStyle _biggerFont = const TextStyle(fontSize: 18.0); \n  ...\n}\n```\n接下来，我们将向 RandomWordsState 类添加一个 _buildSuggestions() 函数，此方法构建显示建议单词对的 ListView。\n\nListView 类提供了一个 builder 属性，itemBuilder 值是一个匿名回调函数， 接受两个参数- BuildContext 和行迭代器 i。迭代器从 0 开始， 每调用一次该函数，i 就会自增 1，对于每个建议的单词对都会执行一次。该模型允许建议的单词对列表在用户滚动时无限增长。\n\n2. 向 RandomWordsState 类添加 _buildSuggestions() 函数，内容如下：\n```dart\n  Widget _buildSuggestions() {\n    return new ListView.builder(\n      padding: const EdgeInsets.all(16.0),\n\n      // 对于每个建议的单词对都会调用一次 itemBuilder，\n      // 然后将单词对添加到 ListTile 行中\n      // 在偶数行，该函数会为单词对添加一个 ListTile row.\n      // 在奇数行，该函数会添加一个分割线的 widget，来分隔相邻的词对。\n      // 注意，在小屏幕上，分割线看起来可能比较吃力。\n\n      itemBuilder: (BuildContext _context, int i) {\n        // 在每一列之前，添加一个1像素高的分隔线widget\n        if (i.isOdd) {\n          return new Divider();\n        }\n\n        // 语法 \"i ~/ 2\" 表示i除以2，但返回值是整形（向下取整）\n        // 比如 i 为：1, 2, 3, 4, 5 时，结果为 0, 1, 1, 2, 2，\n        // 这可以计算出 ListView 中减去分隔线后的实际单词对数量\n        final int index = i ~/ 2;\n        // 如果是建议列表中最后一个单词对\n        if (index >= _suggestions.length) {\n        // ...接着再生成10个单词对，然后添加到建议列表\n          _suggestions.addAll(generateWordPairs().take(10));\n        }\n        return _buildRow(_suggestions[index]);\n      }\n    );\n  }\n```\n对于每一个单词对，_buildSuggestions 函数都会调用一次 _buildRow。 这个函数在 ListTile 中显示每个新词对，这使您在下一步中可以生成更漂亮的显示行，详见本 codelab 的第二部分。\n\n3. 在 RandomWordsState 中添加 _buildRow 函数 :\n```dart\n  Widget _buildRow(WordPair pair) {\n    return new ListTile(\n      title: new Text(\n        pair.asPascalCase,\n        style: _biggerFont,\n      ),\n    );\n  }\n```\n4. 更新 RandomWordsState 的 build 方法以使用 _buildSuggestions()，而不是直接调用单词生成库，代码更改后如下：（使用 Scaffold 类实现基础的 Material Design 布局）\n```dart\n  @override\n  Widget build(BuildContext context) {\n    //final wordPair = new WordPair.random(); // 删掉 ... \n    //return new Text(wordPair.asPascalCase); // ... 这两行\n\n    return new Scaffold (                   // 代码从这里... \n      appBar: new AppBar(\n        title: new Text('Startup Name Generator'),\n      ),\n      body: _buildSuggestions(),\n    );                                      // ... 添加到这里\n  }\n```\n5. 更新 MyApp 的 build 方法, changing the title, and changing the home to be a RandomWords widget.\n```dart\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n      title: 'Startup Name Generator',\n      home: new RandomWords(),\n    );\n  }\n```\n6. 重新启动你的项目工程应用，你应该看到一个单词对列表。尽可能地向下滚动，你将继续看到新的单词对。\n![](img/12_1.png)\n\n## 向列表中添加图标\n在这部分，我们将为每一行添加一个心形的（收藏）图标，下一步你将能够为这个图标加入点击收藏的功能。\n\n1. 添加一个 _saved Set（集合）到 RandomWordsState，这个集合存储用户喜欢（收藏）的单词对。 在这里，Set 比 List 更合适，因为 Set 中不允许重复的值。\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  final List<WordPair> _suggestions = <WordPair>[];\n  final Set<WordPair> _saved = new Set<WordPair>();   // 新增本行\n  final TextStyle _biggerFont = const TextStyle(fontSize: 18.0);\n  ...\n}\n```\n2. 在 _buildRow 方法中添加 alreadySaved 来检查确保单词对还没有添加到收藏夹中。\n```dart\nWidget _buildRow(WordPair pair) {\n  final bool alreadySaved = _saved.contains(pair);  // 新增本行\n  ...\n}\n```\n同时在 _buildRow() 中， 添加一个心形 ❤️ 图标到 ListTiles以启用收藏功能。接下来，你就可以给心形 ❤️ 图标添加交互能力了。\n\n3. 向列表添加图标，如下所示：\n```dart\nWidget _buildRow(WordPair pair) {\n  final bool alreadySaved = _saved.contains(pair);\n  return new ListTile(\n    title: new Text(\n      pair.asPascalCase,\n      style: _biggerFont,\n    ),\n    trailing: new Icon(   // 新增代码开始 ...\n      alreadySaved ? Icons.favorite : Icons.favorite_border,\n      color: alreadySaved ? Colors.red : null,\n    ),                    // ... 新增代码结束\n  );\n}\n```\n4. 热重载应用，你现在可以在每一行看到心形 ❤️图标️，但它们还没有交互。\n\n## 添加交互\n在这部分，我们将为刚刚的心形 ❤️图标增加交互，当用户点击列表中的条目，切换其\"收藏\"状态，并将该词对添加到或移除出\"收藏夹\"。\n\n为了做到这个，我们在 _buildRow 中让心形 ❤️图标变得可以点击。如果单词条目已经添加到收藏夹中， 再次点击它将其从收藏夹中删除。当心形 ❤️图标被点击时，函数调用 setState() 通知框架状态已经改变。\n\n1. 增加 onTap 方法，如下所示：\n```dart\nWidget _buildRow(WordPair pair) {\n  final alreadySaved = _saved.contains(pair);\n  return new ListTile(\n    title: new Text(\n      pair.asPascalCase,\n      style: _biggerFont,\n    ),\n    trailing: new Icon(\n      alreadySaved ? Icons.favorite : Icons.favorite_border,\n      color: alreadySaved ? Colors.red : null,\n    ),\n    onTap: () {      // 增加如下 9 行代码...\n      setState(() {\n        if (alreadySaved) {\n          _saved.remove(pair);\n        } else { \n          _saved.add(pair); \n        } \n      });\n    },               // ... 一直到这里\n  );\n}\n```\n> 提示: 在 Flutter 的响应式风格的框架中，调用 setState() 会为 State 对象触发 build() 方法，从而导致对 UI 的更新\n\n热重载应用，你就可以点击任何一行测试收藏或取消收藏功能，你的点击同时自带 Material Design 里的水波动画特效。\n\n![](img/12_2.png)\n\n## 导航到新页面\n\n在这一步中，您将添加一个显示收藏夹内容的新页面（在 Flutter 中称为路由［route］）。您将学习如何在主路由和新路由之间导航（切换页面）。\n\n在 Flutter 中，导航器管理应用程序的路由栈。将路由推入（push）到导航器的栈中，将会显示更新为该路由页面。 从导航器的栈中弹出（pop）路由，将显示返回到前一个路由。\n\n接下来，我们在 RandomWordsState 的 build 方法中为 AppBar 添加一个列表图标。当用户点击列表图标时，包含收藏夹的新路由页面入栈显示。\n\n1. 将该图标及其相应的操作添加到 build 方法中：\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  ...\n  @override\n  Widget build(BuildContext context) {\n    return new Scaffold(\n      appBar: new AppBar(\n        title: new Text('Startup Name Generator'),\n        actions: <Widget>[      // 新增代码开始 ...\n          new IconButton(icon: const Icon(Icons.list), onPressed: _pushSaved),\n        ],                      // ... 代码新增结束\n      ),\n      body: _buildSuggestions(),\n    );\n  }\n  ...\n}\n```\n> 提示: 某些 widget 属性需要单个 widget（child），而其它一些属性，如 action，需要一组widgets（children），用方括号 [] 表示。\n\n2. 在 RandomWordsState 这个类里添加 _pushSaved() 方法：\n```dart\nclass RandomWordsState extends State<RandomWords> {\n  ...\n  // 新增代码开始\n  void _pushSaved() {\n  }\n  // 新增代码结束 \n}\n```\n3. 热重载应用，列表图标（）将会出现在导航栏中。现在点击它不会有任何反应，因为 _pushSaved 函数还是空的。\n\n接下来，（当用户点击导航栏中的列表图标时）我们会建立一个路由并将其推入到导航管理器栈中。此操作会切换页面以显示新路由，新页面的内容会在 MaterialPageRoute 的 builder 属性中构建，builder 是一个匿名函数。\n\n4. 添加 Navigator.push 调用，这会使路由入栈（以后路由入栈均指推入到导航管理器的栈）\n```dart\nvoid _pushSaved() {\n  Navigator.of(context).push(\n  );\n}\n```\n接下来，添加 MaterialPageRoute 及其 builder。 现在，添加生成 ListTile 行的代码，ListTile 的 divideTiles() 方法在每个 ListTile 之间添加 1 像素的分割线。 该 divided 变量持有最终的列表项，并通过 toList()方法非常方便的转换成列表显示。\n\n5. 添加如下所示的代码：\n```dart\nvoid _pushSaved() {\n  Navigator.of(context).push(\n    new MaterialPageRoute<void>(   // 新增如下20行代码 ...\n      builder: (BuildContext context) {\n        final Iterable<ListTile> tiles = _saved.map(\n          (WordPair pair) {\n            return new ListTile(\n              title: new Text(\n                pair.asPascalCase,\n                style: _biggerFont,\n              ),\n            );\n          },\n        );\n        final List<Widget> divided = ListTile\n          .divideTiles(\n            context: context,\n            tiles: tiles,\n          )\n          .toList();\n      },\n    ),                           // ... 新增代码结束\n  );\n}\n```\nbuilder 返回一个 Scaffold，其中包含名为\"Saved Suggestions\"的新路由的应用栏。新路由的body 由包含 ListTiles 行的 ListView 组成；每行之间通过一个分隔线分隔。\n\n6. 添加水平分隔符，如下代码所示：\n```dart\nvoid _pushSaved() {\n  Navigator.of(context).push(\n    new MaterialPageRoute<void>(\n      builder: (BuildContext context) {\n        final Iterable<ListTile> tiles = _saved.map(\n          (WordPair pair) {\n            return new ListTile(\n              title: new Text(\n                pair.asPascalCase,\n                style: _biggerFont,\n              ),\n            );\n          },\n        );\n        final List<Widget> divided = ListTile\n          .divideTiles(\n            context: context,\n            tiles: tiles,\n          )\n              .toList();\n\n        return new Scaffold(         // 新增 6 行代码开始 ...\n          appBar: new AppBar(\n            title: const Text('Saved Suggestions'),\n          ),\n          body: new ListView(children: divided),\n        );                           // ... 新增代码段结束.\n      },\n    ),\n  );\n}\n```\n7. 热重载应用程序，点击列表项收藏一些项，点击列表图标，在新的 route（路由）页面中显示收藏的内容。Navigator（导航器）会在应用栏中自动添加一个\"返回\"按钮，无需调用Navigator.pop，点击后退按钮就会返回到主页路由。\n\n![](img/12_3.png)\n\n## 修改主题\n这一部分，我们将会一起修改应用的主题。Flutter 里我们使用 theme 来控制你应用的外观和风格，你可以使用默认主题，该主题取决于物理设备或模拟器，也可以自定义主题以适应您的品牌。\n\n你可以通过配置 ThemeData 类轻松更改应用程序的主题，目前我们的应用程序使用默认主题，下面将更改 primaryColor 颜色为白色。\n\n1. 在 MyApp 这个类里修改颜色：\n```dart\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n      title: 'Startup Name Generator',\n      theme: new ThemeData(          // 新增代码开始... \n        primaryColor: Colors.white,\n      ),                             // ... 代码新增结束\n      home: new RandomWords(),\n    );\n  }\n}\n```\n2. 热重载应用。 你会发现，整个背景将会变为白色，包括 app bar（应用栏）。\n\n一个小练习，你可以看一下 [ThemeData](https://docs.flutter.io/flutter/material/ThemeData-class.html) 的文档，添加其他属性来更多改变 UI 样式。Material library 中的 Colors 类提供了许多可以使用的颜色常量， 你可以使用热重载来快速简单地尝试、实验。","slug":"flutter/12_第一个Flutter应用","published":1,"updated":"2019-10-02T10:32:41.812Z","layout":"post","photos":[],"link":"","_id":"ck19bvb34004500wkaumt47fb","content":"<h2 id=\"使用-package\"><a href=\"#使用-package\" class=\"headerlink\" title=\"使用 package\"></a>使用 package</h2><p>在这一步中，你将开始使用一个名为 english_words 的开源软件包，其中包含数千个最常用的英文单词以及一些实用功能。</p>\n<p>你可以 在 <a href=\"https://pub.dartlang.org/flutter/\" target=\"_blank\" rel=\"noopener\">pub.dartlang.org</a> 上找到 english_words 软件包以及其他许多开源软件包。</p>\n<ol>\n<li><p>pubspec 文件管理 Flutter 应用程序的 assets（资源，如图片、package等）。 在pubspec.yaml 中，将 english_words（3.1.0或更高版本）添加到依赖项列表，如下面高亮显示的行：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies:</span><br><span class=\"line\">  flutter:</span><br><span class=\"line\">    sdk: flutter</span><br><span class=\"line\"></span><br><span class=\"line\">  cupertino_icons: ^<span class=\"number\">0.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">  english_words: ^<span class=\"number\">3.1</span><span class=\"number\">.0</span>   # 新增了这一行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Android Studio 的编辑器视图中查看 pubspec 时，单击右上角的 <code>Packages get</code>，这会将依赖包安装到您的项目。您可以在控制台中看到以下内容：</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter packages get</span><br><span class=\"line\">Running \"flutter packages get\" in startup_namer...</span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在 lib/main.dart 中引入，如下所示：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:english_words/english_words.dart'</span>;  <span class=\"comment\">// 新增了这一行</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>在您输入时，Android Studio会为您提供有关库导入的建议。然后它将呈现灰色的导入字符串，让您知道导入的库截至目前尚未被使用。</p>\n<p>接下来，我们使用 English words 包生成文本来替换字符串”Hello World”：</p>\n<p>我们需要进行如下更改：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:english_words/english_words.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() =&gt; runApp(<span class=\"keyword\">new</span> MyApp());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> wordPair = <span class=\"keyword\">new</span> WordPair.random(); <span class=\"comment\">// 新增了这一行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Welcome to Flutter'</span>,</span><br><span class=\"line\">      home: <span class=\"keyword\">new</span> Scaffold(</span><br><span class=\"line\">        appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">          title: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Welcome to Flutter'</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: <span class=\"keyword\">new</span> Center(    <span class=\"comment\">// 这里把之前的 \"const\" 换成了 \"new\".</span></span><br><span class=\"line\">          <span class=\"comment\">//child: const Text('Hello World'),   // 我们不用这样的方式生成文字了</span></span><br><span class=\"line\">          child: <span class=\"keyword\">new</span> Text(wordPair.asPascalCase),  <span class=\"comment\">// 这是新的文字生成方式</span></span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>提示：「大驼峰式命名法」也称为 upper camel case 或 Pascal case，表示字符串中的每个单词（包括第一个单词）都以大写字母开头。所以，uppercamelcase 会变成 UpperCamelCase。</p>\n</blockquote>\n<ol start=\"4\">\n<li>如果你没有把 Center 前面的修饰词从 const 改成 new 的话，系统就会报错，因为这个时候它的子对象已经不是常量，那就不能再用 const 了，所以这里 Center 和 Text 都需要使用 new 创建新的实例。</li>\n</ol>\n<h2 id=\"添加一个-Stateful-widget\"><a href=\"#添加一个-Stateful-widget\" class=\"headerlink\" title=\"添加一个 Stateful widget\"></a>添加一个 Stateful widget</h2><p>Stateless widgets 是不可变的，这意味着它们的属性不能改变——所有的值都是 final。</p>\n<p>Stateful widgets 持有的状态可能在 widget 生命周期中发生变化，实现一个 stateful widget 至少需要两个类：1）一个 StatefulWidget 类；2）一个 State 类，StatefulWidget 类本身是不变的，但是 State 类在 widget 生命周期中始终存在。</p>\n<p>在这一步，你将添加一个 stateful widget（有状态的控件）—— RandomWords，它会创建自己的状态类 —— RandomWordsState，然后你需要将 RandomWords 内嵌到已有的无状态的 MyApp widget。</p>\n<ol>\n<li>创建一个最简的 state 类，这个类可以在任意地方创建而不一定非要在 MyApp 里，我们的示例代码是放在 MyApp 类的最下面了：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO Add build method</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>注意一下 State<randomwords> 的声明。这表明我们在使用专门用于 RandomWords 的 State 泛型类。应用的大部分逻辑和状态都在这里 —— 它会维护 RandomWords 控件的状态。这个类会保存代码生成的单词对，这个单词对列表会随着用户滑动而无限增长，另外还会保存用户喜爱的单词对（第二部分），也即当用户点击爱心图标的时候会从喜爱的列表中添加或者移除当前单词对。</randomwords></p>\n</blockquote>\n<p>RandomWordsState 继承自 RandomWords，我们接下来会创建这个类。</p>\n<ol start=\"2\">\n<li>添加有状态的 RandomWords widget 到 main.dart，RandomWords widget 除了创建 State 类之外几乎没有其他任何东西：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWords</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  RandomWordsState createState() =&gt; <span class=\"keyword\">new</span> RandomWordsState();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>在添加状态类后，IDE 会提示该类缺少 build 方法。接下来，您将添加一个基本的 build 方法，该方法通过将生成单词对的代码从 MyApp 移动到 RandomWordsState 来生成单词对。</p>\n<ol start=\"3\">\n<li><p>将 build 方法添加到 RandomWordState 中，如下所示：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span>                                  <span class=\"comment\">// 新增代码片段 - 开始 ... </span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> WordPair wordPair = <span class=\"keyword\">new</span> WordPair.random();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Text(wordPair.asPascalCase);</span><br><span class=\"line\">  &#125;                                          <span class=\"comment\">// ... 新增的代码片段 - 结束</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如下所示，删除 MyApp 里生成文字的代码：</p>\n</li>\n</ol>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> WordPair wordPair = <span class=\"keyword\">new</span> WordPair.random();  <span class=\"comment\">// 删掉本行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Welcome to Flutter'</span>,</span><br><span class=\"line\">      home: <span class=\"keyword\">new</span> Scaffold(</span><br><span class=\"line\">        appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">          title: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Welcome to Flutter'</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: <span class=\"keyword\">new</span> Center(</span><br><span class=\"line\">          <span class=\"comment\">//child: new Text(wordPair.asPascalCase), // 修改本行内容 </span></span><br><span class=\"line\">          child: <span class=\"keyword\">new</span> RandomWords(),                 <span class=\"comment\">// 修改成本行代码</span></span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>热重载（Hot reload）当前的工程，应用应该像之前一样运行，每次热重载或保存应用程序时都会显示一个单词对。</li>\n</ol>\n<blockquote>\n<p>提示: 如果您尝试热重载，则可能会看到一条警告，考虑重新启动当前应用：<br> <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span>  Reloading...</span><br><span class=\"line\"><span class=\"meta\">&gt;</span>  Not all changed program elements ran during view reassembly; consider restarting.</span><br><span class=\"line\"><span class=\"meta\">&gt;</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>   因为重启应用之后就可以生效，故这可能是误报。</p>\n</blockquote>\n<h2 id=\"创建一个无限滚动的-ListView\"><a href=\"#创建一个无限滚动的-ListView\" class=\"headerlink\" title=\"创建一个无限滚动的 ListView\"></a>创建一个无限滚动的 ListView</h2><p>在这一步中，您将扩展（继承）RandomWordsState 类，以生成并显示单词对列表。 当用户滚动时，ListView 中显示的列表将无限增长。 ListView 的 builder 工厂构造函数允许您按需建立一个懒加载的列表视图。</p>\n<ol>\n<li>向 RandomWordsState 类中添加一个 _suggestions 列表以保存建议的单词对，同时，添加一个 biggerFont 变量来增大字体大小 Also, add a _biggerFont variable for making the font size larger.</li>\n</ol>\n<blockquote>\n<p>提示：在 Dart 语言中使用下划线前缀标识符，会强制其变成私有。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 添加如下两行</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;WordPair&gt; _suggestions = &lt;WordPair&gt;[];</span><br><span class=\"line\">  <span class=\"keyword\">final</span> TextStyle _biggerFont = <span class=\"keyword\">const</span> TextStyle(fontSize: <span class=\"number\">18.0</span>); </span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们将向 RandomWordsState 类添加一个 _buildSuggestions() 函数，此方法构建显示建议单词对的 ListView。</p>\n<p>ListView 类提供了一个 builder 属性，itemBuilder 值是一个匿名回调函数， 接受两个参数- BuildContext 和行迭代器 i。迭代器从 0 开始， 每调用一次该函数，i 就会自增 1，对于每个建议的单词对都会执行一次。该模型允许建议的单词对列表在用户滚动时无限增长。</p>\n<ol start=\"2\">\n<li>向 RandomWordsState 类添加 _buildSuggestions() 函数，内容如下：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildSuggestions() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListView.builder(</span><br><span class=\"line\">    padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">16.0</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对于每个建议的单词对都会调用一次 itemBuilder，</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后将单词对添加到 ListTile 行中</span></span><br><span class=\"line\">    <span class=\"comment\">// 在偶数行，该函数会为单词对添加一个 ListTile row.</span></span><br><span class=\"line\">    <span class=\"comment\">// 在奇数行，该函数会添加一个分割线的 widget，来分隔相邻的词对。</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意，在小屏幕上，分割线看起来可能比较吃力。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    itemBuilder: (BuildContext _context, <span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在每一列之前，添加一个1像素高的分隔线widget</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i.isOdd) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Divider();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 语法 \"i ~/ 2\" 表示i除以2，但返回值是整形（向下取整）</span></span><br><span class=\"line\">      <span class=\"comment\">// 比如 i 为：1, 2, 3, 4, 5 时，结果为 0, 1, 1, 2, 2，</span></span><br><span class=\"line\">      <span class=\"comment\">// 这可以计算出 ListView 中减去分隔线后的实际单词对数量</span></span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> index = i ~/ <span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 如果是建议列表中最后一个单词对</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index &gt;= _suggestions.length) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...接着再生成10个单词对，然后添加到建议列表</span></span><br><span class=\"line\">        _suggestions.addAll(generateWordPairs().take(<span class=\"number\">10</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _buildRow(_suggestions[index]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>对于每一个单词对，_buildSuggestions 函数都会调用一次 _buildRow。 这个函数在 ListTile 中显示每个新词对，这使您在下一步中可以生成更漂亮的显示行，详见本 codelab 的第二部分。</p>\n<ol start=\"3\">\n<li><p>在 RandomWordsState 中添加 _buildRow 函数 :</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildRow(WordPair pair) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">    title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">      pair.asPascalCase,</span><br><span class=\"line\">      style: _biggerFont,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新 RandomWordsState 的 build 方法以使用 _buildSuggestions()，而不是直接调用单词生成库，代码更改后如下：（使用 Scaffold 类实现基础的 Material Design 布局）</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//final wordPair = new WordPair.random(); // 删掉 ... </span></span><br><span class=\"line\">  <span class=\"comment\">//return new Text(wordPair.asPascalCase); // ... 这两行</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Scaffold (                   <span class=\"comment\">// 代码从这里... </span></span><br><span class=\"line\">    appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">      title: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Startup Name Generator'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    body: _buildSuggestions(),</span><br><span class=\"line\">  );                                      <span class=\"comment\">// ... 添加到这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新 MyApp 的 build 方法, changing the title, and changing the home to be a RandomWords widget.</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">    title: <span class=\"string\">'Startup Name Generator'</span>,</span><br><span class=\"line\">    home: <span class=\"keyword\">new</span> RandomWords(),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新启动你的项目工程应用，你应该看到一个单词对列表。尽可能地向下滚动，你将继续看到新的单词对。<br><img src=\"img/12_1.png\" alt></p>\n</li>\n</ol>\n<h2 id=\"向列表中添加图标\"><a href=\"#向列表中添加图标\" class=\"headerlink\" title=\"向列表中添加图标\"></a>向列表中添加图标</h2><p>在这部分，我们将为每一行添加一个心形的（收藏）图标，下一步你将能够为这个图标加入点击收藏的功能。</p>\n<ol>\n<li><p>添加一个 _saved Set（集合）到 RandomWordsState，这个集合存储用户喜欢（收藏）的单词对。 在这里，Set 比 List 更合适，因为 Set 中不允许重复的值。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;WordPair&gt; _suggestions = &lt;WordPair&gt;[];</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">Set</span>&lt;WordPair&gt; _saved = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>&lt;WordPair&gt;();   <span class=\"comment\">// 新增本行</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> TextStyle _biggerFont = <span class=\"keyword\">const</span> TextStyle(fontSize: <span class=\"number\">18.0</span>);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 _buildRow 方法中添加 alreadySaved 来检查确保单词对还没有添加到收藏夹中。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildRow(WordPair pair) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">bool</span> alreadySaved = _saved.contains(pair);  <span class=\"comment\">// 新增本行</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>同时在 _buildRow() 中， 添加一个心形 ❤️ 图标到 ListTiles以启用收藏功能。接下来，你就可以给心形 ❤️ 图标添加交互能力了。</p>\n<ol start=\"3\">\n<li><p>向列表添加图标，如下所示：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildRow(WordPair pair) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">bool</span> alreadySaved = _saved.contains(pair);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">    title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">      pair.asPascalCase,</span><br><span class=\"line\">      style: _biggerFont,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    trailing: <span class=\"keyword\">new</span> Icon(   <span class=\"comment\">// 新增代码开始 ...</span></span><br><span class=\"line\">      alreadySaved ? Icons.favorite : Icons.favorite_border,</span><br><span class=\"line\">      color: alreadySaved ? Colors.red : <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    ),                    <span class=\"comment\">// ... 新增代码结束</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>热重载应用，你现在可以在每一行看到心形 ❤️图标️，但它们还没有交互。</p>\n</li>\n</ol>\n<h2 id=\"添加交互\"><a href=\"#添加交互\" class=\"headerlink\" title=\"添加交互\"></a>添加交互</h2><p>在这部分，我们将为刚刚的心形 ❤️图标增加交互，当用户点击列表中的条目，切换其”收藏”状态，并将该词对添加到或移除出”收藏夹”。</p>\n<p>为了做到这个，我们在 _buildRow 中让心形 ❤️图标变得可以点击。如果单词条目已经添加到收藏夹中， 再次点击它将其从收藏夹中删除。当心形 ❤️图标被点击时，函数调用 setState() 通知框架状态已经改变。</p>\n<ol>\n<li>增加 onTap 方法，如下所示：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildRow(WordPair pair) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> alreadySaved = _saved.contains(pair);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">    title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">      pair.asPascalCase,</span><br><span class=\"line\">      style: _biggerFont,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    trailing: <span class=\"keyword\">new</span> Icon(</span><br><span class=\"line\">      alreadySaved ? Icons.favorite : Icons.favorite_border,</span><br><span class=\"line\">      color: alreadySaved ? Colors.red : <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    onTap: () &#123;      <span class=\"comment\">// 增加如下 9 行代码...</span></span><br><span class=\"line\">      setState(() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (alreadySaved) &#123;</span><br><span class=\"line\">          _saved.remove(pair);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          _saved.add(pair); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,               <span class=\"comment\">// ... 一直到这里</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>提示: 在 Flutter 的响应式风格的框架中，调用 setState() 会为 State 对象触发 build() 方法，从而导致对 UI 的更新</p>\n</blockquote>\n<p>热重载应用，你就可以点击任何一行测试收藏或取消收藏功能，你的点击同时自带 Material Design 里的水波动画特效。</p>\n<p><img src=\"img/12_2.png\" alt></p>\n<h2 id=\"导航到新页面\"><a href=\"#导航到新页面\" class=\"headerlink\" title=\"导航到新页面\"></a>导航到新页面</h2><p>在这一步中，您将添加一个显示收藏夹内容的新页面（在 Flutter 中称为路由［route］）。您将学习如何在主路由和新路由之间导航（切换页面）。</p>\n<p>在 Flutter 中，导航器管理应用程序的路由栈。将路由推入（push）到导航器的栈中，将会显示更新为该路由页面。 从导航器的栈中弹出（pop）路由，将显示返回到前一个路由。</p>\n<p>接下来，我们在 RandomWordsState 的 build 方法中为 AppBar 添加一个列表图标。当用户点击列表图标时，包含收藏夹的新路由页面入栈显示。</p>\n<ol>\n<li>将该图标及其相应的操作添加到 build 方法中：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Scaffold(</span><br><span class=\"line\">      appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">        title: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Startup Name Generator'</span>),</span><br><span class=\"line\">        actions: &lt;Widget&gt;[      <span class=\"comment\">// 新增代码开始 ...</span></span><br><span class=\"line\">          <span class=\"keyword\">new</span> IconButton(icon: <span class=\"keyword\">const</span> Icon(Icons.list), onPressed: _pushSaved),</span><br><span class=\"line\">        ],                      <span class=\"comment\">// ... 代码新增结束</span></span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: _buildSuggestions(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>提示: 某些 widget 属性需要单个 widget（child），而其它一些属性，如 action，需要一组widgets（children），用方括号 [] 表示。</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>在 RandomWordsState 这个类里添加 _pushSaved() 方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 新增代码开始</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> _pushSaved() &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 新增代码结束 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>热重载应用，列表图标（）将会出现在导航栏中。现在点击它不会有任何反应，因为 _pushSaved 函数还是空的。</p>\n</li>\n</ol>\n<p>接下来，（当用户点击导航栏中的列表图标时）我们会建立一个路由并将其推入到导航管理器栈中。此操作会切换页面以显示新路由，新页面的内容会在 MaterialPageRoute 的 builder 属性中构建，builder 是一个匿名函数。</p>\n<ol start=\"4\">\n<li>添加 Navigator.push 调用，这会使路由入栈（以后路由入栈均指推入到导航管理器的栈）<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _pushSaved() &#123;</span><br><span class=\"line\">  Navigator.of(context).push(</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>接下来，添加 MaterialPageRoute 及其 builder。 现在，添加生成 ListTile 行的代码，ListTile 的 divideTiles() 方法在每个 ListTile 之间添加 1 像素的分割线。 该 divided 变量持有最终的列表项，并通过 toList()方法非常方便的转换成列表显示。</p>\n<ol start=\"5\">\n<li>添加如下所示的代码：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _pushSaved() &#123;</span><br><span class=\"line\">  Navigator.of(context).push(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MaterialPageRoute&lt;<span class=\"keyword\">void</span>&gt;(   <span class=\"comment\">// 新增如下20行代码 ...</span></span><br><span class=\"line\">      builder: (BuildContext context) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"built_in\">Iterable</span>&lt;ListTile&gt; tiles = _saved.map(</span><br><span class=\"line\">          (WordPair pair) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">              title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">                pair.asPascalCase,</span><br><span class=\"line\">                style: _biggerFont,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            );</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;Widget&gt; divided = ListTile</span><br><span class=\"line\">          .divideTiles(</span><br><span class=\"line\">            context: context,</span><br><span class=\"line\">            tiles: tiles,</span><br><span class=\"line\">          )</span><br><span class=\"line\">          .toList();</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ),                           <span class=\"comment\">// ... 新增代码结束</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>builder 返回一个 Scaffold，其中包含名为”Saved Suggestions”的新路由的应用栏。新路由的body 由包含 ListTiles 行的 ListView 组成；每行之间通过一个分隔线分隔。</p>\n<ol start=\"6\">\n<li><p>添加水平分隔符，如下代码所示：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _pushSaved() &#123;</span><br><span class=\"line\">  Navigator.of(context).push(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MaterialPageRoute&lt;<span class=\"keyword\">void</span>&gt;(</span><br><span class=\"line\">      builder: (BuildContext context) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"built_in\">Iterable</span>&lt;ListTile&gt; tiles = _saved.map(</span><br><span class=\"line\">          (WordPair pair) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">              title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">                pair.asPascalCase,</span><br><span class=\"line\">                style: _biggerFont,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            );</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;Widget&gt; divided = ListTile</span><br><span class=\"line\">          .divideTiles(</span><br><span class=\"line\">            context: context,</span><br><span class=\"line\">            tiles: tiles,</span><br><span class=\"line\">          )</span><br><span class=\"line\">              .toList();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Scaffold(         <span class=\"comment\">// 新增 6 行代码开始 ...</span></span><br><span class=\"line\">          appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">            title: <span class=\"keyword\">const</span> Text(<span class=\"string\">'Saved Suggestions'</span>),</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          body: <span class=\"keyword\">new</span> ListView(children: divided),</span><br><span class=\"line\">        );                           <span class=\"comment\">// ... 新增代码段结束.</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>热重载应用程序，点击列表项收藏一些项，点击列表图标，在新的 route（路由）页面中显示收藏的内容。Navigator（导航器）会在应用栏中自动添加一个”返回”按钮，无需调用Navigator.pop，点击后退按钮就会返回到主页路由。</p>\n</li>\n</ol>\n<p><img src=\"img/12_3.png\" alt></p>\n<h2 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h2><p>这一部分，我们将会一起修改应用的主题。Flutter 里我们使用 theme 来控制你应用的外观和风格，你可以使用默认主题，该主题取决于物理设备或模拟器，也可以自定义主题以适应您的品牌。</p>\n<p>你可以通过配置 ThemeData 类轻松更改应用程序的主题，目前我们的应用程序使用默认主题，下面将更改 primaryColor 颜色为白色。</p>\n<ol>\n<li><p>在 MyApp 这个类里修改颜色：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Startup Name Generator'</span>,</span><br><span class=\"line\">      theme: <span class=\"keyword\">new</span> ThemeData(          <span class=\"comment\">// 新增代码开始... </span></span><br><span class=\"line\">        primaryColor: Colors.white,</span><br><span class=\"line\">      ),                             <span class=\"comment\">// ... 代码新增结束</span></span><br><span class=\"line\">      home: <span class=\"keyword\">new</span> RandomWords(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>热重载应用。 你会发现，整个背景将会变为白色，包括 app bar（应用栏）。</p>\n</li>\n</ol>\n<p>一个小练习，你可以看一下 <a href=\"https://docs.flutter.io/flutter/material/ThemeData-class.html\" target=\"_blank\" rel=\"noopener\">ThemeData</a> 的文档，添加其他属性来更多改变 UI 样式。Material library 中的 Colors 类提供了许多可以使用的颜色常量， 你可以使用热重载来快速简单地尝试、实验。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用-package\"><a href=\"#使用-package\" class=\"headerlink\" title=\"使用 package\"></a>使用 package</h2><p>在这一步中，你将开始使用一个名为 english_words 的开源软件包，其中包含数千个最常用的英文单词以及一些实用功能。</p>\n<p>你可以 在 <a href=\"https://pub.dartlang.org/flutter/\" target=\"_blank\" rel=\"noopener\">pub.dartlang.org</a> 上找到 english_words 软件包以及其他许多开源软件包。</p>\n<ol>\n<li><p>pubspec 文件管理 Flutter 应用程序的 assets（资源，如图片、package等）。 在pubspec.yaml 中，将 english_words（3.1.0或更高版本）添加到依赖项列表，如下面高亮显示的行：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies:</span><br><span class=\"line\">  flutter:</span><br><span class=\"line\">    sdk: flutter</span><br><span class=\"line\"></span><br><span class=\"line\">  cupertino_icons: ^<span class=\"number\">0.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">  english_words: ^<span class=\"number\">3.1</span><span class=\"number\">.0</span>   # 新增了这一行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在Android Studio 的编辑器视图中查看 pubspec 时，单击右上角的 <code>Packages get</code>，这会将依赖包安装到您的项目。您可以在控制台中看到以下内容：</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter packages get</span><br><span class=\"line\">Running \"flutter packages get\" in startup_namer...</span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在 lib/main.dart 中引入，如下所示：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:english_words/english_words.dart'</span>;  <span class=\"comment\">// 新增了这一行</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>在您输入时，Android Studio会为您提供有关库导入的建议。然后它将呈现灰色的导入字符串，让您知道导入的库截至目前尚未被使用。</p>\n<p>接下来，我们使用 English words 包生成文本来替换字符串”Hello World”：</p>\n<p>我们需要进行如下更改：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:english_words/english_words.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() =&gt; runApp(<span class=\"keyword\">new</span> MyApp());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> wordPair = <span class=\"keyword\">new</span> WordPair.random(); <span class=\"comment\">// 新增了这一行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Welcome to Flutter'</span>,</span><br><span class=\"line\">      home: <span class=\"keyword\">new</span> Scaffold(</span><br><span class=\"line\">        appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">          title: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Welcome to Flutter'</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: <span class=\"keyword\">new</span> Center(    <span class=\"comment\">// 这里把之前的 \"const\" 换成了 \"new\".</span></span><br><span class=\"line\">          <span class=\"comment\">//child: const Text('Hello World'),   // 我们不用这样的方式生成文字了</span></span><br><span class=\"line\">          child: <span class=\"keyword\">new</span> Text(wordPair.asPascalCase),  <span class=\"comment\">// 这是新的文字生成方式</span></span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>提示：「大驼峰式命名法」也称为 upper camel case 或 Pascal case，表示字符串中的每个单词（包括第一个单词）都以大写字母开头。所以，uppercamelcase 会变成 UpperCamelCase。</p>\n</blockquote>\n<ol start=\"4\">\n<li>如果你没有把 Center 前面的修饰词从 const 改成 new 的话，系统就会报错，因为这个时候它的子对象已经不是常量，那就不能再用 const 了，所以这里 Center 和 Text 都需要使用 new 创建新的实例。</li>\n</ol>\n<h2 id=\"添加一个-Stateful-widget\"><a href=\"#添加一个-Stateful-widget\" class=\"headerlink\" title=\"添加一个 Stateful widget\"></a>添加一个 Stateful widget</h2><p>Stateless widgets 是不可变的，这意味着它们的属性不能改变——所有的值都是 final。</p>\n<p>Stateful widgets 持有的状态可能在 widget 生命周期中发生变化，实现一个 stateful widget 至少需要两个类：1）一个 StatefulWidget 类；2）一个 State 类，StatefulWidget 类本身是不变的，但是 State 类在 widget 生命周期中始终存在。</p>\n<p>在这一步，你将添加一个 stateful widget（有状态的控件）—— RandomWords，它会创建自己的状态类 —— RandomWordsState，然后你需要将 RandomWords 内嵌到已有的无状态的 MyApp widget。</p>\n<ol>\n<li>创建一个最简的 state 类，这个类可以在任意地方创建而不一定非要在 MyApp 里，我们的示例代码是放在 MyApp 类的最下面了：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO Add build method</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>注意一下 State<randomwords> 的声明。这表明我们在使用专门用于 RandomWords 的 State 泛型类。应用的大部分逻辑和状态都在这里 —— 它会维护 RandomWords 控件的状态。这个类会保存代码生成的单词对，这个单词对列表会随着用户滑动而无限增长，另外还会保存用户喜爱的单词对（第二部分），也即当用户点击爱心图标的时候会从喜爱的列表中添加或者移除当前单词对。</randomwords></p>\n</blockquote>\n<p>RandomWordsState 继承自 RandomWords，我们接下来会创建这个类。</p>\n<ol start=\"2\">\n<li>添加有状态的 RandomWords widget 到 main.dart，RandomWords widget 除了创建 State 类之外几乎没有其他任何东西：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWords</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  RandomWordsState createState() =&gt; <span class=\"keyword\">new</span> RandomWordsState();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>在添加状态类后，IDE 会提示该类缺少 build 方法。接下来，您将添加一个基本的 build 方法，该方法通过将生成单词对的代码从 MyApp 移动到 RandomWordsState 来生成单词对。</p>\n<ol start=\"3\">\n<li><p>将 build 方法添加到 RandomWordState 中，如下所示：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span>                                  <span class=\"comment\">// 新增代码片段 - 开始 ... </span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> WordPair wordPair = <span class=\"keyword\">new</span> WordPair.random();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Text(wordPair.asPascalCase);</span><br><span class=\"line\">  &#125;                                          <span class=\"comment\">// ... 新增的代码片段 - 结束</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如下所示，删除 MyApp 里生成文字的代码：</p>\n</li>\n</ol>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> WordPair wordPair = <span class=\"keyword\">new</span> WordPair.random();  <span class=\"comment\">// 删掉本行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Welcome to Flutter'</span>,</span><br><span class=\"line\">      home: <span class=\"keyword\">new</span> Scaffold(</span><br><span class=\"line\">        appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">          title: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Welcome to Flutter'</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: <span class=\"keyword\">new</span> Center(</span><br><span class=\"line\">          <span class=\"comment\">//child: new Text(wordPair.asPascalCase), // 修改本行内容 </span></span><br><span class=\"line\">          child: <span class=\"keyword\">new</span> RandomWords(),                 <span class=\"comment\">// 修改成本行代码</span></span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>热重载（Hot reload）当前的工程，应用应该像之前一样运行，每次热重载或保存应用程序时都会显示一个单词对。</li>\n</ol>\n<blockquote>\n<p>提示: 如果您尝试热重载，则可能会看到一条警告，考虑重新启动当前应用：<br> <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span>  Reloading...</span><br><span class=\"line\"><span class=\"meta\">&gt;</span>  Not all changed program elements ran during view reassembly; consider restarting.</span><br><span class=\"line\"><span class=\"meta\">&gt;</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>   因为重启应用之后就可以生效，故这可能是误报。</p>\n</blockquote>\n<h2 id=\"创建一个无限滚动的-ListView\"><a href=\"#创建一个无限滚动的-ListView\" class=\"headerlink\" title=\"创建一个无限滚动的 ListView\"></a>创建一个无限滚动的 ListView</h2><p>在这一步中，您将扩展（继承）RandomWordsState 类，以生成并显示单词对列表。 当用户滚动时，ListView 中显示的列表将无限增长。 ListView 的 builder 工厂构造函数允许您按需建立一个懒加载的列表视图。</p>\n<ol>\n<li>向 RandomWordsState 类中添加一个 _suggestions 列表以保存建议的单词对，同时，添加一个 biggerFont 变量来增大字体大小 Also, add a _biggerFont variable for making the font size larger.</li>\n</ol>\n<blockquote>\n<p>提示：在 Dart 语言中使用下划线前缀标识符，会强制其变成私有。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 添加如下两行</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;WordPair&gt; _suggestions = &lt;WordPair&gt;[];</span><br><span class=\"line\">  <span class=\"keyword\">final</span> TextStyle _biggerFont = <span class=\"keyword\">const</span> TextStyle(fontSize: <span class=\"number\">18.0</span>); </span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们将向 RandomWordsState 类添加一个 _buildSuggestions() 函数，此方法构建显示建议单词对的 ListView。</p>\n<p>ListView 类提供了一个 builder 属性，itemBuilder 值是一个匿名回调函数， 接受两个参数- BuildContext 和行迭代器 i。迭代器从 0 开始， 每调用一次该函数，i 就会自增 1，对于每个建议的单词对都会执行一次。该模型允许建议的单词对列表在用户滚动时无限增长。</p>\n<ol start=\"2\">\n<li>向 RandomWordsState 类添加 _buildSuggestions() 函数，内容如下：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildSuggestions() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListView.builder(</span><br><span class=\"line\">    padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">16.0</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对于每个建议的单词对都会调用一次 itemBuilder，</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后将单词对添加到 ListTile 行中</span></span><br><span class=\"line\">    <span class=\"comment\">// 在偶数行，该函数会为单词对添加一个 ListTile row.</span></span><br><span class=\"line\">    <span class=\"comment\">// 在奇数行，该函数会添加一个分割线的 widget，来分隔相邻的词对。</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意，在小屏幕上，分割线看起来可能比较吃力。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    itemBuilder: (BuildContext _context, <span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在每一列之前，添加一个1像素高的分隔线widget</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i.isOdd) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Divider();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 语法 \"i ~/ 2\" 表示i除以2，但返回值是整形（向下取整）</span></span><br><span class=\"line\">      <span class=\"comment\">// 比如 i 为：1, 2, 3, 4, 5 时，结果为 0, 1, 1, 2, 2，</span></span><br><span class=\"line\">      <span class=\"comment\">// 这可以计算出 ListView 中减去分隔线后的实际单词对数量</span></span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> index = i ~/ <span class=\"number\">2</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 如果是建议列表中最后一个单词对</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index &gt;= _suggestions.length) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...接着再生成10个单词对，然后添加到建议列表</span></span><br><span class=\"line\">        _suggestions.addAll(generateWordPairs().take(<span class=\"number\">10</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _buildRow(_suggestions[index]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>对于每一个单词对，_buildSuggestions 函数都会调用一次 _buildRow。 这个函数在 ListTile 中显示每个新词对，这使您在下一步中可以生成更漂亮的显示行，详见本 codelab 的第二部分。</p>\n<ol start=\"3\">\n<li><p>在 RandomWordsState 中添加 _buildRow 函数 :</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildRow(WordPair pair) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">    title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">      pair.asPascalCase,</span><br><span class=\"line\">      style: _biggerFont,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新 RandomWordsState 的 build 方法以使用 _buildSuggestions()，而不是直接调用单词生成库，代码更改后如下：（使用 Scaffold 类实现基础的 Material Design 布局）</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//final wordPair = new WordPair.random(); // 删掉 ... </span></span><br><span class=\"line\">  <span class=\"comment\">//return new Text(wordPair.asPascalCase); // ... 这两行</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Scaffold (                   <span class=\"comment\">// 代码从这里... </span></span><br><span class=\"line\">    appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">      title: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Startup Name Generator'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    body: _buildSuggestions(),</span><br><span class=\"line\">  );                                      <span class=\"comment\">// ... 添加到这里</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新 MyApp 的 build 方法, changing the title, and changing the home to be a RandomWords widget.</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">    title: <span class=\"string\">'Startup Name Generator'</span>,</span><br><span class=\"line\">    home: <span class=\"keyword\">new</span> RandomWords(),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新启动你的项目工程应用，你应该看到一个单词对列表。尽可能地向下滚动，你将继续看到新的单词对。<br><img src=\"img/12_1.png\" alt></p>\n</li>\n</ol>\n<h2 id=\"向列表中添加图标\"><a href=\"#向列表中添加图标\" class=\"headerlink\" title=\"向列表中添加图标\"></a>向列表中添加图标</h2><p>在这部分，我们将为每一行添加一个心形的（收藏）图标，下一步你将能够为这个图标加入点击收藏的功能。</p>\n<ol>\n<li><p>添加一个 _saved Set（集合）到 RandomWordsState，这个集合存储用户喜欢（收藏）的单词对。 在这里，Set 比 List 更合适，因为 Set 中不允许重复的值。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;WordPair&gt; _suggestions = &lt;WordPair&gt;[];</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">Set</span>&lt;WordPair&gt; _saved = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>&lt;WordPair&gt;();   <span class=\"comment\">// 新增本行</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> TextStyle _biggerFont = <span class=\"keyword\">const</span> TextStyle(fontSize: <span class=\"number\">18.0</span>);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 _buildRow 方法中添加 alreadySaved 来检查确保单词对还没有添加到收藏夹中。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildRow(WordPair pair) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">bool</span> alreadySaved = _saved.contains(pair);  <span class=\"comment\">// 新增本行</span></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>同时在 _buildRow() 中， 添加一个心形 ❤️ 图标到 ListTiles以启用收藏功能。接下来，你就可以给心形 ❤️ 图标添加交互能力了。</p>\n<ol start=\"3\">\n<li><p>向列表添加图标，如下所示：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildRow(WordPair pair) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">bool</span> alreadySaved = _saved.contains(pair);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">    title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">      pair.asPascalCase,</span><br><span class=\"line\">      style: _biggerFont,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    trailing: <span class=\"keyword\">new</span> Icon(   <span class=\"comment\">// 新增代码开始 ...</span></span><br><span class=\"line\">      alreadySaved ? Icons.favorite : Icons.favorite_border,</span><br><span class=\"line\">      color: alreadySaved ? Colors.red : <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    ),                    <span class=\"comment\">// ... 新增代码结束</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>热重载应用，你现在可以在每一行看到心形 ❤️图标️，但它们还没有交互。</p>\n</li>\n</ol>\n<h2 id=\"添加交互\"><a href=\"#添加交互\" class=\"headerlink\" title=\"添加交互\"></a>添加交互</h2><p>在这部分，我们将为刚刚的心形 ❤️图标增加交互，当用户点击列表中的条目，切换其”收藏”状态，并将该词对添加到或移除出”收藏夹”。</p>\n<p>为了做到这个，我们在 _buildRow 中让心形 ❤️图标变得可以点击。如果单词条目已经添加到收藏夹中， 再次点击它将其从收藏夹中删除。当心形 ❤️图标被点击时，函数调用 setState() 通知框架状态已经改变。</p>\n<ol>\n<li>增加 onTap 方法，如下所示：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget _buildRow(WordPair pair) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> alreadySaved = _saved.contains(pair);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">    title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">      pair.asPascalCase,</span><br><span class=\"line\">      style: _biggerFont,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    trailing: <span class=\"keyword\">new</span> Icon(</span><br><span class=\"line\">      alreadySaved ? Icons.favorite : Icons.favorite_border,</span><br><span class=\"line\">      color: alreadySaved ? Colors.red : <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    onTap: () &#123;      <span class=\"comment\">// 增加如下 9 行代码...</span></span><br><span class=\"line\">      setState(() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (alreadySaved) &#123;</span><br><span class=\"line\">          _saved.remove(pair);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">          _saved.add(pair); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,               <span class=\"comment\">// ... 一直到这里</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>提示: 在 Flutter 的响应式风格的框架中，调用 setState() 会为 State 对象触发 build() 方法，从而导致对 UI 的更新</p>\n</blockquote>\n<p>热重载应用，你就可以点击任何一行测试收藏或取消收藏功能，你的点击同时自带 Material Design 里的水波动画特效。</p>\n<p><img src=\"img/12_2.png\" alt></p>\n<h2 id=\"导航到新页面\"><a href=\"#导航到新页面\" class=\"headerlink\" title=\"导航到新页面\"></a>导航到新页面</h2><p>在这一步中，您将添加一个显示收藏夹内容的新页面（在 Flutter 中称为路由［route］）。您将学习如何在主路由和新路由之间导航（切换页面）。</p>\n<p>在 Flutter 中，导航器管理应用程序的路由栈。将路由推入（push）到导航器的栈中，将会显示更新为该路由页面。 从导航器的栈中弹出（pop）路由，将显示返回到前一个路由。</p>\n<p>接下来，我们在 RandomWordsState 的 build 方法中为 AppBar 添加一个列表图标。当用户点击列表图标时，包含收藏夹的新路由页面入栈显示。</p>\n<ol>\n<li>将该图标及其相应的操作添加到 build 方法中：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Scaffold(</span><br><span class=\"line\">      appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">        title: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Startup Name Generator'</span>),</span><br><span class=\"line\">        actions: &lt;Widget&gt;[      <span class=\"comment\">// 新增代码开始 ...</span></span><br><span class=\"line\">          <span class=\"keyword\">new</span> IconButton(icon: <span class=\"keyword\">const</span> Icon(Icons.list), onPressed: _pushSaved),</span><br><span class=\"line\">        ],                      <span class=\"comment\">// ... 代码新增结束</span></span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: _buildSuggestions(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>提示: 某些 widget 属性需要单个 widget（child），而其它一些属性，如 action，需要一组widgets（children），用方括号 [] 表示。</p>\n</blockquote>\n<ol start=\"2\">\n<li><p>在 RandomWordsState 这个类里添加 _pushSaved() 方法：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWordsState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">RandomWords</span>&gt; </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 新增代码开始</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> _pushSaved() &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 新增代码结束 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>热重载应用，列表图标（）将会出现在导航栏中。现在点击它不会有任何反应，因为 _pushSaved 函数还是空的。</p>\n</li>\n</ol>\n<p>接下来，（当用户点击导航栏中的列表图标时）我们会建立一个路由并将其推入到导航管理器栈中。此操作会切换页面以显示新路由，新页面的内容会在 MaterialPageRoute 的 builder 属性中构建，builder 是一个匿名函数。</p>\n<ol start=\"4\">\n<li>添加 Navigator.push 调用，这会使路由入栈（以后路由入栈均指推入到导航管理器的栈）<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _pushSaved() &#123;</span><br><span class=\"line\">  Navigator.of(context).push(</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>接下来，添加 MaterialPageRoute 及其 builder。 现在，添加生成 ListTile 行的代码，ListTile 的 divideTiles() 方法在每个 ListTile 之间添加 1 像素的分割线。 该 divided 变量持有最终的列表项，并通过 toList()方法非常方便的转换成列表显示。</p>\n<ol start=\"5\">\n<li>添加如下所示的代码：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _pushSaved() &#123;</span><br><span class=\"line\">  Navigator.of(context).push(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MaterialPageRoute&lt;<span class=\"keyword\">void</span>&gt;(   <span class=\"comment\">// 新增如下20行代码 ...</span></span><br><span class=\"line\">      builder: (BuildContext context) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"built_in\">Iterable</span>&lt;ListTile&gt; tiles = _saved.map(</span><br><span class=\"line\">          (WordPair pair) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">              title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">                pair.asPascalCase,</span><br><span class=\"line\">                style: _biggerFont,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            );</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;Widget&gt; divided = ListTile</span><br><span class=\"line\">          .divideTiles(</span><br><span class=\"line\">            context: context,</span><br><span class=\"line\">            tiles: tiles,</span><br><span class=\"line\">          )</span><br><span class=\"line\">          .toList();</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ),                           <span class=\"comment\">// ... 新增代码结束</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>builder 返回一个 Scaffold，其中包含名为”Saved Suggestions”的新路由的应用栏。新路由的body 由包含 ListTiles 行的 ListView 组成；每行之间通过一个分隔线分隔。</p>\n<ol start=\"6\">\n<li><p>添加水平分隔符，如下代码所示：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _pushSaved() &#123;</span><br><span class=\"line\">  Navigator.of(context).push(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MaterialPageRoute&lt;<span class=\"keyword\">void</span>&gt;(</span><br><span class=\"line\">      builder: (BuildContext context) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"built_in\">Iterable</span>&lt;ListTile&gt; tiles = _saved.map(</span><br><span class=\"line\">          (WordPair pair) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListTile(</span><br><span class=\"line\">              title: <span class=\"keyword\">new</span> Text(</span><br><span class=\"line\">                pair.asPascalCase,</span><br><span class=\"line\">                style: _biggerFont,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            );</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;Widget&gt; divided = ListTile</span><br><span class=\"line\">          .divideTiles(</span><br><span class=\"line\">            context: context,</span><br><span class=\"line\">            tiles: tiles,</span><br><span class=\"line\">          )</span><br><span class=\"line\">              .toList();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Scaffold(         <span class=\"comment\">// 新增 6 行代码开始 ...</span></span><br><span class=\"line\">          appBar: <span class=\"keyword\">new</span> AppBar(</span><br><span class=\"line\">            title: <span class=\"keyword\">const</span> Text(<span class=\"string\">'Saved Suggestions'</span>),</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          body: <span class=\"keyword\">new</span> ListView(children: divided),</span><br><span class=\"line\">        );                           <span class=\"comment\">// ... 新增代码段结束.</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>热重载应用程序，点击列表项收藏一些项，点击列表图标，在新的 route（路由）页面中显示收藏的内容。Navigator（导航器）会在应用栏中自动添加一个”返回”按钮，无需调用Navigator.pop，点击后退按钮就会返回到主页路由。</p>\n</li>\n</ol>\n<p><img src=\"img/12_3.png\" alt></p>\n<h2 id=\"修改主题\"><a href=\"#修改主题\" class=\"headerlink\" title=\"修改主题\"></a>修改主题</h2><p>这一部分，我们将会一起修改应用的主题。Flutter 里我们使用 theme 来控制你应用的外观和风格，你可以使用默认主题，该主题取决于物理设备或模拟器，也可以自定义主题以适应您的品牌。</p>\n<p>你可以通过配置 ThemeData 类轻松更改应用程序的主题，目前我们的应用程序使用默认主题，下面将更改 primaryColor 颜色为白色。</p>\n<ol>\n<li><p>在 MyApp 这个类里修改颜色：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Startup Name Generator'</span>,</span><br><span class=\"line\">      theme: <span class=\"keyword\">new</span> ThemeData(          <span class=\"comment\">// 新增代码开始... </span></span><br><span class=\"line\">        primaryColor: Colors.white,</span><br><span class=\"line\">      ),                             <span class=\"comment\">// ... 代码新增结束</span></span><br><span class=\"line\">      home: <span class=\"keyword\">new</span> RandomWords(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>热重载应用。 你会发现，整个背景将会变为白色，包括 app bar（应用栏）。</p>\n</li>\n</ol>\n<p>一个小练习，你可以看一下 <a href=\"https://docs.flutter.io/flutter/material/ThemeData-class.html\" target=\"_blank\" rel=\"noopener\">ThemeData</a> 的文档，添加其他属性来更多改变 UI 样式。Material library 中的 Colors 类提供了许多可以使用的颜色常量， 你可以使用热重载来快速简单地尝试、实验。</p>\n"},{"title":"Dart类","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-18T11:24:00.000Z","_content":">Dart是一种面向对象的语言，具有类和基于mixin的继承。每个对象都是一个类的实例，所有的类都是Object的子类。基于mixin的继承意味着，尽管每个类(除了Object)都只有一个超类，但类主体可以在多个类层次结构中重用。\n##基础\n### 使用类的成员（变量和方法）\n```Dart\nvar p = Point(2, 2);\n// 设置实例变量的值 y.\np.y = 3;\n// 为避免最左操作数为空时出现异常，使用 ?.代替.\np?.y = 4;\n// 获取变量的值\nassert(p.y == 3);\n// 调用方法\nnum distance = p.distanceTo(Point(4, 4));\n\n```\n\n### 使用构造函数\n您可以使用构造函数创建一个对象。构造函数名可以是ClassName或ClassName.identifier。\n```Dart\nvar p1 = Point(2, 2);\nvar p2 = Point.fromJson({'x': 1, 'y': 2});\n\n// 下面的代码具有相同的效果，但是在构造函数名之前使用可选的new关键字\n// 在Dart2中new关键字为可选关键字\nvar p1 = new Point(2, 2);\nvar p2 = new Point.fromJson({'x': 1, 'y': 2});\n\n// 有些类提供常量构造函数。要使用常量构造函数创建编译时常量，请将const关键字放在构造函数名之前:\nvar p = const ImmutablePoint(2, 2);\n\n// 构造两个相同的编译时常量会生成一个单一的、规范的实例:\nvar a = const ImmutablePoint(1, 1);\nvar b = const ImmutablePoint(1, 1);\nassert(identical(a, b)); // They are the same instance!\n\n\n// 在常量上下文中，可以在构造函数或文字之前省略const。例如，看看这个代码，它创建了一个const的 map集合:\nconst pointAndLine = const {\n  'point': const [const ImmutablePoint(0, 0)],\n  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],\n};\n\n//除了第一次使用const关键字之外其他的const都可以省略：\nconst pointAndLine = {\n  'point': [ImmutablePoint(0, 0)],\n  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],\n};\n\n```\n### 获得对象的类型\n要在运行时获得对象类型，可以使用对象的runtimeType属性。\n\n```Dart\nprint('The type of a is ${a.runtimeType}');\n```\n\n### 实例变量\n```Dart\n// 所有未初始化的实例变量都具有null值。\nclass Point {\n  num x; // Declare instance variable x, initially null.\n  num y; // Declare y, initially null.\n  num z = 0; // Declare z, initially 0.\n}\n\n// 所有实例变量都生成隐式getter方法。非最终实例变量也生成隐式setter方法。\nclass Point {\n  // 如果在声明实例变量的地方(而不是在构造函数或方法中)初始化实例变量，则在创建实例时(在构造函数及其初始化列表执行之前)设置该值。\n  num x = 2;\n  num y;\n}\n\nvoid main() {\n  var point = Point();\n  point.x = 4; // Use the setter method for x.\n  assert(point.x == 4); // Use the getter method for x.\n  assert(point.y == null); // Values default to null.\n}\n\n```\n\n## 构造函数\n通过创建一个与类同名的函数来声明构造函数(另外，还可以像[命名构造函数]中描述的一样选择一个附加标识符)。构造函数最常见的应用形式是使用构造函数生成一个类的新实例：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(num x, num y) {\n    // There's a better way to do this, stay tuned.\n    this.x = x;\n    this.y = y;\n  }\n}\n```\nthis关键字是指当前实例。\n\n> 注意:只有在名称冲突时才使用它。否则，Dart的代码风格需要省略this\n\n使用构造函数的参数为实例复制的使用非常常见，Dart具有语法上的优势，使这种使用更容易实现：\n```Dart\nclass Point {\n  num x, y;\n\n  // Syntactic sugar for setting x and y\n  // before the constructor body runs.\n  Point(this.x, this.y);\n}\n```\n\n### 默认构造函数\n如果不声明构造函数，则为您提供默认构造函数。默认构造函数没有参数，并在超类中调用无参数构造函数。\n\n### 构造函数不是继承\n子类不从父类继承构造函数。没有声明构造函数的子类只有默认的构造函数（没有参数，没有名称）而不是从父类继承的构造函数。\n\n### 命名的构造函数\n使用命名构造函数可以在一个类中定义多个构造函数，或者让一个类的作用对于开发人员来说更清晰：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  // Named constructor\n  Point.origin() {\n    x = 0;\n    y = 0;\n  }\n}\n```\n一定要记住构造函数是不会从父类继承的，这意味着父类的命名构造函数子类也不会继承。如果你希望使用在超类中定义的命名构造函数来创建子类，则必须在子类中实现该构造函数。\n\n### 调用非默认的超类构造函数\n默认情况下，子类中的构造函数调用父类的未命名的无参数构造函数。父类的构造函数在构造函数体的开始处被调用。如果类中有使用初始化列表，初始化列表将在调用超类之前执行。综上所述，执行顺序如下:\n\n- 初始化列表\n- 超类中的无参数构造函数\n- main类中的无参数构造函数\n\n如果超类没有未命名的无参数构造函数，则必须手动调用超类中的一个构造函数。在冒号(:)之后，在构造函数体(如果有的话)之前指定超类构造函数。\n\n在下例中，Employee类的构造函数中调用了他的超类Person中的命名构造函数。\n```Dart\nclass Person {\n  String firstName;\n\n  Person.fromJson(Map data) {\n    print('in Person');\n  }\n}\n\nclass Employee extends Person {\n  // Person does not have a default constructor;\n  // you must call super.fromJson(data).\n  Employee.fromJson(Map data) : super.fromJson(data) {\n    print('in Employee');\n  }\n}\n\nmain() {\n  var emp = new Employee.fromJson({});\n\n  // Prints:\n  // in Person\n  // in Employee\n  if (emp is Person) {\n    // Type check\n    emp.firstName = 'Bob';\n  }\n  (emp as Person).firstName = 'Bob';\n}\n```\n```Shell\n///结果输出为\nin Person\nin Employee\n```\n因为父类构造函数的参数是在调用构造函数之前执行的，所以参数可以是表达式，比如函数调用:\n```Dart\nclass Employee extends Person {\n  Employee() : super.fromJson(getDefaultData());\n  // ···\n}\n```\n> 警告：在超类的构造函数的参数中不能使用this关键字。例如，参数可以调用static方法但是不能调用实例方法\n\n### 初始化列表\n除了调用超类构造函数之外，还可以在构造函数主体运行之前初始化实例变量。初始值设定项用逗号分开。\n```Dart\n// Initializer list sets instance variables before\n// the constructor body runs.\nPoint.fromJson(Map<String, num> json)\n    : x = json['x'],\n      y = json['y'] {\n  print('In Point.fromJson(): ($x, $y)');\n}\n```\n> 警告:初始化器的右边部分中无法访问this关键字。\n\n在开发期间，可以通过在初始化列表中使用assert来验证输入。\n```Dart\nPoint.withAssert(this.x, this.y) : assert(x >= 0) {\n  print('In Point.withAssert(): ($x, $y)');\n}\n```\n初始化列表在设置final字段时很方便。下面的示例初始化初始化列表中的三个final字段：\n\n```Dart\nimport 'dart:math';\n\nclass Point {\n  final num x;\n  final num y;\n  final num distanceFromOrigin;\n\n  Point(x, y)\n      : x = x,\n        y = y,\n        distanceFromOrigin = sqrt(x * x + y * y);\n}\n\nmain() {\n  var p = new Point(2, 3);\n  print(p.distanceFromOrigin);\n}\n```\n```Shell\n///运行结果\n3.605551275463989\n```\n### 重定向构造函数\n有时，构造函数的唯一目的是重定向到同一个类中的另一个构造函数。重定向构造函数的主体为空，构造函数调用出现在冒号(:)之后。\n```Dart\nclass Point {\n  num x, y;\n\n  // The main constructor for this class.\n  Point(this.x, this.y);\n\n  // Delegates to the main constructor.\n  Point.alongXAxis(num x) : this(x, 0);\n}\n```\n### 常量构造函数\n如果您的类生成的对象不会改变，您可以使这些对象成为编译时常量。为此，定义一个const构造函数，并确保所有实例变量都是final的。\n```Dart\nclass ImmutablePoint {\n  static final ImmutablePoint origin =\n      const ImmutablePoint(0, 0);\n\n  final num x, y;\n\n  const ImmutablePoint(this.x, this.y);\n}\n```\n### 工厂构造函数\n在实现构造函数时使用factory关键字，该构造函数并不总是创建类的新实例。例如，工厂构造函数可以从缓存返回实例，也可以返回子类型的实例。\n\n以下示例演示工厂构造函数从缓存返回对象:\n```Dart\nclass Logger {\n  final String name;\n  bool mute = false;\n\n  // _cache is library-private, thanks to\n  // the _ in front of its name.\n  static final Map<String, Logger> _cache =\n      <String, Logger>{};\n\n  factory Logger(String name) {\n    if (_cache.containsKey(name)) {\n      return _cache[name];\n    } else {\n      final logger = Logger._internal(name);\n      _cache[name] = logger;\n      return logger;\n    }\n  }\n\n  Logger._internal(this.name);\n\n  void log(String msg) {\n    if (!mute) print(msg);\n  }\n}\n```\n> 注意:工厂构造函数不能访问this关键字。\n\n调用工厂构造函数，就像调用其他构造函数一样:\n```Dart\nvar logger = Logger('UI');\nlogger.log('Button clicked');\n```\n\n## 方法\n> 方法是为对象提供行为的函数。\n\n### 实例方法\n对象上的实例方法可以访问实例变量。下面示例中的distanceTo()方法是一个实例方法的示例:\n```dart\nimport 'dart:math';\n\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  num distanceTo(Point other) {\n    var dx = x - other.x;\n    var dy = y - other.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n```\n### Getters 和 setters 方法\ngetter和setter是对对象属性的读写访问的特殊方法。回想一下，每个实例变量都有一个隐式的getter，如果需要的话还可以加上一个setter。使用get和set关键字来实现getter和setter方法可以来读写其他属性：\n```Dart\nclass Rectangle {\n  num left, top, width, height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  // Define two calculated properties: right and bottom.\n  num get right => left + width;\n  set right(num value) => left = value - width;\n  num get bottom => top + height;\n  set bottom(num value) => top = value - height;\n}\n\nvoid main() {\n  var rect = Rectangle(3, 4, 20, 15);\n  assert(rect.left == 3);\n  rect.right = 12;\n  assert(rect.left == -8);\n}\n```\n使用getter和setter，你可以使用方法包装实例变量，而无需改动业务代码。\n\n>注意:诸如increment(++)之类的操作符以预期的方式工作，无论getter是否被显式定义。为了避免任何意外的副作用，操作符只调用getter一次，将其值保存在一个临时变量中。\n\n### 抽象方法\n实例方法、getter和setter方法可以是抽象方法，之定义一个接口但是将具体实现留给其他类。抽象方法只能存在于抽象类中，抽象方法是没有方法体的。\n```dart\nabstract class Doer {\n  // Define instance variables and methods...\n\n  void doSomething(); // Define an abstract method.\n}\n\nclass EffectiveDoer extends Doer {\n  void doSomething() {\n    // Provide an implementation, so the method is not abstract here...\n  }\n}\n```\n调用抽象方法会导致运行时错误。\n\n## 抽象类\n使用abstract修饰符定义不能实例化的抽象类。抽象类对于定义接口非常有用。如果您希望抽象类看起来是可实例化的，请定义一个工厂构造函数。\n\n抽象类通常有抽象方法。这里有一个声明抽象类的例子，它有一个抽象的方法:\n```Dart\n// This class is declared abstract and thus\n// can't be instantiated.\nabstract class AbstractContainer {\n  // Define constructors, fields, methods...\n\n  void updateChildren(); // Abstract method.\n}\n```\n\n## 隐式接口\n每个类都隐式地定义一个接口，该接口包含类的所有实例成员及其实现的任何接口。如果您想创建一个类A，它支持类B的API而不继承B的实现，那么类A应该实现B接口。\n```Dart\n// A person. The implicit interface contains greet().\nclass Person {\n  // In the interface, but visible only in this library.\n  final _name;\n\n  // Not in the interface, since this is a constructor.\n  Person(this._name);\n\n  // In the interface.\n  String greet(String who) => 'Hello, $who. I am $_name.';\n}\n\n// An implementation of the Person interface.\nclass Impostor implements Person {\n  get _name => '';\n\n  String greet(String who) => 'Hi $who. Do you know who I am?';\n}\n\nString greetBob(Person person) => person.greet('Bob');\n\nvoid main() {\n  print(greetBob(Person('Kathy')));\n  print(greetBob(Impostor()));\n}\n```\n这里有一个例子，说明一个类实现多个接口:\n```Dart\nclass Point implements Comparable, Location {...}\n```\n\n## 继承\n使用extend创建子类，使用super引用超类:\n```Dart\nclass Television {\n  void turnOn() {\n    _illuminateDisplay();\n    _activateIrSensor();\n  }\n  // ···\n}\n\nclass SmartTelevision extends Television {\n  void turnOn() {\n    super.turnOn();\n    _bootNetworkInterface();\n    _initializeMemory();\n    _upgradeApps();\n  }\n  // ···\n}\n```\n\n## 重写类的成员\n子类可以覆盖实例方法、getter和setter。您可以使用@override注释来指示你重写了某个成员方法:\n```Dart\nclass SmartTelevision extends Television {\n  @override\n  void turnOn() {...}\n  // ···\n}\n```\n要在类型安全的代码中缩小方法参数或实例变量的类型，可以使用covariant关键字。\n\n### 重写操作符\n您可以重写下表中显示的操作符。例如，如果定义一个Vector类，可以定义一个+方法来让两个向量相加。\n\n`<`\t|`+`|\t`|`\t|`[]`\n--|--|--|--\n`>`\t|`/`|\t`^`|\t`[]=`\n`<=`|\t`~/`|\t`&`|\t`~`\n`>=`|\t`*`\t|`<<`|\t`==`\n`-`\t|`%`\t|`>>`|\n下例在类中重写了+和-操作符：\n```Dart\nclass Vector {\n  final int x, y;\n\n  Vector(this.x, this.y);\n\n  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);\n  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);\n\n  // Operator == and hashCode not shown. For details, see note below.\n  // ···\n}\n\nvoid main() {\n  final v = Vector(2, 3);\n  final w = Vector(2, 2);\n\n  assert(v + w == Vector(4, 5));\n  assert(v - w == Vector(0, 1));\n}\n```\n如果重写`==`，还应该重写对象的hashCode getter。有关override == 和hashCode的示例，请参见[ Implementing map keys]。\n\n有关重写的更多信息，请参见[扩展类]。\n\n### noSuchMethod()\n可以重写noSuchMethod()方法来处理程序访问一个不存在的方法或者成员变量：\n```Dart\nclass A {\n  // Unless you override noSuchMethod, using a\n  // non-existent member results in a NoSuchMethodError.\n  @override\n  void noSuchMethod(Invocation invocation) {\n    print('You tried to use a non-existent member: ' +\n        '${invocation.memberName}');\n  }\n}\n```\n您不能调用未实现的方法，除非下列任何一个是正确的:\n\n- 被调用者有静态方法dynamic\n- 被调用者有一个静态类型来定义未实现的方法(抽象也可以OK)，而接收者的动态类型有一个noSuchMethod()的实现，它与类对象中的方法不同。\n\n## 枚举类型\n枚举类型，通常称为枚举或枚举类型，是一种特殊类型的类，用于表示固定数量的常量值。\n\n### 使用枚举\n使用enum关键字声明一个枚举类型：\n```Dart\nenum Color { red, green, blue }\n```\n枚举中的每个值都有一个索引getter，它返回enum声明中值的从0开始的位置。例如，第一个值有索引0，第二个值有索引1。\n```Dart\nassert(Color.red.index == 0);\nassert(Color.green.index == 1);\nassert(Color.blue.index == 2);\n```\n要获取枚举中所有值的列表，请使用enum的values 常量。\n```Dart\nList<Color> colors = Color.values;\nassert(colors[2] == Color.blue);\n```\n您可以在switch语句中使用enum，如果switch的case不处理enum的所有值，将会报一个警告消息:\n```dart\nvar aColor = Color.blue;\n\nswitch (aColor) {\n  case Color.red:\n    print('Red as roses!');\n    break;\n  case Color.green:\n    print('Green as grass!');\n    break;\n  default: // Without this, you see a WARNING.\n    print(aColor); // 'Color.blue'\n}\n```\n枚举类型有以下限制:\n- 不能子类化、混合或实现枚举。\n- 不能显式实例化一个枚举\n\n## 为类添加mixins特性\nmixin是在多个类层次结构中重用类代码的一种方式。\n\n要使用mixin，请在with关键字后面加上一个或多个mixin名称。下面的例子显示了两个使用mixin的类:\n```Dart\nclass Musician extends Performer with Musical {\n  // ···\n}\n\nclass Maestro extends Person\n    with Musical, Aggressive, Demented {\n  Maestro(String maestroName) {\n    name = maestroName;\n    canConduct = true;\n  }\n}\n\n// 要实现mixin，创建一个Object的子类，不声明构造函数，也不调用super。例如:\n\nabstract class Musical {\n  bool canPlayPiano = false;\n  bool canCompose = false;\n  bool canConduct = false;\n\n  void entertainMe() {\n    if (canPlayPiano) {\n      print('Playing piano');\n    } else if (canConduct) {\n      print('Waving hands');\n    } else {\n      print('Humming to self');\n    }\n  }\n}\n```\n## 静态变量和静态方法\n使用static关键字实现类范围的变量和方法。\n\n### 静态变量\n静态变量(类变量)对于类范围内的状态和常量是有用的:\n```dart\nclass Queue {\n  static const initialCapacity = 16;\n  // ···\n}\n\nvoid main() {\n  assert(Queue.initialCapacity == 16);\n}\n```\n静态变量在使用之前不会初始化。\n\n> 注意:此页面遵循代码样式规范，对常量名使用小驼峰命名法。\n\n### 静态方法\n静态方法(类方法)不对实例进行操作，因此无法访问该实例。例如:\n```Dart\nimport 'dart:math';\n\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n\n  static num distanceBetween(Point a, Point b) {\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n\nvoid main() {\n  var a = Point(2, 2);\n  var b = Point(4, 4);\n  var distance = Point.distanceBetween(a, b);\n  assert(2.8 < distance && distance < 2.9);\n  print(distance);\n}\n```\n>注意:对于通用或广泛使用的实用程序和功能，考虑使用顶级函数，而不是静态方法。\n\n可以使用静态方法作为编译时常量。例如，可以将静态方法作为参数传递给常量构造函数。\n","source":"_posts/dart/07_Dart类.md","raw":"---\ntitle: Dart类\nauthor: JsonYe\ntags:\n- dart\ncategories:\n- Dart\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-18 19:24:00   \n---\n>Dart是一种面向对象的语言，具有类和基于mixin的继承。每个对象都是一个类的实例，所有的类都是Object的子类。基于mixin的继承意味着，尽管每个类(除了Object)都只有一个超类，但类主体可以在多个类层次结构中重用。\n##基础\n### 使用类的成员（变量和方法）\n```Dart\nvar p = Point(2, 2);\n// 设置实例变量的值 y.\np.y = 3;\n// 为避免最左操作数为空时出现异常，使用 ?.代替.\np?.y = 4;\n// 获取变量的值\nassert(p.y == 3);\n// 调用方法\nnum distance = p.distanceTo(Point(4, 4));\n\n```\n\n### 使用构造函数\n您可以使用构造函数创建一个对象。构造函数名可以是ClassName或ClassName.identifier。\n```Dart\nvar p1 = Point(2, 2);\nvar p2 = Point.fromJson({'x': 1, 'y': 2});\n\n// 下面的代码具有相同的效果，但是在构造函数名之前使用可选的new关键字\n// 在Dart2中new关键字为可选关键字\nvar p1 = new Point(2, 2);\nvar p2 = new Point.fromJson({'x': 1, 'y': 2});\n\n// 有些类提供常量构造函数。要使用常量构造函数创建编译时常量，请将const关键字放在构造函数名之前:\nvar p = const ImmutablePoint(2, 2);\n\n// 构造两个相同的编译时常量会生成一个单一的、规范的实例:\nvar a = const ImmutablePoint(1, 1);\nvar b = const ImmutablePoint(1, 1);\nassert(identical(a, b)); // They are the same instance!\n\n\n// 在常量上下文中，可以在构造函数或文字之前省略const。例如，看看这个代码，它创建了一个const的 map集合:\nconst pointAndLine = const {\n  'point': const [const ImmutablePoint(0, 0)],\n  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],\n};\n\n//除了第一次使用const关键字之外其他的const都可以省略：\nconst pointAndLine = {\n  'point': [ImmutablePoint(0, 0)],\n  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],\n};\n\n```\n### 获得对象的类型\n要在运行时获得对象类型，可以使用对象的runtimeType属性。\n\n```Dart\nprint('The type of a is ${a.runtimeType}');\n```\n\n### 实例变量\n```Dart\n// 所有未初始化的实例变量都具有null值。\nclass Point {\n  num x; // Declare instance variable x, initially null.\n  num y; // Declare y, initially null.\n  num z = 0; // Declare z, initially 0.\n}\n\n// 所有实例变量都生成隐式getter方法。非最终实例变量也生成隐式setter方法。\nclass Point {\n  // 如果在声明实例变量的地方(而不是在构造函数或方法中)初始化实例变量，则在创建实例时(在构造函数及其初始化列表执行之前)设置该值。\n  num x = 2;\n  num y;\n}\n\nvoid main() {\n  var point = Point();\n  point.x = 4; // Use the setter method for x.\n  assert(point.x == 4); // Use the getter method for x.\n  assert(point.y == null); // Values default to null.\n}\n\n```\n\n## 构造函数\n通过创建一个与类同名的函数来声明构造函数(另外，还可以像[命名构造函数]中描述的一样选择一个附加标识符)。构造函数最常见的应用形式是使用构造函数生成一个类的新实例：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(num x, num y) {\n    // There's a better way to do this, stay tuned.\n    this.x = x;\n    this.y = y;\n  }\n}\n```\nthis关键字是指当前实例。\n\n> 注意:只有在名称冲突时才使用它。否则，Dart的代码风格需要省略this\n\n使用构造函数的参数为实例复制的使用非常常见，Dart具有语法上的优势，使这种使用更容易实现：\n```Dart\nclass Point {\n  num x, y;\n\n  // Syntactic sugar for setting x and y\n  // before the constructor body runs.\n  Point(this.x, this.y);\n}\n```\n\n### 默认构造函数\n如果不声明构造函数，则为您提供默认构造函数。默认构造函数没有参数，并在超类中调用无参数构造函数。\n\n### 构造函数不是继承\n子类不从父类继承构造函数。没有声明构造函数的子类只有默认的构造函数（没有参数，没有名称）而不是从父类继承的构造函数。\n\n### 命名的构造函数\n使用命名构造函数可以在一个类中定义多个构造函数，或者让一个类的作用对于开发人员来说更清晰：\n```Dart\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  // Named constructor\n  Point.origin() {\n    x = 0;\n    y = 0;\n  }\n}\n```\n一定要记住构造函数是不会从父类继承的，这意味着父类的命名构造函数子类也不会继承。如果你希望使用在超类中定义的命名构造函数来创建子类，则必须在子类中实现该构造函数。\n\n### 调用非默认的超类构造函数\n默认情况下，子类中的构造函数调用父类的未命名的无参数构造函数。父类的构造函数在构造函数体的开始处被调用。如果类中有使用初始化列表，初始化列表将在调用超类之前执行。综上所述，执行顺序如下:\n\n- 初始化列表\n- 超类中的无参数构造函数\n- main类中的无参数构造函数\n\n如果超类没有未命名的无参数构造函数，则必须手动调用超类中的一个构造函数。在冒号(:)之后，在构造函数体(如果有的话)之前指定超类构造函数。\n\n在下例中，Employee类的构造函数中调用了他的超类Person中的命名构造函数。\n```Dart\nclass Person {\n  String firstName;\n\n  Person.fromJson(Map data) {\n    print('in Person');\n  }\n}\n\nclass Employee extends Person {\n  // Person does not have a default constructor;\n  // you must call super.fromJson(data).\n  Employee.fromJson(Map data) : super.fromJson(data) {\n    print('in Employee');\n  }\n}\n\nmain() {\n  var emp = new Employee.fromJson({});\n\n  // Prints:\n  // in Person\n  // in Employee\n  if (emp is Person) {\n    // Type check\n    emp.firstName = 'Bob';\n  }\n  (emp as Person).firstName = 'Bob';\n}\n```\n```Shell\n///结果输出为\nin Person\nin Employee\n```\n因为父类构造函数的参数是在调用构造函数之前执行的，所以参数可以是表达式，比如函数调用:\n```Dart\nclass Employee extends Person {\n  Employee() : super.fromJson(getDefaultData());\n  // ···\n}\n```\n> 警告：在超类的构造函数的参数中不能使用this关键字。例如，参数可以调用static方法但是不能调用实例方法\n\n### 初始化列表\n除了调用超类构造函数之外，还可以在构造函数主体运行之前初始化实例变量。初始值设定项用逗号分开。\n```Dart\n// Initializer list sets instance variables before\n// the constructor body runs.\nPoint.fromJson(Map<String, num> json)\n    : x = json['x'],\n      y = json['y'] {\n  print('In Point.fromJson(): ($x, $y)');\n}\n```\n> 警告:初始化器的右边部分中无法访问this关键字。\n\n在开发期间，可以通过在初始化列表中使用assert来验证输入。\n```Dart\nPoint.withAssert(this.x, this.y) : assert(x >= 0) {\n  print('In Point.withAssert(): ($x, $y)');\n}\n```\n初始化列表在设置final字段时很方便。下面的示例初始化初始化列表中的三个final字段：\n\n```Dart\nimport 'dart:math';\n\nclass Point {\n  final num x;\n  final num y;\n  final num distanceFromOrigin;\n\n  Point(x, y)\n      : x = x,\n        y = y,\n        distanceFromOrigin = sqrt(x * x + y * y);\n}\n\nmain() {\n  var p = new Point(2, 3);\n  print(p.distanceFromOrigin);\n}\n```\n```Shell\n///运行结果\n3.605551275463989\n```\n### 重定向构造函数\n有时，构造函数的唯一目的是重定向到同一个类中的另一个构造函数。重定向构造函数的主体为空，构造函数调用出现在冒号(:)之后。\n```Dart\nclass Point {\n  num x, y;\n\n  // The main constructor for this class.\n  Point(this.x, this.y);\n\n  // Delegates to the main constructor.\n  Point.alongXAxis(num x) : this(x, 0);\n}\n```\n### 常量构造函数\n如果您的类生成的对象不会改变，您可以使这些对象成为编译时常量。为此，定义一个const构造函数，并确保所有实例变量都是final的。\n```Dart\nclass ImmutablePoint {\n  static final ImmutablePoint origin =\n      const ImmutablePoint(0, 0);\n\n  final num x, y;\n\n  const ImmutablePoint(this.x, this.y);\n}\n```\n### 工厂构造函数\n在实现构造函数时使用factory关键字，该构造函数并不总是创建类的新实例。例如，工厂构造函数可以从缓存返回实例，也可以返回子类型的实例。\n\n以下示例演示工厂构造函数从缓存返回对象:\n```Dart\nclass Logger {\n  final String name;\n  bool mute = false;\n\n  // _cache is library-private, thanks to\n  // the _ in front of its name.\n  static final Map<String, Logger> _cache =\n      <String, Logger>{};\n\n  factory Logger(String name) {\n    if (_cache.containsKey(name)) {\n      return _cache[name];\n    } else {\n      final logger = Logger._internal(name);\n      _cache[name] = logger;\n      return logger;\n    }\n  }\n\n  Logger._internal(this.name);\n\n  void log(String msg) {\n    if (!mute) print(msg);\n  }\n}\n```\n> 注意:工厂构造函数不能访问this关键字。\n\n调用工厂构造函数，就像调用其他构造函数一样:\n```Dart\nvar logger = Logger('UI');\nlogger.log('Button clicked');\n```\n\n## 方法\n> 方法是为对象提供行为的函数。\n\n### 实例方法\n对象上的实例方法可以访问实例变量。下面示例中的distanceTo()方法是一个实例方法的示例:\n```dart\nimport 'dart:math';\n\nclass Point {\n  num x, y;\n\n  Point(this.x, this.y);\n\n  num distanceTo(Point other) {\n    var dx = x - other.x;\n    var dy = y - other.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n```\n### Getters 和 setters 方法\ngetter和setter是对对象属性的读写访问的特殊方法。回想一下，每个实例变量都有一个隐式的getter，如果需要的话还可以加上一个setter。使用get和set关键字来实现getter和setter方法可以来读写其他属性：\n```Dart\nclass Rectangle {\n  num left, top, width, height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  // Define two calculated properties: right and bottom.\n  num get right => left + width;\n  set right(num value) => left = value - width;\n  num get bottom => top + height;\n  set bottom(num value) => top = value - height;\n}\n\nvoid main() {\n  var rect = Rectangle(3, 4, 20, 15);\n  assert(rect.left == 3);\n  rect.right = 12;\n  assert(rect.left == -8);\n}\n```\n使用getter和setter，你可以使用方法包装实例变量，而无需改动业务代码。\n\n>注意:诸如increment(++)之类的操作符以预期的方式工作，无论getter是否被显式定义。为了避免任何意外的副作用，操作符只调用getter一次，将其值保存在一个临时变量中。\n\n### 抽象方法\n实例方法、getter和setter方法可以是抽象方法，之定义一个接口但是将具体实现留给其他类。抽象方法只能存在于抽象类中，抽象方法是没有方法体的。\n```dart\nabstract class Doer {\n  // Define instance variables and methods...\n\n  void doSomething(); // Define an abstract method.\n}\n\nclass EffectiveDoer extends Doer {\n  void doSomething() {\n    // Provide an implementation, so the method is not abstract here...\n  }\n}\n```\n调用抽象方法会导致运行时错误。\n\n## 抽象类\n使用abstract修饰符定义不能实例化的抽象类。抽象类对于定义接口非常有用。如果您希望抽象类看起来是可实例化的，请定义一个工厂构造函数。\n\n抽象类通常有抽象方法。这里有一个声明抽象类的例子，它有一个抽象的方法:\n```Dart\n// This class is declared abstract and thus\n// can't be instantiated.\nabstract class AbstractContainer {\n  // Define constructors, fields, methods...\n\n  void updateChildren(); // Abstract method.\n}\n```\n\n## 隐式接口\n每个类都隐式地定义一个接口，该接口包含类的所有实例成员及其实现的任何接口。如果您想创建一个类A，它支持类B的API而不继承B的实现，那么类A应该实现B接口。\n```Dart\n// A person. The implicit interface contains greet().\nclass Person {\n  // In the interface, but visible only in this library.\n  final _name;\n\n  // Not in the interface, since this is a constructor.\n  Person(this._name);\n\n  // In the interface.\n  String greet(String who) => 'Hello, $who. I am $_name.';\n}\n\n// An implementation of the Person interface.\nclass Impostor implements Person {\n  get _name => '';\n\n  String greet(String who) => 'Hi $who. Do you know who I am?';\n}\n\nString greetBob(Person person) => person.greet('Bob');\n\nvoid main() {\n  print(greetBob(Person('Kathy')));\n  print(greetBob(Impostor()));\n}\n```\n这里有一个例子，说明一个类实现多个接口:\n```Dart\nclass Point implements Comparable, Location {...}\n```\n\n## 继承\n使用extend创建子类，使用super引用超类:\n```Dart\nclass Television {\n  void turnOn() {\n    _illuminateDisplay();\n    _activateIrSensor();\n  }\n  // ···\n}\n\nclass SmartTelevision extends Television {\n  void turnOn() {\n    super.turnOn();\n    _bootNetworkInterface();\n    _initializeMemory();\n    _upgradeApps();\n  }\n  // ···\n}\n```\n\n## 重写类的成员\n子类可以覆盖实例方法、getter和setter。您可以使用@override注释来指示你重写了某个成员方法:\n```Dart\nclass SmartTelevision extends Television {\n  @override\n  void turnOn() {...}\n  // ···\n}\n```\n要在类型安全的代码中缩小方法参数或实例变量的类型，可以使用covariant关键字。\n\n### 重写操作符\n您可以重写下表中显示的操作符。例如，如果定义一个Vector类，可以定义一个+方法来让两个向量相加。\n\n`<`\t|`+`|\t`|`\t|`[]`\n--|--|--|--\n`>`\t|`/`|\t`^`|\t`[]=`\n`<=`|\t`~/`|\t`&`|\t`~`\n`>=`|\t`*`\t|`<<`|\t`==`\n`-`\t|`%`\t|`>>`|\n下例在类中重写了+和-操作符：\n```Dart\nclass Vector {\n  final int x, y;\n\n  Vector(this.x, this.y);\n\n  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);\n  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);\n\n  // Operator == and hashCode not shown. For details, see note below.\n  // ···\n}\n\nvoid main() {\n  final v = Vector(2, 3);\n  final w = Vector(2, 2);\n\n  assert(v + w == Vector(4, 5));\n  assert(v - w == Vector(0, 1));\n}\n```\n如果重写`==`，还应该重写对象的hashCode getter。有关override == 和hashCode的示例，请参见[ Implementing map keys]。\n\n有关重写的更多信息，请参见[扩展类]。\n\n### noSuchMethod()\n可以重写noSuchMethod()方法来处理程序访问一个不存在的方法或者成员变量：\n```Dart\nclass A {\n  // Unless you override noSuchMethod, using a\n  // non-existent member results in a NoSuchMethodError.\n  @override\n  void noSuchMethod(Invocation invocation) {\n    print('You tried to use a non-existent member: ' +\n        '${invocation.memberName}');\n  }\n}\n```\n您不能调用未实现的方法，除非下列任何一个是正确的:\n\n- 被调用者有静态方法dynamic\n- 被调用者有一个静态类型来定义未实现的方法(抽象也可以OK)，而接收者的动态类型有一个noSuchMethod()的实现，它与类对象中的方法不同。\n\n## 枚举类型\n枚举类型，通常称为枚举或枚举类型，是一种特殊类型的类，用于表示固定数量的常量值。\n\n### 使用枚举\n使用enum关键字声明一个枚举类型：\n```Dart\nenum Color { red, green, blue }\n```\n枚举中的每个值都有一个索引getter，它返回enum声明中值的从0开始的位置。例如，第一个值有索引0，第二个值有索引1。\n```Dart\nassert(Color.red.index == 0);\nassert(Color.green.index == 1);\nassert(Color.blue.index == 2);\n```\n要获取枚举中所有值的列表，请使用enum的values 常量。\n```Dart\nList<Color> colors = Color.values;\nassert(colors[2] == Color.blue);\n```\n您可以在switch语句中使用enum，如果switch的case不处理enum的所有值，将会报一个警告消息:\n```dart\nvar aColor = Color.blue;\n\nswitch (aColor) {\n  case Color.red:\n    print('Red as roses!');\n    break;\n  case Color.green:\n    print('Green as grass!');\n    break;\n  default: // Without this, you see a WARNING.\n    print(aColor); // 'Color.blue'\n}\n```\n枚举类型有以下限制:\n- 不能子类化、混合或实现枚举。\n- 不能显式实例化一个枚举\n\n## 为类添加mixins特性\nmixin是在多个类层次结构中重用类代码的一种方式。\n\n要使用mixin，请在with关键字后面加上一个或多个mixin名称。下面的例子显示了两个使用mixin的类:\n```Dart\nclass Musician extends Performer with Musical {\n  // ···\n}\n\nclass Maestro extends Person\n    with Musical, Aggressive, Demented {\n  Maestro(String maestroName) {\n    name = maestroName;\n    canConduct = true;\n  }\n}\n\n// 要实现mixin，创建一个Object的子类，不声明构造函数，也不调用super。例如:\n\nabstract class Musical {\n  bool canPlayPiano = false;\n  bool canCompose = false;\n  bool canConduct = false;\n\n  void entertainMe() {\n    if (canPlayPiano) {\n      print('Playing piano');\n    } else if (canConduct) {\n      print('Waving hands');\n    } else {\n      print('Humming to self');\n    }\n  }\n}\n```\n## 静态变量和静态方法\n使用static关键字实现类范围的变量和方法。\n\n### 静态变量\n静态变量(类变量)对于类范围内的状态和常量是有用的:\n```dart\nclass Queue {\n  static const initialCapacity = 16;\n  // ···\n}\n\nvoid main() {\n  assert(Queue.initialCapacity == 16);\n}\n```\n静态变量在使用之前不会初始化。\n\n> 注意:此页面遵循代码样式规范，对常量名使用小驼峰命名法。\n\n### 静态方法\n静态方法(类方法)不对实例进行操作，因此无法访问该实例。例如:\n```Dart\nimport 'dart:math';\n\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n\n  static num distanceBetween(Point a, Point b) {\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n\nvoid main() {\n  var a = Point(2, 2);\n  var b = Point(4, 4);\n  var distance = Point.distanceBetween(a, b);\n  assert(2.8 < distance && distance < 2.9);\n  print(distance);\n}\n```\n>注意:对于通用或广泛使用的实用程序和功能，考虑使用顶级函数，而不是静态方法。\n\n可以使用静态方法作为编译时常量。例如，可以将静态方法作为参数传递给常量构造函数。\n","slug":"dart/07_Dart类","published":1,"updated":"2019-10-02T09:24:47.373Z","layout":"post","photos":[],"link":"","_id":"ck19bvb38004800wkvm1j53ko","content":"<blockquote>\n<p>Dart是一种面向对象的语言，具有类和基于mixin的继承。每个对象都是一个类的实例，所有的类都是Object的子类。基于mixin的继承意味着，尽管每个类(除了Object)都只有一个超类，但类主体可以在多个类层次结构中重用。</p>\n</blockquote>\n<p>##基础</p>\n<h3 id=\"使用类的成员（变量和方法）\"><a href=\"#使用类的成员（变量和方法）\" class=\"headerlink\" title=\"使用类的成员（变量和方法）\"></a>使用类的成员（变量和方法）</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置实例变量的值 y.</span></span><br><span class=\"line\">p.y = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// 为避免最左操作数为空时出现异常，使用 ?.代替.</span></span><br><span class=\"line\">p?.y = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">// 获取变量的值</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(p.y == <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 调用方法</span></span><br><span class=\"line\"><span class=\"built_in\">num</span> distance = p.distanceTo(Point(<span class=\"number\">4</span>, <span class=\"number\">4</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用构造函数\"><a href=\"#使用构造函数\" class=\"headerlink\" title=\"使用构造函数\"></a>使用构造函数</h3><p>您可以使用构造函数创建一个对象。构造函数名可以是ClassName或ClassName.identifier。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = Point.fromJson(&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码具有相同的效果，但是在构造函数名之前使用可选的new关键字</span></span><br><span class=\"line\"><span class=\"comment\">// 在Dart2中new关键字为可选关键字</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point.fromJson(&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有些类提供常量构造函数。要使用常量构造函数创建编译时常量，请将const关键字放在构造函数名之前:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造两个相同的编译时常量会生成一个单一的、规范的实例:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(identical(a, b)); <span class=\"comment\">// They are the same instance!</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在常量上下文中，可以在构造函数或文字之前省略const。例如，看看这个代码，它创建了一个const的 map集合:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointAndLine = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"string\">'point'</span>: <span class=\"keyword\">const</span> [<span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>)],</span><br><span class=\"line\">  <span class=\"string\">'line'</span>: <span class=\"keyword\">const</span> [<span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">10</span>), <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">-2</span>, <span class=\"number\">11</span>)],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//除了第一次使用const关键字之外其他的const都可以省略：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointAndLine = &#123;</span><br><span class=\"line\">  <span class=\"string\">'point'</span>: [ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>)],</span><br><span class=\"line\">  <span class=\"string\">'line'</span>: [ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">10</span>), ImmutablePoint(<span class=\"number\">-2</span>, <span class=\"number\">11</span>)],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获得对象的类型\"><a href=\"#获得对象的类型\" class=\"headerlink\" title=\"获得对象的类型\"></a>获得对象的类型</h3><p>要在运行时获得对象类型，可以使用对象的runtimeType属性。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">'The type of a is <span class=\"subst\">$&#123;a.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 所有未初始化的实例变量都具有null值。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x; <span class=\"comment\">// Declare instance variable x, initially null.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> y; <span class=\"comment\">// Declare y, initially null.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> z = <span class=\"number\">0</span>; <span class=\"comment\">// Declare z, initially 0.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有实例变量都生成隐式getter方法。非最终实例变量也生成隐式setter方法。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果在声明实例变量的地方(而不是在构造函数或方法中)初始化实例变量，则在创建实例时(在构造函数及其初始化列表执行之前)设置该值。</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> point = Point();</span><br><span class=\"line\">  point.x = <span class=\"number\">4</span>; <span class=\"comment\">// Use the setter method for x.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(point.x == <span class=\"number\">4</span>); <span class=\"comment\">// Use the getter method for x.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(point.y == <span class=\"keyword\">null</span>); <span class=\"comment\">// Values default to null.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>通过创建一个与类同名的函数来声明构造函数(另外，还可以像[命名构造函数]中描述的一样选择一个附加标识符)。构造函数最常见的应用形式是使用构造函数生成一个类的新实例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"built_in\">num</span> x, <span class=\"built_in\">num</span> y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// There's a better way to do this, stay tuned.</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>this关键字是指当前实例。</p>\n<blockquote>\n<p>注意:只有在名称冲突时才使用它。否则，Dart的代码风格需要省略this</p>\n</blockquote>\n<p>使用构造函数的参数为实例复制的使用非常常见，Dart具有语法上的优势，使这种使用更容易实现：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Syntactic sugar for setting x and y</span></span><br><span class=\"line\">  <span class=\"comment\">// before the constructor body runs.</span></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h3><p>如果不声明构造函数，则为您提供默认构造函数。默认构造函数没有参数，并在超类中调用无参数构造函数。</p>\n<h3 id=\"构造函数不是继承\"><a href=\"#构造函数不是继承\" class=\"headerlink\" title=\"构造函数不是继承\"></a>构造函数不是继承</h3><p>子类不从父类继承构造函数。没有声明构造函数的子类只有默认的构造函数（没有参数，没有名称）而不是从父类继承的构造函数。</p>\n<h3 id=\"命名的构造函数\"><a href=\"#命名的构造函数\" class=\"headerlink\" title=\"命名的构造函数\"></a>命名的构造函数</h3><p>使用命名构造函数可以在一个类中定义多个构造函数，或者让一个类的作用对于开发人员来说更清晰：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Named constructor</span></span><br><span class=\"line\">  Point.origin() &#123;</span><br><span class=\"line\">    x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    y = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一定要记住构造函数是不会从父类继承的，这意味着父类的命名构造函数子类也不会继承。如果你希望使用在超类中定义的命名构造函数来创建子类，则必须在子类中实现该构造函数。</p>\n<h3 id=\"调用非默认的超类构造函数\"><a href=\"#调用非默认的超类构造函数\" class=\"headerlink\" title=\"调用非默认的超类构造函数\"></a>调用非默认的超类构造函数</h3><p>默认情况下，子类中的构造函数调用父类的未命名的无参数构造函数。父类的构造函数在构造函数体的开始处被调用。如果类中有使用初始化列表，初始化列表将在调用超类之前执行。综上所述，执行顺序如下:</p>\n<ul>\n<li>初始化列表</li>\n<li>超类中的无参数构造函数</li>\n<li>main类中的无参数构造函数</li>\n</ul>\n<p>如果超类没有未命名的无参数构造函数，则必须手动调用超类中的一个构造函数。在冒号(:)之后，在构造函数体(如果有的话)之前指定超类构造函数。</p>\n<p>在下例中，Employee类的构造函数中调用了他的超类Person中的命名构造函数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person.fromJson(<span class=\"built_in\">Map</span> data) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'in Person'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Person does not have a default constructor;</span></span><br><span class=\"line\">  <span class=\"comment\">// you must call super.fromJson(data).</span></span><br><span class=\"line\">  Employee.fromJson(<span class=\"built_in\">Map</span> data) : <span class=\"keyword\">super</span>.fromJson(data) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'in Employee'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> emp = <span class=\"keyword\">new</span> Employee.fromJson(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Prints:</span></span><br><span class=\"line\">  <span class=\"comment\">// in Person</span></span><br><span class=\"line\">  <span class=\"comment\">// in Employee</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (emp <span class=\"keyword\">is</span> Person) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Type check</span></span><br><span class=\"line\">    emp.firstName = <span class=\"string\">'Bob'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  (emp <span class=\"keyword\">as</span> Person).firstName = <span class=\"string\">'Bob'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">///结果输出为</span><br><span class=\"line\">in Person</span><br><span class=\"line\">in Employee</span><br></pre></td></tr></table></figure>\n\n<p>因为父类构造函数的参数是在调用构造函数之前执行的，所以参数可以是表达式，比如函数调用:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  Employee() : <span class=\"keyword\">super</span>.fromJson(getDefaultData());</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>警告：在超类的构造函数的参数中不能使用this关键字。例如，参数可以调用static方法但是不能调用实例方法</p>\n</blockquote>\n<h3 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表\"></a>初始化列表</h3><p>除了调用超类构造函数之外，还可以在构造函数主体运行之前初始化实例变量。初始值设定项用逗号分开。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initializer list sets instance variables before</span></span><br><span class=\"line\"><span class=\"comment\">// the constructor body runs.</span></span><br><span class=\"line\">Point.fromJson(<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">num</span>&gt; json)</span><br><span class=\"line\">    : x = json[<span class=\"string\">'x'</span>],</span><br><span class=\"line\">      y = json[<span class=\"string\">'y'</span>] &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In Point.fromJson(): (<span class=\"subst\">$x</span>, <span class=\"subst\">$y</span>)'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>警告:初始化器的右边部分中无法访问this关键字。</p>\n</blockquote>\n<p>在开发期间，可以通过在初始化列表中使用assert来验证输入。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.withAssert(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y) : <span class=\"keyword\">assert</span>(x &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In Point.withAssert(): (<span class=\"subst\">$x</span>, <span class=\"subst\">$y</span>)'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化列表在设置final字段时很方便。下面的示例初始化初始化列表中的三个final字段：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> distanceFromOrigin;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(x, y)</span><br><span class=\"line\">      : x = x,</span><br><span class=\"line\">        y = y,</span><br><span class=\"line\">        distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(p.distanceFromOrigin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">///运行结果</span><br><span class=\"line\">3.605551275463989</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重定向构造函数\"><a href=\"#重定向构造函数\" class=\"headerlink\" title=\"重定向构造函数\"></a>重定向构造函数</h3><p>有时，构造函数的唯一目的是重定向到同一个类中的另一个构造函数。重定向构造函数的主体为空，构造函数调用出现在冒号(:)之后。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The main constructor for this class.</span></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Delegates to the main constructor.</span></span><br><span class=\"line\">  Point.alongXAxis(<span class=\"built_in\">num</span> x) : <span class=\"keyword\">this</span>(x, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常量构造函数\"><a href=\"#常量构造函数\" class=\"headerlink\" title=\"常量构造函数\"></a>常量构造函数</h3><p>如果您的类生成的对象不会改变，您可以使这些对象成为编译时常量。为此，定义一个const构造函数，并确保所有实例变量都是final的。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImmutablePoint</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutablePoint origin =</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"工厂构造函数\"><a href=\"#工厂构造函数\" class=\"headerlink\" title=\"工厂构造函数\"></a>工厂构造函数</h3><p>在实现构造函数时使用factory关键字，该构造函数并不总是创建类的新实例。例如，工厂构造函数可以从缓存返回实例，也可以返回子类型的实例。</p>\n<p>以下示例演示工厂构造函数从缓存返回对象:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> mute = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// _cache is library-private, thanks to</span></span><br><span class=\"line\">  <span class=\"comment\">// the _ in front of its name.</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, Logger&gt; _cache =</span><br><span class=\"line\">      &lt;<span class=\"built_in\">String</span>, Logger&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> Logger(<span class=\"built_in\">String</span> name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cache.containsKey(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _cache[name];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> logger = Logger._internal(name);</span><br><span class=\"line\">      _cache[name] = logger;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> logger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Logger._internal(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> log(<span class=\"built_in\">String</span> msg) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mute) <span class=\"built_in\">print</span>(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:工厂构造函数不能访问this关键字。</p>\n</blockquote>\n<p>调用工厂构造函数，就像调用其他构造函数一样:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> logger = Logger(<span class=\"string\">'UI'</span>);</span><br><span class=\"line\">logger.log(<span class=\"string\">'Button clicked'</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><blockquote>\n<p>方法是为对象提供行为的函数。</p>\n</blockquote>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><p>对象上的实例方法可以访问实例变量。下面示例中的distanceTo()方法是一个实例方法的示例:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">num</span> distanceTo(Point other) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dx = x - other.x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dy = y - other.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(dx * dx + dy * dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Getters-和-setters-方法\"><a href=\"#Getters-和-setters-方法\" class=\"headerlink\" title=\"Getters 和 setters 方法\"></a>Getters 和 setters 方法</h3><p>getter和setter是对对象属性的读写访问的特殊方法。回想一下，每个实例变量都有一个隐式的getter，如果需要的话还可以加上一个setter。使用get和set关键字来实现getter和setter方法可以来读写其他属性：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> left, top, width, height;</span><br><span class=\"line\"></span><br><span class=\"line\">  Rectangle(<span class=\"keyword\">this</span>.left, <span class=\"keyword\">this</span>.top, <span class=\"keyword\">this</span>.width, <span class=\"keyword\">this</span>.height);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Define two calculated properties: right and bottom.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> right =&gt; left + width;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> right(<span class=\"built_in\">num</span> value) =&gt; left = value - width;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> bottom =&gt; top + height;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> bottom(<span class=\"built_in\">num</span> value) =&gt; top = value - height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rect = Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">3</span>);</span><br><span class=\"line\">  rect.right = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">-8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用getter和setter，你可以使用方法包装实例变量，而无需改动业务代码。</p>\n<blockquote>\n<p>注意:诸如increment(++)之类的操作符以预期的方式工作，无论getter是否被显式定义。为了避免任何意外的副作用，操作符只调用getter一次，将其值保存在一个临时变量中。</p>\n</blockquote>\n<h3 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法\"></a>抽象方法</h3><p>实例方法、getter和setter方法可以是抽象方法，之定义一个接口但是将具体实现留给其他类。抽象方法只能存在于抽象类中，抽象方法是没有方法体的。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Doer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Define instance variables and methods...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> doSomething(); <span class=\"comment\">// Define an abstract method.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EffectiveDoer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Doer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> doSomething() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Provide an implementation, so the method is not abstract here...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用抽象方法会导致运行时错误。</p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>使用abstract修饰符定义不能实例化的抽象类。抽象类对于定义接口非常有用。如果您希望抽象类看起来是可实例化的，请定义一个工厂构造函数。</p>\n<p>抽象类通常有抽象方法。这里有一个声明抽象类的例子，它有一个抽象的方法:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This class is declared abstract and thus</span></span><br><span class=\"line\"><span class=\"comment\">// can't be instantiated.</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractContainer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Define constructors, fields, methods...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> updateChildren(); <span class=\"comment\">// Abstract method.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"隐式接口\"><a href=\"#隐式接口\" class=\"headerlink\" title=\"隐式接口\"></a>隐式接口</h2><p>每个类都隐式地定义一个接口，该接口包含类的所有实例成员及其实现的任何接口。如果您想创建一个类A，它支持类B的API而不继承B的实现，那么类A应该实现B接口。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A person. The implicit interface contains greet().</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// In the interface, but visible only in this library.</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> _name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Not in the interface, since this is a constructor.</span></span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>._name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// In the interface.</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hello, <span class=\"subst\">$who</span>. I am <span class=\"subst\">$_name</span>.'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// An implementation of the Person interface.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Impostor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> _name =&gt; <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hi <span class=\"subst\">$who</span>. Do you know who I am?'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> greetBob(Person person) =&gt; person.greet(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Person(<span class=\"string\">'Kathy'</span>)));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Impostor()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有一个例子，说明一个类实现多个接口:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>, <span class=\"title\">Location</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>使用extend创建子类，使用super引用超类:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;</span><br><span class=\"line\">    _illuminateDisplay();</span><br><span class=\"line\">    _activateIrSensor();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartTelevision</span> <span class=\"keyword\">extends</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.turnOn();</span><br><span class=\"line\">    _bootNetworkInterface();</span><br><span class=\"line\">    _initializeMemory();</span><br><span class=\"line\">    _upgradeApps();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重写类的成员\"><a href=\"#重写类的成员\" class=\"headerlink\" title=\"重写类的成员\"></a>重写类的成员</h2><p>子类可以覆盖实例方法、getter和setter。您可以使用@override注释来指示你重写了某个成员方法:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartTelevision</span> <span class=\"keyword\">extends</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;...&#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要在类型安全的代码中缩小方法参数或实例变量的类型，可以使用covariant关键字。</p>\n<h3 id=\"重写操作符\"><a href=\"#重写操作符\" class=\"headerlink\" title=\"重写操作符\"></a>重写操作符</h3><p>您可以重写下表中显示的操作符。例如，如果定义一个Vector类，可以定义一个+方法来让两个向量相加。</p>\n<p><code>&lt;</code>    |<code>+</code>|    <code>|</code>    |<code>[]</code><br>–|–|–|–<br><code>&gt;</code>    |<code>/</code>|    <code>^</code>|    <code>[]=</code><br><code>&lt;=</code>|    <code>~/</code>|    <code>&amp;</code>|    <code>~</code><br><code>&gt;=</code>|    <code>*</code>    |<code>&lt;&lt;</code>|    <code>==</code><br><code>-</code>    |<code>%</code>    |<code>&gt;&gt;</code>|<br>下例在类中重写了+和-操作符：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> +(Vector v) =&gt; Vector(x + v.x, y + v.y);</span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> -(Vector v) =&gt; Vector(x - v.x, y - v.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Operator == and hashCode not shown. For details, see note below.</span></span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> v = Vector(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> w = Vector(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(v + w == Vector(<span class=\"number\">4</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(v - w == Vector(<span class=\"number\">0</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果重写<code>==</code>，还应该重写对象的hashCode getter。有关override == 和hashCode的示例，请参见[ Implementing map keys]。</p>\n<p>有关重写的更多信息，请参见[扩展类]。</p>\n<h3 id=\"noSuchMethod\"><a href=\"#noSuchMethod\" class=\"headerlink\" title=\"noSuchMethod()\"></a>noSuchMethod()</h3><p>可以重写noSuchMethod()方法来处理程序访问一个不存在的方法或者成员变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Unless you override noSuchMethod, using a</span></span><br><span class=\"line\">  <span class=\"comment\">// non-existent member results in a NoSuchMethodError.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'You tried to use a non-existent member: '</span> +</span><br><span class=\"line\">        <span class=\"string\">'<span class=\"subst\">$&#123;invocation.memberName&#125;</span>'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您不能调用未实现的方法，除非下列任何一个是正确的:</p>\n<ul>\n<li>被调用者有静态方法dynamic</li>\n<li>被调用者有一个静态类型来定义未实现的方法(抽象也可以OK)，而接收者的动态类型有一个noSuchMethod()的实现，它与类对象中的方法不同。</li>\n</ul>\n<h2 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h2><p>枚举类型，通常称为枚举或枚举类型，是一种特殊类型的类，用于表示固定数量的常量值。</p>\n<h3 id=\"使用枚举\"><a href=\"#使用枚举\" class=\"headerlink\" title=\"使用枚举\"></a>使用枚举</h3><p>使用enum关键字声明一个枚举类型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123; red, green, blue &#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举中的每个值都有一个索引getter，它返回enum声明中值的从0开始的位置。例如，第一个值有索引0，第二个值有索引1。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(Color.red.index == <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(Color.green.index == <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(Color.blue.index == <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>要获取枚举中所有值的列表，请使用enum的values 常量。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(colors[<span class=\"number\">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure>\n\n<p>您可以在switch语句中使用enum，如果switch的case不处理enum的所有值，将会报一个警告消息:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aColor = Color.blue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (aColor) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> Color.red:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'Red as roses!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> Color.green:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'Green as grass!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>: <span class=\"comment\">// Without this, you see a WARNING.</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(aColor); <span class=\"comment\">// 'Color.blue'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举类型有以下限制:</p>\n<ul>\n<li>不能子类化、混合或实现枚举。</li>\n<li>不能显式实例化一个枚举</li>\n</ul>\n<h2 id=\"为类添加mixins特性\"><a href=\"#为类添加mixins特性\" class=\"headerlink\" title=\"为类添加mixins特性\"></a>为类添加mixins特性</h2><p>mixin是在多个类层次结构中重用类代码的一种方式。</p>\n<p>要使用mixin，请在with关键字后面加上一个或多个mixin名称。下面的例子显示了两个使用mixin的类:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Musician</span> <span class=\"keyword\">extends</span> <span class=\"title\">Performer</span> <span class=\"title\">with</span> <span class=\"title\">Musical</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maestro</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">with</span> <span class=\"title\">Musical</span>, <span class=\"title\">Aggressive</span>, <span class=\"title\">Demented</span> </span>&#123;</span><br><span class=\"line\">  Maestro(<span class=\"built_in\">String</span> maestroName) &#123;</span><br><span class=\"line\">    name = maestroName;</span><br><span class=\"line\">    canConduct = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 要实现mixin，创建一个Object的子类，不声明构造函数，也不调用super。例如:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Musical</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canPlayPiano = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canCompose = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canConduct = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> entertainMe() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canPlayPiano) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Playing piano'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (canConduct) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Waving hands'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Humming to self'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态变量和静态方法\"><a href=\"#静态变量和静态方法\" class=\"headerlink\" title=\"静态变量和静态方法\"></a>静态变量和静态方法</h2><p>使用static关键字实现类范围的变量和方法。</p>\n<h3 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h3><p>静态变量(类变量)对于类范围内的状态和常量是有用的:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> initialCapacity = <span class=\"number\">16</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Queue.initialCapacity == <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>静态变量在使用之前不会初始化。</p>\n<blockquote>\n<p>注意:此页面遵循代码样式规范，对常量名使用小驼峰命名法。</p>\n</blockquote>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>静态方法(类方法)不对实例进行操作，因此无法访问该实例。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dx = a.x - b.x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dy = a.y - b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(dx * dx + dy * dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = Point(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> distance = Point.distanceBetween(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(<span class=\"number\">2.8</span> &lt; distance &amp;&amp; distance &lt; <span class=\"number\">2.9</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(distance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:对于通用或广泛使用的实用程序和功能，考虑使用顶级函数，而不是静态方法。</p>\n</blockquote>\n<p>可以使用静态方法作为编译时常量。例如，可以将静态方法作为参数传递给常量构造函数。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Dart是一种面向对象的语言，具有类和基于mixin的继承。每个对象都是一个类的实例，所有的类都是Object的子类。基于mixin的继承意味着，尽管每个类(除了Object)都只有一个超类，但类主体可以在多个类层次结构中重用。</p>\n</blockquote>\n<p>##基础</p>\n<h3 id=\"使用类的成员（变量和方法）\"><a href=\"#使用类的成员（变量和方法）\" class=\"headerlink\" title=\"使用类的成员（变量和方法）\"></a>使用类的成员（变量和方法）</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置实例变量的值 y.</span></span><br><span class=\"line\">p.y = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// 为避免最左操作数为空时出现异常，使用 ?.代替.</span></span><br><span class=\"line\">p?.y = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">// 获取变量的值</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span>(p.y == <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 调用方法</span></span><br><span class=\"line\"><span class=\"built_in\">num</span> distance = p.distanceTo(Point(<span class=\"number\">4</span>, <span class=\"number\">4</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用构造函数\"><a href=\"#使用构造函数\" class=\"headerlink\" title=\"使用构造函数\"></a>使用构造函数</h3><p>您可以使用构造函数创建一个对象。构造函数名可以是ClassName或ClassName.identifier。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = Point.fromJson(&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的代码具有相同的效果，但是在构造函数名之前使用可选的new关键字</span></span><br><span class=\"line\"><span class=\"comment\">// 在Dart2中new关键字为可选关键字</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point.fromJson(&#123;<span class=\"string\">'x'</span>: <span class=\"number\">1</span>, <span class=\"string\">'y'</span>: <span class=\"number\">2</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有些类提供常量构造函数。要使用常量构造函数创建编译时常量，请将const关键字放在构造函数名之前:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造两个相同的编译时常量会生成一个单一的、规范的实例:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(identical(a, b)); <span class=\"comment\">// They are the same instance!</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在常量上下文中，可以在构造函数或文字之前省略const。例如，看看这个代码，它创建了一个const的 map集合:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointAndLine = <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  <span class=\"string\">'point'</span>: <span class=\"keyword\">const</span> [<span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>)],</span><br><span class=\"line\">  <span class=\"string\">'line'</span>: <span class=\"keyword\">const</span> [<span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">10</span>), <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">-2</span>, <span class=\"number\">11</span>)],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//除了第一次使用const关键字之外其他的const都可以省略：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointAndLine = &#123;</span><br><span class=\"line\">  <span class=\"string\">'point'</span>: [ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>)],</span><br><span class=\"line\">  <span class=\"string\">'line'</span>: [ImmutablePoint(<span class=\"number\">1</span>, <span class=\"number\">10</span>), ImmutablePoint(<span class=\"number\">-2</span>, <span class=\"number\">11</span>)],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获得对象的类型\"><a href=\"#获得对象的类型\" class=\"headerlink\" title=\"获得对象的类型\"></a>获得对象的类型</h3><p>要在运行时获得对象类型，可以使用对象的runtimeType属性。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">'The type of a is <span class=\"subst\">$&#123;a.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 所有未初始化的实例变量都具有null值。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x; <span class=\"comment\">// Declare instance variable x, initially null.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> y; <span class=\"comment\">// Declare y, initially null.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> z = <span class=\"number\">0</span>; <span class=\"comment\">// Declare z, initially 0.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有实例变量都生成隐式getter方法。非最终实例变量也生成隐式setter方法。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果在声明实例变量的地方(而不是在构造函数或方法中)初始化实例变量，则在创建实例时(在构造函数及其初始化列表执行之前)设置该值。</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> point = Point();</span><br><span class=\"line\">  point.x = <span class=\"number\">4</span>; <span class=\"comment\">// Use the setter method for x.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(point.x == <span class=\"number\">4</span>); <span class=\"comment\">// Use the getter method for x.</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(point.y == <span class=\"keyword\">null</span>); <span class=\"comment\">// Values default to null.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>通过创建一个与类同名的函数来声明构造函数(另外，还可以像[命名构造函数]中描述的一样选择一个附加标识符)。构造函数最常见的应用形式是使用构造函数生成一个类的新实例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"built_in\">num</span> x, <span class=\"built_in\">num</span> y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// There's a better way to do this, stay tuned.</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>this关键字是指当前实例。</p>\n<blockquote>\n<p>注意:只有在名称冲突时才使用它。否则，Dart的代码风格需要省略this</p>\n</blockquote>\n<p>使用构造函数的参数为实例复制的使用非常常见，Dart具有语法上的优势，使这种使用更容易实现：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Syntactic sugar for setting x and y</span></span><br><span class=\"line\">  <span class=\"comment\">// before the constructor body runs.</span></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h3><p>如果不声明构造函数，则为您提供默认构造函数。默认构造函数没有参数，并在超类中调用无参数构造函数。</p>\n<h3 id=\"构造函数不是继承\"><a href=\"#构造函数不是继承\" class=\"headerlink\" title=\"构造函数不是继承\"></a>构造函数不是继承</h3><p>子类不从父类继承构造函数。没有声明构造函数的子类只有默认的构造函数（没有参数，没有名称）而不是从父类继承的构造函数。</p>\n<h3 id=\"命名的构造函数\"><a href=\"#命名的构造函数\" class=\"headerlink\" title=\"命名的构造函数\"></a>命名的构造函数</h3><p>使用命名构造函数可以在一个类中定义多个构造函数，或者让一个类的作用对于开发人员来说更清晰：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Named constructor</span></span><br><span class=\"line\">  Point.origin() &#123;</span><br><span class=\"line\">    x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    y = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一定要记住构造函数是不会从父类继承的，这意味着父类的命名构造函数子类也不会继承。如果你希望使用在超类中定义的命名构造函数来创建子类，则必须在子类中实现该构造函数。</p>\n<h3 id=\"调用非默认的超类构造函数\"><a href=\"#调用非默认的超类构造函数\" class=\"headerlink\" title=\"调用非默认的超类构造函数\"></a>调用非默认的超类构造函数</h3><p>默认情况下，子类中的构造函数调用父类的未命名的无参数构造函数。父类的构造函数在构造函数体的开始处被调用。如果类中有使用初始化列表，初始化列表将在调用超类之前执行。综上所述，执行顺序如下:</p>\n<ul>\n<li>初始化列表</li>\n<li>超类中的无参数构造函数</li>\n<li>main类中的无参数构造函数</li>\n</ul>\n<p>如果超类没有未命名的无参数构造函数，则必须手动调用超类中的一个构造函数。在冒号(:)之后，在构造函数体(如果有的话)之前指定超类构造函数。</p>\n<p>在下例中，Employee类的构造函数中调用了他的超类Person中的命名构造函数。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> firstName;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person.fromJson(<span class=\"built_in\">Map</span> data) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'in Person'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Person does not have a default constructor;</span></span><br><span class=\"line\">  <span class=\"comment\">// you must call super.fromJson(data).</span></span><br><span class=\"line\">  Employee.fromJson(<span class=\"built_in\">Map</span> data) : <span class=\"keyword\">super</span>.fromJson(data) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'in Employee'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> emp = <span class=\"keyword\">new</span> Employee.fromJson(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Prints:</span></span><br><span class=\"line\">  <span class=\"comment\">// in Person</span></span><br><span class=\"line\">  <span class=\"comment\">// in Employee</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (emp <span class=\"keyword\">is</span> Person) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Type check</span></span><br><span class=\"line\">    emp.firstName = <span class=\"string\">'Bob'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  (emp <span class=\"keyword\">as</span> Person).firstName = <span class=\"string\">'Bob'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">///结果输出为</span><br><span class=\"line\">in Person</span><br><span class=\"line\">in Employee</span><br></pre></td></tr></table></figure>\n\n<p>因为父类构造函数的参数是在调用构造函数之前执行的，所以参数可以是表达式，比如函数调用:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  Employee() : <span class=\"keyword\">super</span>.fromJson(getDefaultData());</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>警告：在超类的构造函数的参数中不能使用this关键字。例如，参数可以调用static方法但是不能调用实例方法</p>\n</blockquote>\n<h3 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表\"></a>初始化列表</h3><p>除了调用超类构造函数之外，还可以在构造函数主体运行之前初始化实例变量。初始值设定项用逗号分开。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initializer list sets instance variables before</span></span><br><span class=\"line\"><span class=\"comment\">// the constructor body runs.</span></span><br><span class=\"line\">Point.fromJson(<span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">num</span>&gt; json)</span><br><span class=\"line\">    : x = json[<span class=\"string\">'x'</span>],</span><br><span class=\"line\">      y = json[<span class=\"string\">'y'</span>] &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In Point.fromJson(): (<span class=\"subst\">$x</span>, <span class=\"subst\">$y</span>)'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>警告:初始化器的右边部分中无法访问this关键字。</p>\n</blockquote>\n<p>在开发期间，可以通过在初始化列表中使用assert来验证输入。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.withAssert(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y) : <span class=\"keyword\">assert</span>(x &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">'In Point.withAssert(): (<span class=\"subst\">$x</span>, <span class=\"subst\">$y</span>)'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化列表在设置final字段时很方便。下面的示例初始化初始化列表中的三个final字段：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> y;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> distanceFromOrigin;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(x, y)</span><br><span class=\"line\">      : x = x,</span><br><span class=\"line\">        y = y,</span><br><span class=\"line\">        distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(p.distanceFromOrigin);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">///运行结果</span><br><span class=\"line\">3.605551275463989</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重定向构造函数\"><a href=\"#重定向构造函数\" class=\"headerlink\" title=\"重定向构造函数\"></a>重定向构造函数</h3><p>有时，构造函数的唯一目的是重定向到同一个类中的另一个构造函数。重定向构造函数的主体为空，构造函数调用出现在冒号(:)之后。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The main constructor for this class.</span></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Delegates to the main constructor.</span></span><br><span class=\"line\">  Point.alongXAxis(<span class=\"built_in\">num</span> x) : <span class=\"keyword\">this</span>(x, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常量构造函数\"><a href=\"#常量构造函数\" class=\"headerlink\" title=\"常量构造函数\"></a>常量构造函数</h3><p>如果您的类生成的对象不会改变，您可以使这些对象成为编译时常量。为此，定义一个const构造函数，并确保所有实例变量都是final的。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImmutablePoint</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutablePoint origin =</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ImmutablePoint(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"工厂构造函数\"><a href=\"#工厂构造函数\" class=\"headerlink\" title=\"工厂构造函数\"></a>工厂构造函数</h3><p>在实现构造函数时使用factory关键字，该构造函数并不总是创建类的新实例。例如，工厂构造函数可以从缓存返回实例，也可以返回子类型的实例。</p>\n<p>以下示例演示工厂构造函数从缓存返回对象:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> mute = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// _cache is library-private, thanks to</span></span><br><span class=\"line\">  <span class=\"comment\">// the _ in front of its name.</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, Logger&gt; _cache =</span><br><span class=\"line\">      &lt;<span class=\"built_in\">String</span>, Logger&gt;&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">factory</span> Logger(<span class=\"built_in\">String</span> name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_cache.containsKey(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _cache[name];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> logger = Logger._internal(name);</span><br><span class=\"line\">      _cache[name] = logger;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> logger;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Logger._internal(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> log(<span class=\"built_in\">String</span> msg) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mute) <span class=\"built_in\">print</span>(msg);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:工厂构造函数不能访问this关键字。</p>\n</blockquote>\n<p>调用工厂构造函数，就像调用其他构造函数一样:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> logger = Logger(<span class=\"string\">'UI'</span>);</span><br><span class=\"line\">logger.log(<span class=\"string\">'Button clicked'</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><blockquote>\n<p>方法是为对象提供行为的函数。</p>\n</blockquote>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><p>对象上的实例方法可以访问实例变量。下面示例中的distanceTo()方法是一个实例方法的示例:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">num</span> distanceTo(Point other) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dx = x - other.x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dy = y - other.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(dx * dx + dy * dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Getters-和-setters-方法\"><a href=\"#Getters-和-setters-方法\" class=\"headerlink\" title=\"Getters 和 setters 方法\"></a>Getters 和 setters 方法</h3><p>getter和setter是对对象属性的读写访问的特殊方法。回想一下，每个实例变量都有一个隐式的getter，如果需要的话还可以加上一个setter。使用get和set关键字来实现getter和setter方法可以来读写其他属性：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> left, top, width, height;</span><br><span class=\"line\"></span><br><span class=\"line\">  Rectangle(<span class=\"keyword\">this</span>.left, <span class=\"keyword\">this</span>.top, <span class=\"keyword\">this</span>.width, <span class=\"keyword\">this</span>.height);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Define two calculated properties: right and bottom.</span></span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> right =&gt; left + width;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> right(<span class=\"built_in\">num</span> value) =&gt; left = value - width;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> <span class=\"keyword\">get</span> bottom =&gt; top + height;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> bottom(<span class=\"built_in\">num</span> value) =&gt; top = value - height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rect = Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">20</span>, <span class=\"number\">15</span>);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">3</span>);</span><br><span class=\"line\">  rect.right = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(rect.left == <span class=\"number\">-8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用getter和setter，你可以使用方法包装实例变量，而无需改动业务代码。</p>\n<blockquote>\n<p>注意:诸如increment(++)之类的操作符以预期的方式工作，无论getter是否被显式定义。为了避免任何意外的副作用，操作符只调用getter一次，将其值保存在一个临时变量中。</p>\n</blockquote>\n<h3 id=\"抽象方法\"><a href=\"#抽象方法\" class=\"headerlink\" title=\"抽象方法\"></a>抽象方法</h3><p>实例方法、getter和setter方法可以是抽象方法，之定义一个接口但是将具体实现留给其他类。抽象方法只能存在于抽象类中，抽象方法是没有方法体的。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Doer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Define instance variables and methods...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> doSomething(); <span class=\"comment\">// Define an abstract method.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EffectiveDoer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Doer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> doSomething() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Provide an implementation, so the method is not abstract here...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用抽象方法会导致运行时错误。</p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>使用abstract修饰符定义不能实例化的抽象类。抽象类对于定义接口非常有用。如果您希望抽象类看起来是可实例化的，请定义一个工厂构造函数。</p>\n<p>抽象类通常有抽象方法。这里有一个声明抽象类的例子，它有一个抽象的方法:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This class is declared abstract and thus</span></span><br><span class=\"line\"><span class=\"comment\">// can't be instantiated.</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractContainer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Define constructors, fields, methods...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> updateChildren(); <span class=\"comment\">// Abstract method.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"隐式接口\"><a href=\"#隐式接口\" class=\"headerlink\" title=\"隐式接口\"></a>隐式接口</h2><p>每个类都隐式地定义一个接口，该接口包含类的所有实例成员及其实现的任何接口。如果您想创建一个类A，它支持类B的API而不继承B的实现，那么类A应该实现B接口。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A person. The implicit interface contains greet().</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// In the interface, but visible only in this library.</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> _name;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Not in the interface, since this is a constructor.</span></span><br><span class=\"line\">  Person(<span class=\"keyword\">this</span>._name);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// In the interface.</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hello, <span class=\"subst\">$who</span>. I am <span class=\"subst\">$_name</span>.'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// An implementation of the Person interface.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Impostor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> _name =&gt; <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">String</span> greet(<span class=\"built_in\">String</span> who) =&gt; <span class=\"string\">'Hi <span class=\"subst\">$who</span>. Do you know who I am?'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> greetBob(Person person) =&gt; person.greet(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Person(<span class=\"string\">'Kathy'</span>)));</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(greetBob(Impostor()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有一个例子，说明一个类实现多个接口:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>, <span class=\"title\">Location</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>使用extend创建子类，使用super引用超类:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;</span><br><span class=\"line\">    _illuminateDisplay();</span><br><span class=\"line\">    _activateIrSensor();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartTelevision</span> <span class=\"keyword\">extends</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.turnOn();</span><br><span class=\"line\">    _bootNetworkInterface();</span><br><span class=\"line\">    _initializeMemory();</span><br><span class=\"line\">    _upgradeApps();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重写类的成员\"><a href=\"#重写类的成员\" class=\"headerlink\" title=\"重写类的成员\"></a>重写类的成员</h2><p>子类可以覆盖实例方法、getter和setter。您可以使用@override注释来指示你重写了某个成员方法:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartTelevision</span> <span class=\"keyword\">extends</span> <span class=\"title\">Television</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> turnOn() &#123;...&#125;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要在类型安全的代码中缩小方法参数或实例变量的类型，可以使用covariant关键字。</p>\n<h3 id=\"重写操作符\"><a href=\"#重写操作符\" class=\"headerlink\" title=\"重写操作符\"></a>重写操作符</h3><p>您可以重写下表中显示的操作符。例如，如果定义一个Vector类，可以定义一个+方法来让两个向量相加。</p>\n<p><code>&lt;</code>    |<code>+</code>|    <code>|</code>    |<code>[]</code><br>–|–|–|–<br><code>&gt;</code>    |<code>/</code>|    <code>^</code>|    <code>[]=</code><br><code>&lt;=</code>|    <code>~/</code>|    <code>&amp;</code>|    <code>~</code><br><code>&gt;=</code>|    <code>*</code>    |<code>&lt;&lt;</code>|    <code>==</code><br><code>-</code>    |<code>%</code>    |<code>&gt;&gt;</code>|<br>下例在类中重写了+和-操作符：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> +(Vector v) =&gt; Vector(x + v.x, y + v.y);</span><br><span class=\"line\">  Vector <span class=\"keyword\">operator</span> -(Vector v) =&gt; Vector(x - v.x, y - v.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Operator == and hashCode not shown. For details, see note below.</span></span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> v = Vector(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> w = Vector(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(v + w == Vector(<span class=\"number\">4</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(v - w == Vector(<span class=\"number\">0</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果重写<code>==</code>，还应该重写对象的hashCode getter。有关override == 和hashCode的示例，请参见[ Implementing map keys]。</p>\n<p>有关重写的更多信息，请参见[扩展类]。</p>\n<h3 id=\"noSuchMethod\"><a href=\"#noSuchMethod\" class=\"headerlink\" title=\"noSuchMethod()\"></a>noSuchMethod()</h3><p>可以重写noSuchMethod()方法来处理程序访问一个不存在的方法或者成员变量：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Unless you override noSuchMethod, using a</span></span><br><span class=\"line\">  <span class=\"comment\">// non-existent member results in a NoSuchMethodError.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'You tried to use a non-existent member: '</span> +</span><br><span class=\"line\">        <span class=\"string\">'<span class=\"subst\">$&#123;invocation.memberName&#125;</span>'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>您不能调用未实现的方法，除非下列任何一个是正确的:</p>\n<ul>\n<li>被调用者有静态方法dynamic</li>\n<li>被调用者有一个静态类型来定义未实现的方法(抽象也可以OK)，而接收者的动态类型有一个noSuchMethod()的实现，它与类对象中的方法不同。</li>\n</ul>\n<h2 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h2><p>枚举类型，通常称为枚举或枚举类型，是一种特殊类型的类，用于表示固定数量的常量值。</p>\n<h3 id=\"使用枚举\"><a href=\"#使用枚举\" class=\"headerlink\" title=\"使用枚举\"></a>使用枚举</h3><p>使用enum关键字声明一个枚举类型：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123; red, green, blue &#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举中的每个值都有一个索引getter，它返回enum声明中值的从0开始的位置。例如，第一个值有索引0，第二个值有索引1。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(Color.red.index == <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(Color.green.index == <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(Color.blue.index == <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>要获取枚举中所有值的列表，请使用enum的values 常量。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class=\"line\"><span class=\"keyword\">assert</span>(colors[<span class=\"number\">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure>\n\n<p>您可以在switch语句中使用enum，如果switch的case不处理enum的所有值，将会报一个警告消息:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> aColor = Color.blue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span> (aColor) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> Color.red:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'Red as roses!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> Color.green:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">'Green as grass!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>: <span class=\"comment\">// Without this, you see a WARNING.</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(aColor); <span class=\"comment\">// 'Color.blue'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举类型有以下限制:</p>\n<ul>\n<li>不能子类化、混合或实现枚举。</li>\n<li>不能显式实例化一个枚举</li>\n</ul>\n<h2 id=\"为类添加mixins特性\"><a href=\"#为类添加mixins特性\" class=\"headerlink\" title=\"为类添加mixins特性\"></a>为类添加mixins特性</h2><p>mixin是在多个类层次结构中重用类代码的一种方式。</p>\n<p>要使用mixin，请在with关键字后面加上一个或多个mixin名称。下面的例子显示了两个使用mixin的类:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Musician</span> <span class=\"keyword\">extends</span> <span class=\"title\">Performer</span> <span class=\"title\">with</span> <span class=\"title\">Musical</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maestro</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">with</span> <span class=\"title\">Musical</span>, <span class=\"title\">Aggressive</span>, <span class=\"title\">Demented</span> </span>&#123;</span><br><span class=\"line\">  Maestro(<span class=\"built_in\">String</span> maestroName) &#123;</span><br><span class=\"line\">    name = maestroName;</span><br><span class=\"line\">    canConduct = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 要实现mixin，创建一个Object的子类，不声明构造函数，也不调用super。例如:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Musical</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canPlayPiano = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canCompose = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> canConduct = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> entertainMe() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canPlayPiano) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Playing piano'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (canConduct) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Waving hands'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">'Humming to self'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态变量和静态方法\"><a href=\"#静态变量和静态方法\" class=\"headerlink\" title=\"静态变量和静态方法\"></a>静态变量和静态方法</h2><p>使用static关键字实现类范围的变量和方法。</p>\n<h3 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h3><p>静态变量(类变量)对于类范围内的状态和常量是有用的:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> initialCapacity = <span class=\"number\">16</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ···</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(Queue.initialCapacity == <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>静态变量在使用之前不会初始化。</p>\n<blockquote>\n<p>注意:此页面遵循代码样式规范，对常量名使用小驼峰命名法。</p>\n</blockquote>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>静态方法(类方法)不对实例进行操作，因此无法访问该实例。例如:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">num</span> x, y;</span><br><span class=\"line\">  Point(<span class=\"keyword\">this</span>.x, <span class=\"keyword\">this</span>.y);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dx = a.x - b.x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dy = a.y - b.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(dx * dx + dy * dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = Point(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = Point(<span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> distance = Point.distanceBetween(a, b);</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(<span class=\"number\">2.8</span> &lt; distance &amp;&amp; distance &lt; <span class=\"number\">2.9</span>);</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(distance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意:对于通用或广泛使用的实用程序和功能，考虑使用顶级函数，而不是静态方法。</p>\n</blockquote>\n<p>可以使用静态方法作为编译时常量。例如，可以将静态方法作为参数传递给常量构造函数。</p>\n"},{"title":"ListView","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T16:36:00.000Z","_content":"## 介绍\n> ListView是最常用的可滚动widget，它可以沿一个方向线性排布所有子widget。\n\n```dart\nListView({\n    Key key,\n     //可滚动widget公共参数\n    Axis scrollDirection = Axis.vertical,\n    bool reverse = false,\n    ScrollController controller,\n    bool primary,\n    ScrollPhysics physics,\n    EdgeInsetsGeometry padding,\n    // ListView各个构造函数的共同参数 \n    this.itemExtent,\n    bool shrinkWrap = false,\n    bool addAutomaticKeepAlives = true,\n    bool addRepaintBoundaries = true,\n    bool addSemanticIndexes = true,\n    double cacheExtent,\n    // 子widget列表\n    List<Widget> children = const <Widget>[],\n    int semanticChildCount,\n  })\n```\n\n## 常用属性\n**childrenDelegate**：自定义子模型时用到。\n\n**itemExtent**：Item 的范围，scrollDirection 为 Axis.vertical 时限制高度，scrollDirection 为 Axis.horizontal 限制宽度。\n\n**cacheExtent**：预加载的区域。\n\n**controller**：滑动监听，值为一个 ScrollController 对象，这个属性应该可以用来做下拉刷新和上垃加载，后面详细研究。\n\n**padding**：整个 ListView 的内间距。\n\n**physics**：设置 ListView 如何响应用户的滑动行为，值为一个 ScrollPhysics 对象，它的实现类常用的有：\n    AlwaysScrollableScrollPhysics：总是可以滑动。\n    NeverScrollableScrollPhysics：禁止滚动。\n    BouncingScrollPhysics：内容超过一屏，上拉有回弹效果。\n    ClampingScrollPhysics：包裹内容，不会有回弹，感觉跟 AlwaysScrollableScrollPhysics 差不多。\n\n**primary**：是否是与 PrimaryScrollController 关联的主滚动视图，若为 true 则 controller 必须为空。  \n\n**reverse**：Item 的顺序是否反转，若为 true 则反转。\n\n**scrollDirection**：ListView 的方向，为 Axis.vertical 表示纵向，为 Axis.horizontal 表示横向。\n\n**shrinkWrap**：该属性表示是否根据子widget的总长度来设置ListView的长度，默认值为false 。默认情况下，ListView的会在滚动方向尽可能多的占用空间。当ListView在一个无边界(滚动方向上)的容器中时，shrinkWrap必须为true。\n\n**addAutomaticKeepAlives**：该属性表示是否将列表项（子widget）包裹在AutomaticKeepAlive widget中；典型地，在一个懒加载列表中，如果将列表项包裹在AutomaticKeepAlive中，在该列表项滑出视口时该列表项不会被GC，它会使用KeepAliveNotification来保存其状态。如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。\n\n**addRepaintBoundaries**：该属性表示是否将列表项（子widget）包裹在RepaintBoundary中。当可滚动widget滚动时，将列表项包裹在RepaintBoundary中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加RepaintBoundary反而会更高效。和addAutomaticKeepAlive一样，如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。\n\n## 默认构造函数\n默认构造函数有一个children参数，它接受一个Widget列表（List）。这种方式适合只有少量的子widget的情况，因为这种方式需要将所有children都提前创建好（这需要做大量工作），而不是等到子widget真正显示的时候再创建。实际上通过此方式创建的ListView和使用SingleChildScrollView+Column的方式没有本质的区别。下面是一个例子：\n\n```dart\nListView(\n  shrinkWrap: true, \n  padding: const EdgeInsets.all(20.0),\n  children: <Widget>[\n    const Text('I\\'m dedicating every day to you'),\n    const Text('Domestic life was never quite my style'),\n    const Text('When you smile, you knock me out, I fall apart'),\n    const Text('And I thought I was so smart'),\n  ],\n);\n```\n> *注意：可滚动widget通过一个List来作为其children属性时，只适用于子widget较少的情况，这是一个通用规律，并非ListView自己的特性，像GridView也是如此。\n\n## ListView.builder\n> 适合列表项多（无限)的情况，因为只有当Widget真正显示的时候才会被创建\n\n### 核心属性\n- **itemBuilder** 列表构造器，类型为IndexedWidgetBuilder，返回一个Widget。当列表滚动到具体的index位置时，会调用该构造器构造列表项。\n- **itemCount** 列表项的数量，如果为null，则是无限列表。\n### 示例\n```dart\nListView.builder(\n    itemCount: 100,\n    itemExtent: 50,\n    itemBuilder: (BuildContext context, int index) {\n    return ListTile(\n        title: Text('$index'),\n    );\n    },\n);\n```\n\n## ListView.separated\n> 可以生成列表项之间的分割器，它除了比ListView.builder多了一个separatorBuilder参数，该参数是一个分割器生成器。\n\n### 示例\n> 奇数行添加一条blue色下划线，偶数行添加一条pink色下划线。\n\n","source":"_posts/flutter/可滚动Widget/ListView.md","raw":"---\ntitle: ListView\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-27 00:36:00   \n---\n## 介绍\n> ListView是最常用的可滚动widget，它可以沿一个方向线性排布所有子widget。\n\n```dart\nListView({\n    Key key,\n     //可滚动widget公共参数\n    Axis scrollDirection = Axis.vertical,\n    bool reverse = false,\n    ScrollController controller,\n    bool primary,\n    ScrollPhysics physics,\n    EdgeInsetsGeometry padding,\n    // ListView各个构造函数的共同参数 \n    this.itemExtent,\n    bool shrinkWrap = false,\n    bool addAutomaticKeepAlives = true,\n    bool addRepaintBoundaries = true,\n    bool addSemanticIndexes = true,\n    double cacheExtent,\n    // 子widget列表\n    List<Widget> children = const <Widget>[],\n    int semanticChildCount,\n  })\n```\n\n## 常用属性\n**childrenDelegate**：自定义子模型时用到。\n\n**itemExtent**：Item 的范围，scrollDirection 为 Axis.vertical 时限制高度，scrollDirection 为 Axis.horizontal 限制宽度。\n\n**cacheExtent**：预加载的区域。\n\n**controller**：滑动监听，值为一个 ScrollController 对象，这个属性应该可以用来做下拉刷新和上垃加载，后面详细研究。\n\n**padding**：整个 ListView 的内间距。\n\n**physics**：设置 ListView 如何响应用户的滑动行为，值为一个 ScrollPhysics 对象，它的实现类常用的有：\n    AlwaysScrollableScrollPhysics：总是可以滑动。\n    NeverScrollableScrollPhysics：禁止滚动。\n    BouncingScrollPhysics：内容超过一屏，上拉有回弹效果。\n    ClampingScrollPhysics：包裹内容，不会有回弹，感觉跟 AlwaysScrollableScrollPhysics 差不多。\n\n**primary**：是否是与 PrimaryScrollController 关联的主滚动视图，若为 true 则 controller 必须为空。  \n\n**reverse**：Item 的顺序是否反转，若为 true 则反转。\n\n**scrollDirection**：ListView 的方向，为 Axis.vertical 表示纵向，为 Axis.horizontal 表示横向。\n\n**shrinkWrap**：该属性表示是否根据子widget的总长度来设置ListView的长度，默认值为false 。默认情况下，ListView的会在滚动方向尽可能多的占用空间。当ListView在一个无边界(滚动方向上)的容器中时，shrinkWrap必须为true。\n\n**addAutomaticKeepAlives**：该属性表示是否将列表项（子widget）包裹在AutomaticKeepAlive widget中；典型地，在一个懒加载列表中，如果将列表项包裹在AutomaticKeepAlive中，在该列表项滑出视口时该列表项不会被GC，它会使用KeepAliveNotification来保存其状态。如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。\n\n**addRepaintBoundaries**：该属性表示是否将列表项（子widget）包裹在RepaintBoundary中。当可滚动widget滚动时，将列表项包裹在RepaintBoundary中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加RepaintBoundary反而会更高效。和addAutomaticKeepAlive一样，如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。\n\n## 默认构造函数\n默认构造函数有一个children参数，它接受一个Widget列表（List）。这种方式适合只有少量的子widget的情况，因为这种方式需要将所有children都提前创建好（这需要做大量工作），而不是等到子widget真正显示的时候再创建。实际上通过此方式创建的ListView和使用SingleChildScrollView+Column的方式没有本质的区别。下面是一个例子：\n\n```dart\nListView(\n  shrinkWrap: true, \n  padding: const EdgeInsets.all(20.0),\n  children: <Widget>[\n    const Text('I\\'m dedicating every day to you'),\n    const Text('Domestic life was never quite my style'),\n    const Text('When you smile, you knock me out, I fall apart'),\n    const Text('And I thought I was so smart'),\n  ],\n);\n```\n> *注意：可滚动widget通过一个List来作为其children属性时，只适用于子widget较少的情况，这是一个通用规律，并非ListView自己的特性，像GridView也是如此。\n\n## ListView.builder\n> 适合列表项多（无限)的情况，因为只有当Widget真正显示的时候才会被创建\n\n### 核心属性\n- **itemBuilder** 列表构造器，类型为IndexedWidgetBuilder，返回一个Widget。当列表滚动到具体的index位置时，会调用该构造器构造列表项。\n- **itemCount** 列表项的数量，如果为null，则是无限列表。\n### 示例\n```dart\nListView.builder(\n    itemCount: 100,\n    itemExtent: 50,\n    itemBuilder: (BuildContext context, int index) {\n    return ListTile(\n        title: Text('$index'),\n    );\n    },\n);\n```\n\n## ListView.separated\n> 可以生成列表项之间的分割器，它除了比ListView.builder多了一个separatorBuilder参数，该参数是一个分割器生成器。\n\n### 示例\n> 奇数行添加一条blue色下划线，偶数行添加一条pink色下划线。\n\n","slug":"flutter/可滚动Widget/ListView","published":1,"updated":"2019-10-02T11:51:07.230Z","layout":"post","photos":[],"link":"","_id":"ck19bvb3f004c00wkmycf7cxn","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>ListView是最常用的可滚动widget，它可以沿一个方向线性排布所有子widget。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListView(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">     <span class=\"comment\">//可滚动widget公共参数</span></span><br><span class=\"line\">    Axis scrollDirection = Axis.vertical,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> reverse = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">    ScrollController controller,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> primary,</span><br><span class=\"line\">    ScrollPhysics physics,</span><br><span class=\"line\">    EdgeInsetsGeometry padding,</span><br><span class=\"line\">    <span class=\"comment\">// ListView各个构造函数的共同参数 </span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.itemExtent,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> shrinkWrap = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> addAutomaticKeepAlives = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> addRepaintBoundaries = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> addSemanticIndexes = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"built_in\">double</span> cacheExtent,</span><br><span class=\"line\">    <span class=\"comment\">// 子widget列表</span></span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],</span><br><span class=\"line\">    <span class=\"built_in\">int</span> semanticChildCount,</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用属性\"><a href=\"#常用属性\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h2><p><strong>childrenDelegate</strong>：自定义子模型时用到。</p>\n<p><strong>itemExtent</strong>：Item 的范围，scrollDirection 为 Axis.vertical 时限制高度，scrollDirection 为 Axis.horizontal 限制宽度。</p>\n<p><strong>cacheExtent</strong>：预加载的区域。</p>\n<p><strong>controller</strong>：滑动监听，值为一个 ScrollController 对象，这个属性应该可以用来做下拉刷新和上垃加载，后面详细研究。</p>\n<p><strong>padding</strong>：整个 ListView 的内间距。</p>\n<p><strong>physics</strong>：设置 ListView 如何响应用户的滑动行为，值为一个 ScrollPhysics 对象，它的实现类常用的有：<br>    AlwaysScrollableScrollPhysics：总是可以滑动。<br>    NeverScrollableScrollPhysics：禁止滚动。<br>    BouncingScrollPhysics：内容超过一屏，上拉有回弹效果。<br>    ClampingScrollPhysics：包裹内容，不会有回弹，感觉跟 AlwaysScrollableScrollPhysics 差不多。</p>\n<p><strong>primary</strong>：是否是与 PrimaryScrollController 关联的主滚动视图，若为 true 则 controller 必须为空。  </p>\n<p><strong>reverse</strong>：Item 的顺序是否反转，若为 true 则反转。</p>\n<p><strong>scrollDirection</strong>：ListView 的方向，为 Axis.vertical 表示纵向，为 Axis.horizontal 表示横向。</p>\n<p><strong>shrinkWrap</strong>：该属性表示是否根据子widget的总长度来设置ListView的长度，默认值为false 。默认情况下，ListView的会在滚动方向尽可能多的占用空间。当ListView在一个无边界(滚动方向上)的容器中时，shrinkWrap必须为true。</p>\n<p><strong>addAutomaticKeepAlives</strong>：该属性表示是否将列表项（子widget）包裹在AutomaticKeepAlive widget中；典型地，在一个懒加载列表中，如果将列表项包裹在AutomaticKeepAlive中，在该列表项滑出视口时该列表项不会被GC，它会使用KeepAliveNotification来保存其状态。如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。</p>\n<p><strong>addRepaintBoundaries</strong>：该属性表示是否将列表项（子widget）包裹在RepaintBoundary中。当可滚动widget滚动时，将列表项包裹在RepaintBoundary中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加RepaintBoundary反而会更高效。和addAutomaticKeepAlive一样，如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。</p>\n<h2 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h2><p>默认构造函数有一个children参数，它接受一个Widget列表（List）。这种方式适合只有少量的子widget的情况，因为这种方式需要将所有children都提前创建好（这需要做大量工作），而不是等到子widget真正显示的时候再创建。实际上通过此方式创建的ListView和使用SingleChildScrollView+Column的方式没有本质的区别。下面是一个例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListView(</span><br><span class=\"line\">  shrinkWrap: <span class=\"keyword\">true</span>, </span><br><span class=\"line\">  padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">20.0</span>),</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Text(<span class=\"string\">'I\\'m dedicating every day to you'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Text(<span class=\"string\">'Domestic life was never quite my style'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Text(<span class=\"string\">'When you smile, you knock me out, I fall apart'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Text(<span class=\"string\">'And I thought I was so smart'</span>),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>*注意：可滚动widget通过一个List来作为其children属性时，只适用于子widget较少的情况，这是一个通用规律，并非ListView自己的特性，像GridView也是如此。</p>\n</blockquote>\n<h2 id=\"ListView-builder\"><a href=\"#ListView-builder\" class=\"headerlink\" title=\"ListView.builder\"></a>ListView.builder</h2><blockquote>\n<p>适合列表项多（无限)的情况，因为只有当Widget真正显示的时候才会被创建</p>\n</blockquote>\n<h3 id=\"核心属性\"><a href=\"#核心属性\" class=\"headerlink\" title=\"核心属性\"></a>核心属性</h3><ul>\n<li><strong>itemBuilder</strong> 列表构造器，类型为IndexedWidgetBuilder，返回一个Widget。当列表滚动到具体的index位置时，会调用该构造器构造列表项。</li>\n<li><strong>itemCount</strong> 列表项的数量，如果为null，则是无限列表。<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListView.builder(</span><br><span class=\"line\">    itemCount: <span class=\"number\">100</span>,</span><br><span class=\"line\">    itemExtent: <span class=\"number\">50</span>,</span><br><span class=\"line\">    itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ListTile(</span><br><span class=\"line\">        title: Text(<span class=\"string\">'<span class=\"subst\">$index</span>'</span>),</span><br><span class=\"line\">    );</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"ListView-separated\"><a href=\"#ListView-separated\" class=\"headerlink\" title=\"ListView.separated\"></a>ListView.separated</h2><blockquote>\n<p>可以生成列表项之间的分割器，它除了比ListView.builder多了一个separatorBuilder参数，该参数是一个分割器生成器。</p>\n</blockquote>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><blockquote>\n<p>奇数行添加一条blue色下划线，偶数行添加一条pink色下划线。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>ListView是最常用的可滚动widget，它可以沿一个方向线性排布所有子widget。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListView(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">     <span class=\"comment\">//可滚动widget公共参数</span></span><br><span class=\"line\">    Axis scrollDirection = Axis.vertical,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> reverse = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">    ScrollController controller,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> primary,</span><br><span class=\"line\">    ScrollPhysics physics,</span><br><span class=\"line\">    EdgeInsetsGeometry padding,</span><br><span class=\"line\">    <span class=\"comment\">// ListView各个构造函数的共同参数 </span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.itemExtent,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> shrinkWrap = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> addAutomaticKeepAlives = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> addRepaintBoundaries = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> addSemanticIndexes = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"built_in\">double</span> cacheExtent,</span><br><span class=\"line\">    <span class=\"comment\">// 子widget列表</span></span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],</span><br><span class=\"line\">    <span class=\"built_in\">int</span> semanticChildCount,</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常用属性\"><a href=\"#常用属性\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h2><p><strong>childrenDelegate</strong>：自定义子模型时用到。</p>\n<p><strong>itemExtent</strong>：Item 的范围，scrollDirection 为 Axis.vertical 时限制高度，scrollDirection 为 Axis.horizontal 限制宽度。</p>\n<p><strong>cacheExtent</strong>：预加载的区域。</p>\n<p><strong>controller</strong>：滑动监听，值为一个 ScrollController 对象，这个属性应该可以用来做下拉刷新和上垃加载，后面详细研究。</p>\n<p><strong>padding</strong>：整个 ListView 的内间距。</p>\n<p><strong>physics</strong>：设置 ListView 如何响应用户的滑动行为，值为一个 ScrollPhysics 对象，它的实现类常用的有：<br>    AlwaysScrollableScrollPhysics：总是可以滑动。<br>    NeverScrollableScrollPhysics：禁止滚动。<br>    BouncingScrollPhysics：内容超过一屏，上拉有回弹效果。<br>    ClampingScrollPhysics：包裹内容，不会有回弹，感觉跟 AlwaysScrollableScrollPhysics 差不多。</p>\n<p><strong>primary</strong>：是否是与 PrimaryScrollController 关联的主滚动视图，若为 true 则 controller 必须为空。  </p>\n<p><strong>reverse</strong>：Item 的顺序是否反转，若为 true 则反转。</p>\n<p><strong>scrollDirection</strong>：ListView 的方向，为 Axis.vertical 表示纵向，为 Axis.horizontal 表示横向。</p>\n<p><strong>shrinkWrap</strong>：该属性表示是否根据子widget的总长度来设置ListView的长度，默认值为false 。默认情况下，ListView的会在滚动方向尽可能多的占用空间。当ListView在一个无边界(滚动方向上)的容器中时，shrinkWrap必须为true。</p>\n<p><strong>addAutomaticKeepAlives</strong>：该属性表示是否将列表项（子widget）包裹在AutomaticKeepAlive widget中；典型地，在一个懒加载列表中，如果将列表项包裹在AutomaticKeepAlive中，在该列表项滑出视口时该列表项不会被GC，它会使用KeepAliveNotification来保存其状态。如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。</p>\n<p><strong>addRepaintBoundaries</strong>：该属性表示是否将列表项（子widget）包裹在RepaintBoundary中。当可滚动widget滚动时，将列表项包裹在RepaintBoundary中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加RepaintBoundary反而会更高效。和addAutomaticKeepAlive一样，如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。</p>\n<h2 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h2><p>默认构造函数有一个children参数，它接受一个Widget列表（List）。这种方式适合只有少量的子widget的情况，因为这种方式需要将所有children都提前创建好（这需要做大量工作），而不是等到子widget真正显示的时候再创建。实际上通过此方式创建的ListView和使用SingleChildScrollView+Column的方式没有本质的区别。下面是一个例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListView(</span><br><span class=\"line\">  shrinkWrap: <span class=\"keyword\">true</span>, </span><br><span class=\"line\">  padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">20.0</span>),</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Text(<span class=\"string\">'I\\'m dedicating every day to you'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Text(<span class=\"string\">'Domestic life was never quite my style'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Text(<span class=\"string\">'When you smile, you knock me out, I fall apart'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Text(<span class=\"string\">'And I thought I was so smart'</span>),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>*注意：可滚动widget通过一个List来作为其children属性时，只适用于子widget较少的情况，这是一个通用规律，并非ListView自己的特性，像GridView也是如此。</p>\n</blockquote>\n<h2 id=\"ListView-builder\"><a href=\"#ListView-builder\" class=\"headerlink\" title=\"ListView.builder\"></a>ListView.builder</h2><blockquote>\n<p>适合列表项多（无限)的情况，因为只有当Widget真正显示的时候才会被创建</p>\n</blockquote>\n<h3 id=\"核心属性\"><a href=\"#核心属性\" class=\"headerlink\" title=\"核心属性\"></a>核心属性</h3><ul>\n<li><strong>itemBuilder</strong> 列表构造器，类型为IndexedWidgetBuilder，返回一个Widget。当列表滚动到具体的index位置时，会调用该构造器构造列表项。</li>\n<li><strong>itemCount</strong> 列表项的数量，如果为null，则是无限列表。<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListView.builder(</span><br><span class=\"line\">    itemCount: <span class=\"number\">100</span>,</span><br><span class=\"line\">    itemExtent: <span class=\"number\">50</span>,</span><br><span class=\"line\">    itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ListTile(</span><br><span class=\"line\">        title: Text(<span class=\"string\">'<span class=\"subst\">$index</span>'</span>),</span><br><span class=\"line\">    );</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"ListView-separated\"><a href=\"#ListView-separated\" class=\"headerlink\" title=\"ListView.separated\"></a>ListView.separated</h2><blockquote>\n<p>可以生成列表项之间的分割器，它除了比ListView.builder多了一个separatorBuilder参数，该参数是一个分割器生成器。</p>\n</blockquote>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><blockquote>\n<p>奇数行添加一条blue色下划线，偶数行添加一条pink色下划线。</p>\n</blockquote>\n"},{"title":"可滚动Widget","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T15:14:00.000Z","_content":"## 可滚动Widget简介\n当内容超过显示窗口（ViewPort)时，如果没有特殊处理，Flutter会提示Overflow错误。为此，Flutter提供了多种可滚动Widget用于显示列表和长布局。如ListView、GridView等。\n```dart\nScrollable({\n    ...\n    this.axisDirection = AxisDirection.down,\n    this.controller,\n    this.physics,\n    @required this.viewportBuilder,// 后面介绍\n})\n```\n- axisDirection：滚动方向。\n- physics：此属性接受一个ScrollPhysics对象，它决定可滚动Widget如何响应用户操作。\n- controller：此属性接受一个ScrollController对象。ScrollController的主要作用是控制滚动位置和监听滚动事件。\n\n## Scrollbar\nScrollbar是一个Material风格的滚动指示器（滚动条），如果要给可滚动widget添加滚动条，只需要将Scrollbar作为可股东widget的服widget即可，如：\n```dart\nScrollbar(\n    child: SingleChildScrollView(\n        ...\n    ),\n);\n```\nScrollbar和CupertionScrollbar都是通过ScrollController来监听滚动时间来确定滚动条位置，关于ScrollController详细的内容我们将在后面专门一节介绍。\n\n## CupertionScrollbar\nCupertinoScrollbar是iOS风格的滚动条，如果你使用的是Scrollbar，那么在iOS平台它会自动切换为CupertinoScrollbar。\n\n## ViewPort视口\n在很多布局系统中都有ViewPort的概念，在Flutter中，术语ViewPort（视口），如无特别说明，则是指一个Widget的实际显示区域。例如，一个ListView的显示区域高度是800像素，虽然其列表项总高度可能远远超过800像素，但是其ViewPort仍然是800像素。\n\n## 主轴和纵轴\n在可滚动widget的坐标描述中，通常将滚动方向的陈为主轴，非滚动方向称为纵轴。\n","source":"_posts/flutter/可滚动Widget/可滚动Widget.md","raw":"---\ntitle: 可滚动Widget\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 23:14:00   \n---\n## 可滚动Widget简介\n当内容超过显示窗口（ViewPort)时，如果没有特殊处理，Flutter会提示Overflow错误。为此，Flutter提供了多种可滚动Widget用于显示列表和长布局。如ListView、GridView等。\n```dart\nScrollable({\n    ...\n    this.axisDirection = AxisDirection.down,\n    this.controller,\n    this.physics,\n    @required this.viewportBuilder,// 后面介绍\n})\n```\n- axisDirection：滚动方向。\n- physics：此属性接受一个ScrollPhysics对象，它决定可滚动Widget如何响应用户操作。\n- controller：此属性接受一个ScrollController对象。ScrollController的主要作用是控制滚动位置和监听滚动事件。\n\n## Scrollbar\nScrollbar是一个Material风格的滚动指示器（滚动条），如果要给可滚动widget添加滚动条，只需要将Scrollbar作为可股东widget的服widget即可，如：\n```dart\nScrollbar(\n    child: SingleChildScrollView(\n        ...\n    ),\n);\n```\nScrollbar和CupertionScrollbar都是通过ScrollController来监听滚动时间来确定滚动条位置，关于ScrollController详细的内容我们将在后面专门一节介绍。\n\n## CupertionScrollbar\nCupertinoScrollbar是iOS风格的滚动条，如果你使用的是Scrollbar，那么在iOS平台它会自动切换为CupertinoScrollbar。\n\n## ViewPort视口\n在很多布局系统中都有ViewPort的概念，在Flutter中，术语ViewPort（视口），如无特别说明，则是指一个Widget的实际显示区域。例如，一个ListView的显示区域高度是800像素，虽然其列表项总高度可能远远超过800像素，但是其ViewPort仍然是800像素。\n\n## 主轴和纵轴\n在可滚动widget的坐标描述中，通常将滚动方向的陈为主轴，非滚动方向称为纵轴。\n","slug":"flutter/可滚动Widget/可滚动Widget","published":1,"updated":"2019-10-02T11:50:57.496Z","layout":"post","photos":[],"link":"","_id":"ck19bvb3j004e00wk2yv4iama","content":"<h2 id=\"可滚动Widget简介\"><a href=\"#可滚动Widget简介\" class=\"headerlink\" title=\"可滚动Widget简介\"></a>可滚动Widget简介</h2><p>当内容超过显示窗口（ViewPort)时，如果没有特殊处理，Flutter会提示Overflow错误。为此，Flutter提供了多种可滚动Widget用于显示列表和长布局。如ListView、GridView等。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scrollable(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.axisDirection = AxisDirection.down,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.controller,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.physics,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.viewportBuilder,<span class=\"comment\">// 后面介绍</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>axisDirection：滚动方向。</li>\n<li>physics：此属性接受一个ScrollPhysics对象，它决定可滚动Widget如何响应用户操作。</li>\n<li>controller：此属性接受一个ScrollController对象。ScrollController的主要作用是控制滚动位置和监听滚动事件。</li>\n</ul>\n<h2 id=\"Scrollbar\"><a href=\"#Scrollbar\" class=\"headerlink\" title=\"Scrollbar\"></a>Scrollbar</h2><p>Scrollbar是一个Material风格的滚动指示器（滚动条），如果要给可滚动widget添加滚动条，只需要将Scrollbar作为可股东widget的服widget即可，如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scrollbar(</span><br><span class=\"line\">    child: SingleChildScrollView(</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>Scrollbar和CupertionScrollbar都是通过ScrollController来监听滚动时间来确定滚动条位置，关于ScrollController详细的内容我们将在后面专门一节介绍。</p>\n<h2 id=\"CupertionScrollbar\"><a href=\"#CupertionScrollbar\" class=\"headerlink\" title=\"CupertionScrollbar\"></a>CupertionScrollbar</h2><p>CupertinoScrollbar是iOS风格的滚动条，如果你使用的是Scrollbar，那么在iOS平台它会自动切换为CupertinoScrollbar。</p>\n<h2 id=\"ViewPort视口\"><a href=\"#ViewPort视口\" class=\"headerlink\" title=\"ViewPort视口\"></a>ViewPort视口</h2><p>在很多布局系统中都有ViewPort的概念，在Flutter中，术语ViewPort（视口），如无特别说明，则是指一个Widget的实际显示区域。例如，一个ListView的显示区域高度是800像素，虽然其列表项总高度可能远远超过800像素，但是其ViewPort仍然是800像素。</p>\n<h2 id=\"主轴和纵轴\"><a href=\"#主轴和纵轴\" class=\"headerlink\" title=\"主轴和纵轴\"></a>主轴和纵轴</h2><p>在可滚动widget的坐标描述中，通常将滚动方向的陈为主轴，非滚动方向称为纵轴。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"可滚动Widget简介\"><a href=\"#可滚动Widget简介\" class=\"headerlink\" title=\"可滚动Widget简介\"></a>可滚动Widget简介</h2><p>当内容超过显示窗口（ViewPort)时，如果没有特殊处理，Flutter会提示Overflow错误。为此，Flutter提供了多种可滚动Widget用于显示列表和长布局。如ListView、GridView等。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scrollable(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.axisDirection = AxisDirection.down,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.controller,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.physics,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.viewportBuilder,<span class=\"comment\">// 后面介绍</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>axisDirection：滚动方向。</li>\n<li>physics：此属性接受一个ScrollPhysics对象，它决定可滚动Widget如何响应用户操作。</li>\n<li>controller：此属性接受一个ScrollController对象。ScrollController的主要作用是控制滚动位置和监听滚动事件。</li>\n</ul>\n<h2 id=\"Scrollbar\"><a href=\"#Scrollbar\" class=\"headerlink\" title=\"Scrollbar\"></a>Scrollbar</h2><p>Scrollbar是一个Material风格的滚动指示器（滚动条），如果要给可滚动widget添加滚动条，只需要将Scrollbar作为可股东widget的服widget即可，如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scrollbar(</span><br><span class=\"line\">    child: SingleChildScrollView(</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>Scrollbar和CupertionScrollbar都是通过ScrollController来监听滚动时间来确定滚动条位置，关于ScrollController详细的内容我们将在后面专门一节介绍。</p>\n<h2 id=\"CupertionScrollbar\"><a href=\"#CupertionScrollbar\" class=\"headerlink\" title=\"CupertionScrollbar\"></a>CupertionScrollbar</h2><p>CupertinoScrollbar是iOS风格的滚动条，如果你使用的是Scrollbar，那么在iOS平台它会自动切换为CupertinoScrollbar。</p>\n<h2 id=\"ViewPort视口\"><a href=\"#ViewPort视口\" class=\"headerlink\" title=\"ViewPort视口\"></a>ViewPort视口</h2><p>在很多布局系统中都有ViewPort的概念，在Flutter中，术语ViewPort（视口），如无特别说明，则是指一个Widget的实际显示区域。例如，一个ListView的显示区域高度是800像素，虽然其列表项总高度可能远远超过800像素，但是其ViewPort仍然是800像素。</p>\n<h2 id=\"主轴和纵轴\"><a href=\"#主轴和纵轴\" class=\"headerlink\" title=\"主轴和纵轴\"></a>主轴和纵轴</h2><p>在可滚动widget的坐标描述中，通常将滚动方向的陈为主轴，非滚动方向称为纵轴。</p>\n"},{"title":"Scaffold","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-22T08:14:00.000Z","_content":"## Material 介绍\n### Material Design （质感设计）\n是由Google推出的全新设计语言，旨在为手机、平板电脑、台式机和其他平台提供更一致、更广泛的外观和感觉。从2014年开始，Android到衍生的Android Wear、Auto和TV，Material Design贯穿其中，成为勾通不同平台、设备的灵魂，让用户在不同平台上也有连贯的体验。为了维护这种一致，Google不允许第三方修改Android Wear、Auto和TV的界面以及交互\n\n### Flutter Material \n> Flutter 的 Material 组件\n通过在应用间和平台间提供一个统一的用户体验组件库，把设计和工程合二为一。秉承着 Google 的前端开发标准，Material Design 系统正在向多端一致体验、像素级完美呈现的方向发展。Material Design 组件（MDC）也同样适用于 Android、iOS 和 Web。\n\n## Scaffold\n> Scaffold 实现了基本的 Material 布局。只要是在 Material 中定义了的单个界面显示的布局控件元素，都可以使用 Scaffold 来绘制。\n\n提供展示抽屉(drawers，比如：左边栏)、通知(snack bars) 以及 底部按钮（bottom sheets)。\n\n### 构造函数\n```dart\n///  * [AppBar], which is a horizontal bar typically shown at the top of an app\n///    using the [appBar] property.\n///  * [BottomAppBar], which is a horizontal bar typically shown at the bottom\n///    of an app using the [bottomNavigationBar] property.\n///  * [FloatingActionButton], which is a circular button typically shown in the\n///    bottom right corner of the app using the [floatingActionButton] property.\n///  * [Drawer], which is a vertical panel that is typically displayed to the\n///    left of the body (and often hidden on phones) using the [drawer]\n///    property.\n///  * [BottomNavigationBar], which is a horizontal array of buttons typically\n///    shown along the bottom of the app using the [bottomNavigationBar]\n///    property.\n///  * [SnackBar], which is a temporary notification typically shown near the\n///    bottom of the app using the [ScaffoldState.showSnackBar] method.\n///  * [BottomSheet], which is an overlay typically shown near the bottom of the\n///    app. A bottom sheet can either be persistent, in which case it is shown\n///    using the [ScaffoldState.showBottomSheet] method, or modal, in which case\n///    it is shown using the [showModalBottomSheet] function.\n///  * [ScaffoldState], which is the state associated with this widget.\n///  * <https://material.io/design/layout/responsive-layout-grid.html>\nclass Scaffold extends StatefulWidget {\n  /// Creates a visual scaffold for material design widgets.\n  const Scaffold({\n    Key key,\n    this.appBar,\n    this.body,\n    this.floatingActionButton,\n    this.floatingActionButtonLocation,\n    this.floatingActionButtonAnimator,\n    this.persistentFooterButtons,\n    this.drawer,\n    this.endDrawer,\n    this.bottomNavigationBar,\n    this.bottomSheet,\n    this.backgroundColor,\n    this.resizeToAvoidBottomPadding = true,\n    this.primary = true,\n  }) : assert(primary != null), super(key: key);\n```\n属性\t|说明\n--|--\nappBar\t|显示在Scaffold 顶部 相关连接：https://flutterchina.club/catalog/samples/\nbody\t|当前界面所显示的主要内容\nfloatingActionButton\t|默认右下角的悬浮按钮\nfloatingActionButtonLocation|\t悬浮按钮位置，默认右下角\nfloatingActionButtonAnimator|\t悬浮按钮位置位置变换动画\npersistentFooterButtons\t| 固定在下方显示的按钮。https://material.google.com/components/buttons.html#buttons-persistent-footer-buttons\nbottomNavigationBar\t| 显示在底部的导航栏按钮栏\nbottomSheet\t| 底部按钮\ndrawer | 侧边栏控件\nbackgroundColor| 背景颜色\nresizeToAvoidBottomPadding|控制界面内容 body 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。\n\n### 示例\n```dart\nreturn MaterialApp(\n  home: Scaffold(\n    appBar: AppBar(\n      title: Text(\"这里是 appBar\"),\n    ),\n    body: Container(\n      color: Colors.pink,\n      alignment: Alignment.center,\n      child: Text(\n        \"这里是 Body\",\n        style: TextStyle(color: Colors.white),\n      ),\n    ),\n    floatingActionButton: FloatingActionButton(\n      // 长按时显示的提示\n      tooltip: \"你长按了\",\n      // 前景色\n      foregroundColor: Colors.black,\n      // 背景色\n      backgroundColor: Colors.white,\n      // heroTag :hero效果使用的tag\n      // 未点击时的阴影值\n      elevation: 5.0,\n      // 按下时的阴影值\n      highlightElevation: 12.0,\n\n      child: Icon(Icons.add),\n      onPressed: () {\n        print('你点击了我!');\n      },\n    ),\n    bottomNavigationBar: BottomAppBar(\n      child: Container(\n        height: 100.0,\n        alignment: Alignment.center,\n        child: Text(\"这里是bottomNavigationBar\"),\n      ),\n    ),\n    persistentFooterButtons: <Widget>[\n      Icon(Icons.access_alarms),\n      Icon(Icons.dashboard)\n    ],\n  ),\n);\n```\n![](img/scaffold.jpg)","source":"_posts/flutter/widget/16_Material_Scaffold.md","raw":"---\ntitle: Scaffold\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-22 16:14:00   \n---\n## Material 介绍\n### Material Design （质感设计）\n是由Google推出的全新设计语言，旨在为手机、平板电脑、台式机和其他平台提供更一致、更广泛的外观和感觉。从2014年开始，Android到衍生的Android Wear、Auto和TV，Material Design贯穿其中，成为勾通不同平台、设备的灵魂，让用户在不同平台上也有连贯的体验。为了维护这种一致，Google不允许第三方修改Android Wear、Auto和TV的界面以及交互\n\n### Flutter Material \n> Flutter 的 Material 组件\n通过在应用间和平台间提供一个统一的用户体验组件库，把设计和工程合二为一。秉承着 Google 的前端开发标准，Material Design 系统正在向多端一致体验、像素级完美呈现的方向发展。Material Design 组件（MDC）也同样适用于 Android、iOS 和 Web。\n\n## Scaffold\n> Scaffold 实现了基本的 Material 布局。只要是在 Material 中定义了的单个界面显示的布局控件元素，都可以使用 Scaffold 来绘制。\n\n提供展示抽屉(drawers，比如：左边栏)、通知(snack bars) 以及 底部按钮（bottom sheets)。\n\n### 构造函数\n```dart\n///  * [AppBar], which is a horizontal bar typically shown at the top of an app\n///    using the [appBar] property.\n///  * [BottomAppBar], which is a horizontal bar typically shown at the bottom\n///    of an app using the [bottomNavigationBar] property.\n///  * [FloatingActionButton], which is a circular button typically shown in the\n///    bottom right corner of the app using the [floatingActionButton] property.\n///  * [Drawer], which is a vertical panel that is typically displayed to the\n///    left of the body (and often hidden on phones) using the [drawer]\n///    property.\n///  * [BottomNavigationBar], which is a horizontal array of buttons typically\n///    shown along the bottom of the app using the [bottomNavigationBar]\n///    property.\n///  * [SnackBar], which is a temporary notification typically shown near the\n///    bottom of the app using the [ScaffoldState.showSnackBar] method.\n///  * [BottomSheet], which is an overlay typically shown near the bottom of the\n///    app. A bottom sheet can either be persistent, in which case it is shown\n///    using the [ScaffoldState.showBottomSheet] method, or modal, in which case\n///    it is shown using the [showModalBottomSheet] function.\n///  * [ScaffoldState], which is the state associated with this widget.\n///  * <https://material.io/design/layout/responsive-layout-grid.html>\nclass Scaffold extends StatefulWidget {\n  /// Creates a visual scaffold for material design widgets.\n  const Scaffold({\n    Key key,\n    this.appBar,\n    this.body,\n    this.floatingActionButton,\n    this.floatingActionButtonLocation,\n    this.floatingActionButtonAnimator,\n    this.persistentFooterButtons,\n    this.drawer,\n    this.endDrawer,\n    this.bottomNavigationBar,\n    this.bottomSheet,\n    this.backgroundColor,\n    this.resizeToAvoidBottomPadding = true,\n    this.primary = true,\n  }) : assert(primary != null), super(key: key);\n```\n属性\t|说明\n--|--\nappBar\t|显示在Scaffold 顶部 相关连接：https://flutterchina.club/catalog/samples/\nbody\t|当前界面所显示的主要内容\nfloatingActionButton\t|默认右下角的悬浮按钮\nfloatingActionButtonLocation|\t悬浮按钮位置，默认右下角\nfloatingActionButtonAnimator|\t悬浮按钮位置位置变换动画\npersistentFooterButtons\t| 固定在下方显示的按钮。https://material.google.com/components/buttons.html#buttons-persistent-footer-buttons\nbottomNavigationBar\t| 显示在底部的导航栏按钮栏\nbottomSheet\t| 底部按钮\ndrawer | 侧边栏控件\nbackgroundColor| 背景颜色\nresizeToAvoidBottomPadding|控制界面内容 body 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。\n\n### 示例\n```dart\nreturn MaterialApp(\n  home: Scaffold(\n    appBar: AppBar(\n      title: Text(\"这里是 appBar\"),\n    ),\n    body: Container(\n      color: Colors.pink,\n      alignment: Alignment.center,\n      child: Text(\n        \"这里是 Body\",\n        style: TextStyle(color: Colors.white),\n      ),\n    ),\n    floatingActionButton: FloatingActionButton(\n      // 长按时显示的提示\n      tooltip: \"你长按了\",\n      // 前景色\n      foregroundColor: Colors.black,\n      // 背景色\n      backgroundColor: Colors.white,\n      // heroTag :hero效果使用的tag\n      // 未点击时的阴影值\n      elevation: 5.0,\n      // 按下时的阴影值\n      highlightElevation: 12.0,\n\n      child: Icon(Icons.add),\n      onPressed: () {\n        print('你点击了我!');\n      },\n    ),\n    bottomNavigationBar: BottomAppBar(\n      child: Container(\n        height: 100.0,\n        alignment: Alignment.center,\n        child: Text(\"这里是bottomNavigationBar\"),\n      ),\n    ),\n    persistentFooterButtons: <Widget>[\n      Icon(Icons.access_alarms),\n      Icon(Icons.dashboard)\n    ],\n  ),\n);\n```\n![](img/scaffold.jpg)","slug":"flutter/widget/16_Material_Scaffold","published":1,"updated":"2019-10-02T11:51:15.268Z","layout":"post","photos":[],"link":"","_id":"ck19bvb3p004i00wk6etgetwm","content":"<h2 id=\"Material-介绍\"><a href=\"#Material-介绍\" class=\"headerlink\" title=\"Material 介绍\"></a>Material 介绍</h2><h3 id=\"Material-Design-（质感设计）\"><a href=\"#Material-Design-（质感设计）\" class=\"headerlink\" title=\"Material Design （质感设计）\"></a>Material Design （质感设计）</h3><p>是由Google推出的全新设计语言，旨在为手机、平板电脑、台式机和其他平台提供更一致、更广泛的外观和感觉。从2014年开始，Android到衍生的Android Wear、Auto和TV，Material Design贯穿其中，成为勾通不同平台、设备的灵魂，让用户在不同平台上也有连贯的体验。为了维护这种一致，Google不允许第三方修改Android Wear、Auto和TV的界面以及交互</p>\n<h3 id=\"Flutter-Material\"><a href=\"#Flutter-Material\" class=\"headerlink\" title=\"Flutter Material\"></a>Flutter Material</h3><blockquote>\n<p>Flutter 的 Material 组件<br>通过在应用间和平台间提供一个统一的用户体验组件库，把设计和工程合二为一。秉承着 Google 的前端开发标准，Material Design 系统正在向多端一致体验、像素级完美呈现的方向发展。Material Design 组件（MDC）也同样适用于 Android、iOS 和 Web。</p>\n</blockquote>\n<h2 id=\"Scaffold\"><a href=\"#Scaffold\" class=\"headerlink\" title=\"Scaffold\"></a>Scaffold</h2><blockquote>\n<p>Scaffold 实现了基本的 Material 布局。只要是在 Material 中定义了的单个界面显示的布局控件元素，都可以使用 Scaffold 来绘制。</p>\n</blockquote>\n<p>提供展示抽屉(drawers，比如：左边栏)、通知(snack bars) 以及 底部按钮（bottom sheets)。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///  * [AppBar], which is a horizontal bar typically shown at the top of an app</span></span><br><span class=\"line\"><span class=\"comment\">///    using the [appBar] property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [BottomAppBar], which is a horizontal bar typically shown at the bottom</span></span><br><span class=\"line\"><span class=\"comment\">///    of an app using the [bottomNavigationBar] property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [FloatingActionButton], which is a circular button typically shown in the</span></span><br><span class=\"line\"><span class=\"comment\">///    bottom right corner of the app using the [floatingActionButton] property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [Drawer], which is a vertical panel that is typically displayed to the</span></span><br><span class=\"line\"><span class=\"comment\">///    left of the body (and often hidden on phones) using the [drawer]</span></span><br><span class=\"line\"><span class=\"comment\">///    property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [BottomNavigationBar], which is a horizontal array of buttons typically</span></span><br><span class=\"line\"><span class=\"comment\">///    shown along the bottom of the app using the [bottomNavigationBar]</span></span><br><span class=\"line\"><span class=\"comment\">///    property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [SnackBar], which is a temporary notification typically shown near the</span></span><br><span class=\"line\"><span class=\"comment\">///    bottom of the app using the [ScaffoldState.showSnackBar] method.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [BottomSheet], which is an overlay typically shown near the bottom of the</span></span><br><span class=\"line\"><span class=\"comment\">///    app. A bottom sheet can either be persistent, in which case it is shown</span></span><br><span class=\"line\"><span class=\"comment\">///    using the [ScaffoldState.showBottomSheet] method, or modal, in which case</span></span><br><span class=\"line\"><span class=\"comment\">///    it is shown using the [showModalBottomSheet] function.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [ScaffoldState], which is the state associated with this widget.</span></span><br><span class=\"line\"><span class=\"comment\">///  * &lt;https://material.io/design/layout/responsive-layout-grid.html&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scaffold</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// Creates a visual scaffold for material design widgets.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Scaffold(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.appBar,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.body,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.floatingActionButton,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.floatingActionButtonLocation,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.floatingActionButtonAnimator,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.persistentFooterButtons,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.drawer,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.endDrawer,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bottomNavigationBar,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bottomSheet,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.backgroundColor,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resizeToAvoidBottomPadding = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.primary = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">  &#125;) : <span class=\"keyword\">assert</span>(primary != <span class=\"keyword\">null</span>), <span class=\"keyword\">super</span>(key: key);</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>appBar</td>\n<td>显示在Scaffold 顶部 相关连接：<a href=\"https://flutterchina.club/catalog/samples/\" target=\"_blank\" rel=\"noopener\">https://flutterchina.club/catalog/samples/</a></td>\n</tr>\n<tr>\n<td>body</td>\n<td>当前界面所显示的主要内容</td>\n</tr>\n<tr>\n<td>floatingActionButton</td>\n<td>默认右下角的悬浮按钮</td>\n</tr>\n<tr>\n<td>floatingActionButtonLocation</td>\n<td>悬浮按钮位置，默认右下角</td>\n</tr>\n<tr>\n<td>floatingActionButtonAnimator</td>\n<td>悬浮按钮位置位置变换动画</td>\n</tr>\n<tr>\n<td>persistentFooterButtons</td>\n<td>固定在下方显示的按钮。<a href=\"https://material.google.com/components/buttons.html#buttons-persistent-footer-buttons\" target=\"_blank\" rel=\"noopener\">https://material.google.com/components/buttons.html#buttons-persistent-footer-buttons</a></td>\n</tr>\n<tr>\n<td>bottomNavigationBar</td>\n<td>显示在底部的导航栏按钮栏</td>\n</tr>\n<tr>\n<td>bottomSheet</td>\n<td>底部按钮</td>\n</tr>\n<tr>\n<td>drawer</td>\n<td>侧边栏控件</td>\n</tr>\n<tr>\n<td>backgroundColor</td>\n<td>背景颜色</td>\n</tr>\n<tr>\n<td>resizeToAvoidBottomPadding</td>\n<td>控制界面内容 body 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">  home: Scaffold(</span><br><span class=\"line\">    appBar: AppBar(</span><br><span class=\"line\">      title: Text(<span class=\"string\">\"这里是 appBar\"</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    body: Container(</span><br><span class=\"line\">      color: Colors.pink,</span><br><span class=\"line\">      alignment: Alignment.center,</span><br><span class=\"line\">      child: Text(</span><br><span class=\"line\">        <span class=\"string\">\"这里是 Body\"</span>,</span><br><span class=\"line\">        style: TextStyle(color: Colors.white),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">      <span class=\"comment\">// 长按时显示的提示</span></span><br><span class=\"line\">      tooltip: <span class=\"string\">\"你长按了\"</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 前景色</span></span><br><span class=\"line\">      foregroundColor: Colors.black,</span><br><span class=\"line\">      <span class=\"comment\">// 背景色</span></span><br><span class=\"line\">      backgroundColor: Colors.white,</span><br><span class=\"line\">      <span class=\"comment\">// heroTag :hero效果使用的tag</span></span><br><span class=\"line\">      <span class=\"comment\">// 未点击时的阴影值</span></span><br><span class=\"line\">      elevation: <span class=\"number\">5.0</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 按下时的阴影值</span></span><br><span class=\"line\">      highlightElevation: <span class=\"number\">12.0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      child: Icon(Icons.add),</span><br><span class=\"line\">      onPressed: () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'你点击了我!'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    bottomNavigationBar: BottomAppBar(</span><br><span class=\"line\">      child: Container(</span><br><span class=\"line\">        height: <span class=\"number\">100.0</span>,</span><br><span class=\"line\">        alignment: Alignment.center,</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"这里是bottomNavigationBar\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    persistentFooterButtons: &lt;Widget&gt;[</span><br><span class=\"line\">      Icon(Icons.access_alarms),</span><br><span class=\"line\">      Icon(Icons.dashboard)</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"img/scaffold.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Material-介绍\"><a href=\"#Material-介绍\" class=\"headerlink\" title=\"Material 介绍\"></a>Material 介绍</h2><h3 id=\"Material-Design-（质感设计）\"><a href=\"#Material-Design-（质感设计）\" class=\"headerlink\" title=\"Material Design （质感设计）\"></a>Material Design （质感设计）</h3><p>是由Google推出的全新设计语言，旨在为手机、平板电脑、台式机和其他平台提供更一致、更广泛的外观和感觉。从2014年开始，Android到衍生的Android Wear、Auto和TV，Material Design贯穿其中，成为勾通不同平台、设备的灵魂，让用户在不同平台上也有连贯的体验。为了维护这种一致，Google不允许第三方修改Android Wear、Auto和TV的界面以及交互</p>\n<h3 id=\"Flutter-Material\"><a href=\"#Flutter-Material\" class=\"headerlink\" title=\"Flutter Material\"></a>Flutter Material</h3><blockquote>\n<p>Flutter 的 Material 组件<br>通过在应用间和平台间提供一个统一的用户体验组件库，把设计和工程合二为一。秉承着 Google 的前端开发标准，Material Design 系统正在向多端一致体验、像素级完美呈现的方向发展。Material Design 组件（MDC）也同样适用于 Android、iOS 和 Web。</p>\n</blockquote>\n<h2 id=\"Scaffold\"><a href=\"#Scaffold\" class=\"headerlink\" title=\"Scaffold\"></a>Scaffold</h2><blockquote>\n<p>Scaffold 实现了基本的 Material 布局。只要是在 Material 中定义了的单个界面显示的布局控件元素，都可以使用 Scaffold 来绘制。</p>\n</blockquote>\n<p>提供展示抽屉(drawers，比如：左边栏)、通知(snack bars) 以及 底部按钮（bottom sheets)。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///  * [AppBar], which is a horizontal bar typically shown at the top of an app</span></span><br><span class=\"line\"><span class=\"comment\">///    using the [appBar] property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [BottomAppBar], which is a horizontal bar typically shown at the bottom</span></span><br><span class=\"line\"><span class=\"comment\">///    of an app using the [bottomNavigationBar] property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [FloatingActionButton], which is a circular button typically shown in the</span></span><br><span class=\"line\"><span class=\"comment\">///    bottom right corner of the app using the [floatingActionButton] property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [Drawer], which is a vertical panel that is typically displayed to the</span></span><br><span class=\"line\"><span class=\"comment\">///    left of the body (and often hidden on phones) using the [drawer]</span></span><br><span class=\"line\"><span class=\"comment\">///    property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [BottomNavigationBar], which is a horizontal array of buttons typically</span></span><br><span class=\"line\"><span class=\"comment\">///    shown along the bottom of the app using the [bottomNavigationBar]</span></span><br><span class=\"line\"><span class=\"comment\">///    property.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [SnackBar], which is a temporary notification typically shown near the</span></span><br><span class=\"line\"><span class=\"comment\">///    bottom of the app using the [ScaffoldState.showSnackBar] method.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [BottomSheet], which is an overlay typically shown near the bottom of the</span></span><br><span class=\"line\"><span class=\"comment\">///    app. A bottom sheet can either be persistent, in which case it is shown</span></span><br><span class=\"line\"><span class=\"comment\">///    using the [ScaffoldState.showBottomSheet] method, or modal, in which case</span></span><br><span class=\"line\"><span class=\"comment\">///    it is shown using the [showModalBottomSheet] function.</span></span><br><span class=\"line\"><span class=\"comment\">///  * [ScaffoldState], which is the state associated with this widget.</span></span><br><span class=\"line\"><span class=\"comment\">///  * &lt;https://material.io/design/layout/responsive-layout-grid.html&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scaffold</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/// Creates a visual scaffold for material design widgets.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> Scaffold(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.appBar,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.body,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.floatingActionButton,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.floatingActionButtonLocation,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.floatingActionButtonAnimator,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.persistentFooterButtons,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.drawer,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.endDrawer,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bottomNavigationBar,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.bottomSheet,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.backgroundColor,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resizeToAvoidBottomPadding = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.primary = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">  &#125;) : <span class=\"keyword\">assert</span>(primary != <span class=\"keyword\">null</span>), <span class=\"keyword\">super</span>(key: key);</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>appBar</td>\n<td>显示在Scaffold 顶部 相关连接：<a href=\"https://flutterchina.club/catalog/samples/\" target=\"_blank\" rel=\"noopener\">https://flutterchina.club/catalog/samples/</a></td>\n</tr>\n<tr>\n<td>body</td>\n<td>当前界面所显示的主要内容</td>\n</tr>\n<tr>\n<td>floatingActionButton</td>\n<td>默认右下角的悬浮按钮</td>\n</tr>\n<tr>\n<td>floatingActionButtonLocation</td>\n<td>悬浮按钮位置，默认右下角</td>\n</tr>\n<tr>\n<td>floatingActionButtonAnimator</td>\n<td>悬浮按钮位置位置变换动画</td>\n</tr>\n<tr>\n<td>persistentFooterButtons</td>\n<td>固定在下方显示的按钮。<a href=\"https://material.google.com/components/buttons.html#buttons-persistent-footer-buttons\" target=\"_blank\" rel=\"noopener\">https://material.google.com/components/buttons.html#buttons-persistent-footer-buttons</a></td>\n</tr>\n<tr>\n<td>bottomNavigationBar</td>\n<td>显示在底部的导航栏按钮栏</td>\n</tr>\n<tr>\n<td>bottomSheet</td>\n<td>底部按钮</td>\n</tr>\n<tr>\n<td>drawer</td>\n<td>侧边栏控件</td>\n</tr>\n<tr>\n<td>backgroundColor</td>\n<td>背景颜色</td>\n</tr>\n<tr>\n<td>resizeToAvoidBottomPadding</td>\n<td>控制界面内容 body 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">  home: Scaffold(</span><br><span class=\"line\">    appBar: AppBar(</span><br><span class=\"line\">      title: Text(<span class=\"string\">\"这里是 appBar\"</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    body: Container(</span><br><span class=\"line\">      color: Colors.pink,</span><br><span class=\"line\">      alignment: Alignment.center,</span><br><span class=\"line\">      child: Text(</span><br><span class=\"line\">        <span class=\"string\">\"这里是 Body\"</span>,</span><br><span class=\"line\">        style: TextStyle(color: Colors.white),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">      <span class=\"comment\">// 长按时显示的提示</span></span><br><span class=\"line\">      tooltip: <span class=\"string\">\"你长按了\"</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 前景色</span></span><br><span class=\"line\">      foregroundColor: Colors.black,</span><br><span class=\"line\">      <span class=\"comment\">// 背景色</span></span><br><span class=\"line\">      backgroundColor: Colors.white,</span><br><span class=\"line\">      <span class=\"comment\">// heroTag :hero效果使用的tag</span></span><br><span class=\"line\">      <span class=\"comment\">// 未点击时的阴影值</span></span><br><span class=\"line\">      elevation: <span class=\"number\">5.0</span>,</span><br><span class=\"line\">      <span class=\"comment\">// 按下时的阴影值</span></span><br><span class=\"line\">      highlightElevation: <span class=\"number\">12.0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">      child: Icon(Icons.add),</span><br><span class=\"line\">      onPressed: () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">'你点击了我!'</span>);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    bottomNavigationBar: BottomAppBar(</span><br><span class=\"line\">      child: Container(</span><br><span class=\"line\">        height: <span class=\"number\">100.0</span>,</span><br><span class=\"line\">        alignment: Alignment.center,</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"这里是bottomNavigationBar\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    persistentFooterButtons: &lt;Widget&gt;[</span><br><span class=\"line\">      Icon(Icons.access_alarms),</span><br><span class=\"line\">      Icon(Icons.dashboard)</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"img/scaffold.jpg\" alt></p>\n"},{"title":"SingleChildScrollView","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T15:36:00.000Z","_content":"\n## 介绍\n> 类似Android中的ScrollView，只接收一个子Widget\n## 定义\n```dart\nconst SingleChildScrollView({\n    Key key,\n    this.scrollDirection = Axis.vertical, //滚动方向，默认是垂直方向\n    this.reverse = false, // 是否按照阅读方向相反的方向滑动\n    this.padding,\n    bool primary, //指是否使用widget树中默认的PrimaryScrollController\n    this.physics,\n    this.controller,\n    this.child,\n  })\n```\n## 示例\n```dart\nScrollbar(\n    child: SingleChildScrollView(\n    padding: EdgeInsets.all(16.0),\n    child: Center(\n        child: Column(\n        // 动态创建一个List<Widget>\n        children: str\n            .split(\"\")\n            // 每个字母都可以是一个Text显示，字体是原来的2倍\n            .map((c) => Text(c, textScaleFactor: 2.0))\n            .toList(),\n        ),\n    ),\n    ),\n);\n```\n\n\n","source":"_posts/flutter/可滚动Widget/SingleChildScrollView.md","raw":"---\ntitle: SingleChildScrollView\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 23:36:00   \n---\n\n## 介绍\n> 类似Android中的ScrollView，只接收一个子Widget\n## 定义\n```dart\nconst SingleChildScrollView({\n    Key key,\n    this.scrollDirection = Axis.vertical, //滚动方向，默认是垂直方向\n    this.reverse = false, // 是否按照阅读方向相反的方向滑动\n    this.padding,\n    bool primary, //指是否使用widget树中默认的PrimaryScrollController\n    this.physics,\n    this.controller,\n    this.child,\n  })\n```\n## 示例\n```dart\nScrollbar(\n    child: SingleChildScrollView(\n    padding: EdgeInsets.all(16.0),\n    child: Center(\n        child: Column(\n        // 动态创建一个List<Widget>\n        children: str\n            .split(\"\")\n            // 每个字母都可以是一个Text显示，字体是原来的2倍\n            .map((c) => Text(c, textScaleFactor: 2.0))\n            .toList(),\n        ),\n    ),\n    ),\n);\n```\n\n\n","slug":"flutter/可滚动Widget/SingleChildScrollView","published":1,"updated":"2019-10-02T11:51:02.821Z","layout":"post","photos":[],"link":"","_id":"ck19bvb3w004m00wkskd0qb4l","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>类似Android中的ScrollView，只接收一个子Widget</p>\n</blockquote>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SingleChildScrollView(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.scrollDirection = Axis.vertical, <span class=\"comment\">//滚动方向，默认是垂直方向</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.reverse = <span class=\"keyword\">false</span>, <span class=\"comment\">// 是否按照阅读方向相反的方向滑动</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.padding,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> primary, <span class=\"comment\">//指是否使用widget树中默认的PrimaryScrollController</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.physics,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.controller,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.child,</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scrollbar(</span><br><span class=\"line\">    child: SingleChildScrollView(</span><br><span class=\"line\">    padding: EdgeInsets.all(<span class=\"number\">16.0</span>),</span><br><span class=\"line\">    child: Center(</span><br><span class=\"line\">        child: Column(</span><br><span class=\"line\">        <span class=\"comment\">// 动态创建一个List&lt;Widget&gt;</span></span><br><span class=\"line\">        children: str</span><br><span class=\"line\">            .split(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 每个字母都可以是一个Text显示，字体是原来的2倍</span></span><br><span class=\"line\">            .map((c) =&gt; Text(c, textScaleFactor: <span class=\"number\">2.0</span>))</span><br><span class=\"line\">            .toList(),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>类似Android中的ScrollView，只接收一个子Widget</p>\n</blockquote>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SingleChildScrollView(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.scrollDirection = Axis.vertical, <span class=\"comment\">//滚动方向，默认是垂直方向</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.reverse = <span class=\"keyword\">false</span>, <span class=\"comment\">// 是否按照阅读方向相反的方向滑动</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.padding,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> primary, <span class=\"comment\">//指是否使用widget树中默认的PrimaryScrollController</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.physics,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.controller,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.child,</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scrollbar(</span><br><span class=\"line\">    child: SingleChildScrollView(</span><br><span class=\"line\">    padding: EdgeInsets.all(<span class=\"number\">16.0</span>),</span><br><span class=\"line\">    child: Center(</span><br><span class=\"line\">        child: Column(</span><br><span class=\"line\">        <span class=\"comment\">// 动态创建一个List&lt;Widget&gt;</span></span><br><span class=\"line\">        children: str</span><br><span class=\"line\">            .split(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 每个字母都可以是一个Text显示，字体是原来的2倍</span></span><br><span class=\"line\">            .map((c) =&gt; Text(c, textScaleFactor: <span class=\"number\">2.0</span>))</span><br><span class=\"line\">            .toList(),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n"},{"title":"AppBar","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-25T03:14:00.000Z","_content":"## 介绍\n> AppBar 显示在app的顶部。AppBar包含5大部分，如下图：\n![](../img/appBar.png)\n\n### 构造函数\n```dart\nAppBar({\n  Key key,\n  this.leading,//在标题前面显示的一个控件，在首页通常显示应用的 logo；在其他界面通常显示为返回按钮\n  this.automaticallyImplyLeading = true,\n  this.title,//Toolbar 中主要内容，通常显示为当前界面的标题文字\n  this.actions,//一个 Widget 列表，代表 Toolbar 中所显示的菜单，对于常用的菜单，通常使用 IconButton 来表示；对于不常用的菜单通常使用 PopupMenuButton 来显示为三个点，点击后弹出二级菜单\n  this.flexibleSpace,//一个显示在 AppBar 下方的控件，高度和 AppBar 高度一样，可以实现一些特殊的效果，该属性通常在SliverAppBar 中使用\n  this.bottom,//一个 AppBarBottomWidget 对象，通常是 TabBar。用来在 Toolbar 标题下面显示一个 Tab 导航栏\n  this.elevation = 4.0,//纸墨设计中控件的 z 坐标顺序，默认值为 4，对于可滚动的 SliverAppBar，当 SliverAppBar 和内容同级的时候，该值为 0， 当内容滚动 SliverAppBar 变为 Toolbar 的时候，修改 elevation 的值\n  this.backgroundColor,//APP bar 的颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用\n  this.brightness,//App bar 的亮度，有白色和黑色两种主题，默认值为 ThemeData.primaryColorBrightness\n  this.iconTheme,//App bar 上图标的颜色、透明度、和尺寸信息。默认值为 ThemeData.primaryIconTheme\n  this.textTheme,//App bar 上的文字样式。默认值为 ThemeData.primaryTextTheme\n  this.primary = true,\n  this.centerTitle,//标题是否居中显示，默认值根据不同的操作系统，显示方式不一样,true居中 false居左\n  this.titleSpacing = NavigationToolbar.kMiddleSpacing,\n  this.toolbarOpacity = 1.0,\n  this.bottomOpacity = 1.0,\n})\n \n```\n | 属性            | 说明                                     |\n | --------------- | ---------------------------------------- |\n | leading         | 左上角的控件，一般放一个icon，位置如上图 |\n | title           | 标题，位置如上图                         |\n | actions         | 一系列的组件，位置如上图                 |\n | flexibleSpace   | 位置如上图                               |\n | bottom          | 位置如上图                               |\n | elevation       | 阴影Z轴                                  |\n | backgroundColor | 背景颜色                                 |\n | brightness      | 亮度                                     |\n | iconTheme       | 图标样式                                 |\n | textTheme       | 字体样式                                 |\n | centerTitle     | title是否显示在中间                      |\n\n### 示例\n```dart\nreturn MaterialApp(\n  home: Scaffold(\n   appBar: AppBar(\n          leading: Icon(Icons.menu),\n          title: Text(\"标题\"),\n          centerTitle: true,\n          actions: <Widget>[\n            IconButton(\n              icon: Icon(Icons.playlist_play),\n              tooltip: \"Air it\",\n              onPressed: (){\n                print(\"你点击了 Air\");\n              },\n            ),\n            IconButton(\n              icon: Icon(Icons.playlist_add),\n              tooltip: 'Restitch it',\n              onPressed: (){\n                print(\"你点击了 Restitch\");\n              },\n            ),\n            IconButton(\n              icon: Icon(Icons.playlist_add_check),\n              tooltip: 'Repair  it',\n              onPressed: (){\n                print(\"你点击了 Repair\");\n              },\n            ),\n          ],\n          flexibleSpace: Container(\n            color: Colors.blue,\n            alignment: Alignment.bottomLeft,\n            child: Text(\"这里是flexibleSpace\",style: TextStyle(color: Colors.white),),\n          ),\n          bottom: PreferredSize(child: Text(\"这里是bottom\"), preferredSize: null),\n        ),\n  ),\n);\n```\n![](img/appBarDemo.png)","source":"_posts/flutter/widget/17_Material_AppBar.md","raw":"---\ntitle: AppBar\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-25 11:14:00   \n---\n## 介绍\n> AppBar 显示在app的顶部。AppBar包含5大部分，如下图：\n![](../img/appBar.png)\n\n### 构造函数\n```dart\nAppBar({\n  Key key,\n  this.leading,//在标题前面显示的一个控件，在首页通常显示应用的 logo；在其他界面通常显示为返回按钮\n  this.automaticallyImplyLeading = true,\n  this.title,//Toolbar 中主要内容，通常显示为当前界面的标题文字\n  this.actions,//一个 Widget 列表，代表 Toolbar 中所显示的菜单，对于常用的菜单，通常使用 IconButton 来表示；对于不常用的菜单通常使用 PopupMenuButton 来显示为三个点，点击后弹出二级菜单\n  this.flexibleSpace,//一个显示在 AppBar 下方的控件，高度和 AppBar 高度一样，可以实现一些特殊的效果，该属性通常在SliverAppBar 中使用\n  this.bottom,//一个 AppBarBottomWidget 对象，通常是 TabBar。用来在 Toolbar 标题下面显示一个 Tab 导航栏\n  this.elevation = 4.0,//纸墨设计中控件的 z 坐标顺序，默认值为 4，对于可滚动的 SliverAppBar，当 SliverAppBar 和内容同级的时候，该值为 0， 当内容滚动 SliverAppBar 变为 Toolbar 的时候，修改 elevation 的值\n  this.backgroundColor,//APP bar 的颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用\n  this.brightness,//App bar 的亮度，有白色和黑色两种主题，默认值为 ThemeData.primaryColorBrightness\n  this.iconTheme,//App bar 上图标的颜色、透明度、和尺寸信息。默认值为 ThemeData.primaryIconTheme\n  this.textTheme,//App bar 上的文字样式。默认值为 ThemeData.primaryTextTheme\n  this.primary = true,\n  this.centerTitle,//标题是否居中显示，默认值根据不同的操作系统，显示方式不一样,true居中 false居左\n  this.titleSpacing = NavigationToolbar.kMiddleSpacing,\n  this.toolbarOpacity = 1.0,\n  this.bottomOpacity = 1.0,\n})\n \n```\n | 属性            | 说明                                     |\n | --------------- | ---------------------------------------- |\n | leading         | 左上角的控件，一般放一个icon，位置如上图 |\n | title           | 标题，位置如上图                         |\n | actions         | 一系列的组件，位置如上图                 |\n | flexibleSpace   | 位置如上图                               |\n | bottom          | 位置如上图                               |\n | elevation       | 阴影Z轴                                  |\n | backgroundColor | 背景颜色                                 |\n | brightness      | 亮度                                     |\n | iconTheme       | 图标样式                                 |\n | textTheme       | 字体样式                                 |\n | centerTitle     | title是否显示在中间                      |\n\n### 示例\n```dart\nreturn MaterialApp(\n  home: Scaffold(\n   appBar: AppBar(\n          leading: Icon(Icons.menu),\n          title: Text(\"标题\"),\n          centerTitle: true,\n          actions: <Widget>[\n            IconButton(\n              icon: Icon(Icons.playlist_play),\n              tooltip: \"Air it\",\n              onPressed: (){\n                print(\"你点击了 Air\");\n              },\n            ),\n            IconButton(\n              icon: Icon(Icons.playlist_add),\n              tooltip: 'Restitch it',\n              onPressed: (){\n                print(\"你点击了 Restitch\");\n              },\n            ),\n            IconButton(\n              icon: Icon(Icons.playlist_add_check),\n              tooltip: 'Repair  it',\n              onPressed: (){\n                print(\"你点击了 Repair\");\n              },\n            ),\n          ],\n          flexibleSpace: Container(\n            color: Colors.blue,\n            alignment: Alignment.bottomLeft,\n            child: Text(\"这里是flexibleSpace\",style: TextStyle(color: Colors.white),),\n          ),\n          bottom: PreferredSize(child: Text(\"这里是bottom\"), preferredSize: null),\n        ),\n  ),\n);\n```\n![](img/appBarDemo.png)","slug":"flutter/widget/17_Material_AppBar","published":1,"updated":"2019-10-02T11:51:18.762Z","layout":"post","photos":[],"link":"","_id":"ck19bvb40004p00wk2ynedz3k","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>AppBar 显示在app的顶部。AppBar包含5大部分，如下图：<br><img src=\"../img/appBar.png\" alt></p>\n</blockquote>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AppBar(&#123;</span><br><span class=\"line\">  Key key,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.leading,<span class=\"comment\">//在标题前面显示的一个控件，在首页通常显示应用的 logo；在其他界面通常显示为返回按钮</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.automaticallyImplyLeading = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.title,<span class=\"comment\">//Toolbar 中主要内容，通常显示为当前界面的标题文字</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.actions,<span class=\"comment\">//一个 Widget 列表，代表 Toolbar 中所显示的菜单，对于常用的菜单，通常使用 IconButton 来表示；对于不常用的菜单通常使用 PopupMenuButton 来显示为三个点，点击后弹出二级菜单</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.flexibleSpace,<span class=\"comment\">//一个显示在 AppBar 下方的控件，高度和 AppBar 高度一样，可以实现一些特殊的效果，该属性通常在SliverAppBar 中使用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bottom,<span class=\"comment\">//一个 AppBarBottomWidget 对象，通常是 TabBar。用来在 Toolbar 标题下面显示一个 Tab 导航栏</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.elevation = <span class=\"number\">4.0</span>,<span class=\"comment\">//纸墨设计中控件的 z 坐标顺序，默认值为 4，对于可滚动的 SliverAppBar，当 SliverAppBar 和内容同级的时候，该值为 0， 当内容滚动 SliverAppBar 变为 Toolbar 的时候，修改 elevation 的值</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.backgroundColor,<span class=\"comment\">//APP bar 的颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.brightness,<span class=\"comment\">//App bar 的亮度，有白色和黑色两种主题，默认值为 ThemeData.primaryColorBrightness</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.iconTheme,<span class=\"comment\">//App bar 上图标的颜色、透明度、和尺寸信息。默认值为 ThemeData.primaryIconTheme</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textTheme,<span class=\"comment\">//App bar 上的文字样式。默认值为 ThemeData.primaryTextTheme</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.primary = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.centerTitle,<span class=\"comment\">//标题是否居中显示，默认值根据不同的操作系统，显示方式不一样,true居中 false居左</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toolbarOpacity = <span class=\"number\">1.0</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bottomOpacity = <span class=\"number\">1.0</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>leading</td>\n<td>左上角的控件，一般放一个icon，位置如上图</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题，位置如上图</td>\n</tr>\n<tr>\n<td>actions</td>\n<td>一系列的组件，位置如上图</td>\n</tr>\n<tr>\n<td>flexibleSpace</td>\n<td>位置如上图</td>\n</tr>\n<tr>\n<td>bottom</td>\n<td>位置如上图</td>\n</tr>\n<tr>\n<td>elevation</td>\n<td>阴影Z轴</td>\n</tr>\n<tr>\n<td>backgroundColor</td>\n<td>背景颜色</td>\n</tr>\n<tr>\n<td>brightness</td>\n<td>亮度</td>\n</tr>\n<tr>\n<td>iconTheme</td>\n<td>图标样式</td>\n</tr>\n<tr>\n<td>textTheme</td>\n<td>字体样式</td>\n</tr>\n<tr>\n<td>centerTitle</td>\n<td>title是否显示在中间</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">  home: Scaffold(</span><br><span class=\"line\">   appBar: AppBar(</span><br><span class=\"line\">          leading: Icon(Icons.menu),</span><br><span class=\"line\">          title: Text(<span class=\"string\">\"标题\"</span>),</span><br><span class=\"line\">          centerTitle: <span class=\"keyword\">true</span>,</span><br><span class=\"line\">          actions: &lt;Widget&gt;[</span><br><span class=\"line\">            IconButton(</span><br><span class=\"line\">              icon: Icon(Icons.playlist_play),</span><br><span class=\"line\">              tooltip: <span class=\"string\">\"Air it\"</span>,</span><br><span class=\"line\">              onPressed: ()&#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了 Air\"</span>);</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            IconButton(</span><br><span class=\"line\">              icon: Icon(Icons.playlist_add),</span><br><span class=\"line\">              tooltip: <span class=\"string\">'Restitch it'</span>,</span><br><span class=\"line\">              onPressed: ()&#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了 Restitch\"</span>);</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            IconButton(</span><br><span class=\"line\">              icon: Icon(Icons.playlist_add_check),</span><br><span class=\"line\">              tooltip: <span class=\"string\">'Repair  it'</span>,</span><br><span class=\"line\">              onPressed: ()&#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了 Repair\"</span>);</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ],</span><br><span class=\"line\">          flexibleSpace: Container(</span><br><span class=\"line\">            color: Colors.blue,</span><br><span class=\"line\">            alignment: Alignment.bottomLeft,</span><br><span class=\"line\">            child: Text(<span class=\"string\">\"这里是flexibleSpace\"</span>,style: TextStyle(color: Colors.white),),</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          bottom: PreferredSize(child: Text(<span class=\"string\">\"这里是bottom\"</span>), preferredSize: <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"img/appBarDemo.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>AppBar 显示在app的顶部。AppBar包含5大部分，如下图：<br><img src=\"../img/appBar.png\" alt></p>\n</blockquote>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AppBar(&#123;</span><br><span class=\"line\">  Key key,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.leading,<span class=\"comment\">//在标题前面显示的一个控件，在首页通常显示应用的 logo；在其他界面通常显示为返回按钮</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.automaticallyImplyLeading = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.title,<span class=\"comment\">//Toolbar 中主要内容，通常显示为当前界面的标题文字</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.actions,<span class=\"comment\">//一个 Widget 列表，代表 Toolbar 中所显示的菜单，对于常用的菜单，通常使用 IconButton 来表示；对于不常用的菜单通常使用 PopupMenuButton 来显示为三个点，点击后弹出二级菜单</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.flexibleSpace,<span class=\"comment\">//一个显示在 AppBar 下方的控件，高度和 AppBar 高度一样，可以实现一些特殊的效果，该属性通常在SliverAppBar 中使用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bottom,<span class=\"comment\">//一个 AppBarBottomWidget 对象，通常是 TabBar。用来在 Toolbar 标题下面显示一个 Tab 导航栏</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.elevation = <span class=\"number\">4.0</span>,<span class=\"comment\">//纸墨设计中控件的 z 坐标顺序，默认值为 4，对于可滚动的 SliverAppBar，当 SliverAppBar 和内容同级的时候，该值为 0， 当内容滚动 SliverAppBar 变为 Toolbar 的时候，修改 elevation 的值</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.backgroundColor,<span class=\"comment\">//APP bar 的颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.brightness,<span class=\"comment\">//App bar 的亮度，有白色和黑色两种主题，默认值为 ThemeData.primaryColorBrightness</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.iconTheme,<span class=\"comment\">//App bar 上图标的颜色、透明度、和尺寸信息。默认值为 ThemeData.primaryIconTheme</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textTheme,<span class=\"comment\">//App bar 上的文字样式。默认值为 ThemeData.primaryTextTheme</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.primary = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.centerTitle,<span class=\"comment\">//标题是否居中显示，默认值根据不同的操作系统，显示方式不一样,true居中 false居左</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.toolbarOpacity = <span class=\"number\">1.0</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bottomOpacity = <span class=\"number\">1.0</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>leading</td>\n<td>左上角的控件，一般放一个icon，位置如上图</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题，位置如上图</td>\n</tr>\n<tr>\n<td>actions</td>\n<td>一系列的组件，位置如上图</td>\n</tr>\n<tr>\n<td>flexibleSpace</td>\n<td>位置如上图</td>\n</tr>\n<tr>\n<td>bottom</td>\n<td>位置如上图</td>\n</tr>\n<tr>\n<td>elevation</td>\n<td>阴影Z轴</td>\n</tr>\n<tr>\n<td>backgroundColor</td>\n<td>背景颜色</td>\n</tr>\n<tr>\n<td>brightness</td>\n<td>亮度</td>\n</tr>\n<tr>\n<td>iconTheme</td>\n<td>图标样式</td>\n</tr>\n<tr>\n<td>textTheme</td>\n<td>字体样式</td>\n</tr>\n<tr>\n<td>centerTitle</td>\n<td>title是否显示在中间</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">  home: Scaffold(</span><br><span class=\"line\">   appBar: AppBar(</span><br><span class=\"line\">          leading: Icon(Icons.menu),</span><br><span class=\"line\">          title: Text(<span class=\"string\">\"标题\"</span>),</span><br><span class=\"line\">          centerTitle: <span class=\"keyword\">true</span>,</span><br><span class=\"line\">          actions: &lt;Widget&gt;[</span><br><span class=\"line\">            IconButton(</span><br><span class=\"line\">              icon: Icon(Icons.playlist_play),</span><br><span class=\"line\">              tooltip: <span class=\"string\">\"Air it\"</span>,</span><br><span class=\"line\">              onPressed: ()&#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了 Air\"</span>);</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            IconButton(</span><br><span class=\"line\">              icon: Icon(Icons.playlist_add),</span><br><span class=\"line\">              tooltip: <span class=\"string\">'Restitch it'</span>,</span><br><span class=\"line\">              onPressed: ()&#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了 Restitch\"</span>);</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            IconButton(</span><br><span class=\"line\">              icon: Icon(Icons.playlist_add_check),</span><br><span class=\"line\">              tooltip: <span class=\"string\">'Repair  it'</span>,</span><br><span class=\"line\">              onPressed: ()&#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了 Repair\"</span>);</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ],</span><br><span class=\"line\">          flexibleSpace: Container(</span><br><span class=\"line\">            color: Colors.blue,</span><br><span class=\"line\">            alignment: Alignment.bottomLeft,</span><br><span class=\"line\">            child: Text(<span class=\"string\">\"这里是flexibleSpace\"</span>,style: TextStyle(color: Colors.white),),</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          bottom: PreferredSize(child: Text(<span class=\"string\">\"这里是bottom\"</span>), preferredSize: <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"img/appBarDemo.png\" alt></p>\n"},{"title":"PopupMenu","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-25T09:54:00.000Z","_content":"\n## 介绍\n> 弹出式菜单\n\n\n### 示例\n```dart\nimport 'package:flutter/material.dart';\n\nclass PopupMenuMaterial extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() {\n    return _PopupMenuDemo();\n  }\n}\n\nclass _PopupMenuDemo extends State<PopupMenuMaterial> {\n  String _normalTitle = \"NormalPopMenu\";\n  String _iconTitle = \"IconPopMenu\";\n  String _checkedTitle = \"CheckedPopupMenuItem\";\n\n  @override\n  Widget build(BuildContext context) {\n    return _popupMenuList(context);\n  }\n\n  ///\n  /// 创建\n  ///\n  Widget _popupMenuList(BuildContext context) {\n    return ListView(\n      padding: EdgeInsets.all(10.0),\n      children: <Widget>[\n        _normalPopMenu(),\n        Divider(),\n        _iconPopMenu(),\n        Divider(),\n        _checkedPopupMenuItem(),\n        Divider(),\n        _popupMenuDivider(),\n        Divider(),\n        _showMenu(context),\n        Divider(),\n      ],\n    );\n  }\n\n  ///\n  /// 1. 默认PopMenu\n  ///\n  Widget _normalPopMenu() {\n    return PopupMenuButton<String>(\n      child: Text(\n        _normalTitle,\n      ),\n      itemBuilder: (BuildContext context) => <PopupMenuItem<String>>[\n            new PopupMenuItem<String>(\n                value: 'Item One', child: new Text('Item One')),\n            new PopupMenuItem<String>(\n                value: 'Item Two', child: new Text('Item Two')),\n            new PopupMenuItem<String>(\n                value: 'Item Three', child: new Text('Item Three')),\n            new PopupMenuItem<String>(\n                value: 'I am Item Four', child: new Text('I am Item Four'))\n          ],\n      onSelected: (String value) {\n        setState(() {\n          if (value != null) {\n            _normalTitle = \"NormalPopMenu : \" + value;\n          }\n        });\n      },\n    );\n  }\n\n  ///\n  /// 2. 带有Icon\n  ///\n  Widget _iconPopMenu() {\n    return PopupMenuButton<String>(\n      child: Text(\n        _iconTitle,\n      ),\n      itemBuilder: (BuildContext context) => <PopupMenuItem<String>>[\n            PopupMenuItem<String>(\n              value: 'Icon One',\n              child: ListTile(\n                leading: Icon(Icons.looks_one),\n                title: Text(\"Item one\"),\n              ),\n            ),\n            PopupMenuItem<String>(\n              value: 'Icon Two',\n              // 若需要处理带图标的样式时，官网提供的 Demo 是借助的 ListTile 来处理的，\n              // 但是小菜测试发现图标与文字距离偏大，原因在于 ListTile 默认左侧图标 leading 距离不可直接调整，\n              // 建议用 Row 或其他方式调整\n              child: Row(\n                children: <Widget>[\n                  Padding(\n                      padding: EdgeInsets.fromLTRB(0.0, 0.0, 8.0, 0.0),\n                      child: Icon(Icons.looks_two)),\n                  Text('Item Two')\n                ],\n              ),\n            ),\n            PopupMenuItem<String>(\n              value: 'Icon Three',\n              child: ListTile(\n                leading: Icon(Icons.threed_rotation),\n                title: Text(\"Item Three\"),\n              ),\n            ),\n            PopupMenuItem<String>(\n              value: 'Icon Four , No Icon !',\n              child: ListTile(\n                title: Text(\"Item Four,No Icon\"),\n              ),\n            )\n          ],\n      onSelected: (String value) {\n        setState(() {\n          _iconTitle = \"IconPopMenu : \" + value;\n        });\n      },\n    );\n  }\n\n  /// 3. CheckedPopupMenuItem\n  Widget _checkedPopupMenuItem() {\n    return PopupMenuButton<String>(\n      child: Text(_checkedTitle),\n      itemBuilder: (BuildContext context) => <PopupMenuItem<String>>[\n            CheckedPopupMenuItem<String>(\n              checked: _checkedTitle == 'Checked One',\n              value: 'Checked One',\n              child: Text(\"Check One\"),\n            ),\n            CheckedPopupMenuItem<String>(\n              checked: _checkedTitle == 'Checked Two',\n              value: 'Checked Two',\n              child: Text(\"Check Two\"),\n            ),\n            CheckedPopupMenuItem<String>(\n              checked: _checkedTitle == 'Checked Three',\n              value: 'Checked Three',\n              child: Text(\"Check Three\"),\n            ),\n            CheckedPopupMenuItem<String>(\n              checked: _checkedTitle == 'Checked Four',\n              value: 'Checked Four',\n              child: Text(\"Check Four\"),\n            ),\n          ],\n      onSelected: (String value) {\n        setState(() {\n          _checkedTitle = value;\n        });\n      },\n    );\n  }\n\n  /// 4. PopupMenuDivider\n  ///  PopupMenuDivider 是一条水平分割线，注意数组要使用父类 PopupMenuEntry，配合其他 item 样式共同使用。\n  ///  PopupMenuDivider 可以调整高度，但无法调整颜色，有需要的话可以进行自定义。\n  Widget _popupMenuDivider() {\n    return PopupMenuButton<String>(\n      itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[\n            PopupMenuItem<String>(\n              value: 'Item One',\n              child: Text('Item One'),\n            ),\n            PopupMenuDivider(\n              height: 1.0,\n            ),\n            PopupMenuItem<String>(\n              value: 'Item Two',\n              child: Text('Item Two'),\n            ),\n            PopupMenuDivider(\n              height: 4.0,\n            ),\n            PopupMenuItem<String>(\n              value: 'Item Three',\n              child: Text('Item Three'),\n            ),\n            PopupMenuDivider(\n              height: 2.0,\n            ),\n            PopupMenuItem<String>(\n              value: 'Item Four',\n              child: Text('Item Four'),\n            ),\n          ],\n      child: Text(\"PopupMenuDivider\"),\n    );\n  }\n\n  /// 5. showMenu\n  Widget _showMenu(BuildContext context) {\n    return Text(\"// TODO showMenu\");\n  }\n}\n\n```","source":"_posts/flutter/widget/19_Material_PopupMenu.md","raw":"---\ntitle: PopupMenu\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-25 17:54:00   \n---\n\n## 介绍\n> 弹出式菜单\n\n\n### 示例\n```dart\nimport 'package:flutter/material.dart';\n\nclass PopupMenuMaterial extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() {\n    return _PopupMenuDemo();\n  }\n}\n\nclass _PopupMenuDemo extends State<PopupMenuMaterial> {\n  String _normalTitle = \"NormalPopMenu\";\n  String _iconTitle = \"IconPopMenu\";\n  String _checkedTitle = \"CheckedPopupMenuItem\";\n\n  @override\n  Widget build(BuildContext context) {\n    return _popupMenuList(context);\n  }\n\n  ///\n  /// 创建\n  ///\n  Widget _popupMenuList(BuildContext context) {\n    return ListView(\n      padding: EdgeInsets.all(10.0),\n      children: <Widget>[\n        _normalPopMenu(),\n        Divider(),\n        _iconPopMenu(),\n        Divider(),\n        _checkedPopupMenuItem(),\n        Divider(),\n        _popupMenuDivider(),\n        Divider(),\n        _showMenu(context),\n        Divider(),\n      ],\n    );\n  }\n\n  ///\n  /// 1. 默认PopMenu\n  ///\n  Widget _normalPopMenu() {\n    return PopupMenuButton<String>(\n      child: Text(\n        _normalTitle,\n      ),\n      itemBuilder: (BuildContext context) => <PopupMenuItem<String>>[\n            new PopupMenuItem<String>(\n                value: 'Item One', child: new Text('Item One')),\n            new PopupMenuItem<String>(\n                value: 'Item Two', child: new Text('Item Two')),\n            new PopupMenuItem<String>(\n                value: 'Item Three', child: new Text('Item Three')),\n            new PopupMenuItem<String>(\n                value: 'I am Item Four', child: new Text('I am Item Four'))\n          ],\n      onSelected: (String value) {\n        setState(() {\n          if (value != null) {\n            _normalTitle = \"NormalPopMenu : \" + value;\n          }\n        });\n      },\n    );\n  }\n\n  ///\n  /// 2. 带有Icon\n  ///\n  Widget _iconPopMenu() {\n    return PopupMenuButton<String>(\n      child: Text(\n        _iconTitle,\n      ),\n      itemBuilder: (BuildContext context) => <PopupMenuItem<String>>[\n            PopupMenuItem<String>(\n              value: 'Icon One',\n              child: ListTile(\n                leading: Icon(Icons.looks_one),\n                title: Text(\"Item one\"),\n              ),\n            ),\n            PopupMenuItem<String>(\n              value: 'Icon Two',\n              // 若需要处理带图标的样式时，官网提供的 Demo 是借助的 ListTile 来处理的，\n              // 但是小菜测试发现图标与文字距离偏大，原因在于 ListTile 默认左侧图标 leading 距离不可直接调整，\n              // 建议用 Row 或其他方式调整\n              child: Row(\n                children: <Widget>[\n                  Padding(\n                      padding: EdgeInsets.fromLTRB(0.0, 0.0, 8.0, 0.0),\n                      child: Icon(Icons.looks_two)),\n                  Text('Item Two')\n                ],\n              ),\n            ),\n            PopupMenuItem<String>(\n              value: 'Icon Three',\n              child: ListTile(\n                leading: Icon(Icons.threed_rotation),\n                title: Text(\"Item Three\"),\n              ),\n            ),\n            PopupMenuItem<String>(\n              value: 'Icon Four , No Icon !',\n              child: ListTile(\n                title: Text(\"Item Four,No Icon\"),\n              ),\n            )\n          ],\n      onSelected: (String value) {\n        setState(() {\n          _iconTitle = \"IconPopMenu : \" + value;\n        });\n      },\n    );\n  }\n\n  /// 3. CheckedPopupMenuItem\n  Widget _checkedPopupMenuItem() {\n    return PopupMenuButton<String>(\n      child: Text(_checkedTitle),\n      itemBuilder: (BuildContext context) => <PopupMenuItem<String>>[\n            CheckedPopupMenuItem<String>(\n              checked: _checkedTitle == 'Checked One',\n              value: 'Checked One',\n              child: Text(\"Check One\"),\n            ),\n            CheckedPopupMenuItem<String>(\n              checked: _checkedTitle == 'Checked Two',\n              value: 'Checked Two',\n              child: Text(\"Check Two\"),\n            ),\n            CheckedPopupMenuItem<String>(\n              checked: _checkedTitle == 'Checked Three',\n              value: 'Checked Three',\n              child: Text(\"Check Three\"),\n            ),\n            CheckedPopupMenuItem<String>(\n              checked: _checkedTitle == 'Checked Four',\n              value: 'Checked Four',\n              child: Text(\"Check Four\"),\n            ),\n          ],\n      onSelected: (String value) {\n        setState(() {\n          _checkedTitle = value;\n        });\n      },\n    );\n  }\n\n  /// 4. PopupMenuDivider\n  ///  PopupMenuDivider 是一条水平分割线，注意数组要使用父类 PopupMenuEntry，配合其他 item 样式共同使用。\n  ///  PopupMenuDivider 可以调整高度，但无法调整颜色，有需要的话可以进行自定义。\n  Widget _popupMenuDivider() {\n    return PopupMenuButton<String>(\n      itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[\n            PopupMenuItem<String>(\n              value: 'Item One',\n              child: Text('Item One'),\n            ),\n            PopupMenuDivider(\n              height: 1.0,\n            ),\n            PopupMenuItem<String>(\n              value: 'Item Two',\n              child: Text('Item Two'),\n            ),\n            PopupMenuDivider(\n              height: 4.0,\n            ),\n            PopupMenuItem<String>(\n              value: 'Item Three',\n              child: Text('Item Three'),\n            ),\n            PopupMenuDivider(\n              height: 2.0,\n            ),\n            PopupMenuItem<String>(\n              value: 'Item Four',\n              child: Text('Item Four'),\n            ),\n          ],\n      child: Text(\"PopupMenuDivider\"),\n    );\n  }\n\n  /// 5. showMenu\n  Widget _showMenu(BuildContext context) {\n    return Text(\"// TODO showMenu\");\n  }\n}\n\n```","slug":"flutter/widget/19_Material_PopupMenu","published":1,"updated":"2019-10-02T11:51:25.340Z","layout":"post","photos":[],"link":"","_id":"ck19bvb45004s00wkxol680pa","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>弹出式菜单</p>\n</blockquote>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopupMenuMaterial</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _PopupMenuDemo();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_PopupMenuDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">PopupMenuMaterial</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> _normalTitle = <span class=\"string\">\"NormalPopMenu\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> _iconTitle = <span class=\"string\">\"IconPopMenu\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> _checkedTitle = <span class=\"string\">\"CheckedPopupMenuItem\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _popupMenuList(context);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// 创建</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  Widget _popupMenuList(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ListView(</span><br><span class=\"line\">      padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">      children: &lt;Widget&gt;[</span><br><span class=\"line\">        _normalPopMenu(),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">        _iconPopMenu(),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">        _checkedPopupMenuItem(),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">        _popupMenuDivider(),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">        _showMenu(context),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// 1. 默认PopMenu</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  Widget _normalPopMenu() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PopupMenuButton&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">      child: Text(</span><br><span class=\"line\">        _normalTitle,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;&gt;[</span><br><span class=\"line\">            <span class=\"keyword\">new</span> PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">                value: <span class=\"string\">'Item One'</span>, child: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Item One'</span>)),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">                value: <span class=\"string\">'Item Two'</span>, child: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Item Two'</span>)),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">                value: <span class=\"string\">'Item Three'</span>, child: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Item Three'</span>)),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">                value: <span class=\"string\">'I am Item Four'</span>, child: <span class=\"keyword\">new</span> Text(<span class=\"string\">'I am Item Four'</span>))</span><br><span class=\"line\">          ],</span><br><span class=\"line\">      onSelected: (<span class=\"built_in\">String</span> value) &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            _normalTitle = <span class=\"string\">\"NormalPopMenu : \"</span> + value;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// 2. 带有Icon</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  Widget _iconPopMenu() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PopupMenuButton&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">      child: Text(</span><br><span class=\"line\">        _iconTitle,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;&gt;[</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Icon One'</span>,</span><br><span class=\"line\">              child: ListTile(</span><br><span class=\"line\">                leading: Icon(Icons.looks_one),</span><br><span class=\"line\">                title: Text(<span class=\"string\">\"Item one\"</span>),</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Icon Two'</span>,</span><br><span class=\"line\">              <span class=\"comment\">// 若需要处理带图标的样式时，官网提供的 Demo 是借助的 ListTile 来处理的，</span></span><br><span class=\"line\">              <span class=\"comment\">// 但是小菜测试发现图标与文字距离偏大，原因在于 ListTile 默认左侧图标 leading 距离不可直接调整，</span></span><br><span class=\"line\">              <span class=\"comment\">// 建议用 Row 或其他方式调整</span></span><br><span class=\"line\">              child: Row(</span><br><span class=\"line\">                children: &lt;Widget&gt;[</span><br><span class=\"line\">                  Padding(</span><br><span class=\"line\">                      padding: EdgeInsets.fromLTRB(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">8.0</span>, <span class=\"number\">0.0</span>),</span><br><span class=\"line\">                      child: Icon(Icons.looks_two)),</span><br><span class=\"line\">                  Text(<span class=\"string\">'Item Two'</span>)</span><br><span class=\"line\">                ],</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Icon Three'</span>,</span><br><span class=\"line\">              child: ListTile(</span><br><span class=\"line\">                leading: Icon(Icons.threed_rotation),</span><br><span class=\"line\">                title: Text(<span class=\"string\">\"Item Three\"</span>),</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Icon Four , No Icon !'</span>,</span><br><span class=\"line\">              child: ListTile(</span><br><span class=\"line\">                title: Text(<span class=\"string\">\"Item Four,No Icon\"</span>),</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            )</span><br><span class=\"line\">          ],</span><br><span class=\"line\">      onSelected: (<span class=\"built_in\">String</span> value) &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          _iconTitle = <span class=\"string\">\"IconPopMenu : \"</span> + value;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// 3. CheckedPopupMenuItem</span></span><br><span class=\"line\">  Widget _checkedPopupMenuItem() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PopupMenuButton&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">      child: Text(_checkedTitle),</span><br><span class=\"line\">      itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;&gt;[</span><br><span class=\"line\">            CheckedPopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              checked: _checkedTitle == <span class=\"string\">'Checked One'</span>,</span><br><span class=\"line\">              value: <span class=\"string\">'Checked One'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">\"Check One\"</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            CheckedPopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              checked: _checkedTitle == <span class=\"string\">'Checked Two'</span>,</span><br><span class=\"line\">              value: <span class=\"string\">'Checked Two'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">\"Check Two\"</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            CheckedPopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              checked: _checkedTitle == <span class=\"string\">'Checked Three'</span>,</span><br><span class=\"line\">              value: <span class=\"string\">'Checked Three'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">\"Check Three\"</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            CheckedPopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              checked: _checkedTitle == <span class=\"string\">'Checked Four'</span>,</span><br><span class=\"line\">              value: <span class=\"string\">'Checked Four'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">\"Check Four\"</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ],</span><br><span class=\"line\">      onSelected: (<span class=\"built_in\">String</span> value) &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          _checkedTitle = value;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// 4. PopupMenuDivider</span></span><br><span class=\"line\">  <span class=\"comment\">///  PopupMenuDivider 是一条水平分割线，注意数组要使用父类 PopupMenuEntry，配合其他 item 样式共同使用。</span></span><br><span class=\"line\">  <span class=\"comment\">///  PopupMenuDivider 可以调整高度，但无法调整颜色，有需要的话可以进行自定义。</span></span><br><span class=\"line\">  Widget _popupMenuDivider() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PopupMenuButton&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">      itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuEntry&lt;<span class=\"built_in\">String</span>&gt;&gt;[</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Item One'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">'Item One'</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuDivider(</span><br><span class=\"line\">              height: <span class=\"number\">1.0</span>,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Item Two'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">'Item Two'</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuDivider(</span><br><span class=\"line\">              height: <span class=\"number\">4.0</span>,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Item Three'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">'Item Three'</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuDivider(</span><br><span class=\"line\">              height: <span class=\"number\">2.0</span>,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Item Four'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">'Item Four'</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ],</span><br><span class=\"line\">      child: Text(<span class=\"string\">\"PopupMenuDivider\"</span>),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// 5. showMenu</span></span><br><span class=\"line\">  Widget _showMenu(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Text(<span class=\"string\">\"// TODO showMenu\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>弹出式菜单</p>\n</blockquote>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopupMenuMaterial</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _PopupMenuDemo();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_PopupMenuDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">PopupMenuMaterial</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> _normalTitle = <span class=\"string\">\"NormalPopMenu\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> _iconTitle = <span class=\"string\">\"IconPopMenu\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> _checkedTitle = <span class=\"string\">\"CheckedPopupMenuItem\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _popupMenuList(context);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// 创建</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  Widget _popupMenuList(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ListView(</span><br><span class=\"line\">      padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">      children: &lt;Widget&gt;[</span><br><span class=\"line\">        _normalPopMenu(),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">        _iconPopMenu(),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">        _checkedPopupMenuItem(),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">        _popupMenuDivider(),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">        _showMenu(context),</span><br><span class=\"line\">        Divider(),</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// 1. 默认PopMenu</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  Widget _normalPopMenu() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PopupMenuButton&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">      child: Text(</span><br><span class=\"line\">        _normalTitle,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;&gt;[</span><br><span class=\"line\">            <span class=\"keyword\">new</span> PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">                value: <span class=\"string\">'Item One'</span>, child: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Item One'</span>)),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">                value: <span class=\"string\">'Item Two'</span>, child: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Item Two'</span>)),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">                value: <span class=\"string\">'Item Three'</span>, child: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Item Three'</span>)),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">                value: <span class=\"string\">'I am Item Four'</span>, child: <span class=\"keyword\">new</span> Text(<span class=\"string\">'I am Item Four'</span>))</span><br><span class=\"line\">          ],</span><br><span class=\"line\">      onSelected: (<span class=\"built_in\">String</span> value) &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            _normalTitle = <span class=\"string\">\"NormalPopMenu : \"</span> + value;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  <span class=\"comment\">/// 2. 带有Icon</span></span><br><span class=\"line\">  <span class=\"comment\">///</span></span><br><span class=\"line\">  Widget _iconPopMenu() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PopupMenuButton&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">      child: Text(</span><br><span class=\"line\">        _iconTitle,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;&gt;[</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Icon One'</span>,</span><br><span class=\"line\">              child: ListTile(</span><br><span class=\"line\">                leading: Icon(Icons.looks_one),</span><br><span class=\"line\">                title: Text(<span class=\"string\">\"Item one\"</span>),</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Icon Two'</span>,</span><br><span class=\"line\">              <span class=\"comment\">// 若需要处理带图标的样式时，官网提供的 Demo 是借助的 ListTile 来处理的，</span></span><br><span class=\"line\">              <span class=\"comment\">// 但是小菜测试发现图标与文字距离偏大，原因在于 ListTile 默认左侧图标 leading 距离不可直接调整，</span></span><br><span class=\"line\">              <span class=\"comment\">// 建议用 Row 或其他方式调整</span></span><br><span class=\"line\">              child: Row(</span><br><span class=\"line\">                children: &lt;Widget&gt;[</span><br><span class=\"line\">                  Padding(</span><br><span class=\"line\">                      padding: EdgeInsets.fromLTRB(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">8.0</span>, <span class=\"number\">0.0</span>),</span><br><span class=\"line\">                      child: Icon(Icons.looks_two)),</span><br><span class=\"line\">                  Text(<span class=\"string\">'Item Two'</span>)</span><br><span class=\"line\">                ],</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Icon Three'</span>,</span><br><span class=\"line\">              child: ListTile(</span><br><span class=\"line\">                leading: Icon(Icons.threed_rotation),</span><br><span class=\"line\">                title: Text(<span class=\"string\">\"Item Three\"</span>),</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Icon Four , No Icon !'</span>,</span><br><span class=\"line\">              child: ListTile(</span><br><span class=\"line\">                title: Text(<span class=\"string\">\"Item Four,No Icon\"</span>),</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            )</span><br><span class=\"line\">          ],</span><br><span class=\"line\">      onSelected: (<span class=\"built_in\">String</span> value) &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          _iconTitle = <span class=\"string\">\"IconPopMenu : \"</span> + value;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// 3. CheckedPopupMenuItem</span></span><br><span class=\"line\">  Widget _checkedPopupMenuItem() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PopupMenuButton&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">      child: Text(_checkedTitle),</span><br><span class=\"line\">      itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;&gt;[</span><br><span class=\"line\">            CheckedPopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              checked: _checkedTitle == <span class=\"string\">'Checked One'</span>,</span><br><span class=\"line\">              value: <span class=\"string\">'Checked One'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">\"Check One\"</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            CheckedPopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              checked: _checkedTitle == <span class=\"string\">'Checked Two'</span>,</span><br><span class=\"line\">              value: <span class=\"string\">'Checked Two'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">\"Check Two\"</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            CheckedPopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              checked: _checkedTitle == <span class=\"string\">'Checked Three'</span>,</span><br><span class=\"line\">              value: <span class=\"string\">'Checked Three'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">\"Check Three\"</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            CheckedPopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              checked: _checkedTitle == <span class=\"string\">'Checked Four'</span>,</span><br><span class=\"line\">              value: <span class=\"string\">'Checked Four'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">\"Check Four\"</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ],</span><br><span class=\"line\">      onSelected: (<span class=\"built_in\">String</span> value) &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          _checkedTitle = value;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// 4. PopupMenuDivider</span></span><br><span class=\"line\">  <span class=\"comment\">///  PopupMenuDivider 是一条水平分割线，注意数组要使用父类 PopupMenuEntry，配合其他 item 样式共同使用。</span></span><br><span class=\"line\">  <span class=\"comment\">///  PopupMenuDivider 可以调整高度，但无法调整颜色，有需要的话可以进行自定义。</span></span><br><span class=\"line\">  Widget _popupMenuDivider() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> PopupMenuButton&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">      itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuEntry&lt;<span class=\"built_in\">String</span>&gt;&gt;[</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Item One'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">'Item One'</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuDivider(</span><br><span class=\"line\">              height: <span class=\"number\">1.0</span>,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Item Two'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">'Item Two'</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuDivider(</span><br><span class=\"line\">              height: <span class=\"number\">4.0</span>,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Item Three'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">'Item Three'</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuDivider(</span><br><span class=\"line\">              height: <span class=\"number\">2.0</span>,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            PopupMenuItem&lt;<span class=\"built_in\">String</span>&gt;(</span><br><span class=\"line\">              value: <span class=\"string\">'Item Four'</span>,</span><br><span class=\"line\">              child: Text(<span class=\"string\">'Item Four'</span>),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ],</span><br><span class=\"line\">      child: Text(<span class=\"string\">\"PopupMenuDivider\"</span>),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// 5. showMenu</span></span><br><span class=\"line\">  Widget _showMenu(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Text(<span class=\"string\">\"// TODO showMenu\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Image&Icon","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T05:14:00.000Z","_content":"> Flutter 可以使用Image加载显示asset、本地、内存以及网络图片\n\n## ImageProvider\n> 是一个抽象类，定义了图片数据获取的接口load()，不同的数据源由对应不同的ImageProvider，如AssertImage、NetworkImage\n\n## Image\n\n### 类结构\n```dart\n const Image({\n    Key key,\n    @required this.image, // 图片源\n    this.semanticLabel,\n    this.excludeFromSemantics = false,\n    this.width,//图片的宽\n    this.height, //图片高度\n    this.color,//图片的混合色值\n    this.colorBlendMode,//混合模式\n    this.fit,//缩放模式\n    this.alignment = Alignment.center, //对齐方式\n    this.repeat = ImageRepeat.noRepeat,//重复方式\n    this.centerSlice,// 内部拉伸区域\n    this.matchTextDirection = false,\n    this.gaplessPlayback = false,\n    this.filterQuality = FilterQuality.low,\n  })\n```\n### 构造方法\n| 方式          | 解释                                                              |\n| ------------- | ----------------------------------------------------------------- |\n| Image()       | 通用方法，使用ImageProvider实现，如下方法本质上也是使用的这个方法 |\n| Image.asset   | 加载资源图片                                                      |\n| Image.file    | 加载本地图片文件                                                  |\n| Image.network | 加载网络图片                                                      |\n| Image.memory  | 加载Uint8List资源图片                                             |\n\n### 属性\n#### image\n> 抽象类，需要自己实现获取图片数据的操作\n\n常用ImageProvider\n- ExactAssetImage\n- AssetImage\n- NetworkImage\n- FileImage\n- MemoryImage\n\n#### width & height\n> 显示区域的宽和高。\n\n#### fit\n> 缩放模式\n\n- BoxFit.fill 全图显示，拉伸、充满\n- BoxFit.contain 原比例全图显示\n- BoxFit.cover 拉伸、裁剪、充满\n- BoxFit.fitWidth 宽度充满\n- BoxFit.fitHeight 高度充满\n- BoxFit.scaleDown 类似contain，但是不允许显示超过源图片大小，可变小，不可变大\n- BoxFit.none 原图显示\n\n#### color & colorBlendMode\n> 混合模式，配合使用\n\n#### alignment\n> 控制图片的摆放位置\n\n#### repeat\n> 重复显示\n- ImageRepeat.repeat X、Y方向都重复显示\n- ImageRepeat.repeatX 横向重复\n- ImageRepeat.repeatY 竖向重复\n- ImageRepeat.none 不重复\n  \n#### centerSlice\n> 当图片被拉伸时，centerSlice定义的区域会被拉升\n```dart\nImage image = Image.asset(\n    'image/14v.png',\n    width: 300.0,\n    height: 300.0,\n    fit: BoxFit.contain,\n    centerSlice: Rect.fromCircle(\n        center: const Offset(100.0,100.0),\n        radius: 10.0,\n    ),\n)\n```\n```dart\nassert(sourceSize == inputSize, 'centerSlice was used with a BoxFit that does not guarantee that the image is fully visible.');\n```\n`* 当显示比例小于原图片大小时，会报错！`\n\n#### matchTextDirection\n> 与 Directionality 配合使用\n\n#### gaplessPlayback\n> 当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留。若值为true，保留，若为false，不保留，直接空白等待下一张图片加载。\n\n## Icon\n> Flutter中可以像Web开发一样使用iconfont,即字体图标，它是将图标做成字体文件，然后通过指定不同的字符而显示不同的图片。\n\nIcon与Image相比有如下优势\n1. 体积小\n2. 矢量化，放大不变形。\n3. 可以应用文本样式。\n4. 可以利用TextSpan和文本混用。\n\n### 使用Material Design字体图标\nFlutter默认包含了一套Material Design的字体图标，在pubspec.yaml文件中的配置如下：\n```dart\n flutter:\n   user-material-design: true\n```\n所有的图标集合可查看官网 http://material.io/tools/icons\n","source":"_posts/flutter/widget/Image&Icon.md","raw":"---\ntitle: Image&Icon\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 13:14:00   \n---\n> Flutter 可以使用Image加载显示asset、本地、内存以及网络图片\n\n## ImageProvider\n> 是一个抽象类，定义了图片数据获取的接口load()，不同的数据源由对应不同的ImageProvider，如AssertImage、NetworkImage\n\n## Image\n\n### 类结构\n```dart\n const Image({\n    Key key,\n    @required this.image, // 图片源\n    this.semanticLabel,\n    this.excludeFromSemantics = false,\n    this.width,//图片的宽\n    this.height, //图片高度\n    this.color,//图片的混合色值\n    this.colorBlendMode,//混合模式\n    this.fit,//缩放模式\n    this.alignment = Alignment.center, //对齐方式\n    this.repeat = ImageRepeat.noRepeat,//重复方式\n    this.centerSlice,// 内部拉伸区域\n    this.matchTextDirection = false,\n    this.gaplessPlayback = false,\n    this.filterQuality = FilterQuality.low,\n  })\n```\n### 构造方法\n| 方式          | 解释                                                              |\n| ------------- | ----------------------------------------------------------------- |\n| Image()       | 通用方法，使用ImageProvider实现，如下方法本质上也是使用的这个方法 |\n| Image.asset   | 加载资源图片                                                      |\n| Image.file    | 加载本地图片文件                                                  |\n| Image.network | 加载网络图片                                                      |\n| Image.memory  | 加载Uint8List资源图片                                             |\n\n### 属性\n#### image\n> 抽象类，需要自己实现获取图片数据的操作\n\n常用ImageProvider\n- ExactAssetImage\n- AssetImage\n- NetworkImage\n- FileImage\n- MemoryImage\n\n#### width & height\n> 显示区域的宽和高。\n\n#### fit\n> 缩放模式\n\n- BoxFit.fill 全图显示，拉伸、充满\n- BoxFit.contain 原比例全图显示\n- BoxFit.cover 拉伸、裁剪、充满\n- BoxFit.fitWidth 宽度充满\n- BoxFit.fitHeight 高度充满\n- BoxFit.scaleDown 类似contain，但是不允许显示超过源图片大小，可变小，不可变大\n- BoxFit.none 原图显示\n\n#### color & colorBlendMode\n> 混合模式，配合使用\n\n#### alignment\n> 控制图片的摆放位置\n\n#### repeat\n> 重复显示\n- ImageRepeat.repeat X、Y方向都重复显示\n- ImageRepeat.repeatX 横向重复\n- ImageRepeat.repeatY 竖向重复\n- ImageRepeat.none 不重复\n  \n#### centerSlice\n> 当图片被拉伸时，centerSlice定义的区域会被拉升\n```dart\nImage image = Image.asset(\n    'image/14v.png',\n    width: 300.0,\n    height: 300.0,\n    fit: BoxFit.contain,\n    centerSlice: Rect.fromCircle(\n        center: const Offset(100.0,100.0),\n        radius: 10.0,\n    ),\n)\n```\n```dart\nassert(sourceSize == inputSize, 'centerSlice was used with a BoxFit that does not guarantee that the image is fully visible.');\n```\n`* 当显示比例小于原图片大小时，会报错！`\n\n#### matchTextDirection\n> 与 Directionality 配合使用\n\n#### gaplessPlayback\n> 当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留。若值为true，保留，若为false，不保留，直接空白等待下一张图片加载。\n\n## Icon\n> Flutter中可以像Web开发一样使用iconfont,即字体图标，它是将图标做成字体文件，然后通过指定不同的字符而显示不同的图片。\n\nIcon与Image相比有如下优势\n1. 体积小\n2. 矢量化，放大不变形。\n3. 可以应用文本样式。\n4. 可以利用TextSpan和文本混用。\n\n### 使用Material Design字体图标\nFlutter默认包含了一套Material Design的字体图标，在pubspec.yaml文件中的配置如下：\n```dart\n flutter:\n   user-material-design: true\n```\n所有的图标集合可查看官网 http://material.io/tools/icons\n","slug":"flutter/widget/Image&Icon","published":1,"updated":"2019-10-02T11:51:41.152Z","layout":"post","photos":[],"link":"","_id":"ck19bvb48004u00wkr312ra07","content":"<blockquote>\n<p>Flutter 可以使用Image加载显示asset、本地、内存以及网络图片</p>\n</blockquote>\n<h2 id=\"ImageProvider\"><a href=\"#ImageProvider\" class=\"headerlink\" title=\"ImageProvider\"></a>ImageProvider</h2><blockquote>\n<p>是一个抽象类，定义了图片数据获取的接口load()，不同的数据源由对应不同的ImageProvider，如AssertImage、NetworkImage</p>\n</blockquote>\n<h2 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h2><h3 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Image(&#123;</span><br><span class=\"line\">   Key key,</span><br><span class=\"line\">   <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.image, <span class=\"comment\">// 图片源</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.semanticLabel,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.excludeFromSemantics = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.width,<span class=\"comment\">//图片的宽</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.height, <span class=\"comment\">//图片高度</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.color,<span class=\"comment\">//图片的混合色值</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.colorBlendMode,<span class=\"comment\">//混合模式</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.fit,<span class=\"comment\">//缩放模式</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.alignment = Alignment.center, <span class=\"comment\">//对齐方式</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.repeat = ImageRepeat.noRepeat,<span class=\"comment\">//重复方式</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.centerSlice,<span class=\"comment\">// 内部拉伸区域</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.matchTextDirection = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.gaplessPlayback = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.filterQuality = FilterQuality.low,</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Image()</td>\n<td>通用方法，使用ImageProvider实现，如下方法本质上也是使用的这个方法</td>\n</tr>\n<tr>\n<td>Image.asset</td>\n<td>加载资源图片</td>\n</tr>\n<tr>\n<td>Image.file</td>\n<td>加载本地图片文件</td>\n</tr>\n<tr>\n<td>Image.network</td>\n<td>加载网络图片</td>\n</tr>\n<tr>\n<td>Image.memory</td>\n<td>加载Uint8List资源图片</td>\n</tr>\n</tbody></table>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><h4 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h4><blockquote>\n<p>抽象类，需要自己实现获取图片数据的操作</p>\n</blockquote>\n<p>常用ImageProvider</p>\n<ul>\n<li>ExactAssetImage</li>\n<li>AssetImage</li>\n<li>NetworkImage</li>\n<li>FileImage</li>\n<li>MemoryImage</li>\n</ul>\n<h4 id=\"width-amp-height\"><a href=\"#width-amp-height\" class=\"headerlink\" title=\"width &amp; height\"></a>width &amp; height</h4><blockquote>\n<p>显示区域的宽和高。</p>\n</blockquote>\n<h4 id=\"fit\"><a href=\"#fit\" class=\"headerlink\" title=\"fit\"></a>fit</h4><blockquote>\n<p>缩放模式</p>\n</blockquote>\n<ul>\n<li>BoxFit.fill 全图显示，拉伸、充满</li>\n<li>BoxFit.contain 原比例全图显示</li>\n<li>BoxFit.cover 拉伸、裁剪、充满</li>\n<li>BoxFit.fitWidth 宽度充满</li>\n<li>BoxFit.fitHeight 高度充满</li>\n<li>BoxFit.scaleDown 类似contain，但是不允许显示超过源图片大小，可变小，不可变大</li>\n<li>BoxFit.none 原图显示</li>\n</ul>\n<h4 id=\"color-amp-colorBlendMode\"><a href=\"#color-amp-colorBlendMode\" class=\"headerlink\" title=\"color &amp; colorBlendMode\"></a>color &amp; colorBlendMode</h4><blockquote>\n<p>混合模式，配合使用</p>\n</blockquote>\n<h4 id=\"alignment\"><a href=\"#alignment\" class=\"headerlink\" title=\"alignment\"></a>alignment</h4><blockquote>\n<p>控制图片的摆放位置</p>\n</blockquote>\n<h4 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat\"></a>repeat</h4><blockquote>\n<p>重复显示</p>\n<ul>\n<li>ImageRepeat.repeat X、Y方向都重复显示</li>\n<li>ImageRepeat.repeatX 横向重复</li>\n<li>ImageRepeat.repeatY 竖向重复</li>\n<li>ImageRepeat.none 不重复</li>\n</ul>\n</blockquote>\n<h4 id=\"centerSlice\"><a href=\"#centerSlice\" class=\"headerlink\" title=\"centerSlice\"></a>centerSlice</h4><blockquote>\n<p>当图片被拉伸时，centerSlice定义的区域会被拉升</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image image = Image.asset(</span><br><span class=\"line\">    <span class=\"string\">'image/14v.png'</span>,</span><br><span class=\"line\">    width: <span class=\"number\">300.0</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300.0</span>,</span><br><span class=\"line\">    fit: BoxFit.contain,</span><br><span class=\"line\">    centerSlice: Rect.fromCircle(</span><br><span class=\"line\">        center: <span class=\"keyword\">const</span> Offset(<span class=\"number\">100.0</span>,<span class=\"number\">100.0</span>),</span><br><span class=\"line\">        radius: <span class=\"number\">10.0</span>,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(sourceSize == inputSize, <span class=\"string\">'centerSlice was used with a BoxFit that does not guarantee that the image is fully visible.'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>* 当显示比例小于原图片大小时，会报错！</code></p>\n<h4 id=\"matchTextDirection\"><a href=\"#matchTextDirection\" class=\"headerlink\" title=\"matchTextDirection\"></a>matchTextDirection</h4><blockquote>\n<p>与 Directionality 配合使用</p>\n</blockquote>\n<h4 id=\"gaplessPlayback\"><a href=\"#gaplessPlayback\" class=\"headerlink\" title=\"gaplessPlayback\"></a>gaplessPlayback</h4><blockquote>\n<p>当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留。若值为true，保留，若为false，不保留，直接空白等待下一张图片加载。</p>\n</blockquote>\n<h2 id=\"Icon\"><a href=\"#Icon\" class=\"headerlink\" title=\"Icon\"></a>Icon</h2><blockquote>\n<p>Flutter中可以像Web开发一样使用iconfont,即字体图标，它是将图标做成字体文件，然后通过指定不同的字符而显示不同的图片。</p>\n</blockquote>\n<p>Icon与Image相比有如下优势</p>\n<ol>\n<li>体积小</li>\n<li>矢量化，放大不变形。</li>\n<li>可以应用文本样式。</li>\n<li>可以利用TextSpan和文本混用。</li>\n</ol>\n<h3 id=\"使用Material-Design字体图标\"><a href=\"#使用Material-Design字体图标\" class=\"headerlink\" title=\"使用Material Design字体图标\"></a>使用Material Design字体图标</h3><p>Flutter默认包含了一套Material Design的字体图标，在pubspec.yaml文件中的配置如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter:</span><br><span class=\"line\">  user-material-design: <span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>所有的图标集合可查看官网 <a href=\"http://material.io/tools/icons\" target=\"_blank\" rel=\"noopener\">http://material.io/tools/icons</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Flutter 可以使用Image加载显示asset、本地、内存以及网络图片</p>\n</blockquote>\n<h2 id=\"ImageProvider\"><a href=\"#ImageProvider\" class=\"headerlink\" title=\"ImageProvider\"></a>ImageProvider</h2><blockquote>\n<p>是一个抽象类，定义了图片数据获取的接口load()，不同的数据源由对应不同的ImageProvider，如AssertImage、NetworkImage</p>\n</blockquote>\n<h2 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h2><h3 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Image(&#123;</span><br><span class=\"line\">   Key key,</span><br><span class=\"line\">   <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.image, <span class=\"comment\">// 图片源</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.semanticLabel,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.excludeFromSemantics = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.width,<span class=\"comment\">//图片的宽</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.height, <span class=\"comment\">//图片高度</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.color,<span class=\"comment\">//图片的混合色值</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.colorBlendMode,<span class=\"comment\">//混合模式</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.fit,<span class=\"comment\">//缩放模式</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.alignment = Alignment.center, <span class=\"comment\">//对齐方式</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.repeat = ImageRepeat.noRepeat,<span class=\"comment\">//重复方式</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.centerSlice,<span class=\"comment\">// 内部拉伸区域</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.matchTextDirection = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.gaplessPlayback = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.filterQuality = FilterQuality.low,</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Image()</td>\n<td>通用方法，使用ImageProvider实现，如下方法本质上也是使用的这个方法</td>\n</tr>\n<tr>\n<td>Image.asset</td>\n<td>加载资源图片</td>\n</tr>\n<tr>\n<td>Image.file</td>\n<td>加载本地图片文件</td>\n</tr>\n<tr>\n<td>Image.network</td>\n<td>加载网络图片</td>\n</tr>\n<tr>\n<td>Image.memory</td>\n<td>加载Uint8List资源图片</td>\n</tr>\n</tbody></table>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><h4 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h4><blockquote>\n<p>抽象类，需要自己实现获取图片数据的操作</p>\n</blockquote>\n<p>常用ImageProvider</p>\n<ul>\n<li>ExactAssetImage</li>\n<li>AssetImage</li>\n<li>NetworkImage</li>\n<li>FileImage</li>\n<li>MemoryImage</li>\n</ul>\n<h4 id=\"width-amp-height\"><a href=\"#width-amp-height\" class=\"headerlink\" title=\"width &amp; height\"></a>width &amp; height</h4><blockquote>\n<p>显示区域的宽和高。</p>\n</blockquote>\n<h4 id=\"fit\"><a href=\"#fit\" class=\"headerlink\" title=\"fit\"></a>fit</h4><blockquote>\n<p>缩放模式</p>\n</blockquote>\n<ul>\n<li>BoxFit.fill 全图显示，拉伸、充满</li>\n<li>BoxFit.contain 原比例全图显示</li>\n<li>BoxFit.cover 拉伸、裁剪、充满</li>\n<li>BoxFit.fitWidth 宽度充满</li>\n<li>BoxFit.fitHeight 高度充满</li>\n<li>BoxFit.scaleDown 类似contain，但是不允许显示超过源图片大小，可变小，不可变大</li>\n<li>BoxFit.none 原图显示</li>\n</ul>\n<h4 id=\"color-amp-colorBlendMode\"><a href=\"#color-amp-colorBlendMode\" class=\"headerlink\" title=\"color &amp; colorBlendMode\"></a>color &amp; colorBlendMode</h4><blockquote>\n<p>混合模式，配合使用</p>\n</blockquote>\n<h4 id=\"alignment\"><a href=\"#alignment\" class=\"headerlink\" title=\"alignment\"></a>alignment</h4><blockquote>\n<p>控制图片的摆放位置</p>\n</blockquote>\n<h4 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat\"></a>repeat</h4><blockquote>\n<p>重复显示</p>\n<ul>\n<li>ImageRepeat.repeat X、Y方向都重复显示</li>\n<li>ImageRepeat.repeatX 横向重复</li>\n<li>ImageRepeat.repeatY 竖向重复</li>\n<li>ImageRepeat.none 不重复</li>\n</ul>\n</blockquote>\n<h4 id=\"centerSlice\"><a href=\"#centerSlice\" class=\"headerlink\" title=\"centerSlice\"></a>centerSlice</h4><blockquote>\n<p>当图片被拉伸时，centerSlice定义的区域会被拉升</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image image = Image.asset(</span><br><span class=\"line\">    <span class=\"string\">'image/14v.png'</span>,</span><br><span class=\"line\">    width: <span class=\"number\">300.0</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300.0</span>,</span><br><span class=\"line\">    fit: BoxFit.contain,</span><br><span class=\"line\">    centerSlice: Rect.fromCircle(</span><br><span class=\"line\">        center: <span class=\"keyword\">const</span> Offset(<span class=\"number\">100.0</span>,<span class=\"number\">100.0</span>),</span><br><span class=\"line\">        radius: <span class=\"number\">10.0</span>,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(sourceSize == inputSize, <span class=\"string\">'centerSlice was used with a BoxFit that does not guarantee that the image is fully visible.'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>* 当显示比例小于原图片大小时，会报错！</code></p>\n<h4 id=\"matchTextDirection\"><a href=\"#matchTextDirection\" class=\"headerlink\" title=\"matchTextDirection\"></a>matchTextDirection</h4><blockquote>\n<p>与 Directionality 配合使用</p>\n</blockquote>\n<h4 id=\"gaplessPlayback\"><a href=\"#gaplessPlayback\" class=\"headerlink\" title=\"gaplessPlayback\"></a>gaplessPlayback</h4><blockquote>\n<p>当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留。若值为true，保留，若为false，不保留，直接空白等待下一张图片加载。</p>\n</blockquote>\n<h2 id=\"Icon\"><a href=\"#Icon\" class=\"headerlink\" title=\"Icon\"></a>Icon</h2><blockquote>\n<p>Flutter中可以像Web开发一样使用iconfont,即字体图标，它是将图标做成字体文件，然后通过指定不同的字符而显示不同的图片。</p>\n</blockquote>\n<p>Icon与Image相比有如下优势</p>\n<ol>\n<li>体积小</li>\n<li>矢量化，放大不变形。</li>\n<li>可以应用文本样式。</li>\n<li>可以利用TextSpan和文本混用。</li>\n</ol>\n<h3 id=\"使用Material-Design字体图标\"><a href=\"#使用Material-Design字体图标\" class=\"headerlink\" title=\"使用Material Design字体图标\"></a>使用Material Design字体图标</h3><p>Flutter默认包含了一套Material Design的字体图标，在pubspec.yaml文件中的配置如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter:</span><br><span class=\"line\">  user-material-design: <span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>所有的图标集合可查看官网 <a href=\"http://material.io/tools/icons\" target=\"_blank\" rel=\"noopener\">http://material.io/tools/icons</a></p>\n"},{"title":"Button","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T07:54:00.000Z","_content":"## 介绍\n> 在Material Widget 库中提供了多种按钮Widget，如RaisedButton、FlatButton、OutlineButton等。\n\n所有Material库中的按钮都具备以下共同点：\n1. 按下时会有“水波动画”。\n2. 有一个onPressed属性来设置点击的回调，当按下时会执行回调，如果不提供该回调则按钮会处于禁用状态，不相应用户点击。\n\n## RaisedButton\n> 漂浮按钮，默认带有阴影、灰色背景，按下后，阴影变大。\n### 定义\n```dart\n const RaisedButton({\n    Key key,\n    @required VoidCallback onPressed, //按钮点击回调\n    ValueChanged<bool> onHighlightChanged,\n    ButtonTextTheme textTheme,\n    Color textColor, //按钮文字颜色\n    Color disabledTextColor, //按钮禁用时的文字颜色\n    Color color,//按钮背景颜色\n    Color disabledColor,//按钮禁用时的背景颜色\n    Color highlightColor,//按钮按下时的背景颜色\n    Color splashColor,//点击时，水波动画中水波的颜色\n    Brightness colorBrightness, //按钮主题\n    double elevation,//正常状态下的阴影\n    double highlightElevation,//按下时的阴影\n    double disabledElevation,// 禁用时的阴影\n    EdgeInsetsGeometry padding, //按钮的填充\n    ShapeBorder shape, //外形\n    Clip clipBehavior = Clip.none,\n    MaterialTapTargetSize materialTapTargetSize,\n    Duration animationDuration,\n    Widget child, //按钮的内容\n  })\n```\n### 简单样例\n```dart\nRaisedButton(\n    onPressed: () => print(\"你点击了RaisedButton\"),\n    child: Text(\"RaisedButton\"),\n)\n```\n\n## FlatButton\n> 扁平按钮，默认背景透明并不带阴影，按下后，会有背景色。\n### 定义\n```dart\nconst FlatButton({\n    Key key,\n    @required VoidCallback onPressed,//按钮点击回调\n    ValueChanged<bool> onHighlightChanged,\n    ButtonTextTheme textTheme,\n    Color textColor,//按钮文字颜色\n    Color disabledTextColor, //按钮禁用时的文字颜色\n    Color color,//按钮背景颜色\n    Color disabledColor,//按钮禁用时的背景颜色\n    Color highlightColor,//按钮按下时的背景颜色\n    Color splashColor,//点击时，水波动画中水波的颜色\n    Brightness colorBrightness,//按钮主题，默认是浅色主题 \n    EdgeInsetsGeometry padding,//按钮的填充\n    ShapeBorder shape,//外形\n    Clip clipBehavior = Clip.none,\n    MaterialTapTargetSize materialTapTargetSize,\n    @required Widget child,//按钮的内容\n  })\n```\n### 样例\n```dart\nFlatButton(\n    onPressed: () => print(\"你点击了FlatButton\"),\n    child: Text(\"FlatButton\"),\n)\n```\n\n## OutlineButton\n> OutlineButton默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)：\n### 定义\n```dart\nconst OutlineButton({\n    Key key,\n    @required VoidCallback onPressed, \n    ButtonTextTheme textTheme,\n    Color textColor,\n    Color disabledTextColor,\n    Color color,//按钮背景颜色\n    Color highlightColor,//按钮按下时的背景颜色\n    Color splashColor,//点击时，水波动画中水波的颜色\n    double highlightElevation,\n    this.borderSide,\n    this.disabledBorderColor,\n    this.highlightedBorderColor,\n    EdgeInsetsGeometry padding,\n    ShapeBorder shape,\n    Clip clipBehavior = Clip.none,\n    Widget child,\n  })\n```\n\n### 样例\n```dart\nOutlineButton(\n    onPressed: () => print(\"你点击了OutlineButton\"),\n    child: Text(\"OutlineButton\"),\n)\n```\n\n## IconButton\n> 可点击的Icon，不包含文字，默认没有背景，点击会出现背景\n\n### 定义\n```dart\n const IconButton({\n    Key key,\n    this.iconSize = 24.0,// icon大小\n    this.padding = const EdgeInsets.all(8.0),\n    this.alignment = Alignment.center,// 默认居中\n    @required this.icon,// 内部的icon\n    this.color,//按钮背景颜色\n    this.highlightColor,//按钮按下时的背景颜色\n    this.splashColor, //点击时，水波动画中水波的颜色\n    this.disabledColor,// 禁用颜色\n    @required this.onPressed,// 点击回调\n    this.tooltip // 长按回调\n  })\n```\n\n### 样例\n\n```dart\nIconButton(\n    onPressed: () => print(\"你点击了IconButton\"),\n    tooltip:\"你长按了我\",\n    icon: Icon(Icons.thumb_up),\n)\n```\n## 自定义按钮样式\n> 按钮外观可以通过其属性来定义，不同按钮属性大同小异。\n\n### 自定义一个圆角蓝色按钮\n```dart\nFlatButton(\n    color\n)\n```\n\n\n\n","source":"_posts/flutter/widget/Button.md","raw":"---\ntitle: Button\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 15:54:00   \n---\n## 介绍\n> 在Material Widget 库中提供了多种按钮Widget，如RaisedButton、FlatButton、OutlineButton等。\n\n所有Material库中的按钮都具备以下共同点：\n1. 按下时会有“水波动画”。\n2. 有一个onPressed属性来设置点击的回调，当按下时会执行回调，如果不提供该回调则按钮会处于禁用状态，不相应用户点击。\n\n## RaisedButton\n> 漂浮按钮，默认带有阴影、灰色背景，按下后，阴影变大。\n### 定义\n```dart\n const RaisedButton({\n    Key key,\n    @required VoidCallback onPressed, //按钮点击回调\n    ValueChanged<bool> onHighlightChanged,\n    ButtonTextTheme textTheme,\n    Color textColor, //按钮文字颜色\n    Color disabledTextColor, //按钮禁用时的文字颜色\n    Color color,//按钮背景颜色\n    Color disabledColor,//按钮禁用时的背景颜色\n    Color highlightColor,//按钮按下时的背景颜色\n    Color splashColor,//点击时，水波动画中水波的颜色\n    Brightness colorBrightness, //按钮主题\n    double elevation,//正常状态下的阴影\n    double highlightElevation,//按下时的阴影\n    double disabledElevation,// 禁用时的阴影\n    EdgeInsetsGeometry padding, //按钮的填充\n    ShapeBorder shape, //外形\n    Clip clipBehavior = Clip.none,\n    MaterialTapTargetSize materialTapTargetSize,\n    Duration animationDuration,\n    Widget child, //按钮的内容\n  })\n```\n### 简单样例\n```dart\nRaisedButton(\n    onPressed: () => print(\"你点击了RaisedButton\"),\n    child: Text(\"RaisedButton\"),\n)\n```\n\n## FlatButton\n> 扁平按钮，默认背景透明并不带阴影，按下后，会有背景色。\n### 定义\n```dart\nconst FlatButton({\n    Key key,\n    @required VoidCallback onPressed,//按钮点击回调\n    ValueChanged<bool> onHighlightChanged,\n    ButtonTextTheme textTheme,\n    Color textColor,//按钮文字颜色\n    Color disabledTextColor, //按钮禁用时的文字颜色\n    Color color,//按钮背景颜色\n    Color disabledColor,//按钮禁用时的背景颜色\n    Color highlightColor,//按钮按下时的背景颜色\n    Color splashColor,//点击时，水波动画中水波的颜色\n    Brightness colorBrightness,//按钮主题，默认是浅色主题 \n    EdgeInsetsGeometry padding,//按钮的填充\n    ShapeBorder shape,//外形\n    Clip clipBehavior = Clip.none,\n    MaterialTapTargetSize materialTapTargetSize,\n    @required Widget child,//按钮的内容\n  })\n```\n### 样例\n```dart\nFlatButton(\n    onPressed: () => print(\"你点击了FlatButton\"),\n    child: Text(\"FlatButton\"),\n)\n```\n\n## OutlineButton\n> OutlineButton默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)：\n### 定义\n```dart\nconst OutlineButton({\n    Key key,\n    @required VoidCallback onPressed, \n    ButtonTextTheme textTheme,\n    Color textColor,\n    Color disabledTextColor,\n    Color color,//按钮背景颜色\n    Color highlightColor,//按钮按下时的背景颜色\n    Color splashColor,//点击时，水波动画中水波的颜色\n    double highlightElevation,\n    this.borderSide,\n    this.disabledBorderColor,\n    this.highlightedBorderColor,\n    EdgeInsetsGeometry padding,\n    ShapeBorder shape,\n    Clip clipBehavior = Clip.none,\n    Widget child,\n  })\n```\n\n### 样例\n```dart\nOutlineButton(\n    onPressed: () => print(\"你点击了OutlineButton\"),\n    child: Text(\"OutlineButton\"),\n)\n```\n\n## IconButton\n> 可点击的Icon，不包含文字，默认没有背景，点击会出现背景\n\n### 定义\n```dart\n const IconButton({\n    Key key,\n    this.iconSize = 24.0,// icon大小\n    this.padding = const EdgeInsets.all(8.0),\n    this.alignment = Alignment.center,// 默认居中\n    @required this.icon,// 内部的icon\n    this.color,//按钮背景颜色\n    this.highlightColor,//按钮按下时的背景颜色\n    this.splashColor, //点击时，水波动画中水波的颜色\n    this.disabledColor,// 禁用颜色\n    @required this.onPressed,// 点击回调\n    this.tooltip // 长按回调\n  })\n```\n\n### 样例\n\n```dart\nIconButton(\n    onPressed: () => print(\"你点击了IconButton\"),\n    tooltip:\"你长按了我\",\n    icon: Icon(Icons.thumb_up),\n)\n```\n## 自定义按钮样式\n> 按钮外观可以通过其属性来定义，不同按钮属性大同小异。\n\n### 自定义一个圆角蓝色按钮\n```dart\nFlatButton(\n    color\n)\n```\n\n\n\n","slug":"flutter/widget/Button","published":1,"updated":"2019-10-02T11:51:29.033Z","layout":"post","photos":[],"link":"","_id":"ck19bvb4d004y00wk3e07t5tr","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>在Material Widget 库中提供了多种按钮Widget，如RaisedButton、FlatButton、OutlineButton等。</p>\n</blockquote>\n<p>所有Material库中的按钮都具备以下共同点：</p>\n<ol>\n<li>按下时会有“水波动画”。</li>\n<li>有一个onPressed属性来设置点击的回调，当按下时会执行回调，如果不提供该回调则按钮会处于禁用状态，不相应用户点击。</li>\n</ol>\n<h2 id=\"RaisedButton\"><a href=\"#RaisedButton\" class=\"headerlink\" title=\"RaisedButton\"></a>RaisedButton</h2><blockquote>\n<p>漂浮按钮，默认带有阴影、灰色背景，按下后，阴影变大。</p>\n</blockquote>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> RaisedButton(&#123;</span><br><span class=\"line\">   Key key,</span><br><span class=\"line\">   <span class=\"meta\">@required</span> VoidCallback onPressed, <span class=\"comment\">//按钮点击回调</span></span><br><span class=\"line\">   ValueChanged&lt;<span class=\"built_in\">bool</span>&gt; onHighlightChanged,</span><br><span class=\"line\">   ButtonTextTheme textTheme,</span><br><span class=\"line\">   Color textColor, <span class=\"comment\">//按钮文字颜色</span></span><br><span class=\"line\">   Color disabledTextColor, <span class=\"comment\">//按钮禁用时的文字颜色</span></span><br><span class=\"line\">   Color color,<span class=\"comment\">//按钮背景颜色</span></span><br><span class=\"line\">   Color disabledColor,<span class=\"comment\">//按钮禁用时的背景颜色</span></span><br><span class=\"line\">   Color highlightColor,<span class=\"comment\">//按钮按下时的背景颜色</span></span><br><span class=\"line\">   Color splashColor,<span class=\"comment\">//点击时，水波动画中水波的颜色</span></span><br><span class=\"line\">   Brightness colorBrightness, <span class=\"comment\">//按钮主题</span></span><br><span class=\"line\">   <span class=\"built_in\">double</span> elevation,<span class=\"comment\">//正常状态下的阴影</span></span><br><span class=\"line\">   <span class=\"built_in\">double</span> highlightElevation,<span class=\"comment\">//按下时的阴影</span></span><br><span class=\"line\">   <span class=\"built_in\">double</span> disabledElevation,<span class=\"comment\">// 禁用时的阴影</span></span><br><span class=\"line\">   EdgeInsetsGeometry padding, <span class=\"comment\">//按钮的填充</span></span><br><span class=\"line\">   ShapeBorder shape, <span class=\"comment\">//外形</span></span><br><span class=\"line\">   Clip clipBehavior = Clip.none,</span><br><span class=\"line\">   MaterialTapTargetSize materialTapTargetSize,</span><br><span class=\"line\">   <span class=\"built_in\">Duration</span> animationDuration,</span><br><span class=\"line\">   Widget child, <span class=\"comment\">//按钮的内容</span></span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单样例\"><a href=\"#简单样例\" class=\"headerlink\" title=\"简单样例\"></a>简单样例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RaisedButton(</span><br><span class=\"line\">    onPressed: () =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了RaisedButton\"</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"RaisedButton\"</span>),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"FlatButton\"><a href=\"#FlatButton\" class=\"headerlink\" title=\"FlatButton\"></a>FlatButton</h2><blockquote>\n<p>扁平按钮，默认背景透明并不带阴影，按下后，会有背景色。</p>\n</blockquote>\n<h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> FlatButton(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> VoidCallback onPressed,<span class=\"comment\">//按钮点击回调</span></span><br><span class=\"line\">    ValueChanged&lt;<span class=\"built_in\">bool</span>&gt; onHighlightChanged,</span><br><span class=\"line\">    ButtonTextTheme textTheme,</span><br><span class=\"line\">    Color textColor,<span class=\"comment\">//按钮文字颜色</span></span><br><span class=\"line\">    Color disabledTextColor, <span class=\"comment\">//按钮禁用时的文字颜色</span></span><br><span class=\"line\">    Color color,<span class=\"comment\">//按钮背景颜色</span></span><br><span class=\"line\">    Color disabledColor,<span class=\"comment\">//按钮禁用时的背景颜色</span></span><br><span class=\"line\">    Color highlightColor,<span class=\"comment\">//按钮按下时的背景颜色</span></span><br><span class=\"line\">    Color splashColor,<span class=\"comment\">//点击时，水波动画中水波的颜色</span></span><br><span class=\"line\">    Brightness colorBrightness,<span class=\"comment\">//按钮主题，默认是浅色主题 </span></span><br><span class=\"line\">    EdgeInsetsGeometry padding,<span class=\"comment\">//按钮的填充</span></span><br><span class=\"line\">    ShapeBorder shape,<span class=\"comment\">//外形</span></span><br><span class=\"line\">    Clip clipBehavior = Clip.none,</span><br><span class=\"line\">    MaterialTapTargetSize materialTapTargetSize,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> Widget child,<span class=\"comment\">//按钮的内容</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlatButton(</span><br><span class=\"line\">    onPressed: () =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了FlatButton\"</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"FlatButton\"</span>),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"OutlineButton\"><a href=\"#OutlineButton\" class=\"headerlink\" title=\"OutlineButton\"></a>OutlineButton</h2><blockquote>\n<p>OutlineButton默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)：</p>\n</blockquote>\n<h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> OutlineButton(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> VoidCallback onPressed, </span><br><span class=\"line\">    ButtonTextTheme textTheme,</span><br><span class=\"line\">    Color textColor,</span><br><span class=\"line\">    Color disabledTextColor,</span><br><span class=\"line\">    Color color,<span class=\"comment\">//按钮背景颜色</span></span><br><span class=\"line\">    Color highlightColor,<span class=\"comment\">//按钮按下时的背景颜色</span></span><br><span class=\"line\">    Color splashColor,<span class=\"comment\">//点击时，水波动画中水波的颜色</span></span><br><span class=\"line\">    <span class=\"built_in\">double</span> highlightElevation,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.borderSide,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.disabledBorderColor,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.highlightedBorderColor,</span><br><span class=\"line\">    EdgeInsetsGeometry padding,</span><br><span class=\"line\">    ShapeBorder shape,</span><br><span class=\"line\">    Clip clipBehavior = Clip.none,</span><br><span class=\"line\">    Widget child,</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"样例-1\"><a href=\"#样例-1\" class=\"headerlink\" title=\"样例\"></a>样例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutlineButton(</span><br><span class=\"line\">    onPressed: () =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了OutlineButton\"</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"OutlineButton\"</span>),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IconButton\"><a href=\"#IconButton\" class=\"headerlink\" title=\"IconButton\"></a>IconButton</h2><blockquote>\n<p>可点击的Icon，不包含文字，默认没有背景，点击会出现背景</p>\n</blockquote>\n<h3 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> IconButton(&#123;</span><br><span class=\"line\">   Key key,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.iconSize = <span class=\"number\">24.0</span>,<span class=\"comment\">// icon大小</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.padding = <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">8.0</span>),</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.alignment = Alignment.center,<span class=\"comment\">// 默认居中</span></span><br><span class=\"line\">   <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.icon,<span class=\"comment\">// 内部的icon</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.color,<span class=\"comment\">//按钮背景颜色</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.highlightColor,<span class=\"comment\">//按钮按下时的背景颜色</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.splashColor, <span class=\"comment\">//点击时，水波动画中水波的颜色</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.disabledColor,<span class=\"comment\">// 禁用颜色</span></span><br><span class=\"line\">   <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.onPressed,<span class=\"comment\">// 点击回调</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.tooltip <span class=\"comment\">// 长按回调</span></span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"样例-2\"><a href=\"#样例-2\" class=\"headerlink\" title=\"样例\"></a>样例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IconButton(</span><br><span class=\"line\">    onPressed: () =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了IconButton\"</span>),</span><br><span class=\"line\">    tooltip:<span class=\"string\">\"你长按了我\"</span>,</span><br><span class=\"line\">    icon: Icon(Icons.thumb_up),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义按钮样式\"><a href=\"#自定义按钮样式\" class=\"headerlink\" title=\"自定义按钮样式\"></a>自定义按钮样式</h2><blockquote>\n<p>按钮外观可以通过其属性来定义，不同按钮属性大同小异。</p>\n</blockquote>\n<h3 id=\"自定义一个圆角蓝色按钮\"><a href=\"#自定义一个圆角蓝色按钮\" class=\"headerlink\" title=\"自定义一个圆角蓝色按钮\"></a>自定义一个圆角蓝色按钮</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlatButton(</span><br><span class=\"line\">    color</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>在Material Widget 库中提供了多种按钮Widget，如RaisedButton、FlatButton、OutlineButton等。</p>\n</blockquote>\n<p>所有Material库中的按钮都具备以下共同点：</p>\n<ol>\n<li>按下时会有“水波动画”。</li>\n<li>有一个onPressed属性来设置点击的回调，当按下时会执行回调，如果不提供该回调则按钮会处于禁用状态，不相应用户点击。</li>\n</ol>\n<h2 id=\"RaisedButton\"><a href=\"#RaisedButton\" class=\"headerlink\" title=\"RaisedButton\"></a>RaisedButton</h2><blockquote>\n<p>漂浮按钮，默认带有阴影、灰色背景，按下后，阴影变大。</p>\n</blockquote>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> RaisedButton(&#123;</span><br><span class=\"line\">   Key key,</span><br><span class=\"line\">   <span class=\"meta\">@required</span> VoidCallback onPressed, <span class=\"comment\">//按钮点击回调</span></span><br><span class=\"line\">   ValueChanged&lt;<span class=\"built_in\">bool</span>&gt; onHighlightChanged,</span><br><span class=\"line\">   ButtonTextTheme textTheme,</span><br><span class=\"line\">   Color textColor, <span class=\"comment\">//按钮文字颜色</span></span><br><span class=\"line\">   Color disabledTextColor, <span class=\"comment\">//按钮禁用时的文字颜色</span></span><br><span class=\"line\">   Color color,<span class=\"comment\">//按钮背景颜色</span></span><br><span class=\"line\">   Color disabledColor,<span class=\"comment\">//按钮禁用时的背景颜色</span></span><br><span class=\"line\">   Color highlightColor,<span class=\"comment\">//按钮按下时的背景颜色</span></span><br><span class=\"line\">   Color splashColor,<span class=\"comment\">//点击时，水波动画中水波的颜色</span></span><br><span class=\"line\">   Brightness colorBrightness, <span class=\"comment\">//按钮主题</span></span><br><span class=\"line\">   <span class=\"built_in\">double</span> elevation,<span class=\"comment\">//正常状态下的阴影</span></span><br><span class=\"line\">   <span class=\"built_in\">double</span> highlightElevation,<span class=\"comment\">//按下时的阴影</span></span><br><span class=\"line\">   <span class=\"built_in\">double</span> disabledElevation,<span class=\"comment\">// 禁用时的阴影</span></span><br><span class=\"line\">   EdgeInsetsGeometry padding, <span class=\"comment\">//按钮的填充</span></span><br><span class=\"line\">   ShapeBorder shape, <span class=\"comment\">//外形</span></span><br><span class=\"line\">   Clip clipBehavior = Clip.none,</span><br><span class=\"line\">   MaterialTapTargetSize materialTapTargetSize,</span><br><span class=\"line\">   <span class=\"built_in\">Duration</span> animationDuration,</span><br><span class=\"line\">   Widget child, <span class=\"comment\">//按钮的内容</span></span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单样例\"><a href=\"#简单样例\" class=\"headerlink\" title=\"简单样例\"></a>简单样例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RaisedButton(</span><br><span class=\"line\">    onPressed: () =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了RaisedButton\"</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"RaisedButton\"</span>),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"FlatButton\"><a href=\"#FlatButton\" class=\"headerlink\" title=\"FlatButton\"></a>FlatButton</h2><blockquote>\n<p>扁平按钮，默认背景透明并不带阴影，按下后，会有背景色。</p>\n</blockquote>\n<h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> FlatButton(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> VoidCallback onPressed,<span class=\"comment\">//按钮点击回调</span></span><br><span class=\"line\">    ValueChanged&lt;<span class=\"built_in\">bool</span>&gt; onHighlightChanged,</span><br><span class=\"line\">    ButtonTextTheme textTheme,</span><br><span class=\"line\">    Color textColor,<span class=\"comment\">//按钮文字颜色</span></span><br><span class=\"line\">    Color disabledTextColor, <span class=\"comment\">//按钮禁用时的文字颜色</span></span><br><span class=\"line\">    Color color,<span class=\"comment\">//按钮背景颜色</span></span><br><span class=\"line\">    Color disabledColor,<span class=\"comment\">//按钮禁用时的背景颜色</span></span><br><span class=\"line\">    Color highlightColor,<span class=\"comment\">//按钮按下时的背景颜色</span></span><br><span class=\"line\">    Color splashColor,<span class=\"comment\">//点击时，水波动画中水波的颜色</span></span><br><span class=\"line\">    Brightness colorBrightness,<span class=\"comment\">//按钮主题，默认是浅色主题 </span></span><br><span class=\"line\">    EdgeInsetsGeometry padding,<span class=\"comment\">//按钮的填充</span></span><br><span class=\"line\">    ShapeBorder shape,<span class=\"comment\">//外形</span></span><br><span class=\"line\">    Clip clipBehavior = Clip.none,</span><br><span class=\"line\">    MaterialTapTargetSize materialTapTargetSize,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> Widget child,<span class=\"comment\">//按钮的内容</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlatButton(</span><br><span class=\"line\">    onPressed: () =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了FlatButton\"</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"FlatButton\"</span>),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"OutlineButton\"><a href=\"#OutlineButton\" class=\"headerlink\" title=\"OutlineButton\"></a>OutlineButton</h2><blockquote>\n<p>OutlineButton默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)：</p>\n</blockquote>\n<h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> OutlineButton(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> VoidCallback onPressed, </span><br><span class=\"line\">    ButtonTextTheme textTheme,</span><br><span class=\"line\">    Color textColor,</span><br><span class=\"line\">    Color disabledTextColor,</span><br><span class=\"line\">    Color color,<span class=\"comment\">//按钮背景颜色</span></span><br><span class=\"line\">    Color highlightColor,<span class=\"comment\">//按钮按下时的背景颜色</span></span><br><span class=\"line\">    Color splashColor,<span class=\"comment\">//点击时，水波动画中水波的颜色</span></span><br><span class=\"line\">    <span class=\"built_in\">double</span> highlightElevation,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.borderSide,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.disabledBorderColor,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.highlightedBorderColor,</span><br><span class=\"line\">    EdgeInsetsGeometry padding,</span><br><span class=\"line\">    ShapeBorder shape,</span><br><span class=\"line\">    Clip clipBehavior = Clip.none,</span><br><span class=\"line\">    Widget child,</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"样例-1\"><a href=\"#样例-1\" class=\"headerlink\" title=\"样例\"></a>样例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutlineButton(</span><br><span class=\"line\">    onPressed: () =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了OutlineButton\"</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"OutlineButton\"</span>),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IconButton\"><a href=\"#IconButton\" class=\"headerlink\" title=\"IconButton\"></a>IconButton</h2><blockquote>\n<p>可点击的Icon，不包含文字，默认没有背景，点击会出现背景</p>\n</blockquote>\n<h3 id=\"定义-3\"><a href=\"#定义-3\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> IconButton(&#123;</span><br><span class=\"line\">   Key key,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.iconSize = <span class=\"number\">24.0</span>,<span class=\"comment\">// icon大小</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.padding = <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">8.0</span>),</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.alignment = Alignment.center,<span class=\"comment\">// 默认居中</span></span><br><span class=\"line\">   <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.icon,<span class=\"comment\">// 内部的icon</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.color,<span class=\"comment\">//按钮背景颜色</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.highlightColor,<span class=\"comment\">//按钮按下时的背景颜色</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.splashColor, <span class=\"comment\">//点击时，水波动画中水波的颜色</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.disabledColor,<span class=\"comment\">// 禁用颜色</span></span><br><span class=\"line\">   <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.onPressed,<span class=\"comment\">// 点击回调</span></span><br><span class=\"line\">   <span class=\"keyword\">this</span>.tooltip <span class=\"comment\">// 长按回调</span></span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"样例-2\"><a href=\"#样例-2\" class=\"headerlink\" title=\"样例\"></a>样例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IconButton(</span><br><span class=\"line\">    onPressed: () =&gt; <span class=\"built_in\">print</span>(<span class=\"string\">\"你点击了IconButton\"</span>),</span><br><span class=\"line\">    tooltip:<span class=\"string\">\"你长按了我\"</span>,</span><br><span class=\"line\">    icon: Icon(Icons.thumb_up),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义按钮样式\"><a href=\"#自定义按钮样式\" class=\"headerlink\" title=\"自定义按钮样式\"></a>自定义按钮样式</h2><blockquote>\n<p>按钮外观可以通过其属性来定义，不同按钮属性大同小异。</p>\n</blockquote>\n<h3 id=\"自定义一个圆角蓝色按钮\"><a href=\"#自定义一个圆角蓝色按钮\" class=\"headerlink\" title=\"自定义一个圆角蓝色按钮\"></a>自定义一个圆角蓝色按钮</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlatButton(</span><br><span class=\"line\">    color</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"BottomNavigationBar","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-25T03:54:00.000Z","_content":"\n## 介绍\n> 底部导航是常见的APP布局方式，实际上我自己常用的app都是底部导航的\n\n##相关属性\n### BottomNavigationBar\n | 属性         | 说明                                                                |\n | ------------ | ------------------------------------------------------------------- |\n | items        | BottomNavigationBarItem 列表，包含了导航栏中的按钮                  |\n | currentIndex | 当前所高亮的按钮index                                               |\n | type         | BottomNavigationBarType 中定义的类型，有 fixed 和 shifting 两种类型 |\n | fixedColor   | 如果 type 类型为 fixed，则通过 fixedColor 设置选中 item 的颜色      |\n | iconSize     | BottomNavigationBarItem 中 icon 的大小                              |\n### BottomNavigationBarItem \n | 属性            | 说明                     |\n | --------------- | ------------------------ |\n | icon            | 图标 widget，一般为 Icon |\n | title           | 标题 widget，一般为 Text |\n | backgroundColor | item 的背景颜色          |\n\n### 示例\n```dart\nimport 'package:flutter/material.dart';\n\nclass BottomNavigationBarMaterial extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() => _BottomNavigationBar();\n}\n\nclass _BottomNavigationBar extends State<BottomNavigationBarMaterial> {\n  int _selectIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"BottomNavigationBar\"),\n        ),\n        bottomNavigationBar: BottomNavigationBar(\n          items: <BottomNavigationBarItem>[\n            BottomNavigationBarItem(\n              title: Text(\n                '首页',\n              ),\n              icon: Icon(\n                Icons.home,\n                color: Colors.black,\n              ),\n              activeIcon: Icon(\n                Icons.home,\n                color: Colors.pinkAccent,\n              ),\n            ),\n            BottomNavigationBarItem(\n              title: Text(\n                '通讯录',\n              ),\n              icon: Icon(\n                Icons.perm_contact_calendar,\n                color: Colors.black,\n              ),\n              activeIcon: Icon(\n                Icons.perm_contact_calendar,\n                color: Colors.pinkAccent,\n              ),\n            ),\n            BottomNavigationBarItem(\n              title: Text(\n                '新闻',\n              ),\n              icon: Icon(\n                Icons.fiber_new,\n                color: Colors.black,\n              ),\n              activeIcon: Icon(\n                Icons.fiber_new,\n                color: Colors.pinkAccent,\n              ),\n            ),\n            BottomNavigationBarItem(\n              title: Text(\n                '我',\n              ),\n              icon: Icon(\n                Icons.person_pin,\n                color: Colors.black,\n              ),\n              activeIcon: Icon(\n                Icons.person_pin,\n                color: Colors.pinkAccent,\n              ),\n            ),\n          ],\n          // icon大小\n          iconSize: 24,\n          // 默认选中第几个\n          currentIndex: _selectIndex,\n          // 选中变化回调\n          onTap: (index) {\n            setState(() {\n              _selectIndex = index;\n            });\n          },\n          // type=BottomNavigationBarType.fixed时选中字体的颜色\n          fixedColor: Colors.pinkAccent,\n          type: BottomNavigationBarType.fixed,\n        ),\n      ),\n    );\n  }\n}\n\n```\n![](img/bottomNavigationBarDemo.png)","source":"_posts/flutter/widget/18_Material_BottomNavigationBar.md","raw":"---\ntitle: BottomNavigationBar\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-25 11:54:00   \n---\n\n## 介绍\n> 底部导航是常见的APP布局方式，实际上我自己常用的app都是底部导航的\n\n##相关属性\n### BottomNavigationBar\n | 属性         | 说明                                                                |\n | ------------ | ------------------------------------------------------------------- |\n | items        | BottomNavigationBarItem 列表，包含了导航栏中的按钮                  |\n | currentIndex | 当前所高亮的按钮index                                               |\n | type         | BottomNavigationBarType 中定义的类型，有 fixed 和 shifting 两种类型 |\n | fixedColor   | 如果 type 类型为 fixed，则通过 fixedColor 设置选中 item 的颜色      |\n | iconSize     | BottomNavigationBarItem 中 icon 的大小                              |\n### BottomNavigationBarItem \n | 属性            | 说明                     |\n | --------------- | ------------------------ |\n | icon            | 图标 widget，一般为 Icon |\n | title           | 标题 widget，一般为 Text |\n | backgroundColor | item 的背景颜色          |\n\n### 示例\n```dart\nimport 'package:flutter/material.dart';\n\nclass BottomNavigationBarMaterial extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() => _BottomNavigationBar();\n}\n\nclass _BottomNavigationBar extends State<BottomNavigationBarMaterial> {\n  int _selectIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\"BottomNavigationBar\"),\n        ),\n        bottomNavigationBar: BottomNavigationBar(\n          items: <BottomNavigationBarItem>[\n            BottomNavigationBarItem(\n              title: Text(\n                '首页',\n              ),\n              icon: Icon(\n                Icons.home,\n                color: Colors.black,\n              ),\n              activeIcon: Icon(\n                Icons.home,\n                color: Colors.pinkAccent,\n              ),\n            ),\n            BottomNavigationBarItem(\n              title: Text(\n                '通讯录',\n              ),\n              icon: Icon(\n                Icons.perm_contact_calendar,\n                color: Colors.black,\n              ),\n              activeIcon: Icon(\n                Icons.perm_contact_calendar,\n                color: Colors.pinkAccent,\n              ),\n            ),\n            BottomNavigationBarItem(\n              title: Text(\n                '新闻',\n              ),\n              icon: Icon(\n                Icons.fiber_new,\n                color: Colors.black,\n              ),\n              activeIcon: Icon(\n                Icons.fiber_new,\n                color: Colors.pinkAccent,\n              ),\n            ),\n            BottomNavigationBarItem(\n              title: Text(\n                '我',\n              ),\n              icon: Icon(\n                Icons.person_pin,\n                color: Colors.black,\n              ),\n              activeIcon: Icon(\n                Icons.person_pin,\n                color: Colors.pinkAccent,\n              ),\n            ),\n          ],\n          // icon大小\n          iconSize: 24,\n          // 默认选中第几个\n          currentIndex: _selectIndex,\n          // 选中变化回调\n          onTap: (index) {\n            setState(() {\n              _selectIndex = index;\n            });\n          },\n          // type=BottomNavigationBarType.fixed时选中字体的颜色\n          fixedColor: Colors.pinkAccent,\n          type: BottomNavigationBarType.fixed,\n        ),\n      ),\n    );\n  }\n}\n\n```\n![](img/bottomNavigationBarDemo.png)","slug":"flutter/widget/18_Material_BottomNavigationBar","published":1,"updated":"2019-10-02T11:51:22.046Z","layout":"post","photos":[],"link":"","_id":"ck19bvb4h005100wky2iotofj","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>底部导航是常见的APP布局方式，实际上我自己常用的app都是底部导航的</p>\n</blockquote>\n<p>##相关属性</p>\n<h3 id=\"BottomNavigationBar\"><a href=\"#BottomNavigationBar\" class=\"headerlink\" title=\"BottomNavigationBar\"></a>BottomNavigationBar</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>items</td>\n<td>BottomNavigationBarItem 列表，包含了导航栏中的按钮</td>\n</tr>\n<tr>\n<td>currentIndex</td>\n<td>当前所高亮的按钮index</td>\n</tr>\n<tr>\n<td>type</td>\n<td>BottomNavigationBarType 中定义的类型，有 fixed 和 shifting 两种类型</td>\n</tr>\n<tr>\n<td>fixedColor</td>\n<td>如果 type 类型为 fixed，则通过 fixedColor 设置选中 item 的颜色</td>\n</tr>\n<tr>\n<td>iconSize</td>\n<td>BottomNavigationBarItem 中 icon 的大小</td>\n</tr>\n<tr>\n<td>### BottomNavigationBarItem</td>\n<td></td>\n</tr>\n<tr>\n<td>属性</td>\n<td>说明</td>\n</tr>\n<tr>\n<td>—————</td>\n<td>————————</td>\n</tr>\n<tr>\n<td>icon</td>\n<td>图标 widget，一般为 Icon</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题 widget，一般为 Text</td>\n</tr>\n<tr>\n<td>backgroundColor</td>\n<td>item 的背景颜色</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BottomNavigationBarMaterial</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  State&lt;StatefulWidget&gt; createState() =&gt; _BottomNavigationBar();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_BottomNavigationBar</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">BottomNavigationBarMaterial</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> _selectIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      home: Scaffold(</span><br><span class=\"line\">        appBar: AppBar(</span><br><span class=\"line\">          title: Text(<span class=\"string\">\"BottomNavigationBar\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        bottomNavigationBar: BottomNavigationBar(</span><br><span class=\"line\">          items: &lt;BottomNavigationBarItem&gt;[</span><br><span class=\"line\">            BottomNavigationBarItem(</span><br><span class=\"line\">              title: Text(</span><br><span class=\"line\">                <span class=\"string\">'首页'</span>,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              icon: Icon(</span><br><span class=\"line\">                Icons.home,</span><br><span class=\"line\">                color: Colors.black,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              activeIcon: Icon(</span><br><span class=\"line\">                Icons.home,</span><br><span class=\"line\">                color: Colors.pinkAccent,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            BottomNavigationBarItem(</span><br><span class=\"line\">              title: Text(</span><br><span class=\"line\">                <span class=\"string\">'通讯录'</span>,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              icon: Icon(</span><br><span class=\"line\">                Icons.perm_contact_calendar,</span><br><span class=\"line\">                color: Colors.black,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              activeIcon: Icon(</span><br><span class=\"line\">                Icons.perm_contact_calendar,</span><br><span class=\"line\">                color: Colors.pinkAccent,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            BottomNavigationBarItem(</span><br><span class=\"line\">              title: Text(</span><br><span class=\"line\">                <span class=\"string\">'新闻'</span>,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              icon: Icon(</span><br><span class=\"line\">                Icons.fiber_new,</span><br><span class=\"line\">                color: Colors.black,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              activeIcon: Icon(</span><br><span class=\"line\">                Icons.fiber_new,</span><br><span class=\"line\">                color: Colors.pinkAccent,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            BottomNavigationBarItem(</span><br><span class=\"line\">              title: Text(</span><br><span class=\"line\">                <span class=\"string\">'我'</span>,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              icon: Icon(</span><br><span class=\"line\">                Icons.person_pin,</span><br><span class=\"line\">                color: Colors.black,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              activeIcon: Icon(</span><br><span class=\"line\">                Icons.person_pin,</span><br><span class=\"line\">                color: Colors.pinkAccent,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ],</span><br><span class=\"line\">          <span class=\"comment\">// icon大小</span></span><br><span class=\"line\">          iconSize: <span class=\"number\">24</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 默认选中第几个</span></span><br><span class=\"line\">          currentIndex: _selectIndex,</span><br><span class=\"line\">          <span class=\"comment\">// 选中变化回调</span></span><br><span class=\"line\">          onTap: (index) &#123;</span><br><span class=\"line\">            setState(() &#123;</span><br><span class=\"line\">              _selectIndex = index;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"comment\">// type=BottomNavigationBarType.fixed时选中字体的颜色</span></span><br><span class=\"line\">          fixedColor: Colors.pinkAccent,</span><br><span class=\"line\">          type: BottomNavigationBarType.fixed,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"img/bottomNavigationBarDemo.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>底部导航是常见的APP布局方式，实际上我自己常用的app都是底部导航的</p>\n</blockquote>\n<p>##相关属性</p>\n<h3 id=\"BottomNavigationBar\"><a href=\"#BottomNavigationBar\" class=\"headerlink\" title=\"BottomNavigationBar\"></a>BottomNavigationBar</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>items</td>\n<td>BottomNavigationBarItem 列表，包含了导航栏中的按钮</td>\n</tr>\n<tr>\n<td>currentIndex</td>\n<td>当前所高亮的按钮index</td>\n</tr>\n<tr>\n<td>type</td>\n<td>BottomNavigationBarType 中定义的类型，有 fixed 和 shifting 两种类型</td>\n</tr>\n<tr>\n<td>fixedColor</td>\n<td>如果 type 类型为 fixed，则通过 fixedColor 设置选中 item 的颜色</td>\n</tr>\n<tr>\n<td>iconSize</td>\n<td>BottomNavigationBarItem 中 icon 的大小</td>\n</tr>\n<tr>\n<td>### BottomNavigationBarItem</td>\n<td></td>\n</tr>\n<tr>\n<td>属性</td>\n<td>说明</td>\n</tr>\n<tr>\n<td>—————</td>\n<td>————————</td>\n</tr>\n<tr>\n<td>icon</td>\n<td>图标 widget，一般为 Icon</td>\n</tr>\n<tr>\n<td>title</td>\n<td>标题 widget，一般为 Text</td>\n</tr>\n<tr>\n<td>backgroundColor</td>\n<td>item 的背景颜色</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BottomNavigationBarMaterial</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  State&lt;StatefulWidget&gt; createState() =&gt; _BottomNavigationBar();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_BottomNavigationBar</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">BottomNavigationBarMaterial</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> _selectIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      home: Scaffold(</span><br><span class=\"line\">        appBar: AppBar(</span><br><span class=\"line\">          title: Text(<span class=\"string\">\"BottomNavigationBar\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        bottomNavigationBar: BottomNavigationBar(</span><br><span class=\"line\">          items: &lt;BottomNavigationBarItem&gt;[</span><br><span class=\"line\">            BottomNavigationBarItem(</span><br><span class=\"line\">              title: Text(</span><br><span class=\"line\">                <span class=\"string\">'首页'</span>,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              icon: Icon(</span><br><span class=\"line\">                Icons.home,</span><br><span class=\"line\">                color: Colors.black,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              activeIcon: Icon(</span><br><span class=\"line\">                Icons.home,</span><br><span class=\"line\">                color: Colors.pinkAccent,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            BottomNavigationBarItem(</span><br><span class=\"line\">              title: Text(</span><br><span class=\"line\">                <span class=\"string\">'通讯录'</span>,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              icon: Icon(</span><br><span class=\"line\">                Icons.perm_contact_calendar,</span><br><span class=\"line\">                color: Colors.black,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              activeIcon: Icon(</span><br><span class=\"line\">                Icons.perm_contact_calendar,</span><br><span class=\"line\">                color: Colors.pinkAccent,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            BottomNavigationBarItem(</span><br><span class=\"line\">              title: Text(</span><br><span class=\"line\">                <span class=\"string\">'新闻'</span>,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              icon: Icon(</span><br><span class=\"line\">                Icons.fiber_new,</span><br><span class=\"line\">                color: Colors.black,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              activeIcon: Icon(</span><br><span class=\"line\">                Icons.fiber_new,</span><br><span class=\"line\">                color: Colors.pinkAccent,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            BottomNavigationBarItem(</span><br><span class=\"line\">              title: Text(</span><br><span class=\"line\">                <span class=\"string\">'我'</span>,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              icon: Icon(</span><br><span class=\"line\">                Icons.person_pin,</span><br><span class=\"line\">                color: Colors.black,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">              activeIcon: Icon(</span><br><span class=\"line\">                Icons.person_pin,</span><br><span class=\"line\">                color: Colors.pinkAccent,</span><br><span class=\"line\">              ),</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ],</span><br><span class=\"line\">          <span class=\"comment\">// icon大小</span></span><br><span class=\"line\">          iconSize: <span class=\"number\">24</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 默认选中第几个</span></span><br><span class=\"line\">          currentIndex: _selectIndex,</span><br><span class=\"line\">          <span class=\"comment\">// 选中变化回调</span></span><br><span class=\"line\">          onTap: (index) &#123;</span><br><span class=\"line\">            setState(() &#123;</span><br><span class=\"line\">              _selectIndex = index;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"comment\">// type=BottomNavigationBarType.fixed时选中字体的颜色</span></span><br><span class=\"line\">          fixedColor: Colors.pinkAccent,</span><br><span class=\"line\">          type: BottomNavigationBarType.fixed,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"img/bottomNavigationBarDemo.png\" alt></p>\n"},{"title":"Text","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T07:14:00.000Z","_content":"## 1. 介绍\n> Text用于显示简单样式文本，它包含一些控制文本显示样式的一些属性。\n\n## 类结构\n![](../img/13_1.png)\n\n## 属性\n### data\n> 显示的文本\n\n### style\n> 字体样式\n\n| 属性值          | 意义                                            |\n| --------------- | ----------------------------------------------- |\n| inherit         | 是否继承                                        |\n| color           | 字体颜色                                        |\n| fontSize        | 字体大小                                        |\n| fontWeight      | 字体厚度，也就是字体粗细                        |\n| fontStyle       | normal或者italic                                |\n| letterSpacing   | 字母间隙(负值可以让字母更紧凑)                  |\n| wordSpacing     | 单词间隙(负值可以让单词更紧凑)                  |\n| textBaseLine    | 文本绘制基线(alphabetic/ideographic)            |\n| height          | 高度                                            |\n| locale          | 区域设置                                        |\n| decoration      | 文字装饰(none/underline/overline/lineThrough)   |\n| decorationColor | 文字装饰的颜色                                  |\n| decorationStyle | 文字装饰的风格(solid/double/dotted/dashed/wavy) |\n| fontFamily      | 字体                                            |\n\n### textAlign\n> 文本对齐\n\n| TextAlign        | 说明      |\n| ---------------- | --------- |\n| TextAlign.left   | 左对齐    |\n| TextAlign.right  | 右对齐    |\n| TextAlign.center | 居中      |\n| TextAlign.justfy | 两端对齐  |\n| TextAlign.start  | 类似left  |\n| TextAlign.end    | 类似right |\n\n### textDiection\n> 文字方向\n- TextDirection.ltr 左\n- TextDirection.rtl 右\n  \n### softWrap\n> 是否自动换行,若为false，文字将不考虑容器大小，单行显示，超出屏幕部分将默认截断处理\n\n### overflow\n> 文字溢出的显示方式\n- TextOverflow.clip 默认裁剪\n- TextOverflow.fade 逐渐隐藏\n- TextOverflow.ellipsis 省略号\n\n### textScaleFactor\n> 显示倍率，相当于放大多少倍\n\n### maxLines\n> 最大显示行数\n\n### textSpan\n> 对一个Text内容的不同部分按照不同的样式显示，这时就可以使用TextSpan。\n\n#### 构造函数\n```dart\nconst TextSpan({\n  TextStyle style, \n  Sting text,\n  List<TextSpan> children,\n  GestureRecognizer recognizer,\n});\n```\n\n#### 示例\n```dart\nText.rich(TextSpan(\n    children: [\n     TextSpan(\n       text: \"Home: \"\n     ),\n     TextSpan(\n       text: \"https://flutterchina.club\",\n       style: TextStyle(\n         color: Colors.blue\n       ),  \n       recognizer: _tapRecognizer\n     ),\n    ]\n))\n```\n\n\n\n\n\n\n\n\n","source":"_posts/flutter/widget/Text.md","raw":"---\ntitle: Text\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 15:14:00   \n---\n## 1. 介绍\n> Text用于显示简单样式文本，它包含一些控制文本显示样式的一些属性。\n\n## 类结构\n![](../img/13_1.png)\n\n## 属性\n### data\n> 显示的文本\n\n### style\n> 字体样式\n\n| 属性值          | 意义                                            |\n| --------------- | ----------------------------------------------- |\n| inherit         | 是否继承                                        |\n| color           | 字体颜色                                        |\n| fontSize        | 字体大小                                        |\n| fontWeight      | 字体厚度，也就是字体粗细                        |\n| fontStyle       | normal或者italic                                |\n| letterSpacing   | 字母间隙(负值可以让字母更紧凑)                  |\n| wordSpacing     | 单词间隙(负值可以让单词更紧凑)                  |\n| textBaseLine    | 文本绘制基线(alphabetic/ideographic)            |\n| height          | 高度                                            |\n| locale          | 区域设置                                        |\n| decoration      | 文字装饰(none/underline/overline/lineThrough)   |\n| decorationColor | 文字装饰的颜色                                  |\n| decorationStyle | 文字装饰的风格(solid/double/dotted/dashed/wavy) |\n| fontFamily      | 字体                                            |\n\n### textAlign\n> 文本对齐\n\n| TextAlign        | 说明      |\n| ---------------- | --------- |\n| TextAlign.left   | 左对齐    |\n| TextAlign.right  | 右对齐    |\n| TextAlign.center | 居中      |\n| TextAlign.justfy | 两端对齐  |\n| TextAlign.start  | 类似left  |\n| TextAlign.end    | 类似right |\n\n### textDiection\n> 文字方向\n- TextDirection.ltr 左\n- TextDirection.rtl 右\n  \n### softWrap\n> 是否自动换行,若为false，文字将不考虑容器大小，单行显示，超出屏幕部分将默认截断处理\n\n### overflow\n> 文字溢出的显示方式\n- TextOverflow.clip 默认裁剪\n- TextOverflow.fade 逐渐隐藏\n- TextOverflow.ellipsis 省略号\n\n### textScaleFactor\n> 显示倍率，相当于放大多少倍\n\n### maxLines\n> 最大显示行数\n\n### textSpan\n> 对一个Text内容的不同部分按照不同的样式显示，这时就可以使用TextSpan。\n\n#### 构造函数\n```dart\nconst TextSpan({\n  TextStyle style, \n  Sting text,\n  List<TextSpan> children,\n  GestureRecognizer recognizer,\n});\n```\n\n#### 示例\n```dart\nText.rich(TextSpan(\n    children: [\n     TextSpan(\n       text: \"Home: \"\n     ),\n     TextSpan(\n       text: \"https://flutterchina.club\",\n       style: TextStyle(\n         color: Colors.blue\n       ),  \n       recognizer: _tapRecognizer\n     ),\n    ]\n))\n```\n\n\n\n\n\n\n\n\n","slug":"flutter/widget/Text","published":1,"updated":"2019-10-02T11:51:45.960Z","layout":"post","photos":[],"link":"","_id":"ck19bvb4l005400wkxaickp9p","content":"<h2 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h2><blockquote>\n<p>Text用于显示简单样式文本，它包含一些控制文本显示样式的一些属性。</p>\n</blockquote>\n<h2 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h2><p><img src=\"../img/13_1.png\" alt></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><blockquote>\n<p>显示的文本</p>\n</blockquote>\n<h3 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h3><blockquote>\n<p>字体样式</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>inherit</td>\n<td>是否继承</td>\n</tr>\n<tr>\n<td>color</td>\n<td>字体颜色</td>\n</tr>\n<tr>\n<td>fontSize</td>\n<td>字体大小</td>\n</tr>\n<tr>\n<td>fontWeight</td>\n<td>字体厚度，也就是字体粗细</td>\n</tr>\n<tr>\n<td>fontStyle</td>\n<td>normal或者italic</td>\n</tr>\n<tr>\n<td>letterSpacing</td>\n<td>字母间隙(负值可以让字母更紧凑)</td>\n</tr>\n<tr>\n<td>wordSpacing</td>\n<td>单词间隙(负值可以让单词更紧凑)</td>\n</tr>\n<tr>\n<td>textBaseLine</td>\n<td>文本绘制基线(alphabetic/ideographic)</td>\n</tr>\n<tr>\n<td>height</td>\n<td>高度</td>\n</tr>\n<tr>\n<td>locale</td>\n<td>区域设置</td>\n</tr>\n<tr>\n<td>decoration</td>\n<td>文字装饰(none/underline/overline/lineThrough)</td>\n</tr>\n<tr>\n<td>decorationColor</td>\n<td>文字装饰的颜色</td>\n</tr>\n<tr>\n<td>decorationStyle</td>\n<td>文字装饰的风格(solid/double/dotted/dashed/wavy)</td>\n</tr>\n<tr>\n<td>fontFamily</td>\n<td>字体</td>\n</tr>\n</tbody></table>\n<h3 id=\"textAlign\"><a href=\"#textAlign\" class=\"headerlink\" title=\"textAlign\"></a>textAlign</h3><blockquote>\n<p>文本对齐</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>TextAlign</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TextAlign.left</td>\n<td>左对齐</td>\n</tr>\n<tr>\n<td>TextAlign.right</td>\n<td>右对齐</td>\n</tr>\n<tr>\n<td>TextAlign.center</td>\n<td>居中</td>\n</tr>\n<tr>\n<td>TextAlign.justfy</td>\n<td>两端对齐</td>\n</tr>\n<tr>\n<td>TextAlign.start</td>\n<td>类似left</td>\n</tr>\n<tr>\n<td>TextAlign.end</td>\n<td>类似right</td>\n</tr>\n</tbody></table>\n<h3 id=\"textDiection\"><a href=\"#textDiection\" class=\"headerlink\" title=\"textDiection\"></a>textDiection</h3><blockquote>\n<p>文字方向</p>\n<ul>\n<li>TextDirection.ltr 左</li>\n<li>TextDirection.rtl 右</li>\n</ul>\n</blockquote>\n<h3 id=\"softWrap\"><a href=\"#softWrap\" class=\"headerlink\" title=\"softWrap\"></a>softWrap</h3><blockquote>\n<p>是否自动换行,若为false，文字将不考虑容器大小，单行显示，超出屏幕部分将默认截断处理</p>\n</blockquote>\n<h3 id=\"overflow\"><a href=\"#overflow\" class=\"headerlink\" title=\"overflow\"></a>overflow</h3><blockquote>\n<p>文字溢出的显示方式</p>\n<ul>\n<li>TextOverflow.clip 默认裁剪</li>\n<li>TextOverflow.fade 逐渐隐藏</li>\n<li>TextOverflow.ellipsis 省略号</li>\n</ul>\n</blockquote>\n<h3 id=\"textScaleFactor\"><a href=\"#textScaleFactor\" class=\"headerlink\" title=\"textScaleFactor\"></a>textScaleFactor</h3><blockquote>\n<p>显示倍率，相当于放大多少倍</p>\n</blockquote>\n<h3 id=\"maxLines\"><a href=\"#maxLines\" class=\"headerlink\" title=\"maxLines\"></a>maxLines</h3><blockquote>\n<p>最大显示行数</p>\n</blockquote>\n<h3 id=\"textSpan\"><a href=\"#textSpan\" class=\"headerlink\" title=\"textSpan\"></a>textSpan</h3><blockquote>\n<p>对一个Text内容的不同部分按照不同的样式显示，这时就可以使用TextSpan。</p>\n</blockquote>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> TextSpan(&#123;</span><br><span class=\"line\">  TextStyle style, </span><br><span class=\"line\">  Sting text,</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;TextSpan&gt; children,</span><br><span class=\"line\">  GestureRecognizer recognizer,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text.rich(TextSpan(</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">     TextSpan(</span><br><span class=\"line\">       text: <span class=\"string\">\"Home: \"</span></span><br><span class=\"line\">     ),</span><br><span class=\"line\">     TextSpan(</span><br><span class=\"line\">       text: <span class=\"string\">\"https://flutterchina.club\"</span>,</span><br><span class=\"line\">       style: TextStyle(</span><br><span class=\"line\">         color: Colors.blue</span><br><span class=\"line\">       ),  </span><br><span class=\"line\">       recognizer: _tapRecognizer</span><br><span class=\"line\">     ),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">))</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h2><blockquote>\n<p>Text用于显示简单样式文本，它包含一些控制文本显示样式的一些属性。</p>\n</blockquote>\n<h2 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h2><p><img src=\"../img/13_1.png\" alt></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><blockquote>\n<p>显示的文本</p>\n</blockquote>\n<h3 id=\"style\"><a href=\"#style\" class=\"headerlink\" title=\"style\"></a>style</h3><blockquote>\n<p>字体样式</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>inherit</td>\n<td>是否继承</td>\n</tr>\n<tr>\n<td>color</td>\n<td>字体颜色</td>\n</tr>\n<tr>\n<td>fontSize</td>\n<td>字体大小</td>\n</tr>\n<tr>\n<td>fontWeight</td>\n<td>字体厚度，也就是字体粗细</td>\n</tr>\n<tr>\n<td>fontStyle</td>\n<td>normal或者italic</td>\n</tr>\n<tr>\n<td>letterSpacing</td>\n<td>字母间隙(负值可以让字母更紧凑)</td>\n</tr>\n<tr>\n<td>wordSpacing</td>\n<td>单词间隙(负值可以让单词更紧凑)</td>\n</tr>\n<tr>\n<td>textBaseLine</td>\n<td>文本绘制基线(alphabetic/ideographic)</td>\n</tr>\n<tr>\n<td>height</td>\n<td>高度</td>\n</tr>\n<tr>\n<td>locale</td>\n<td>区域设置</td>\n</tr>\n<tr>\n<td>decoration</td>\n<td>文字装饰(none/underline/overline/lineThrough)</td>\n</tr>\n<tr>\n<td>decorationColor</td>\n<td>文字装饰的颜色</td>\n</tr>\n<tr>\n<td>decorationStyle</td>\n<td>文字装饰的风格(solid/double/dotted/dashed/wavy)</td>\n</tr>\n<tr>\n<td>fontFamily</td>\n<td>字体</td>\n</tr>\n</tbody></table>\n<h3 id=\"textAlign\"><a href=\"#textAlign\" class=\"headerlink\" title=\"textAlign\"></a>textAlign</h3><blockquote>\n<p>文本对齐</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>TextAlign</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TextAlign.left</td>\n<td>左对齐</td>\n</tr>\n<tr>\n<td>TextAlign.right</td>\n<td>右对齐</td>\n</tr>\n<tr>\n<td>TextAlign.center</td>\n<td>居中</td>\n</tr>\n<tr>\n<td>TextAlign.justfy</td>\n<td>两端对齐</td>\n</tr>\n<tr>\n<td>TextAlign.start</td>\n<td>类似left</td>\n</tr>\n<tr>\n<td>TextAlign.end</td>\n<td>类似right</td>\n</tr>\n</tbody></table>\n<h3 id=\"textDiection\"><a href=\"#textDiection\" class=\"headerlink\" title=\"textDiection\"></a>textDiection</h3><blockquote>\n<p>文字方向</p>\n<ul>\n<li>TextDirection.ltr 左</li>\n<li>TextDirection.rtl 右</li>\n</ul>\n</blockquote>\n<h3 id=\"softWrap\"><a href=\"#softWrap\" class=\"headerlink\" title=\"softWrap\"></a>softWrap</h3><blockquote>\n<p>是否自动换行,若为false，文字将不考虑容器大小，单行显示，超出屏幕部分将默认截断处理</p>\n</blockquote>\n<h3 id=\"overflow\"><a href=\"#overflow\" class=\"headerlink\" title=\"overflow\"></a>overflow</h3><blockquote>\n<p>文字溢出的显示方式</p>\n<ul>\n<li>TextOverflow.clip 默认裁剪</li>\n<li>TextOverflow.fade 逐渐隐藏</li>\n<li>TextOverflow.ellipsis 省略号</li>\n</ul>\n</blockquote>\n<h3 id=\"textScaleFactor\"><a href=\"#textScaleFactor\" class=\"headerlink\" title=\"textScaleFactor\"></a>textScaleFactor</h3><blockquote>\n<p>显示倍率，相当于放大多少倍</p>\n</blockquote>\n<h3 id=\"maxLines\"><a href=\"#maxLines\" class=\"headerlink\" title=\"maxLines\"></a>maxLines</h3><blockquote>\n<p>最大显示行数</p>\n</blockquote>\n<h3 id=\"textSpan\"><a href=\"#textSpan\" class=\"headerlink\" title=\"textSpan\"></a>textSpan</h3><blockquote>\n<p>对一个Text内容的不同部分按照不同的样式显示，这时就可以使用TextSpan。</p>\n</blockquote>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> TextSpan(&#123;</span><br><span class=\"line\">  TextStyle style, </span><br><span class=\"line\">  Sting text,</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;TextSpan&gt; children,</span><br><span class=\"line\">  GestureRecognizer recognizer,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text.rich(TextSpan(</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">     TextSpan(</span><br><span class=\"line\">       text: <span class=\"string\">\"Home: \"</span></span><br><span class=\"line\">     ),</span><br><span class=\"line\">     TextSpan(</span><br><span class=\"line\">       text: <span class=\"string\">\"https://flutterchina.club\"</span>,</span><br><span class=\"line\">       style: TextStyle(</span><br><span class=\"line\">         color: Colors.blue</span><br><span class=\"line\">       ),  </span><br><span class=\"line\">       recognizer: _tapRecognizer</span><br><span class=\"line\">     ),</span><br><span class=\"line\">    ]</span><br><span class=\"line\">))</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Image","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-22T04:14:00.000Z","_content":"## 介绍\n> Image, 图片显示Widget, 和Android ImageView相似，但是从实际使用的方法上看，与常用的图片加载库，如Picasso，Glide等相似，支持本地图片，资源图片，网络图片等加载方式。\n\n## 类结构\n![](../img/15_1.jpg)\n\n## 构造方法\n| 方式          | 解释                                                              |\n| ------------- | ----------------------------------------------------------------- |\n| Image()       | 通用方法，使用ImageProvider实现，如下方法本质上也是使用的这个方法 |\n| Image.asset   | 加载资源图片                                                      |\n| Image.file    | 加载本地图片文件                                                  |\n| Image.network | 加载网络图片                                                      |\n| Image.memory  | 加载Uint8List资源图片                                             |\n\n## 属性\n### image\n> 抽象类，需要自己实现获取图片数据的操作\n\n常用ImageProvider\n- ExactAssetImage\n- AssetImage\n- NetworkImage\n- FileImage\n- MemoryImage\n\n### width & height\n> 显示区域的宽和高。\n\n### fit\n> 显示形式\n\n- BoxFit.fill 全图显示，拉伸、充满\n- BoxFit.contain 原比例全图显示\n- BoxFit.cover 拉伸、裁剪、充满\n- BoxFit.fitWidth 宽度充满\n- BoxFit.fitHeight 高度充满\n- BoxFit.scaleDown 类似contain，但是不允许显示超过源图片大小，可变小，不可变大\n- BoxFit.none 原图显示\n\n### color & colorBlendMode\n> 混合模式，配合使用\n\n### alignment\n> 控制图片的摆放位置\n\n### repeat\n> 重复显示\n- ImageRepeat.repeat X、Y方向都重复显示\n- ImageRepeat.repeatX 横向重复\n- ImageRepeat.repeatY 竖向重复\n- ImageRepeat.none 不重复\n  \n### centerSlice\n> 当图片被拉伸时，centerSlice定义的区域会被拉升\n```dart\nImage image = Image.asset(\n    'image/14v.png',\n    width: 300.0,\n    height: 300.0,\n    fit: BoxFit.contain,\n    centerSlice: Rect.fromCircle(\n        center: const Offset(100.0,100.0),\n        radius: 10.0,\n    ),\n)\n```\n```dart\nassert(sourceSize == inputSize, 'centerSlice was used with a BoxFit that does not guarantee that the image is fully visible.');\n```\n`* 当显示比例小于原图片大小时，会报错！`\n\n### matchTextDirection\n> 与 Directionality 配合使用\n\n### gaplessPlayback\n> 当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留。若值为true，保留，若为false，不保留，直接空白等待下一张图片加载。\n\n\n","source":"_posts/flutter/widget/image.md","raw":"---\ntitle: Image\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-22 12:14:00   \n---\n## 介绍\n> Image, 图片显示Widget, 和Android ImageView相似，但是从实际使用的方法上看，与常用的图片加载库，如Picasso，Glide等相似，支持本地图片，资源图片，网络图片等加载方式。\n\n## 类结构\n![](../img/15_1.jpg)\n\n## 构造方法\n| 方式          | 解释                                                              |\n| ------------- | ----------------------------------------------------------------- |\n| Image()       | 通用方法，使用ImageProvider实现，如下方法本质上也是使用的这个方法 |\n| Image.asset   | 加载资源图片                                                      |\n| Image.file    | 加载本地图片文件                                                  |\n| Image.network | 加载网络图片                                                      |\n| Image.memory  | 加载Uint8List资源图片                                             |\n\n## 属性\n### image\n> 抽象类，需要自己实现获取图片数据的操作\n\n常用ImageProvider\n- ExactAssetImage\n- AssetImage\n- NetworkImage\n- FileImage\n- MemoryImage\n\n### width & height\n> 显示区域的宽和高。\n\n### fit\n> 显示形式\n\n- BoxFit.fill 全图显示，拉伸、充满\n- BoxFit.contain 原比例全图显示\n- BoxFit.cover 拉伸、裁剪、充满\n- BoxFit.fitWidth 宽度充满\n- BoxFit.fitHeight 高度充满\n- BoxFit.scaleDown 类似contain，但是不允许显示超过源图片大小，可变小，不可变大\n- BoxFit.none 原图显示\n\n### color & colorBlendMode\n> 混合模式，配合使用\n\n### alignment\n> 控制图片的摆放位置\n\n### repeat\n> 重复显示\n- ImageRepeat.repeat X、Y方向都重复显示\n- ImageRepeat.repeatX 横向重复\n- ImageRepeat.repeatY 竖向重复\n- ImageRepeat.none 不重复\n  \n### centerSlice\n> 当图片被拉伸时，centerSlice定义的区域会被拉升\n```dart\nImage image = Image.asset(\n    'image/14v.png',\n    width: 300.0,\n    height: 300.0,\n    fit: BoxFit.contain,\n    centerSlice: Rect.fromCircle(\n        center: const Offset(100.0,100.0),\n        radius: 10.0,\n    ),\n)\n```\n```dart\nassert(sourceSize == inputSize, 'centerSlice was used with a BoxFit that does not guarantee that the image is fully visible.');\n```\n`* 当显示比例小于原图片大小时，会报错！`\n\n### matchTextDirection\n> 与 Directionality 配合使用\n\n### gaplessPlayback\n> 当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留。若值为true，保留，若为false，不保留，直接空白等待下一张图片加载。\n\n\n","slug":"flutter/widget/image","published":1,"updated":"2019-10-02T11:51:32.518Z","layout":"post","photos":[],"link":"","_id":"ck19bvb4s005700wk45za9b8r","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>Image, 图片显示Widget, 和Android ImageView相似，但是从实际使用的方法上看，与常用的图片加载库，如Picasso，Glide等相似，支持本地图片，资源图片，网络图片等加载方式。</p>\n</blockquote>\n<h2 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h2><p><img src=\"../img/15_1.jpg\" alt></p>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Image()</td>\n<td>通用方法，使用ImageProvider实现，如下方法本质上也是使用的这个方法</td>\n</tr>\n<tr>\n<td>Image.asset</td>\n<td>加载资源图片</td>\n</tr>\n<tr>\n<td>Image.file</td>\n<td>加载本地图片文件</td>\n</tr>\n<tr>\n<td>Image.network</td>\n<td>加载网络图片</td>\n</tr>\n<tr>\n<td>Image.memory</td>\n<td>加载Uint8List资源图片</td>\n</tr>\n</tbody></table>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h3><blockquote>\n<p>抽象类，需要自己实现获取图片数据的操作</p>\n</blockquote>\n<p>常用ImageProvider</p>\n<ul>\n<li>ExactAssetImage</li>\n<li>AssetImage</li>\n<li>NetworkImage</li>\n<li>FileImage</li>\n<li>MemoryImage</li>\n</ul>\n<h3 id=\"width-amp-height\"><a href=\"#width-amp-height\" class=\"headerlink\" title=\"width &amp; height\"></a>width &amp; height</h3><blockquote>\n<p>显示区域的宽和高。</p>\n</blockquote>\n<h3 id=\"fit\"><a href=\"#fit\" class=\"headerlink\" title=\"fit\"></a>fit</h3><blockquote>\n<p>显示形式</p>\n</blockquote>\n<ul>\n<li>BoxFit.fill 全图显示，拉伸、充满</li>\n<li>BoxFit.contain 原比例全图显示</li>\n<li>BoxFit.cover 拉伸、裁剪、充满</li>\n<li>BoxFit.fitWidth 宽度充满</li>\n<li>BoxFit.fitHeight 高度充满</li>\n<li>BoxFit.scaleDown 类似contain，但是不允许显示超过源图片大小，可变小，不可变大</li>\n<li>BoxFit.none 原图显示</li>\n</ul>\n<h3 id=\"color-amp-colorBlendMode\"><a href=\"#color-amp-colorBlendMode\" class=\"headerlink\" title=\"color &amp; colorBlendMode\"></a>color &amp; colorBlendMode</h3><blockquote>\n<p>混合模式，配合使用</p>\n</blockquote>\n<h3 id=\"alignment\"><a href=\"#alignment\" class=\"headerlink\" title=\"alignment\"></a>alignment</h3><blockquote>\n<p>控制图片的摆放位置</p>\n</blockquote>\n<h3 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat\"></a>repeat</h3><blockquote>\n<p>重复显示</p>\n<ul>\n<li>ImageRepeat.repeat X、Y方向都重复显示</li>\n<li>ImageRepeat.repeatX 横向重复</li>\n<li>ImageRepeat.repeatY 竖向重复</li>\n<li>ImageRepeat.none 不重复</li>\n</ul>\n</blockquote>\n<h3 id=\"centerSlice\"><a href=\"#centerSlice\" class=\"headerlink\" title=\"centerSlice\"></a>centerSlice</h3><blockquote>\n<p>当图片被拉伸时，centerSlice定义的区域会被拉升</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image image = Image.asset(</span><br><span class=\"line\">    <span class=\"string\">'image/14v.png'</span>,</span><br><span class=\"line\">    width: <span class=\"number\">300.0</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300.0</span>,</span><br><span class=\"line\">    fit: BoxFit.contain,</span><br><span class=\"line\">    centerSlice: Rect.fromCircle(</span><br><span class=\"line\">        center: <span class=\"keyword\">const</span> Offset(<span class=\"number\">100.0</span>,<span class=\"number\">100.0</span>),</span><br><span class=\"line\">        radius: <span class=\"number\">10.0</span>,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(sourceSize == inputSize, <span class=\"string\">'centerSlice was used with a BoxFit that does not guarantee that the image is fully visible.'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>* 当显示比例小于原图片大小时，会报错！</code></p>\n<h3 id=\"matchTextDirection\"><a href=\"#matchTextDirection\" class=\"headerlink\" title=\"matchTextDirection\"></a>matchTextDirection</h3><blockquote>\n<p>与 Directionality 配合使用</p>\n</blockquote>\n<h3 id=\"gaplessPlayback\"><a href=\"#gaplessPlayback\" class=\"headerlink\" title=\"gaplessPlayback\"></a>gaplessPlayback</h3><blockquote>\n<p>当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留。若值为true，保留，若为false，不保留，直接空白等待下一张图片加载。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>Image, 图片显示Widget, 和Android ImageView相似，但是从实际使用的方法上看，与常用的图片加载库，如Picasso，Glide等相似，支持本地图片，资源图片，网络图片等加载方式。</p>\n</blockquote>\n<h2 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h2><p><img src=\"../img/15_1.jpg\" alt></p>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Image()</td>\n<td>通用方法，使用ImageProvider实现，如下方法本质上也是使用的这个方法</td>\n</tr>\n<tr>\n<td>Image.asset</td>\n<td>加载资源图片</td>\n</tr>\n<tr>\n<td>Image.file</td>\n<td>加载本地图片文件</td>\n</tr>\n<tr>\n<td>Image.network</td>\n<td>加载网络图片</td>\n</tr>\n<tr>\n<td>Image.memory</td>\n<td>加载Uint8List资源图片</td>\n</tr>\n</tbody></table>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h3><blockquote>\n<p>抽象类，需要自己实现获取图片数据的操作</p>\n</blockquote>\n<p>常用ImageProvider</p>\n<ul>\n<li>ExactAssetImage</li>\n<li>AssetImage</li>\n<li>NetworkImage</li>\n<li>FileImage</li>\n<li>MemoryImage</li>\n</ul>\n<h3 id=\"width-amp-height\"><a href=\"#width-amp-height\" class=\"headerlink\" title=\"width &amp; height\"></a>width &amp; height</h3><blockquote>\n<p>显示区域的宽和高。</p>\n</blockquote>\n<h3 id=\"fit\"><a href=\"#fit\" class=\"headerlink\" title=\"fit\"></a>fit</h3><blockquote>\n<p>显示形式</p>\n</blockquote>\n<ul>\n<li>BoxFit.fill 全图显示，拉伸、充满</li>\n<li>BoxFit.contain 原比例全图显示</li>\n<li>BoxFit.cover 拉伸、裁剪、充满</li>\n<li>BoxFit.fitWidth 宽度充满</li>\n<li>BoxFit.fitHeight 高度充满</li>\n<li>BoxFit.scaleDown 类似contain，但是不允许显示超过源图片大小，可变小，不可变大</li>\n<li>BoxFit.none 原图显示</li>\n</ul>\n<h3 id=\"color-amp-colorBlendMode\"><a href=\"#color-amp-colorBlendMode\" class=\"headerlink\" title=\"color &amp; colorBlendMode\"></a>color &amp; colorBlendMode</h3><blockquote>\n<p>混合模式，配合使用</p>\n</blockquote>\n<h3 id=\"alignment\"><a href=\"#alignment\" class=\"headerlink\" title=\"alignment\"></a>alignment</h3><blockquote>\n<p>控制图片的摆放位置</p>\n</blockquote>\n<h3 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat\"></a>repeat</h3><blockquote>\n<p>重复显示</p>\n<ul>\n<li>ImageRepeat.repeat X、Y方向都重复显示</li>\n<li>ImageRepeat.repeatX 横向重复</li>\n<li>ImageRepeat.repeatY 竖向重复</li>\n<li>ImageRepeat.none 不重复</li>\n</ul>\n</blockquote>\n<h3 id=\"centerSlice\"><a href=\"#centerSlice\" class=\"headerlink\" title=\"centerSlice\"></a>centerSlice</h3><blockquote>\n<p>当图片被拉伸时，centerSlice定义的区域会被拉升</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Image image = Image.asset(</span><br><span class=\"line\">    <span class=\"string\">'image/14v.png'</span>,</span><br><span class=\"line\">    width: <span class=\"number\">300.0</span>,</span><br><span class=\"line\">    height: <span class=\"number\">300.0</span>,</span><br><span class=\"line\">    fit: BoxFit.contain,</span><br><span class=\"line\">    centerSlice: Rect.fromCircle(</span><br><span class=\"line\">        center: <span class=\"keyword\">const</span> Offset(<span class=\"number\">100.0</span>,<span class=\"number\">100.0</span>),</span><br><span class=\"line\">        radius: <span class=\"number\">10.0</span>,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(sourceSize == inputSize, <span class=\"string\">'centerSlice was used with a BoxFit that does not guarantee that the image is fully visible.'</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>* 当显示比例小于原图片大小时，会报错！</code></p>\n<h3 id=\"matchTextDirection\"><a href=\"#matchTextDirection\" class=\"headerlink\" title=\"matchTextDirection\"></a>matchTextDirection</h3><blockquote>\n<p>与 Directionality 配合使用</p>\n</blockquote>\n<h3 id=\"gaplessPlayback\"><a href=\"#gaplessPlayback\" class=\"headerlink\" title=\"gaplessPlayback\"></a>gaplessPlayback</h3><blockquote>\n<p>当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留。若值为true，保留，若为false，不保留，直接空白等待下一张图片加载。</p>\n</blockquote>\n"},{"title":"Container","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T08:43:00.000Z","_content":"## 介绍\nContainer 容器控件，包含一个子Widget，具备alignment、padding等属性，方便布局摆放child\n\n## 类结构\n![](img/14_1.png)\n\n## 属性\n### child\n> 子控件\n\n### alignment\n> 对齐方式\n```dart\n /// The top left corner.\n  static const Alignment topLeft = Alignment(-1.0, -1.0);\n  /// The center point along the top edge.\n  static const Alignment topCenter = Alignment(0.0, -1.0);\n  /// The top right corner.\n  static const Alignment topRight = Alignment(1.0, -1.0);\n  /// The center point along the left edge.\n  static const Alignment centerLeft = Alignment(-1.0, 0.0);\n  /// The center point, both horizontally and vertically.\n  static const Alignment center = Alignment(0.0, 0.0);\n  /// The center point along the right edge.\n  static const Alignment centerRight = Alignment(1.0, 0.0);\n  /// The bottom left corner.\n  static const Alignment bottomLeft = Alignment(-1.0, 1.0);\n  /// The center point along the bottom edge.\n  static const Alignment bottomCenter = Alignment(0.0, 1.0);\n  /// The bottom right corner.\n  static const Alignment bottomRight = Alignment(1.0, 1.0);\n```\n### color  和 decoration\n> 设置背景色或背景\n* 两者无法共存\n```dart\nassert(color == null || decoration == null,\n    'Cannot provide both a color and a decoration\\n'\n    'The color argument is just a shorthand for \"decoration: new BoxDecoration(color: color)\".'\n),\ndecoration = decoration ?? (color != null ? BoxDecoration(color: color) : null),\n```\n\n\n### foregroundDecoration\n> 前景设置\n\n### margin\n> 边距设置\n\n### constraints\n> 布局约束\n\n### transform\n> 矩阵变换\n\n","source":"_posts/flutter/容器/Container.md","raw":"---\ntitle: Container\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- 容器\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 16:43:00   \n---\n## 介绍\nContainer 容器控件，包含一个子Widget，具备alignment、padding等属性，方便布局摆放child\n\n## 类结构\n![](img/14_1.png)\n\n## 属性\n### child\n> 子控件\n\n### alignment\n> 对齐方式\n```dart\n /// The top left corner.\n  static const Alignment topLeft = Alignment(-1.0, -1.0);\n  /// The center point along the top edge.\n  static const Alignment topCenter = Alignment(0.0, -1.0);\n  /// The top right corner.\n  static const Alignment topRight = Alignment(1.0, -1.0);\n  /// The center point along the left edge.\n  static const Alignment centerLeft = Alignment(-1.0, 0.0);\n  /// The center point, both horizontally and vertically.\n  static const Alignment center = Alignment(0.0, 0.0);\n  /// The center point along the right edge.\n  static const Alignment centerRight = Alignment(1.0, 0.0);\n  /// The bottom left corner.\n  static const Alignment bottomLeft = Alignment(-1.0, 1.0);\n  /// The center point along the bottom edge.\n  static const Alignment bottomCenter = Alignment(0.0, 1.0);\n  /// The bottom right corner.\n  static const Alignment bottomRight = Alignment(1.0, 1.0);\n```\n### color  和 decoration\n> 设置背景色或背景\n* 两者无法共存\n```dart\nassert(color == null || decoration == null,\n    'Cannot provide both a color and a decoration\\n'\n    'The color argument is just a shorthand for \"decoration: new BoxDecoration(color: color)\".'\n),\ndecoration = decoration ?? (color != null ? BoxDecoration(color: color) : null),\n```\n\n\n### foregroundDecoration\n> 前景设置\n\n### margin\n> 边距设置\n\n### constraints\n> 布局约束\n\n### transform\n> 矩阵变换\n\n","slug":"flutter/容器/Container","published":1,"updated":"2019-10-02T11:58:55.234Z","layout":"post","photos":[],"link":"","_id":"ck19bvb51005a00wkrzhu6yzh","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Container 容器控件，包含一个子Widget，具备alignment、padding等属性，方便布局摆放child</p>\n<h2 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h2><p><img src=\"img/14_1.png\" alt></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child\"></a>child</h3><blockquote>\n<p>子控件</p>\n</blockquote>\n<h3 id=\"alignment\"><a href=\"#alignment\" class=\"headerlink\" title=\"alignment\"></a>alignment</h3><blockquote>\n<p>对齐方式</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The top left corner.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment topLeft = Alignment(<span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point along the top edge.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment topCenter = Alignment(<span class=\"number\">0.0</span>, <span class=\"number\">-1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The top right corner.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment topRight = Alignment(<span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point along the left edge.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment centerLeft = Alignment(<span class=\"number\">-1.0</span>, <span class=\"number\">0.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point, both horizontally and vertically.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment center = Alignment(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point along the right edge.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment centerRight = Alignment(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The bottom left corner.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment bottomLeft = Alignment(<span class=\"number\">-1.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point along the bottom edge.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment bottomCenter = Alignment(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The bottom right corner.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment bottomRight = Alignment(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"color-和-decoration\"><a href=\"#color-和-decoration\" class=\"headerlink\" title=\"color  和 decoration\"></a>color  和 decoration</h3><blockquote>\n<p>设置背景色或背景</p>\n<ul>\n<li>两者无法共存</li>\n</ul>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(color == <span class=\"keyword\">null</span> || decoration == <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">'Cannot provide both a color and a decoration\\n'</span></span><br><span class=\"line\">    <span class=\"string\">'The color argument is just a shorthand for \"decoration: new BoxDecoration(color: color)\".'</span></span><br><span class=\"line\">),</span><br><span class=\"line\">decoration = decoration ?? (color != <span class=\"keyword\">null</span> ? BoxDecoration(color: color) : <span class=\"keyword\">null</span>),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"foregroundDecoration\"><a href=\"#foregroundDecoration\" class=\"headerlink\" title=\"foregroundDecoration\"></a>foregroundDecoration</h3><blockquote>\n<p>前景设置</p>\n</blockquote>\n<h3 id=\"margin\"><a href=\"#margin\" class=\"headerlink\" title=\"margin\"></a>margin</h3><blockquote>\n<p>边距设置</p>\n</blockquote>\n<h3 id=\"constraints\"><a href=\"#constraints\" class=\"headerlink\" title=\"constraints\"></a>constraints</h3><blockquote>\n<p>布局约束</p>\n</blockquote>\n<h3 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h3><blockquote>\n<p>矩阵变换</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Container 容器控件，包含一个子Widget，具备alignment、padding等属性，方便布局摆放child</p>\n<h2 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h2><p><img src=\"img/14_1.png\" alt></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h3 id=\"child\"><a href=\"#child\" class=\"headerlink\" title=\"child\"></a>child</h3><blockquote>\n<p>子控件</p>\n</blockquote>\n<h3 id=\"alignment\"><a href=\"#alignment\" class=\"headerlink\" title=\"alignment\"></a>alignment</h3><blockquote>\n<p>对齐方式</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// The top left corner.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment topLeft = Alignment(<span class=\"number\">-1.0</span>, <span class=\"number\">-1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point along the top edge.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment topCenter = Alignment(<span class=\"number\">0.0</span>, <span class=\"number\">-1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The top right corner.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment topRight = Alignment(<span class=\"number\">1.0</span>, <span class=\"number\">-1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point along the left edge.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment centerLeft = Alignment(<span class=\"number\">-1.0</span>, <span class=\"number\">0.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point, both horizontally and vertically.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment center = Alignment(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point along the right edge.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment centerRight = Alignment(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The bottom left corner.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment bottomLeft = Alignment(<span class=\"number\">-1.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The center point along the bottom edge.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment bottomCenter = Alignment(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\"> <span class=\"comment\">/// The bottom right corner.</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> Alignment bottomRight = Alignment(<span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"color-和-decoration\"><a href=\"#color-和-decoration\" class=\"headerlink\" title=\"color  和 decoration\"></a>color  和 decoration</h3><blockquote>\n<p>设置背景色或背景</p>\n<ul>\n<li>两者无法共存</li>\n</ul>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span>(color == <span class=\"keyword\">null</span> || decoration == <span class=\"keyword\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">'Cannot provide both a color and a decoration\\n'</span></span><br><span class=\"line\">    <span class=\"string\">'The color argument is just a shorthand for \"decoration: new BoxDecoration(color: color)\".'</span></span><br><span class=\"line\">),</span><br><span class=\"line\">decoration = decoration ?? (color != <span class=\"keyword\">null</span> ? BoxDecoration(color: color) : <span class=\"keyword\">null</span>),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"foregroundDecoration\"><a href=\"#foregroundDecoration\" class=\"headerlink\" title=\"foregroundDecoration\"></a>foregroundDecoration</h3><blockquote>\n<p>前景设置</p>\n</blockquote>\n<h3 id=\"margin\"><a href=\"#margin\" class=\"headerlink\" title=\"margin\"></a>margin</h3><blockquote>\n<p>边距设置</p>\n</blockquote>\n<h3 id=\"constraints\"><a href=\"#constraints\" class=\"headerlink\" title=\"constraints\"></a>constraints</h3><blockquote>\n<p>布局约束</p>\n</blockquote>\n<h3 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h3><blockquote>\n<p>矩阵变换</p>\n</blockquote>\n"},{"title":"Padding&Align&Center","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T08:46:00.000Z","_content":"## Padding\n> Padding可以给其子节点添加补白（填充）\n### 定义\n```dart\nPadding({\n  ...\n  EdgeInsetsGeometry padding,\n  Widget child,\n})\n```\nEdgeInsetsGeometry是一个抽象类，开发中，我们一般都使用EdgeInsets，它是EdgeInsetsGeometry的一个子类，定义了一些设置补白的便捷方法。\n###  EdgeInsets\n我们看看EdgeInsets提供的便捷方法：\n\n- fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的补白。\n- all(double value) : 所有方向均使用相同数值的补白。\n- only({left, top, right ,bottom })：可以设置具体某个方向的补白(可以同时指定多个方向)。\n- symmetric({ vertical, horizontal })：用于设置对称方向的补白，vertical指top和bottom，horizontal指left和right。\n- \n### 示例\n```dart\nContainer(\n  color: Colors.pink,\n  child: Padding(\n    padding: const EdgeInsets.all(10.0),\n    child: Container(\n      color: Colors.blue,\n      child: Padding(\n        padding: const EdgeInsets.all(10.0),\n        child: Container(\n          color: Colors.pink,\n          alignment: Alignment.center,\n          child: Text(\n            \"演示 Padding\",\n            style: TextStyle(\n              color: Colors.white,\n              fontSize: 20.0,\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n```\n![](../img/padding.jpg)\n\n## Align\n> Align本身实现的功能并不复杂，设置child的对齐方式，例如居中、居左居右等，并根据child尺寸调节自身尺寸。\n\nAlign的布局行为分为两种情况：\n\n1. 当widthFactor和heightFactor为null的时候，当其有限制条件的时候，Align会根据限制条件尽量的扩展自己的尺寸，当没有限制条件的时候，会调整到child的尺寸；\n2. 当widthFactor或者heightFactor不为null的时候，Aligin会根据factor属性，扩展自己的尺寸，例如设置widthFactor为2.0的时候，那么，Align的宽度将会是child的两倍。\n\nAlign为什么会有这样的布局行为呢？原因很简单，设置对齐方式的话，如果外层元素尺寸不确定的话，内部的对齐就无法确定。因此，会有宽高因子、根据外层限制扩大到最大尺寸、外层不确定时调整到child尺寸这些行为。\n\n## Center\n> Center继承自Align，只不过是将alignment设置为Alignment.center，其他属性例如widthFactor、heightFactor，布局行为，都与Align完全一样。","source":"_posts/flutter/容器/Padding&Align&Center.md","raw":"---\ntitle: Padding&Align&Center\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- 容器\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 16:46:00   \n---\n## Padding\n> Padding可以给其子节点添加补白（填充）\n### 定义\n```dart\nPadding({\n  ...\n  EdgeInsetsGeometry padding,\n  Widget child,\n})\n```\nEdgeInsetsGeometry是一个抽象类，开发中，我们一般都使用EdgeInsets，它是EdgeInsetsGeometry的一个子类，定义了一些设置补白的便捷方法。\n###  EdgeInsets\n我们看看EdgeInsets提供的便捷方法：\n\n- fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的补白。\n- all(double value) : 所有方向均使用相同数值的补白。\n- only({left, top, right ,bottom })：可以设置具体某个方向的补白(可以同时指定多个方向)。\n- symmetric({ vertical, horizontal })：用于设置对称方向的补白，vertical指top和bottom，horizontal指left和right。\n- \n### 示例\n```dart\nContainer(\n  color: Colors.pink,\n  child: Padding(\n    padding: const EdgeInsets.all(10.0),\n    child: Container(\n      color: Colors.blue,\n      child: Padding(\n        padding: const EdgeInsets.all(10.0),\n        child: Container(\n          color: Colors.pink,\n          alignment: Alignment.center,\n          child: Text(\n            \"演示 Padding\",\n            style: TextStyle(\n              color: Colors.white,\n              fontSize: 20.0,\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n```\n![](../img/padding.jpg)\n\n## Align\n> Align本身实现的功能并不复杂，设置child的对齐方式，例如居中、居左居右等，并根据child尺寸调节自身尺寸。\n\nAlign的布局行为分为两种情况：\n\n1. 当widthFactor和heightFactor为null的时候，当其有限制条件的时候，Align会根据限制条件尽量的扩展自己的尺寸，当没有限制条件的时候，会调整到child的尺寸；\n2. 当widthFactor或者heightFactor不为null的时候，Aligin会根据factor属性，扩展自己的尺寸，例如设置widthFactor为2.0的时候，那么，Align的宽度将会是child的两倍。\n\nAlign为什么会有这样的布局行为呢？原因很简单，设置对齐方式的话，如果外层元素尺寸不确定的话，内部的对齐就无法确定。因此，会有宽高因子、根据外层限制扩大到最大尺寸、外层不确定时调整到child尺寸这些行为。\n\n## Center\n> Center继承自Align，只不过是将alignment设置为Alignment.center，其他属性例如widthFactor、heightFactor，布局行为，都与Align完全一样。","slug":"flutter/容器/Padding&Align&Center","published":1,"updated":"2019-10-02T11:59:30.461Z","layout":"post","photos":[],"link":"","_id":"ck19bvb56005d00wktxnrgrw4","content":"<h2 id=\"Padding\"><a href=\"#Padding\" class=\"headerlink\" title=\"Padding\"></a>Padding</h2><blockquote>\n<p>Padding可以给其子节点添加补白（填充）</p>\n</blockquote>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Padding(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  EdgeInsetsGeometry padding,</span><br><span class=\"line\">  Widget child,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>EdgeInsetsGeometry是一个抽象类，开发中，我们一般都使用EdgeInsets，它是EdgeInsetsGeometry的一个子类，定义了一些设置补白的便捷方法。</p>\n<h3 id=\"EdgeInsets\"><a href=\"#EdgeInsets\" class=\"headerlink\" title=\"EdgeInsets\"></a>EdgeInsets</h3><p>我们看看EdgeInsets提供的便捷方法：</p>\n<ul>\n<li>fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的补白。</li>\n<li>all(double value) : 所有方向均使用相同数值的补白。</li>\n<li>only({left, top, right ,bottom })：可以设置具体某个方向的补白(可以同时指定多个方向)。</li>\n<li>symmetric({ vertical, horizontal })：用于设置对称方向的补白，vertical指top和bottom，horizontal指left和right。</li>\n<li><h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container(</span><br><span class=\"line\">  color: Colors.pink,</span><br><span class=\"line\">  child: Padding(</span><br><span class=\"line\">    padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">    child: Container(</span><br><span class=\"line\">      color: Colors.blue,</span><br><span class=\"line\">      child: Padding(</span><br><span class=\"line\">        padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">        child: Container(</span><br><span class=\"line\">          color: Colors.pink,</span><br><span class=\"line\">          alignment: Alignment.center,</span><br><span class=\"line\">          child: Text(</span><br><span class=\"line\">            <span class=\"string\">\"演示 Padding\"</span>,</span><br><span class=\"line\">            style: TextStyle(</span><br><span class=\"line\">              color: Colors.white,</span><br><span class=\"line\">              fontSize: <span class=\"number\">20.0</span>,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"../img/padding.jpg\" alt></p>\n<h2 id=\"Align\"><a href=\"#Align\" class=\"headerlink\" title=\"Align\"></a>Align</h2><blockquote>\n<p>Align本身实现的功能并不复杂，设置child的对齐方式，例如居中、居左居右等，并根据child尺寸调节自身尺寸。</p>\n</blockquote>\n<p>Align的布局行为分为两种情况：</p>\n<ol>\n<li>当widthFactor和heightFactor为null的时候，当其有限制条件的时候，Align会根据限制条件尽量的扩展自己的尺寸，当没有限制条件的时候，会调整到child的尺寸；</li>\n<li>当widthFactor或者heightFactor不为null的时候，Aligin会根据factor属性，扩展自己的尺寸，例如设置widthFactor为2.0的时候，那么，Align的宽度将会是child的两倍。</li>\n</ol>\n<p>Align为什么会有这样的布局行为呢？原因很简单，设置对齐方式的话，如果外层元素尺寸不确定的话，内部的对齐就无法确定。因此，会有宽高因子、根据外层限制扩大到最大尺寸、外层不确定时调整到child尺寸这些行为。</p>\n<h2 id=\"Center\"><a href=\"#Center\" class=\"headerlink\" title=\"Center\"></a>Center</h2><blockquote>\n<p>Center继承自Align，只不过是将alignment设置为Alignment.center，其他属性例如widthFactor、heightFactor，布局行为，都与Align完全一样。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Padding\"><a href=\"#Padding\" class=\"headerlink\" title=\"Padding\"></a>Padding</h2><blockquote>\n<p>Padding可以给其子节点添加补白（填充）</p>\n</blockquote>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Padding(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  EdgeInsetsGeometry padding,</span><br><span class=\"line\">  Widget child,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>EdgeInsetsGeometry是一个抽象类，开发中，我们一般都使用EdgeInsets，它是EdgeInsetsGeometry的一个子类，定义了一些设置补白的便捷方法。</p>\n<h3 id=\"EdgeInsets\"><a href=\"#EdgeInsets\" class=\"headerlink\" title=\"EdgeInsets\"></a>EdgeInsets</h3><p>我们看看EdgeInsets提供的便捷方法：</p>\n<ul>\n<li>fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的补白。</li>\n<li>all(double value) : 所有方向均使用相同数值的补白。</li>\n<li>only({left, top, right ,bottom })：可以设置具体某个方向的补白(可以同时指定多个方向)。</li>\n<li>symmetric({ vertical, horizontal })：用于设置对称方向的补白，vertical指top和bottom，horizontal指left和right。</li>\n<li><h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container(</span><br><span class=\"line\">  color: Colors.pink,</span><br><span class=\"line\">  child: Padding(</span><br><span class=\"line\">    padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">    child: Container(</span><br><span class=\"line\">      color: Colors.blue,</span><br><span class=\"line\">      child: Padding(</span><br><span class=\"line\">        padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">        child: Container(</span><br><span class=\"line\">          color: Colors.pink,</span><br><span class=\"line\">          alignment: Alignment.center,</span><br><span class=\"line\">          child: Text(</span><br><span class=\"line\">            <span class=\"string\">\"演示 Padding\"</span>,</span><br><span class=\"line\">            style: TextStyle(</span><br><span class=\"line\">              color: Colors.white,</span><br><span class=\"line\">              fontSize: <span class=\"number\">20.0</span>,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"../img/padding.jpg\" alt></p>\n<h2 id=\"Align\"><a href=\"#Align\" class=\"headerlink\" title=\"Align\"></a>Align</h2><blockquote>\n<p>Align本身实现的功能并不复杂，设置child的对齐方式，例如居中、居左居右等，并根据child尺寸调节自身尺寸。</p>\n</blockquote>\n<p>Align的布局行为分为两种情况：</p>\n<ol>\n<li>当widthFactor和heightFactor为null的时候，当其有限制条件的时候，Align会根据限制条件尽量的扩展自己的尺寸，当没有限制条件的时候，会调整到child的尺寸；</li>\n<li>当widthFactor或者heightFactor不为null的时候，Aligin会根据factor属性，扩展自己的尺寸，例如设置widthFactor为2.0的时候，那么，Align的宽度将会是child的两倍。</li>\n</ol>\n<p>Align为什么会有这样的布局行为呢？原因很简单，设置对齐方式的话，如果外层元素尺寸不确定的话，内部的对齐就无法确定。因此，会有宽高因子、根据外层限制扩大到最大尺寸、外层不确定时调整到child尺寸这些行为。</p>\n<h2 id=\"Center\"><a href=\"#Center\" class=\"headerlink\" title=\"Center\"></a>Center</h2><blockquote>\n<p>Center继承自Align，只不过是将alignment设置为Alignment.center，其他属性例如widthFactor、heightFactor，布局行为，都与Align完全一样。</p>\n</blockquote>\n"},{"title":"变换Transform","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T09:16:00.000Z","_content":"## 介绍\n> Transform可以在其子Widget绘制时对其应用一个矩阵变换（transformation），Matrix4是一个4D矩阵，通过它我们可以实现各种矩阵操作。\n\n```dart\nContainer(\n  color: Colors.black,\n  child: new Transform(\n    alignment: Alignment.topRight, //相对于坐标系原点的对齐方式\n    transform: new Matrix4.skewY(0.3), //沿Y轴倾斜0.3弧度\n    child: new Container(\n      padding: const EdgeInsets.all(8.0),\n      color: Colors.deepOrange,\n      child: const Text('Apartment for rent!'),\n    ),\n  ),\n);\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910160248494.png)\n\n关于矩阵变换的相关内容属于线性代数范畴，本书不做讨论，读者有兴趣可以自行了解。本书中，我们把焦点放在Flutter中一些常见的变换效果上。\n\n## 平移\nTransform.translate接收一个offset参数，可以在绘制时沿x、y轴对子widget平移指定的距离。\n```dart\nDecoratedBox(\n  decoration:BoxDecoration(color: Colors.red),\n  //默认原点为左上角，左移20像素，向上平移5像素  \n  child: Transform.translate(offset: Offset(-20.0, -5.0),\n    child: Text(\"Hello world\"),\n  ),\n)\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910161953078.png)\n\n## 旋转\nTransform.rotate可以对子widget进行旋转变换，如：\n```dart\nDecoratedBox(\n  decoration:BoxDecoration(color: Colors.red),\n  child: Transform.rotate(\n    //旋转90度\n    angle:math.pi/2 ,\n    child: Text(\"Hello world\"),\n  ),\n)；\n```\n注意：要使用math.pi需先进行如下导包。\n```dart\nimport 'dart:math' as math;\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910162408030.png)\n\n## 缩放\nTransform.scale可以对子Widget进行缩小或放大，如：\n```dart\nDecoratedBox(\n  decoration:BoxDecoration(color: Colors.red),\n  child: Transform.scale(\n      scale: 1.5, //放大到1.5倍\n      child: Text(\"Hello world\")\n  )\n);\n```\n![效果：](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910162817059.png)\n\n## 注意\nTransform的变换是应用在绘制阶段，而并不是应用在布局(layout)阶段，所以无论对子widget应用何种变化，其占用空间的大小和在屏幕上的位置都是固定不变的，因为这些是在布局阶段就确定的。下面我们具体说明：\n```dart\n Row(\n  mainAxisAlignment: MainAxisAlignment.center,\n  children: <Widget>[\n    DecoratedBox(\n      decoration:BoxDecoration(color: Colors.red),\n      child: Transform.scale(scale: 1.5,\n          child: Text(\"Hello world\")\n      )\n    ),\n    Text(\"你好\", style: TextStyle(color: Colors.green, fontSize: 18.0),)\n  ],\n)\n```\n![显示效果：](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910164454967.png)\n\n\n由于第一个Text应用变换(放大)后，其在绘制时会放大，但其占用的空间依然为红色部分，所以第二个text会紧挨着红色部分，最终就会出现文字有重合部分。\n\n由于矩阵变化只会作用在绘制阶段，所以在某些场景下，在UI需要变化时，可以直接通过矩阵变化来达到视觉上的UI改变，而不需要去重新触发build流程，这样会节省layout的开销，所以性能会比较好。如之前介绍的Flow widget，它内部就是用矩阵变换来更新UI，除此之外，Flutter的动画widget中也大量使用了Transform以提高性能。\n\n## RotatedBox\nRotatedBox和Transform.rotate功能相似，它们都可以对子widget进行旋转变换，但是有一点不同：RotatedBox的变换是在layout阶段，会影响在子widget的位置和大小。我们将上面介绍Transform.rotate时的示例改一下：\n```dart\nRow(\n  mainAxisAlignment: MainAxisAlignment.center,\n  children: <Widget>[\n    DecoratedBox(\n      decoration: BoxDecoration(color: Colors.red),\n      //将Transform.rotate换成RotatedBox  \n      child: RotatedBox(\n        quarterTurns: 1, //旋转90度(1/4圈)\n        child: Text(\"Hello world\"),\n      ),\n    ),\n    Text(\"你好\", style: TextStyle(color: Colors.green, fontSize: 18.0),)\n  ],\n),\n```\n![效果：](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910170603964.png)\n\n由于RotatedBox是作用于layout阶段，所以widget会旋转90度（而不只是绘制的内容），decoration会作用到widget所占用的实际空间上，所以就是上图的效果。读者可以和前面Transform.rotate示例对比理解。","source":"_posts/flutter/容器/变换Transform.md","raw":"---\ntitle: 变换Transform\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- 容器\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 17:16:00   \n---\n## 介绍\n> Transform可以在其子Widget绘制时对其应用一个矩阵变换（transformation），Matrix4是一个4D矩阵，通过它我们可以实现各种矩阵操作。\n\n```dart\nContainer(\n  color: Colors.black,\n  child: new Transform(\n    alignment: Alignment.topRight, //相对于坐标系原点的对齐方式\n    transform: new Matrix4.skewY(0.3), //沿Y轴倾斜0.3弧度\n    child: new Container(\n      padding: const EdgeInsets.all(8.0),\n      color: Colors.deepOrange,\n      child: const Text('Apartment for rent!'),\n    ),\n  ),\n);\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910160248494.png)\n\n关于矩阵变换的相关内容属于线性代数范畴，本书不做讨论，读者有兴趣可以自行了解。本书中，我们把焦点放在Flutter中一些常见的变换效果上。\n\n## 平移\nTransform.translate接收一个offset参数，可以在绘制时沿x、y轴对子widget平移指定的距离。\n```dart\nDecoratedBox(\n  decoration:BoxDecoration(color: Colors.red),\n  //默认原点为左上角，左移20像素，向上平移5像素  \n  child: Transform.translate(offset: Offset(-20.0, -5.0),\n    child: Text(\"Hello world\"),\n  ),\n)\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910161953078.png)\n\n## 旋转\nTransform.rotate可以对子widget进行旋转变换，如：\n```dart\nDecoratedBox(\n  decoration:BoxDecoration(color: Colors.red),\n  child: Transform.rotate(\n    //旋转90度\n    angle:math.pi/2 ,\n    child: Text(\"Hello world\"),\n  ),\n)；\n```\n注意：要使用math.pi需先进行如下导包。\n```dart\nimport 'dart:math' as math;\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910162408030.png)\n\n## 缩放\nTransform.scale可以对子Widget进行缩小或放大，如：\n```dart\nDecoratedBox(\n  decoration:BoxDecoration(color: Colors.red),\n  child: Transform.scale(\n      scale: 1.5, //放大到1.5倍\n      child: Text(\"Hello world\")\n  )\n);\n```\n![效果：](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910162817059.png)\n\n## 注意\nTransform的变换是应用在绘制阶段，而并不是应用在布局(layout)阶段，所以无论对子widget应用何种变化，其占用空间的大小和在屏幕上的位置都是固定不变的，因为这些是在布局阶段就确定的。下面我们具体说明：\n```dart\n Row(\n  mainAxisAlignment: MainAxisAlignment.center,\n  children: <Widget>[\n    DecoratedBox(\n      decoration:BoxDecoration(color: Colors.red),\n      child: Transform.scale(scale: 1.5,\n          child: Text(\"Hello world\")\n      )\n    ),\n    Text(\"你好\", style: TextStyle(color: Colors.green, fontSize: 18.0),)\n  ],\n)\n```\n![显示效果：](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910164454967.png)\n\n\n由于第一个Text应用变换(放大)后，其在绘制时会放大，但其占用的空间依然为红色部分，所以第二个text会紧挨着红色部分，最终就会出现文字有重合部分。\n\n由于矩阵变化只会作用在绘制阶段，所以在某些场景下，在UI需要变化时，可以直接通过矩阵变化来达到视觉上的UI改变，而不需要去重新触发build流程，这样会节省layout的开销，所以性能会比较好。如之前介绍的Flow widget，它内部就是用矩阵变换来更新UI，除此之外，Flutter的动画widget中也大量使用了Transform以提高性能。\n\n## RotatedBox\nRotatedBox和Transform.rotate功能相似，它们都可以对子widget进行旋转变换，但是有一点不同：RotatedBox的变换是在layout阶段，会影响在子widget的位置和大小。我们将上面介绍Transform.rotate时的示例改一下：\n```dart\nRow(\n  mainAxisAlignment: MainAxisAlignment.center,\n  children: <Widget>[\n    DecoratedBox(\n      decoration: BoxDecoration(color: Colors.red),\n      //将Transform.rotate换成RotatedBox  \n      child: RotatedBox(\n        quarterTurns: 1, //旋转90度(1/4圈)\n        child: Text(\"Hello world\"),\n      ),\n    ),\n    Text(\"你好\", style: TextStyle(color: Colors.green, fontSize: 18.0),)\n  ],\n),\n```\n![效果：](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910170603964.png)\n\n由于RotatedBox是作用于layout阶段，所以widget会旋转90度（而不只是绘制的内容），decoration会作用到widget所占用的实际空间上，所以就是上图的效果。读者可以和前面Transform.rotate示例对比理解。","slug":"flutter/容器/变换Transform","published":1,"updated":"2019-10-02T11:58:04.677Z","layout":"post","photos":[],"link":"","_id":"ck19bvb5e005g00wkg0kl6468","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>Transform可以在其子Widget绘制时对其应用一个矩阵变换（transformation），Matrix4是一个4D矩阵，通过它我们可以实现各种矩阵操作。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container(</span><br><span class=\"line\">  color: Colors.black,</span><br><span class=\"line\">  child: <span class=\"keyword\">new</span> Transform(</span><br><span class=\"line\">    alignment: Alignment.topRight, <span class=\"comment\">//相对于坐标系原点的对齐方式</span></span><br><span class=\"line\">    transform: <span class=\"keyword\">new</span> Matrix4.skewY(<span class=\"number\">0.3</span>), <span class=\"comment\">//沿Y轴倾斜0.3弧度</span></span><br><span class=\"line\">    child: <span class=\"keyword\">new</span> Container(</span><br><span class=\"line\">      padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">8.0</span>),</span><br><span class=\"line\">      color: Colors.deepOrange,</span><br><span class=\"line\">      child: <span class=\"keyword\">const</span> Text(<span class=\"string\">'Apartment for rent!'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910160248494.png\" alt></p>\n<p>关于矩阵变换的相关内容属于线性代数范畴，本书不做讨论，读者有兴趣可以自行了解。本书中，我们把焦点放在Flutter中一些常见的变换效果上。</p>\n<h2 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h2><p>Transform.translate接收一个offset参数，可以在绘制时沿x、y轴对子widget平移指定的距离。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DecoratedBox(</span><br><span class=\"line\">  decoration:BoxDecoration(color: Colors.red),</span><br><span class=\"line\">  <span class=\"comment\">//默认原点为左上角，左移20像素，向上平移5像素  </span></span><br><span class=\"line\">  child: Transform.translate(offset: Offset(<span class=\"number\">-20.0</span>, <span class=\"number\">-5.0</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"Hello world\"</span>),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910161953078.png\" alt></p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>Transform.rotate可以对子widget进行旋转变换，如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DecoratedBox(</span><br><span class=\"line\">  decoration:BoxDecoration(color: Colors.red),</span><br><span class=\"line\">  child: Transform.rotate(</span><br><span class=\"line\">    <span class=\"comment\">//旋转90度</span></span><br><span class=\"line\">    angle:math.pi/<span class=\"number\">2</span> ,</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"Hello world\"</span>),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">)；</span><br></pre></td></tr></table></figure>\n\n<p>注意：要使用math.pi需先进行如下导包。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span> <span class=\"keyword\">as</span> math;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910162408030.png\" alt></p>\n<h2 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h2><p>Transform.scale可以对子Widget进行缩小或放大，如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DecoratedBox(</span><br><span class=\"line\">  decoration:BoxDecoration(color: Colors.red),</span><br><span class=\"line\">  child: Transform.scale(</span><br><span class=\"line\">      scale: <span class=\"number\">1.5</span>, <span class=\"comment\">//放大到1.5倍</span></span><br><span class=\"line\">      child: Text(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910162817059.png\" alt=\"效果：\"></p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>Transform的变换是应用在绘制阶段，而并不是应用在布局(layout)阶段，所以无论对子widget应用何种变化，其占用空间的大小和在屏幕上的位置都是固定不变的，因为这些是在布局阶段就确定的。下面我们具体说明：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> Row(</span><br><span class=\"line\">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    DecoratedBox(</span><br><span class=\"line\">      decoration:BoxDecoration(color: Colors.red),</span><br><span class=\"line\">      child: Transform.scale(scale: <span class=\"number\">1.5</span>,</span><br><span class=\"line\">          child: Text(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    Text(<span class=\"string\">\"你好\"</span>, style: TextStyle(color: Colors.green, fontSize: <span class=\"number\">18.0</span>),)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910164454967.png\" alt=\"显示效果：\"></p>\n<p>由于第一个Text应用变换(放大)后，其在绘制时会放大，但其占用的空间依然为红色部分，所以第二个text会紧挨着红色部分，最终就会出现文字有重合部分。</p>\n<p>由于矩阵变化只会作用在绘制阶段，所以在某些场景下，在UI需要变化时，可以直接通过矩阵变化来达到视觉上的UI改变，而不需要去重新触发build流程，这样会节省layout的开销，所以性能会比较好。如之前介绍的Flow widget，它内部就是用矩阵变换来更新UI，除此之外，Flutter的动画widget中也大量使用了Transform以提高性能。</p>\n<h2 id=\"RotatedBox\"><a href=\"#RotatedBox\" class=\"headerlink\" title=\"RotatedBox\"></a>RotatedBox</h2><p>RotatedBox和Transform.rotate功能相似，它们都可以对子widget进行旋转变换，但是有一点不同：RotatedBox的变换是在layout阶段，会影响在子widget的位置和大小。我们将上面介绍Transform.rotate时的示例改一下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Row(</span><br><span class=\"line\">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    DecoratedBox(</span><br><span class=\"line\">      decoration: BoxDecoration(color: Colors.red),</span><br><span class=\"line\">      <span class=\"comment\">//将Transform.rotate换成RotatedBox  </span></span><br><span class=\"line\">      child: RotatedBox(</span><br><span class=\"line\">        quarterTurns: <span class=\"number\">1</span>, <span class=\"comment\">//旋转90度(1/4圈)</span></span><br><span class=\"line\">        child: Text(<span class=\"string\">\"Hello world\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    Text(<span class=\"string\">\"你好\"</span>, style: TextStyle(color: Colors.green, fontSize: <span class=\"number\">18.0</span>),)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">),</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910170603964.png\" alt=\"效果：\"></p>\n<p>由于RotatedBox是作用于layout阶段，所以widget会旋转90度（而不只是绘制的内容），decoration会作用到widget所占用的实际空间上，所以就是上图的效果。读者可以和前面Transform.rotate示例对比理解。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>Transform可以在其子Widget绘制时对其应用一个矩阵变换（transformation），Matrix4是一个4D矩阵，通过它我们可以实现各种矩阵操作。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container(</span><br><span class=\"line\">  color: Colors.black,</span><br><span class=\"line\">  child: <span class=\"keyword\">new</span> Transform(</span><br><span class=\"line\">    alignment: Alignment.topRight, <span class=\"comment\">//相对于坐标系原点的对齐方式</span></span><br><span class=\"line\">    transform: <span class=\"keyword\">new</span> Matrix4.skewY(<span class=\"number\">0.3</span>), <span class=\"comment\">//沿Y轴倾斜0.3弧度</span></span><br><span class=\"line\">    child: <span class=\"keyword\">new</span> Container(</span><br><span class=\"line\">      padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">8.0</span>),</span><br><span class=\"line\">      color: Colors.deepOrange,</span><br><span class=\"line\">      child: <span class=\"keyword\">const</span> Text(<span class=\"string\">'Apartment for rent!'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910160248494.png\" alt></p>\n<p>关于矩阵变换的相关内容属于线性代数范畴，本书不做讨论，读者有兴趣可以自行了解。本书中，我们把焦点放在Flutter中一些常见的变换效果上。</p>\n<h2 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h2><p>Transform.translate接收一个offset参数，可以在绘制时沿x、y轴对子widget平移指定的距离。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DecoratedBox(</span><br><span class=\"line\">  decoration:BoxDecoration(color: Colors.red),</span><br><span class=\"line\">  <span class=\"comment\">//默认原点为左上角，左移20像素，向上平移5像素  </span></span><br><span class=\"line\">  child: Transform.translate(offset: Offset(<span class=\"number\">-20.0</span>, <span class=\"number\">-5.0</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"Hello world\"</span>),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910161953078.png\" alt></p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>Transform.rotate可以对子widget进行旋转变换，如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DecoratedBox(</span><br><span class=\"line\">  decoration:BoxDecoration(color: Colors.red),</span><br><span class=\"line\">  child: Transform.rotate(</span><br><span class=\"line\">    <span class=\"comment\">//旋转90度</span></span><br><span class=\"line\">    angle:math.pi/<span class=\"number\">2</span> ,</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"Hello world\"</span>),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">)；</span><br></pre></td></tr></table></figure>\n\n<p>注意：要使用math.pi需先进行如下导包。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span> <span class=\"keyword\">as</span> math;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910162408030.png\" alt></p>\n<h2 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h2><p>Transform.scale可以对子Widget进行缩小或放大，如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DecoratedBox(</span><br><span class=\"line\">  decoration:BoxDecoration(color: Colors.red),</span><br><span class=\"line\">  child: Transform.scale(</span><br><span class=\"line\">      scale: <span class=\"number\">1.5</span>, <span class=\"comment\">//放大到1.5倍</span></span><br><span class=\"line\">      child: Text(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910162817059.png\" alt=\"效果：\"></p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>Transform的变换是应用在绘制阶段，而并不是应用在布局(layout)阶段，所以无论对子widget应用何种变化，其占用空间的大小和在屏幕上的位置都是固定不变的，因为这些是在布局阶段就确定的。下面我们具体说明：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> Row(</span><br><span class=\"line\">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    DecoratedBox(</span><br><span class=\"line\">      decoration:BoxDecoration(color: Colors.red),</span><br><span class=\"line\">      child: Transform.scale(scale: <span class=\"number\">1.5</span>,</span><br><span class=\"line\">          child: Text(<span class=\"string\">\"Hello world\"</span>)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    Text(<span class=\"string\">\"你好\"</span>, style: TextStyle(color: Colors.green, fontSize: <span class=\"number\">18.0</span>),)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910164454967.png\" alt=\"显示效果：\"></p>\n<p>由于第一个Text应用变换(放大)后，其在绘制时会放大，但其占用的空间依然为红色部分，所以第二个text会紧挨着红色部分，最终就会出现文字有重合部分。</p>\n<p>由于矩阵变化只会作用在绘制阶段，所以在某些场景下，在UI需要变化时，可以直接通过矩阵变化来达到视觉上的UI改变，而不需要去重新触发build流程，这样会节省layout的开销，所以性能会比较好。如之前介绍的Flow widget，它内部就是用矩阵变换来更新UI，除此之外，Flutter的动画widget中也大量使用了Transform以提高性能。</p>\n<h2 id=\"RotatedBox\"><a href=\"#RotatedBox\" class=\"headerlink\" title=\"RotatedBox\"></a>RotatedBox</h2><p>RotatedBox和Transform.rotate功能相似，它们都可以对子widget进行旋转变换，但是有一点不同：RotatedBox的变换是在layout阶段，会影响在子widget的位置和大小。我们将上面介绍Transform.rotate时的示例改一下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Row(</span><br><span class=\"line\">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    DecoratedBox(</span><br><span class=\"line\">      decoration: BoxDecoration(color: Colors.red),</span><br><span class=\"line\">      <span class=\"comment\">//将Transform.rotate换成RotatedBox  </span></span><br><span class=\"line\">      child: RotatedBox(</span><br><span class=\"line\">        quarterTurns: <span class=\"number\">1</span>, <span class=\"comment\">//旋转90度(1/4圈)</span></span><br><span class=\"line\">        child: Text(<span class=\"string\">\"Hello world\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    Text(<span class=\"string\">\"你好\"</span>, style: TextStyle(color: Colors.green, fontSize: <span class=\"number\">18.0</span>),)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">),</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910170603964.png\" alt=\"效果：\"></p>\n<p>由于RotatedBox是作用于layout阶段，所以widget会旋转90度（而不只是绘制的内容），decoration会作用到widget所占用的实际空间上，所以就是上图的效果。读者可以和前面Transform.rotate示例对比理解。</p>\n"},{"title":"布局","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T15:14:00.000Z","_content":"## 介绍\n布局类Widget都会包含一个或多个子widget，不同的布局类Widget对子widget排版(layout)方式不同。我们在前面说过Element树才是最终的绘制树，Element树是通过widget树来创建的（通过Widget.createElement()），widget其实就是Element的配置数据。Flutter中，根据Widget是否需要包含子节点将Widget分为了三类，分别对应三种Element，如下表：\n\nWidget|\t对应的Element\t|用途\n--|--|--\nLeafRenderObjectWidget|\tLeafRenderObjectElement|\tWidget树的叶子节点，用于没有子节点的widget，通常基础widget都属于这一类，如Text、Image。\nSingleChildRenderObjectWidget|\tSingleChildRenderObjectElement|\t包含一个子Widget，如：ConstrainedBox、DecoratedBox等\nMultiChildRenderObjectWidget|\tMultiChildRenderObjectElement|\t包含多个子Widget，一般都有一个children参数，接受一个Widget数组。如Row、Column、Stack等\n\n>注意，Flutter中的很多Widget是直接继承自StatelessWidget或StatefulWidget，然后在build()方法中构建真正的RenderObjectWidget，如Text，它其实是继承自StatelessWidget，然后在build()方法中通过RichText来构建其子树，而RichText才是继承自LeafRenderObjectWidget。所以为了方便叙述，我们也可以直接说Text属于LeafRenderObjectWidget（其它widget也可以这么描述），这才是本质。读到这里我们也会发现，其实StatelessWidget和StatefulWidget就是两个用于组合Widget的基类，它们本身并不关联最终的渲染对象（RenderObjectWidget）。\n\n## 常见布局\n1. 线性布局 \n   > Row、Column\n2. 弹性布局\n   >Flex\n3. 流式布局\n   > Wrap、Flow\n4. 层叠布局\n   > Stack、Positioned","source":"_posts/flutter/布局/布局类Widget.md","raw":"---\ntitle: 布局\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- 布局\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 23:14:00   \n---\n## 介绍\n布局类Widget都会包含一个或多个子widget，不同的布局类Widget对子widget排版(layout)方式不同。我们在前面说过Element树才是最终的绘制树，Element树是通过widget树来创建的（通过Widget.createElement()），widget其实就是Element的配置数据。Flutter中，根据Widget是否需要包含子节点将Widget分为了三类，分别对应三种Element，如下表：\n\nWidget|\t对应的Element\t|用途\n--|--|--\nLeafRenderObjectWidget|\tLeafRenderObjectElement|\tWidget树的叶子节点，用于没有子节点的widget，通常基础widget都属于这一类，如Text、Image。\nSingleChildRenderObjectWidget|\tSingleChildRenderObjectElement|\t包含一个子Widget，如：ConstrainedBox、DecoratedBox等\nMultiChildRenderObjectWidget|\tMultiChildRenderObjectElement|\t包含多个子Widget，一般都有一个children参数，接受一个Widget数组。如Row、Column、Stack等\n\n>注意，Flutter中的很多Widget是直接继承自StatelessWidget或StatefulWidget，然后在build()方法中构建真正的RenderObjectWidget，如Text，它其实是继承自StatelessWidget，然后在build()方法中通过RichText来构建其子树，而RichText才是继承自LeafRenderObjectWidget。所以为了方便叙述，我们也可以直接说Text属于LeafRenderObjectWidget（其它widget也可以这么描述），这才是本质。读到这里我们也会发现，其实StatelessWidget和StatefulWidget就是两个用于组合Widget的基类，它们本身并不关联最终的渲染对象（RenderObjectWidget）。\n\n## 常见布局\n1. 线性布局 \n   > Row、Column\n2. 弹性布局\n   >Flex\n3. 流式布局\n   > Wrap、Flow\n4. 层叠布局\n   > Stack、Positioned","slug":"flutter/布局/布局类Widget","published":1,"updated":"2019-10-02T11:50:47.283Z","layout":"post","photos":[],"link":"","_id":"ck19bvb69006b00wkbelf22ho","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>布局类Widget都会包含一个或多个子widget，不同的布局类Widget对子widget排版(layout)方式不同。我们在前面说过Element树才是最终的绘制树，Element树是通过widget树来创建的（通过Widget.createElement()），widget其实就是Element的配置数据。Flutter中，根据Widget是否需要包含子节点将Widget分为了三类，分别对应三种Element，如下表：</p>\n<table>\n<thead>\n<tr>\n<th>Widget</th>\n<th>对应的Element</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LeafRenderObjectWidget</td>\n<td>LeafRenderObjectElement</td>\n<td>Widget树的叶子节点，用于没有子节点的widget，通常基础widget都属于这一类，如Text、Image。</td>\n</tr>\n<tr>\n<td>SingleChildRenderObjectWidget</td>\n<td>SingleChildRenderObjectElement</td>\n<td>包含一个子Widget，如：ConstrainedBox、DecoratedBox等</td>\n</tr>\n<tr>\n<td>MultiChildRenderObjectWidget</td>\n<td>MultiChildRenderObjectElement</td>\n<td>包含多个子Widget，一般都有一个children参数，接受一个Widget数组。如Row、Column、Stack等</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意，Flutter中的很多Widget是直接继承自StatelessWidget或StatefulWidget，然后在build()方法中构建真正的RenderObjectWidget，如Text，它其实是继承自StatelessWidget，然后在build()方法中通过RichText来构建其子树，而RichText才是继承自LeafRenderObjectWidget。所以为了方便叙述，我们也可以直接说Text属于LeafRenderObjectWidget（其它widget也可以这么描述），这才是本质。读到这里我们也会发现，其实StatelessWidget和StatefulWidget就是两个用于组合Widget的基类，它们本身并不关联最终的渲染对象（RenderObjectWidget）。</p>\n</blockquote>\n<h2 id=\"常见布局\"><a href=\"#常见布局\" class=\"headerlink\" title=\"常见布局\"></a>常见布局</h2><ol>\n<li>线性布局 <blockquote>\n<p>Row、Column</p>\n</blockquote>\n</li>\n<li>弹性布局<blockquote>\n<p>Flex</p>\n</blockquote>\n</li>\n<li>流式布局<blockquote>\n<p>Wrap、Flow</p>\n</blockquote>\n</li>\n<li>层叠布局<blockquote>\n<p>Stack、Positioned</p>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>布局类Widget都会包含一个或多个子widget，不同的布局类Widget对子widget排版(layout)方式不同。我们在前面说过Element树才是最终的绘制树，Element树是通过widget树来创建的（通过Widget.createElement()），widget其实就是Element的配置数据。Flutter中，根据Widget是否需要包含子节点将Widget分为了三类，分别对应三种Element，如下表：</p>\n<table>\n<thead>\n<tr>\n<th>Widget</th>\n<th>对应的Element</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LeafRenderObjectWidget</td>\n<td>LeafRenderObjectElement</td>\n<td>Widget树的叶子节点，用于没有子节点的widget，通常基础widget都属于这一类，如Text、Image。</td>\n</tr>\n<tr>\n<td>SingleChildRenderObjectWidget</td>\n<td>SingleChildRenderObjectElement</td>\n<td>包含一个子Widget，如：ConstrainedBox、DecoratedBox等</td>\n</tr>\n<tr>\n<td>MultiChildRenderObjectWidget</td>\n<td>MultiChildRenderObjectElement</td>\n<td>包含多个子Widget，一般都有一个children参数，接受一个Widget数组。如Row、Column、Stack等</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意，Flutter中的很多Widget是直接继承自StatelessWidget或StatefulWidget，然后在build()方法中构建真正的RenderObjectWidget，如Text，它其实是继承自StatelessWidget，然后在build()方法中通过RichText来构建其子树，而RichText才是继承自LeafRenderObjectWidget。所以为了方便叙述，我们也可以直接说Text属于LeafRenderObjectWidget（其它widget也可以这么描述），这才是本质。读到这里我们也会发现，其实StatelessWidget和StatefulWidget就是两个用于组合Widget的基类，它们本身并不关联最终的渲染对象（RenderObjectWidget）。</p>\n</blockquote>\n<h2 id=\"常见布局\"><a href=\"#常见布局\" class=\"headerlink\" title=\"常见布局\"></a>常见布局</h2><ol>\n<li>线性布局 <blockquote>\n<p>Row、Column</p>\n</blockquote>\n</li>\n<li>弹性布局<blockquote>\n<p>Flex</p>\n</blockquote>\n</li>\n<li>流式布局<blockquote>\n<p>Wrap、Flow</p>\n</blockquote>\n</li>\n<li>层叠布局<blockquote>\n<p>Stack、Positioned</p>\n</blockquote>\n</li>\n</ol>\n"},{"title":"Row&Colum","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T07:51:00.000Z","_content":"## 介绍\n> 沿着水平或垂直方向排列Widget。\n\n## Column&Row\n> 垂直和水平线性布局\n\n```dart\nColumn({\n    Key key,\n    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,// 表示子Widgets在Column所占用的水平空间内对齐方式\n    MainAxisSize mainAxisSize = MainAxisSize.max,//在垂直方向上的占据空间\n    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,// 表示子Widgets在纵轴方向的对齐方式\n    TextDirection textDirection,// 水平布局的顺序（从左到右、从右到左）\n    VerticalDirection verticalDirection = VerticalDirection.down,// 表示Column纵轴（垂直）的对齐方向\n    TextBaseline textBaseline,\n    List<Widget> children = const <Widget>[],// 子控件\n  }) \n```\n- textDirection：表示水平方向子widget的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)。\n- mainAxisSize：表示Row在主轴(水平)方向占用的空间，默认是MainAxisSize.max，表示尽可能多的占用水平方向的空间，此时无论子widgets实际占用多少水平空间，Row的宽度始终等于水平方向的最大宽度；而MainAxisSize.min表示尽可能少的占用水平空间，当子widgets没有占满水平剩余空间，则Row的实际宽度等于所有子widgets占用的的水平空间；\n- mainAxisAlignment：表示子Widgets在Row所占用的水平空间内对齐方式，如果mainAxisSize值为MainAxisSize.min，则此属性无意义，因为子widgets的宽度等于Row的宽度。只有当mainAxisSize的值为MainAxisSize.max时，此属性才有意义，MainAxisAlignment.start表示沿textDirection的初始方向对齐，如textDirection取值为TextDirection.ltr时，则MainAxisAlignment.start表示左对齐，textDirection取值为TextDirection.rtl时表示从右对齐。而MainAxisAlignment.end和MainAxisAlignment.start正好相反；MainAxisAlignment.center表示居中对齐。读者可以这么理解：textDirection是mainAxisAlignment的参考系。\n- verticalDirection：表示Row纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下。\n- crossAxisAlignment：表示子Widgets在纵轴方向的对齐方式，Row的高度等于子Widgets中最高的子元素高度，它的取值和MainAxisAlignment一样(包含start、end、 center三个值)，不同的是crossAxisAlignment的参考系是verticalDirection，即verticalDirection值为VerticalDirection.down时crossAxisAlignment.start指顶部对齐，verticalDirection值为VerticalDirection.up时，crossAxisAlignment.start指底部对齐；而crossAxisAlignment.end和crossAxisAlignment.start正好相反；\n- children ：子Widgets数组。","source":"_posts/flutter/布局/Row&Colum.md","raw":"---\ntitle: Row&Colum\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- 布局\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 15:51:00   \n---\n## 介绍\n> 沿着水平或垂直方向排列Widget。\n\n## Column&Row\n> 垂直和水平线性布局\n\n```dart\nColumn({\n    Key key,\n    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,// 表示子Widgets在Column所占用的水平空间内对齐方式\n    MainAxisSize mainAxisSize = MainAxisSize.max,//在垂直方向上的占据空间\n    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,// 表示子Widgets在纵轴方向的对齐方式\n    TextDirection textDirection,// 水平布局的顺序（从左到右、从右到左）\n    VerticalDirection verticalDirection = VerticalDirection.down,// 表示Column纵轴（垂直）的对齐方向\n    TextBaseline textBaseline,\n    List<Widget> children = const <Widget>[],// 子控件\n  }) \n```\n- textDirection：表示水平方向子widget的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)。\n- mainAxisSize：表示Row在主轴(水平)方向占用的空间，默认是MainAxisSize.max，表示尽可能多的占用水平方向的空间，此时无论子widgets实际占用多少水平空间，Row的宽度始终等于水平方向的最大宽度；而MainAxisSize.min表示尽可能少的占用水平空间，当子widgets没有占满水平剩余空间，则Row的实际宽度等于所有子widgets占用的的水平空间；\n- mainAxisAlignment：表示子Widgets在Row所占用的水平空间内对齐方式，如果mainAxisSize值为MainAxisSize.min，则此属性无意义，因为子widgets的宽度等于Row的宽度。只有当mainAxisSize的值为MainAxisSize.max时，此属性才有意义，MainAxisAlignment.start表示沿textDirection的初始方向对齐，如textDirection取值为TextDirection.ltr时，则MainAxisAlignment.start表示左对齐，textDirection取值为TextDirection.rtl时表示从右对齐。而MainAxisAlignment.end和MainAxisAlignment.start正好相反；MainAxisAlignment.center表示居中对齐。读者可以这么理解：textDirection是mainAxisAlignment的参考系。\n- verticalDirection：表示Row纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下。\n- crossAxisAlignment：表示子Widgets在纵轴方向的对齐方式，Row的高度等于子Widgets中最高的子元素高度，它的取值和MainAxisAlignment一样(包含start、end、 center三个值)，不同的是crossAxisAlignment的参考系是verticalDirection，即verticalDirection值为VerticalDirection.down时crossAxisAlignment.start指顶部对齐，verticalDirection值为VerticalDirection.up时，crossAxisAlignment.start指底部对齐；而crossAxisAlignment.end和crossAxisAlignment.start正好相反；\n- children ：子Widgets数组。","slug":"flutter/布局/Row&Colum","published":1,"updated":"2019-10-02T11:54:39.090Z","layout":"post","photos":[],"link":"","_id":"ck19bvb6b006c00wk867foyjq","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>沿着水平或垂直方向排列Widget。</p>\n</blockquote>\n<h2 id=\"Column-amp-Row\"><a href=\"#Column-amp-Row\" class=\"headerlink\" title=\"Column&amp;Row\"></a>Column&amp;Row</h2><blockquote>\n<p>垂直和水平线性布局</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Column(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,<span class=\"comment\">// 表示子Widgets在Column所占用的水平空间内对齐方式</span></span><br><span class=\"line\">    MainAxisSize mainAxisSize = MainAxisSize.max,<span class=\"comment\">//在垂直方向上的占据空间</span></span><br><span class=\"line\">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,<span class=\"comment\">// 表示子Widgets在纵轴方向的对齐方式</span></span><br><span class=\"line\">    TextDirection textDirection,<span class=\"comment\">// 水平布局的顺序（从左到右、从右到左）</span></span><br><span class=\"line\">    VerticalDirection verticalDirection = VerticalDirection.down,<span class=\"comment\">// 表示Column纵轴（垂直）的对齐方向</span></span><br><span class=\"line\">    TextBaseline textBaseline,</span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],<span class=\"comment\">// 子控件</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>textDirection：表示水平方向子widget的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)。</li>\n<li>mainAxisSize：表示Row在主轴(水平)方向占用的空间，默认是MainAxisSize.max，表示尽可能多的占用水平方向的空间，此时无论子widgets实际占用多少水平空间，Row的宽度始终等于水平方向的最大宽度；而MainAxisSize.min表示尽可能少的占用水平空间，当子widgets没有占满水平剩余空间，则Row的实际宽度等于所有子widgets占用的的水平空间；</li>\n<li>mainAxisAlignment：表示子Widgets在Row所占用的水平空间内对齐方式，如果mainAxisSize值为MainAxisSize.min，则此属性无意义，因为子widgets的宽度等于Row的宽度。只有当mainAxisSize的值为MainAxisSize.max时，此属性才有意义，MainAxisAlignment.start表示沿textDirection的初始方向对齐，如textDirection取值为TextDirection.ltr时，则MainAxisAlignment.start表示左对齐，textDirection取值为TextDirection.rtl时表示从右对齐。而MainAxisAlignment.end和MainAxisAlignment.start正好相反；MainAxisAlignment.center表示居中对齐。读者可以这么理解：textDirection是mainAxisAlignment的参考系。</li>\n<li>verticalDirection：表示Row纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下。</li>\n<li>crossAxisAlignment：表示子Widgets在纵轴方向的对齐方式，Row的高度等于子Widgets中最高的子元素高度，它的取值和MainAxisAlignment一样(包含start、end、 center三个值)，不同的是crossAxisAlignment的参考系是verticalDirection，即verticalDirection值为VerticalDirection.down时crossAxisAlignment.start指顶部对齐，verticalDirection值为VerticalDirection.up时，crossAxisAlignment.start指底部对齐；而crossAxisAlignment.end和crossAxisAlignment.start正好相反；</li>\n<li>children ：子Widgets数组。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>沿着水平或垂直方向排列Widget。</p>\n</blockquote>\n<h2 id=\"Column-amp-Row\"><a href=\"#Column-amp-Row\" class=\"headerlink\" title=\"Column&amp;Row\"></a>Column&amp;Row</h2><blockquote>\n<p>垂直和水平线性布局</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Column(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,<span class=\"comment\">// 表示子Widgets在Column所占用的水平空间内对齐方式</span></span><br><span class=\"line\">    MainAxisSize mainAxisSize = MainAxisSize.max,<span class=\"comment\">//在垂直方向上的占据空间</span></span><br><span class=\"line\">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,<span class=\"comment\">// 表示子Widgets在纵轴方向的对齐方式</span></span><br><span class=\"line\">    TextDirection textDirection,<span class=\"comment\">// 水平布局的顺序（从左到右、从右到左）</span></span><br><span class=\"line\">    VerticalDirection verticalDirection = VerticalDirection.down,<span class=\"comment\">// 表示Column纵轴（垂直）的对齐方向</span></span><br><span class=\"line\">    TextBaseline textBaseline,</span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],<span class=\"comment\">// 子控件</span></span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>textDirection：表示水平方向子widget的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)。</li>\n<li>mainAxisSize：表示Row在主轴(水平)方向占用的空间，默认是MainAxisSize.max，表示尽可能多的占用水平方向的空间，此时无论子widgets实际占用多少水平空间，Row的宽度始终等于水平方向的最大宽度；而MainAxisSize.min表示尽可能少的占用水平空间，当子widgets没有占满水平剩余空间，则Row的实际宽度等于所有子widgets占用的的水平空间；</li>\n<li>mainAxisAlignment：表示子Widgets在Row所占用的水平空间内对齐方式，如果mainAxisSize值为MainAxisSize.min，则此属性无意义，因为子widgets的宽度等于Row的宽度。只有当mainAxisSize的值为MainAxisSize.max时，此属性才有意义，MainAxisAlignment.start表示沿textDirection的初始方向对齐，如textDirection取值为TextDirection.ltr时，则MainAxisAlignment.start表示左对齐，textDirection取值为TextDirection.rtl时表示从右对齐。而MainAxisAlignment.end和MainAxisAlignment.start正好相反；MainAxisAlignment.center表示居中对齐。读者可以这么理解：textDirection是mainAxisAlignment的参考系。</li>\n<li>verticalDirection：表示Row纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下。</li>\n<li>crossAxisAlignment：表示子Widgets在纵轴方向的对齐方式，Row的高度等于子Widgets中最高的子元素高度，它的取值和MainAxisAlignment一样(包含start、end、 center三个值)，不同的是crossAxisAlignment的参考系是verticalDirection，即verticalDirection值为VerticalDirection.down时crossAxisAlignment.start指顶部对齐，verticalDirection值为VerticalDirection.up时，crossAxisAlignment.start指底部对齐；而crossAxisAlignment.end和crossAxisAlignment.start正好相反；</li>\n<li>children ：子Widgets数组。</li>\n</ul>\n"},{"title":"Flex&Expand","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T08:16:00.000Z","_content":"## Flex\nFlex可以沿着水平或垂直方向排列子widget，如果你知道主轴方向，使用Row或Column会方便一些，因为Row和Column都继承自Flex，参数基本相同，所以能使用Flex的地方一定可以使用Row或Column。Flex本身功能是很强大的，它也可以和Expanded配合实现弹性布局，接下来我们只讨论Flex和弹性布局相关的属性(其它属性已经在介绍Row和Column时介绍过了)。\n```dart\nFlex({\n  ...\n  @required this.direction, //弹性布局的方向, Row默认为水平方向，Column默认为垂直方向\n  List<Widget> children = const <Widget>[],\n})\n```\nFlex继承自MultiChildRenderObjectWidget，对应的RenderObject为RenderFlex，RenderFlex中实现了其布局算法。\n\n## Expanded\n可以按比例“扩伸”Row、Column和Flex子widget所占用的空间。\n```dart\nconst Expanded({\n  int flex = 1, \n  @required Widget child,\n})\n```\nflex为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间","source":"_posts/flutter/布局/Flex&Expand.md","raw":"---\ntitle: Flex&Expand\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- 布局\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 16:16:00   \n---\n## Flex\nFlex可以沿着水平或垂直方向排列子widget，如果你知道主轴方向，使用Row或Column会方便一些，因为Row和Column都继承自Flex，参数基本相同，所以能使用Flex的地方一定可以使用Row或Column。Flex本身功能是很强大的，它也可以和Expanded配合实现弹性布局，接下来我们只讨论Flex和弹性布局相关的属性(其它属性已经在介绍Row和Column时介绍过了)。\n```dart\nFlex({\n  ...\n  @required this.direction, //弹性布局的方向, Row默认为水平方向，Column默认为垂直方向\n  List<Widget> children = const <Widget>[],\n})\n```\nFlex继承自MultiChildRenderObjectWidget，对应的RenderObject为RenderFlex，RenderFlex中实现了其布局算法。\n\n## Expanded\n可以按比例“扩伸”Row、Column和Flex子widget所占用的空间。\n```dart\nconst Expanded({\n  int flex = 1, \n  @required Widget child,\n})\n```\nflex为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间","slug":"flutter/布局/Flex&Expand","published":1,"updated":"2019-10-02T11:53:51.738Z","layout":"post","photos":[],"link":"","_id":"ck19bvb6e006e00wkhp08fa0t","content":"<h2 id=\"Flex\"><a href=\"#Flex\" class=\"headerlink\" title=\"Flex\"></a>Flex</h2><p>Flex可以沿着水平或垂直方向排列子widget，如果你知道主轴方向，使用Row或Column会方便一些，因为Row和Column都继承自Flex，参数基本相同，所以能使用Flex的地方一定可以使用Row或Column。Flex本身功能是很强大的，它也可以和Expanded配合实现弹性布局，接下来我们只讨论Flex和弹性布局相关的属性(其它属性已经在介绍Row和Column时介绍过了)。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flex(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.direction, <span class=\"comment\">//弹性布局的方向, Row默认为水平方向，Column默认为垂直方向</span></span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Flex继承自MultiChildRenderObjectWidget，对应的RenderObject为RenderFlex，RenderFlex中实现了其布局算法。</p>\n<h2 id=\"Expanded\"><a href=\"#Expanded\" class=\"headerlink\" title=\"Expanded\"></a>Expanded</h2><p>可以按比例“扩伸”Row、Column和Flex子widget所占用的空间。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Expanded(&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> flex = <span class=\"number\">1</span>, </span><br><span class=\"line\">  <span class=\"meta\">@required</span> Widget child,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>flex为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Flex\"><a href=\"#Flex\" class=\"headerlink\" title=\"Flex\"></a>Flex</h2><p>Flex可以沿着水平或垂直方向排列子widget，如果你知道主轴方向，使用Row或Column会方便一些，因为Row和Column都继承自Flex，参数基本相同，所以能使用Flex的地方一定可以使用Row或Column。Flex本身功能是很强大的，它也可以和Expanded配合实现弹性布局，接下来我们只讨论Flex和弹性布局相关的属性(其它属性已经在介绍Row和Column时介绍过了)。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flex(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.direction, <span class=\"comment\">//弹性布局的方向, Row默认为水平方向，Column默认为垂直方向</span></span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Flex继承自MultiChildRenderObjectWidget，对应的RenderObject为RenderFlex，RenderFlex中实现了其布局算法。</p>\n<h2 id=\"Expanded\"><a href=\"#Expanded\" class=\"headerlink\" title=\"Expanded\"></a>Expanded</h2><p>可以按比例“扩伸”Row、Column和Flex子widget所占用的空间。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Expanded(&#123;</span><br><span class=\"line\">  <span class=\"built_in\">int</span> flex = <span class=\"number\">1</span>, </span><br><span class=\"line\">  <span class=\"meta\">@required</span> Widget child,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>flex为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间</p>\n"},{"title":"android发展史及系统架构","author":"JsonYe","copyright":true,"date":"2015-04-29T09:32:00.000Z","_content":"\n## 1.1 Android发展史与现状\n\nAndy Rubin创立22个月后→（2005年）Google收购。\n\n2008 Patrick Brady于Google I/O 演讲“Anatomy & Physiology of an Android”，并提出的 Android HAL 架构图。\n\n### Android版本升级  \nAndroid系统今后将继续每半年一次的升级步伐，分别定在每年的夏天和年终。每代Android系统都将以食物命名，比如1.5版叫做 Cupcake(纸杯蛋糕)，1.6版为Donut(甜甜圈)，然后是Eclair(法式奶油夹心甜点)和Flan(水果馅饼)。Donut将把社交网络功能作为升级重点，在“手机的各种体验中”都增加社交网络元素。  \n#### 1.5 (Cupcake)  \n基于Linux Kernel 2.6.27 2009年4月30日，官方1.5版本(Cupcake)的Android发布。主要的更新如下:  \n● 拍摄/回放视频，并支持上传到youtube  \n● 支持立体声蓝牙耳机，同时改善自动配对性能  \n● 最新的采用WebKit技术的浏览器，支持拷贝/粘帖和页面中搜索  \n● GPS性能大大提高  \n● 屏幕虚拟键盘  \n● 主屏幕增加音乐播放器和相框widgets  \n● 应用程序自动随着手机旋转  \n● 短信，Gmail，日历，浏览器的用户界面大幅改善，比如说Gmail现在可以批量删除邮件了  \n● 相机启动速度加快，拍摄图片可以直接上传到picasa  \n● 来电照片显示  \n#### 1.6 (Donut)  \n基于Linux Kernel 2.6.29 2009年9月15日, 1.6(Donut)版本SDK发布。主要的更新如下:  \n● 完全重新设计的Android Market  \n● 手势支持  \n● 支持CDMA网络  \n● 文字转语音系统(TXT-2-speech)  \n● 快速搜索框  \n● 全新的拍照界面  \n● 应用程序耗电查看  \n● 支持VPN  \n● 支持更多的屏幕分辨率  \n● 支持OpenCore2媒体引擎  \n● 新增面向视觉或听觉困难人群的易用性插件  \n#### 2.0/2.0.1/2.1(Eclair)  \n基于Linux Kernel 2.6.29 2009年10月26日, 2.0(Eclair)版本SDK发布。主要的更新如下:  \n● 优化硬件速度  \n● \"Car Home\"程序  \n● 支持更多的屏幕分辨率  \n● 重整界面  \n● 新的浏览器的用户界面和支持HTML5  \n● 新的联系人名单  \n● 更好的白色/黑色背景比率  \n● 改进Google Maps 3.1.2  \n● 支持Microsoft Exchange  \n● 支持内置相机闪光灯  \n● 数字变焦  \n● 改进的虚拟键盘  \n● 蓝牙2.1  \nAndroid的代号序列会按甜点名字中首个英文字母(C、D、E、F)的排列顺序。  \n下一个版本的Android将会命名为Froyo(冻酸奶,基于Linux Kernel 2.6.32)。Froyo 之后的版本的Android将会命名为Gingerbread(姜饼,基于Linux Kernel 2.6.33/34)。\n\n**Android****版本**\n\n**发布日期**\n\n**代号**\n\n**Android 1.1**\n\n**Android 1.5**\n\n2009年4月30日\n\nCupcake（纸杯蛋糕）\n\n**Android 1.6**\n\n2009年9月15日\n\nDonut（炸面圈）\n\n**Android 2.0/2.1**\n\n2009年10月26日\n\nEclair（长松饼）\n\n**Android 2.2**\n\n2010年5月20日\n\nFroyo（冻酸奶）\n\n**Android 2.3**\n\n2010年12月6日\n\nGingerbread（姜饼）\n\n**Android 3.0/3.1/3.2**\n\n2011年2月22日\n\nHoneycomb（蜂巢）\n\n**Android 4.0**\n\n2011年10月19日\n\nIce Cream Sandwich（冰淇淋三明治）\n\n**Android 4.1**\n\n2012年6月28日\n\nJelly Bean（果冻豆）\n\n**Android 4.2**\n\n2012年10月8日\n\nJelly Bean（果冻豆）\n\n**Android5.0**\n\n待定\n\nLime Pie（酸橙派）\n\n### 1.2 Android系统的架构与特性\n\n#### 1.2.1 Android系统架构\n\nAndroid系统的底层是建立在Linux系统之上的，它采用软件叠层（Software Stack）的方式进行构建。使得层与层之间相互分离，明确各层的分工。这种分工保证了层与层之间的低苟合，当下层发生改变的时候，上层应用程序无需做任何改变。\n\n下图为Android系统的系统架构图：\n\n![](http://s1.51cto.com/wyfs02/M01/25/73/wKioL1NgW-Si7ae7AAEJ_vZkaJ0908.jpg)\n\n如图可知，Android系统分为四个层，从高到底分别是：应用程序层（Application）、应用程序框架层（Application Framework）、系统运行库层（Libraries）和Linux内核层（Linux Kernel）。\n\nAndroid操作系统可以在四个主要层面上分为5个部分：\n\n##### 1\\. 应用程序层（Application）\n\nAndroid系统包含了一系列核心应用程序，包括电子邮件、短信SMS、日历、拨号器、地图、浏览器、联系人等。这些应用程序都是用Java语言编写。本书重点讲解如何编写Android系统上运行的应用程序，在程序分层上，与系统核心应用程序平级。\n\n##### 2\\. 应用程序框架层（Application Framework）\n\nAndroid应用程序框架提供了大量的API供开发人员使用，Android应用程序的开发，就是调用这些API，根据需求实现功能。\n\n应用程序框架是应用程序的基础。为了软件的复用，任何一个应用程序都可以开发Android系统的功能模块，只要发布的时候遵循应用程序框架的规范，其它应用程序也可以使用这个功能模块。\n\n##### 3\\. 系统运行库层（Libraries）**\n\nAndroid系统运行库是用C/C++语言编写的，是一套被不同组件所使用的函数库组成的集合。一般来说，Android应用开发者无法直接调用这套函数库，都是通过它上层的应用程序框架提供的API来对这些函数库进行调用。\n\n下面对一些核心库进行简单的介绍：\n\n> **Libc：**从BSD系统派生出来的标准C系统库，在此基础之上，为了便携式Linux系统专门进行了调整。\n> \n> **Medio Framework：**基于PacketView的OpenCORE，这套媒体库支持播放与录制硬盘及视频格式的文件，并能查看静态图片。\n> \n> **Surface Manager：**在执行多个应用程序的时，负责管理显示与存取操作间的互动，同时负责2D绘图与3D绘图进行显示合成。\n> \n> **WebKit：**Web浏览器引擎，该引擎为Android浏览器提供支持。\n> \n> **SGL：**底层的2D图像引擎。\n> \n> **3D libraries：**基于OpenGL ES 1.0API，提供使用软硬件实现3D加速的功能。\n> \n> **FreeType：**提供位图和向量字体的支持。\n> \n> **SQLite：**轻量级的关系型数据库。\n\n\n##### 4\\. Android运行时**\n\n    Android运行时由两部分完成：Android核心库和Dalvik虚拟机。其中核心库集提供了Java语言核心库所能使用的绝大部分功能，Dalvik虚拟机负责运行Android应用程序。\n\n    虽然Android应用程序通过Java语言编写，而每个Java程序都会在Java虚拟机JVM内运行，但是Android系统毕竟是运行在移动设备上的，由于硬件的限制， Android应用程序并不使用Java的虚拟机JVM来运行程序，而是使用自己独立的虚拟机Dalvik VM，它针对多个同时高效运行的虚拟机进行了优化。每个Android应用程序都运行在单独的一个Dalvik虚拟机内，因此Android系统可以方便对应用程序进行隔离。\n\n##### 5\\. Linux内核\n\nAndroid系统是基于Linux2.6之上建立的操作系统，它的Linux内核为Android系统提供了安全性、内存管理、进程管理、网络协议栈、驱动模型等核心系统服务。Linux内核帮助Android系统实现了底层硬件与上层软件之间的抽象。\n\n#### 1.2.2 Dalvik VM和JVM的区别\n\nJVM（Java虚拟机）是一个虚构出来的运行Java程序的运行时，是通过在实际的计算机上仿真模拟各种计算机功能的实现。它具有完善的硬件架构（如处理器、堆栈、寄存器等），还具有相应的指令系统，使用JVM就是使Java程序支持与操作系统无关。理论上在任何操作系统中，只要有对应的JVM，即可运行Java程序。\n\nDalvik VM是在Android系统上运行Android程序的虚拟机，其指令集是基于寄存器架构的，执行特有的文件格式-dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。\n\n由于Android应用程序的开发编程语言是Java，而Java程序运行在JVM（Java虚拟机）上的，因此有些人会把Android的虚拟机DalvikVM和JVM弄混淆，但是实际上Dalvik并未遵守JVM规范，而且两者也是互不兼容。\n\n从Dalvik VM和JVM的编译过程分析，它们的编译过程如下：\n\n```\nJVM：.java→.class→.jar\nDalvik VM：.java→.class→.dex\n```\n\n从它们的编译过程可以看出，JVM运行的是.class文件的Java字节码，但是Dalvik VM运行的是其转换后的dex（Dalvik Executable）文件。JVM字节从.class文件或者JAR包中加载字节码然后运行，而Dalvik VM无法直接从.class文件或JAR包中加载字节码，它需要通过DX工具将应用程序所有的.class文件编译成一个.dex文件，Dalvik VM则运行这个.dex文件。\n\n下图显示了Dalvik VM与JVM编译过程的区别：\n\n![](http://s4.51cto.com/wyfs02/M01/25/73/wKiom1NgXMOTVyNiAAB-h8_94xE986.jpg)\n\n从图中可以看出，Dalvik VM把.java文件编译成.class后，会对.class进行重构，整合的基本元素（常量池、类定义、数据段）,最后压缩写进一个.dex文件中。其中，常量池描述了所有的常量，包括引用、方法名、数值常量等；类定义包括访问标识、类名等基本信息；数据段中包含各种被VM指定的方法代码以及类和方法的相关信息和实例变量。这种把多个.class文件进行整合的方法，大大提高了Android程序的运行速度，例如：应用程序中多个类定义了字符串常量TAG，而在JVM中，会编译成多个.class文件，每个.class文件的常量池中，均包含这个TAG常量，但是Dalvik VM在编译成.dex文件之后，其常量池里只有一个TAG常量。\n\nJVM和Dalvik VM还有一点非常重要的不同，就是基于的架构不同。JVM是基于栈的架构，而Dalvik VM是基于寄存器的架构。相对于基于栈的JVM而言，基于寄存器的Dalvik VM实现虽然牺牲了一些硬件上的通用性，但是它在代码的执行效率上要更胜一筹。一般来讲，VM中指令的解释执行的时间主要花费在以下三个方面：\n\n> 分发指令；\n> \n> 访问运算数；\n> \n> 执行运算；\n\n\n其中分发指令这个环节对性能的影响最大。在基于寄存器的Dalvik VM中，可以更有效的减少冗余指令的分发，减少内存的读写访问。\n\n从JVM和Dalvik VM的区别上来说，Dalvik VM主要是针对Android这个嵌入式操作系统的特点进行了各种优化，使其更省电、更省内存、运行效率更高，但是牺牲了一些JVM的与平台无关的特性。实际上，Dalvik VM本就是为Android设计的，无需考虑其它平台的问题。这里只是介绍了JVM和Dalvik VM的两个重要的区别，毕竟本书并不是讲解Android内核的，这里只是点明Dalvik VM的特点，读者对这部分的内容了解即可。\n\n### 1.2.3 Android系统平台的优势\n\nAndroid系统相对于其它操作系统，有如下几点优势：\n\n#### 1. 开放性\n\n首先就是Android系统的开放性，其开发平台允许任何移动终端厂商加入到Android联盟中来，降低了开发门槛，使其拥有更多的开发者，随着用户和应用的日益丰富，也将推进Android系统的成熟。同时，开放性有利于Android设备的普及以及市场竞争力，这样有利于消费者买到更低价位的Android设备。\n\n#### 2. 丰富的硬件选择\n\n同样由于Android系统的开放性，众多硬件厂商可以推出各种的搭载Android系统的设备。现如今，Android系统不仅仅只是运行在手机上，越来越多的设备开始支持Android系统，如电视、可佩戴设备、数码相机等。\n\n#### 3. 便于开发\n\nGoogle开放了Android的系统源码，提供了开发者一个自由的开发环境，不必受到各种条条框框的束缚。\n\n#### 4. Google服务的支持\n\nGoogle公司作为一个做服务的公司，它提供了如地图、邮件、搜索等服务，Android系统可以对这些服务进行无缝的结合。","source":"_posts/android/base/android发展史及系统架构.md","raw":"title: android发展史及系统架构\nauthor: JsonYe\ntags:\n  - Android\ncategories:\n  - Android基础\ncopyright: true\ndate: 2015-04-29 17:32:00\n---\n\n## 1.1 Android发展史与现状\n\nAndy Rubin创立22个月后→（2005年）Google收购。\n\n2008 Patrick Brady于Google I/O 演讲“Anatomy & Physiology of an Android”，并提出的 Android HAL 架构图。\n\n### Android版本升级  \nAndroid系统今后将继续每半年一次的升级步伐，分别定在每年的夏天和年终。每代Android系统都将以食物命名，比如1.5版叫做 Cupcake(纸杯蛋糕)，1.6版为Donut(甜甜圈)，然后是Eclair(法式奶油夹心甜点)和Flan(水果馅饼)。Donut将把社交网络功能作为升级重点，在“手机的各种体验中”都增加社交网络元素。  \n#### 1.5 (Cupcake)  \n基于Linux Kernel 2.6.27 2009年4月30日，官方1.5版本(Cupcake)的Android发布。主要的更新如下:  \n● 拍摄/回放视频，并支持上传到youtube  \n● 支持立体声蓝牙耳机，同时改善自动配对性能  \n● 最新的采用WebKit技术的浏览器，支持拷贝/粘帖和页面中搜索  \n● GPS性能大大提高  \n● 屏幕虚拟键盘  \n● 主屏幕增加音乐播放器和相框widgets  \n● 应用程序自动随着手机旋转  \n● 短信，Gmail，日历，浏览器的用户界面大幅改善，比如说Gmail现在可以批量删除邮件了  \n● 相机启动速度加快，拍摄图片可以直接上传到picasa  \n● 来电照片显示  \n#### 1.6 (Donut)  \n基于Linux Kernel 2.6.29 2009年9月15日, 1.6(Donut)版本SDK发布。主要的更新如下:  \n● 完全重新设计的Android Market  \n● 手势支持  \n● 支持CDMA网络  \n● 文字转语音系统(TXT-2-speech)  \n● 快速搜索框  \n● 全新的拍照界面  \n● 应用程序耗电查看  \n● 支持VPN  \n● 支持更多的屏幕分辨率  \n● 支持OpenCore2媒体引擎  \n● 新增面向视觉或听觉困难人群的易用性插件  \n#### 2.0/2.0.1/2.1(Eclair)  \n基于Linux Kernel 2.6.29 2009年10月26日, 2.0(Eclair)版本SDK发布。主要的更新如下:  \n● 优化硬件速度  \n● \"Car Home\"程序  \n● 支持更多的屏幕分辨率  \n● 重整界面  \n● 新的浏览器的用户界面和支持HTML5  \n● 新的联系人名单  \n● 更好的白色/黑色背景比率  \n● 改进Google Maps 3.1.2  \n● 支持Microsoft Exchange  \n● 支持内置相机闪光灯  \n● 数字变焦  \n● 改进的虚拟键盘  \n● 蓝牙2.1  \nAndroid的代号序列会按甜点名字中首个英文字母(C、D、E、F)的排列顺序。  \n下一个版本的Android将会命名为Froyo(冻酸奶,基于Linux Kernel 2.6.32)。Froyo 之后的版本的Android将会命名为Gingerbread(姜饼,基于Linux Kernel 2.6.33/34)。\n\n**Android****版本**\n\n**发布日期**\n\n**代号**\n\n**Android 1.1**\n\n**Android 1.5**\n\n2009年4月30日\n\nCupcake（纸杯蛋糕）\n\n**Android 1.6**\n\n2009年9月15日\n\nDonut（炸面圈）\n\n**Android 2.0/2.1**\n\n2009年10月26日\n\nEclair（长松饼）\n\n**Android 2.2**\n\n2010年5月20日\n\nFroyo（冻酸奶）\n\n**Android 2.3**\n\n2010年12月6日\n\nGingerbread（姜饼）\n\n**Android 3.0/3.1/3.2**\n\n2011年2月22日\n\nHoneycomb（蜂巢）\n\n**Android 4.0**\n\n2011年10月19日\n\nIce Cream Sandwich（冰淇淋三明治）\n\n**Android 4.1**\n\n2012年6月28日\n\nJelly Bean（果冻豆）\n\n**Android 4.2**\n\n2012年10月8日\n\nJelly Bean（果冻豆）\n\n**Android5.0**\n\n待定\n\nLime Pie（酸橙派）\n\n### 1.2 Android系统的架构与特性\n\n#### 1.2.1 Android系统架构\n\nAndroid系统的底层是建立在Linux系统之上的，它采用软件叠层（Software Stack）的方式进行构建。使得层与层之间相互分离，明确各层的分工。这种分工保证了层与层之间的低苟合，当下层发生改变的时候，上层应用程序无需做任何改变。\n\n下图为Android系统的系统架构图：\n\n![](http://s1.51cto.com/wyfs02/M01/25/73/wKioL1NgW-Si7ae7AAEJ_vZkaJ0908.jpg)\n\n如图可知，Android系统分为四个层，从高到底分别是：应用程序层（Application）、应用程序框架层（Application Framework）、系统运行库层（Libraries）和Linux内核层（Linux Kernel）。\n\nAndroid操作系统可以在四个主要层面上分为5个部分：\n\n##### 1\\. 应用程序层（Application）\n\nAndroid系统包含了一系列核心应用程序，包括电子邮件、短信SMS、日历、拨号器、地图、浏览器、联系人等。这些应用程序都是用Java语言编写。本书重点讲解如何编写Android系统上运行的应用程序，在程序分层上，与系统核心应用程序平级。\n\n##### 2\\. 应用程序框架层（Application Framework）\n\nAndroid应用程序框架提供了大量的API供开发人员使用，Android应用程序的开发，就是调用这些API，根据需求实现功能。\n\n应用程序框架是应用程序的基础。为了软件的复用，任何一个应用程序都可以开发Android系统的功能模块，只要发布的时候遵循应用程序框架的规范，其它应用程序也可以使用这个功能模块。\n\n##### 3\\. 系统运行库层（Libraries）**\n\nAndroid系统运行库是用C/C++语言编写的，是一套被不同组件所使用的函数库组成的集合。一般来说，Android应用开发者无法直接调用这套函数库，都是通过它上层的应用程序框架提供的API来对这些函数库进行调用。\n\n下面对一些核心库进行简单的介绍：\n\n> **Libc：**从BSD系统派生出来的标准C系统库，在此基础之上，为了便携式Linux系统专门进行了调整。\n> \n> **Medio Framework：**基于PacketView的OpenCORE，这套媒体库支持播放与录制硬盘及视频格式的文件，并能查看静态图片。\n> \n> **Surface Manager：**在执行多个应用程序的时，负责管理显示与存取操作间的互动，同时负责2D绘图与3D绘图进行显示合成。\n> \n> **WebKit：**Web浏览器引擎，该引擎为Android浏览器提供支持。\n> \n> **SGL：**底层的2D图像引擎。\n> \n> **3D libraries：**基于OpenGL ES 1.0API，提供使用软硬件实现3D加速的功能。\n> \n> **FreeType：**提供位图和向量字体的支持。\n> \n> **SQLite：**轻量级的关系型数据库。\n\n\n##### 4\\. Android运行时**\n\n    Android运行时由两部分完成：Android核心库和Dalvik虚拟机。其中核心库集提供了Java语言核心库所能使用的绝大部分功能，Dalvik虚拟机负责运行Android应用程序。\n\n    虽然Android应用程序通过Java语言编写，而每个Java程序都会在Java虚拟机JVM内运行，但是Android系统毕竟是运行在移动设备上的，由于硬件的限制， Android应用程序并不使用Java的虚拟机JVM来运行程序，而是使用自己独立的虚拟机Dalvik VM，它针对多个同时高效运行的虚拟机进行了优化。每个Android应用程序都运行在单独的一个Dalvik虚拟机内，因此Android系统可以方便对应用程序进行隔离。\n\n##### 5\\. Linux内核\n\nAndroid系统是基于Linux2.6之上建立的操作系统，它的Linux内核为Android系统提供了安全性、内存管理、进程管理、网络协议栈、驱动模型等核心系统服务。Linux内核帮助Android系统实现了底层硬件与上层软件之间的抽象。\n\n#### 1.2.2 Dalvik VM和JVM的区别\n\nJVM（Java虚拟机）是一个虚构出来的运行Java程序的运行时，是通过在实际的计算机上仿真模拟各种计算机功能的实现。它具有完善的硬件架构（如处理器、堆栈、寄存器等），还具有相应的指令系统，使用JVM就是使Java程序支持与操作系统无关。理论上在任何操作系统中，只要有对应的JVM，即可运行Java程序。\n\nDalvik VM是在Android系统上运行Android程序的虚拟机，其指令集是基于寄存器架构的，执行特有的文件格式-dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。\n\n由于Android应用程序的开发编程语言是Java，而Java程序运行在JVM（Java虚拟机）上的，因此有些人会把Android的虚拟机DalvikVM和JVM弄混淆，但是实际上Dalvik并未遵守JVM规范，而且两者也是互不兼容。\n\n从Dalvik VM和JVM的编译过程分析，它们的编译过程如下：\n\n```\nJVM：.java→.class→.jar\nDalvik VM：.java→.class→.dex\n```\n\n从它们的编译过程可以看出，JVM运行的是.class文件的Java字节码，但是Dalvik VM运行的是其转换后的dex（Dalvik Executable）文件。JVM字节从.class文件或者JAR包中加载字节码然后运行，而Dalvik VM无法直接从.class文件或JAR包中加载字节码，它需要通过DX工具将应用程序所有的.class文件编译成一个.dex文件，Dalvik VM则运行这个.dex文件。\n\n下图显示了Dalvik VM与JVM编译过程的区别：\n\n![](http://s4.51cto.com/wyfs02/M01/25/73/wKiom1NgXMOTVyNiAAB-h8_94xE986.jpg)\n\n从图中可以看出，Dalvik VM把.java文件编译成.class后，会对.class进行重构，整合的基本元素（常量池、类定义、数据段）,最后压缩写进一个.dex文件中。其中，常量池描述了所有的常量，包括引用、方法名、数值常量等；类定义包括访问标识、类名等基本信息；数据段中包含各种被VM指定的方法代码以及类和方法的相关信息和实例变量。这种把多个.class文件进行整合的方法，大大提高了Android程序的运行速度，例如：应用程序中多个类定义了字符串常量TAG，而在JVM中，会编译成多个.class文件，每个.class文件的常量池中，均包含这个TAG常量，但是Dalvik VM在编译成.dex文件之后，其常量池里只有一个TAG常量。\n\nJVM和Dalvik VM还有一点非常重要的不同，就是基于的架构不同。JVM是基于栈的架构，而Dalvik VM是基于寄存器的架构。相对于基于栈的JVM而言，基于寄存器的Dalvik VM实现虽然牺牲了一些硬件上的通用性，但是它在代码的执行效率上要更胜一筹。一般来讲，VM中指令的解释执行的时间主要花费在以下三个方面：\n\n> 分发指令；\n> \n> 访问运算数；\n> \n> 执行运算；\n\n\n其中分发指令这个环节对性能的影响最大。在基于寄存器的Dalvik VM中，可以更有效的减少冗余指令的分发，减少内存的读写访问。\n\n从JVM和Dalvik VM的区别上来说，Dalvik VM主要是针对Android这个嵌入式操作系统的特点进行了各种优化，使其更省电、更省内存、运行效率更高，但是牺牲了一些JVM的与平台无关的特性。实际上，Dalvik VM本就是为Android设计的，无需考虑其它平台的问题。这里只是介绍了JVM和Dalvik VM的两个重要的区别，毕竟本书并不是讲解Android内核的，这里只是点明Dalvik VM的特点，读者对这部分的内容了解即可。\n\n### 1.2.3 Android系统平台的优势\n\nAndroid系统相对于其它操作系统，有如下几点优势：\n\n#### 1. 开放性\n\n首先就是Android系统的开放性，其开发平台允许任何移动终端厂商加入到Android联盟中来，降低了开发门槛，使其拥有更多的开发者，随着用户和应用的日益丰富，也将推进Android系统的成熟。同时，开放性有利于Android设备的普及以及市场竞争力，这样有利于消费者买到更低价位的Android设备。\n\n#### 2. 丰富的硬件选择\n\n同样由于Android系统的开放性，众多硬件厂商可以推出各种的搭载Android系统的设备。现如今，Android系统不仅仅只是运行在手机上，越来越多的设备开始支持Android系统，如电视、可佩戴设备、数码相机等。\n\n#### 3. 便于开发\n\nGoogle开放了Android的系统源码，提供了开发者一个自由的开发环境，不必受到各种条条框框的束缚。\n\n#### 4. Google服务的支持\n\nGoogle公司作为一个做服务的公司，它提供了如地图、邮件、搜索等服务，Android系统可以对这些服务进行无缝的结合。","slug":"android/base/android发展史及系统架构","published":1,"updated":"2019-10-02T08:40:59.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck19bvb6i006h00wka88au6nu","content":"<h2 id=\"1-1-Android发展史与现状\"><a href=\"#1-1-Android发展史与现状\" class=\"headerlink\" title=\"1.1 Android发展史与现状\"></a>1.1 Android发展史与现状</h2><p>Andy Rubin创立22个月后→（2005年）Google收购。</p>\n<p>2008 Patrick Brady于Google I/O 演讲“Anatomy &amp; Physiology of an Android”，并提出的 Android HAL 架构图。</p>\n<h3 id=\"Android版本升级\"><a href=\"#Android版本升级\" class=\"headerlink\" title=\"Android版本升级\"></a>Android版本升级</h3><p>Android系统今后将继续每半年一次的升级步伐，分别定在每年的夏天和年终。每代Android系统都将以食物命名，比如1.5版叫做 Cupcake(纸杯蛋糕)，1.6版为Donut(甜甜圈)，然后是Eclair(法式奶油夹心甜点)和Flan(水果馅饼)。Donut将把社交网络功能作为升级重点，在“手机的各种体验中”都增加社交网络元素。  </p>\n<h4 id=\"1-5-Cupcake\"><a href=\"#1-5-Cupcake\" class=\"headerlink\" title=\"1.5 (Cupcake)\"></a>1.5 (Cupcake)</h4><p>基于Linux Kernel 2.6.27 2009年4月30日，官方1.5版本(Cupcake)的Android发布。主要的更新如下:<br>● 拍摄/回放视频，并支持上传到youtube<br>● 支持立体声蓝牙耳机，同时改善自动配对性能<br>● 最新的采用WebKit技术的浏览器，支持拷贝/粘帖和页面中搜索<br>● GPS性能大大提高<br>● 屏幕虚拟键盘<br>● 主屏幕增加音乐播放器和相框widgets<br>● 应用程序自动随着手机旋转<br>● 短信，Gmail，日历，浏览器的用户界面大幅改善，比如说Gmail现在可以批量删除邮件了<br>● 相机启动速度加快，拍摄图片可以直接上传到picasa<br>● 来电照片显示  </p>\n<h4 id=\"1-6-Donut\"><a href=\"#1-6-Donut\" class=\"headerlink\" title=\"1.6 (Donut)\"></a>1.6 (Donut)</h4><p>基于Linux Kernel 2.6.29 2009年9月15日, 1.6(Donut)版本SDK发布。主要的更新如下:<br>● 完全重新设计的Android Market<br>● 手势支持<br>● 支持CDMA网络<br>● 文字转语音系统(TXT-2-speech)<br>● 快速搜索框<br>● 全新的拍照界面<br>● 应用程序耗电查看<br>● 支持VPN<br>● 支持更多的屏幕分辨率<br>● 支持OpenCore2媒体引擎<br>● 新增面向视觉或听觉困难人群的易用性插件  </p>\n<h4 id=\"2-0-2-0-1-2-1-Eclair\"><a href=\"#2-0-2-0-1-2-1-Eclair\" class=\"headerlink\" title=\"2.0/2.0.1/2.1(Eclair)\"></a>2.0/2.0.1/2.1(Eclair)</h4><p>基于Linux Kernel 2.6.29 2009年10月26日, 2.0(Eclair)版本SDK发布。主要的更新如下:<br>● 优化硬件速度<br>● “Car Home”程序<br>● 支持更多的屏幕分辨率<br>● 重整界面<br>● 新的浏览器的用户界面和支持HTML5<br>● 新的联系人名单<br>● 更好的白色/黑色背景比率<br>● 改进Google Maps 3.1.2<br>● 支持Microsoft Exchange<br>● 支持内置相机闪光灯<br>● 数字变焦<br>● 改进的虚拟键盘<br>● 蓝牙2.1<br>Android的代号序列会按甜点名字中首个英文字母(C、D、E、F)的排列顺序。<br>下一个版本的Android将会命名为Froyo(冻酸奶,基于Linux Kernel 2.6.32)。Froyo 之后的版本的Android将会命名为Gingerbread(姜饼,基于Linux Kernel 2.6.33/34)。</p>\n<p><strong>Android**</strong>版本**</p>\n<p><strong>发布日期</strong></p>\n<p><strong>代号</strong></p>\n<p><strong>Android 1.1</strong></p>\n<p><strong>Android 1.5</strong></p>\n<p>2009年4月30日</p>\n<p>Cupcake（纸杯蛋糕）</p>\n<p><strong>Android 1.6</strong></p>\n<p>2009年9月15日</p>\n<p>Donut（炸面圈）</p>\n<p><strong>Android 2.0/2.1</strong></p>\n<p>2009年10月26日</p>\n<p>Eclair（长松饼）</p>\n<p><strong>Android 2.2</strong></p>\n<p>2010年5月20日</p>\n<p>Froyo（冻酸奶）</p>\n<p><strong>Android 2.3</strong></p>\n<p>2010年12月6日</p>\n<p>Gingerbread（姜饼）</p>\n<p><strong>Android 3.0/3.1/3.2</strong></p>\n<p>2011年2月22日</p>\n<p>Honeycomb（蜂巢）</p>\n<p><strong>Android 4.0</strong></p>\n<p>2011年10月19日</p>\n<p>Ice Cream Sandwich（冰淇淋三明治）</p>\n<p><strong>Android 4.1</strong></p>\n<p>2012年6月28日</p>\n<p>Jelly Bean（果冻豆）</p>\n<p><strong>Android 4.2</strong></p>\n<p>2012年10月8日</p>\n<p>Jelly Bean（果冻豆）</p>\n<p><strong>Android5.0</strong></p>\n<p>待定</p>\n<p>Lime Pie（酸橙派）</p>\n<h3 id=\"1-2-Android系统的架构与特性\"><a href=\"#1-2-Android系统的架构与特性\" class=\"headerlink\" title=\"1.2 Android系统的架构与特性\"></a>1.2 Android系统的架构与特性</h3><h4 id=\"1-2-1-Android系统架构\"><a href=\"#1-2-1-Android系统架构\" class=\"headerlink\" title=\"1.2.1 Android系统架构\"></a>1.2.1 Android系统架构</h4><p>Android系统的底层是建立在Linux系统之上的，它采用软件叠层（Software Stack）的方式进行构建。使得层与层之间相互分离，明确各层的分工。这种分工保证了层与层之间的低苟合，当下层发生改变的时候，上层应用程序无需做任何改变。</p>\n<p>下图为Android系统的系统架构图：</p>\n<p><img src=\"http://s1.51cto.com/wyfs02/M01/25/73/wKioL1NgW-Si7ae7AAEJ_vZkaJ0908.jpg\" alt></p>\n<p>如图可知，Android系统分为四个层，从高到底分别是：应用程序层（Application）、应用程序框架层（Application Framework）、系统运行库层（Libraries）和Linux内核层（Linux Kernel）。</p>\n<p>Android操作系统可以在四个主要层面上分为5个部分：</p>\n<h5 id=\"1-应用程序层（Application）\"><a href=\"#1-应用程序层（Application）\" class=\"headerlink\" title=\"1. 应用程序层（Application）\"></a>1. 应用程序层（Application）</h5><p>Android系统包含了一系列核心应用程序，包括电子邮件、短信SMS、日历、拨号器、地图、浏览器、联系人等。这些应用程序都是用Java语言编写。本书重点讲解如何编写Android系统上运行的应用程序，在程序分层上，与系统核心应用程序平级。</p>\n<h5 id=\"2-应用程序框架层（Application-Framework）\"><a href=\"#2-应用程序框架层（Application-Framework）\" class=\"headerlink\" title=\"2. 应用程序框架层（Application Framework）\"></a>2. 应用程序框架层（Application Framework）</h5><p>Android应用程序框架提供了大量的API供开发人员使用，Android应用程序的开发，就是调用这些API，根据需求实现功能。</p>\n<p>应用程序框架是应用程序的基础。为了软件的复用，任何一个应用程序都可以开发Android系统的功能模块，只要发布的时候遵循应用程序框架的规范，其它应用程序也可以使用这个功能模块。</p>\n<h5 id=\"3-系统运行库层（Libraries）\"><a href=\"#3-系统运行库层（Libraries）\" class=\"headerlink\" title=\"3. 系统运行库层（Libraries）**\"></a>3. 系统运行库层（Libraries）**</h5><p>Android系统运行库是用C/C++语言编写的，是一套被不同组件所使用的函数库组成的集合。一般来说，Android应用开发者无法直接调用这套函数库，都是通过它上层的应用程序框架提供的API来对这些函数库进行调用。</p>\n<p>下面对一些核心库进行简单的介绍：</p>\n<blockquote>\n<p><strong>Libc：</strong>从BSD系统派生出来的标准C系统库，在此基础之上，为了便携式Linux系统专门进行了调整。</p>\n<p><strong>Medio Framework：</strong>基于PacketView的OpenCORE，这套媒体库支持播放与录制硬盘及视频格式的文件，并能查看静态图片。</p>\n<p><strong>Surface Manager：</strong>在执行多个应用程序的时，负责管理显示与存取操作间的互动，同时负责2D绘图与3D绘图进行显示合成。</p>\n<p><strong>WebKit：</strong>Web浏览器引擎，该引擎为Android浏览器提供支持。</p>\n<p><strong>SGL：</strong>底层的2D图像引擎。</p>\n<p><strong>3D libraries：</strong>基于OpenGL ES 1.0API，提供使用软硬件实现3D加速的功能。</p>\n<p><strong>FreeType：</strong>提供位图和向量字体的支持。</p>\n<p><strong>SQLite：</strong>轻量级的关系型数据库。</p>\n</blockquote>\n<h5 id=\"4-Android运行时\"><a href=\"#4-Android运行时\" class=\"headerlink\" title=\"4. Android运行时**\"></a>4. Android运行时**</h5><pre><code>Android运行时由两部分完成：Android核心库和Dalvik虚拟机。其中核心库集提供了Java语言核心库所能使用的绝大部分功能，Dalvik虚拟机负责运行Android应用程序。\n\n虽然Android应用程序通过Java语言编写，而每个Java程序都会在Java虚拟机JVM内运行，但是Android系统毕竟是运行在移动设备上的，由于硬件的限制， Android应用程序并不使用Java的虚拟机JVM来运行程序，而是使用自己独立的虚拟机Dalvik VM，它针对多个同时高效运行的虚拟机进行了优化。每个Android应用程序都运行在单独的一个Dalvik虚拟机内，因此Android系统可以方便对应用程序进行隔离。</code></pre><h5 id=\"5-Linux内核\"><a href=\"#5-Linux内核\" class=\"headerlink\" title=\"5. Linux内核\"></a>5. Linux内核</h5><p>Android系统是基于Linux2.6之上建立的操作系统，它的Linux内核为Android系统提供了安全性、内存管理、进程管理、网络协议栈、驱动模型等核心系统服务。Linux内核帮助Android系统实现了底层硬件与上层软件之间的抽象。</p>\n<h4 id=\"1-2-2-Dalvik-VM和JVM的区别\"><a href=\"#1-2-2-Dalvik-VM和JVM的区别\" class=\"headerlink\" title=\"1.2.2 Dalvik VM和JVM的区别\"></a>1.2.2 Dalvik VM和JVM的区别</h4><p>JVM（Java虚拟机）是一个虚构出来的运行Java程序的运行时，是通过在实际的计算机上仿真模拟各种计算机功能的实现。它具有完善的硬件架构（如处理器、堆栈、寄存器等），还具有相应的指令系统，使用JVM就是使Java程序支持与操作系统无关。理论上在任何操作系统中，只要有对应的JVM，即可运行Java程序。</p>\n<p>Dalvik VM是在Android系统上运行Android程序的虚拟机，其指令集是基于寄存器架构的，执行特有的文件格式-dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。</p>\n<p>由于Android应用程序的开发编程语言是Java，而Java程序运行在JVM（Java虚拟机）上的，因此有些人会把Android的虚拟机DalvikVM和JVM弄混淆，但是实际上Dalvik并未遵守JVM规范，而且两者也是互不兼容。</p>\n<p>从Dalvik VM和JVM的编译过程分析，它们的编译过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JVM：.java→.class→.jar</span><br><span class=\"line\">Dalvik VM：.java→.class→.dex</span><br></pre></td></tr></table></figure>\n\n<p>从它们的编译过程可以看出，JVM运行的是.class文件的Java字节码，但是Dalvik VM运行的是其转换后的dex（Dalvik Executable）文件。JVM字节从.class文件或者JAR包中加载字节码然后运行，而Dalvik VM无法直接从.class文件或JAR包中加载字节码，它需要通过DX工具将应用程序所有的.class文件编译成一个.dex文件，Dalvik VM则运行这个.dex文件。</p>\n<p>下图显示了Dalvik VM与JVM编译过程的区别：</p>\n<p><img src=\"http://s4.51cto.com/wyfs02/M01/25/73/wKiom1NgXMOTVyNiAAB-h8_94xE986.jpg\" alt></p>\n<p>从图中可以看出，Dalvik VM把.java文件编译成.class后，会对.class进行重构，整合的基本元素（常量池、类定义、数据段）,最后压缩写进一个.dex文件中。其中，常量池描述了所有的常量，包括引用、方法名、数值常量等；类定义包括访问标识、类名等基本信息；数据段中包含各种被VM指定的方法代码以及类和方法的相关信息和实例变量。这种把多个.class文件进行整合的方法，大大提高了Android程序的运行速度，例如：应用程序中多个类定义了字符串常量TAG，而在JVM中，会编译成多个.class文件，每个.class文件的常量池中，均包含这个TAG常量，但是Dalvik VM在编译成.dex文件之后，其常量池里只有一个TAG常量。</p>\n<p>JVM和Dalvik VM还有一点非常重要的不同，就是基于的架构不同。JVM是基于栈的架构，而Dalvik VM是基于寄存器的架构。相对于基于栈的JVM而言，基于寄存器的Dalvik VM实现虽然牺牲了一些硬件上的通用性，但是它在代码的执行效率上要更胜一筹。一般来讲，VM中指令的解释执行的时间主要花费在以下三个方面：</p>\n<blockquote>\n<p>分发指令；</p>\n<p>访问运算数；</p>\n<p>执行运算；</p>\n</blockquote>\n<p>其中分发指令这个环节对性能的影响最大。在基于寄存器的Dalvik VM中，可以更有效的减少冗余指令的分发，减少内存的读写访问。</p>\n<p>从JVM和Dalvik VM的区别上来说，Dalvik VM主要是针对Android这个嵌入式操作系统的特点进行了各种优化，使其更省电、更省内存、运行效率更高，但是牺牲了一些JVM的与平台无关的特性。实际上，Dalvik VM本就是为Android设计的，无需考虑其它平台的问题。这里只是介绍了JVM和Dalvik VM的两个重要的区别，毕竟本书并不是讲解Android内核的，这里只是点明Dalvik VM的特点，读者对这部分的内容了解即可。</p>\n<h3 id=\"1-2-3-Android系统平台的优势\"><a href=\"#1-2-3-Android系统平台的优势\" class=\"headerlink\" title=\"1.2.3 Android系统平台的优势\"></a>1.2.3 Android系统平台的优势</h3><p>Android系统相对于其它操作系统，有如下几点优势：</p>\n<h4 id=\"1-开放性\"><a href=\"#1-开放性\" class=\"headerlink\" title=\"1. 开放性\"></a>1. 开放性</h4><p>首先就是Android系统的开放性，其开发平台允许任何移动终端厂商加入到Android联盟中来，降低了开发门槛，使其拥有更多的开发者，随着用户和应用的日益丰富，也将推进Android系统的成熟。同时，开放性有利于Android设备的普及以及市场竞争力，这样有利于消费者买到更低价位的Android设备。</p>\n<h4 id=\"2-丰富的硬件选择\"><a href=\"#2-丰富的硬件选择\" class=\"headerlink\" title=\"2. 丰富的硬件选择\"></a>2. 丰富的硬件选择</h4><p>同样由于Android系统的开放性，众多硬件厂商可以推出各种的搭载Android系统的设备。现如今，Android系统不仅仅只是运行在手机上，越来越多的设备开始支持Android系统，如电视、可佩戴设备、数码相机等。</p>\n<h4 id=\"3-便于开发\"><a href=\"#3-便于开发\" class=\"headerlink\" title=\"3. 便于开发\"></a>3. 便于开发</h4><p>Google开放了Android的系统源码，提供了开发者一个自由的开发环境，不必受到各种条条框框的束缚。</p>\n<h4 id=\"4-Google服务的支持\"><a href=\"#4-Google服务的支持\" class=\"headerlink\" title=\"4. Google服务的支持\"></a>4. Google服务的支持</h4><p>Google公司作为一个做服务的公司，它提供了如地图、邮件、搜索等服务，Android系统可以对这些服务进行无缝的结合。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-1-Android发展史与现状\"><a href=\"#1-1-Android发展史与现状\" class=\"headerlink\" title=\"1.1 Android发展史与现状\"></a>1.1 Android发展史与现状</h2><p>Andy Rubin创立22个月后→（2005年）Google收购。</p>\n<p>2008 Patrick Brady于Google I/O 演讲“Anatomy &amp; Physiology of an Android”，并提出的 Android HAL 架构图。</p>\n<h3 id=\"Android版本升级\"><a href=\"#Android版本升级\" class=\"headerlink\" title=\"Android版本升级\"></a>Android版本升级</h3><p>Android系统今后将继续每半年一次的升级步伐，分别定在每年的夏天和年终。每代Android系统都将以食物命名，比如1.5版叫做 Cupcake(纸杯蛋糕)，1.6版为Donut(甜甜圈)，然后是Eclair(法式奶油夹心甜点)和Flan(水果馅饼)。Donut将把社交网络功能作为升级重点，在“手机的各种体验中”都增加社交网络元素。  </p>\n<h4 id=\"1-5-Cupcake\"><a href=\"#1-5-Cupcake\" class=\"headerlink\" title=\"1.5 (Cupcake)\"></a>1.5 (Cupcake)</h4><p>基于Linux Kernel 2.6.27 2009年4月30日，官方1.5版本(Cupcake)的Android发布。主要的更新如下:<br>● 拍摄/回放视频，并支持上传到youtube<br>● 支持立体声蓝牙耳机，同时改善自动配对性能<br>● 最新的采用WebKit技术的浏览器，支持拷贝/粘帖和页面中搜索<br>● GPS性能大大提高<br>● 屏幕虚拟键盘<br>● 主屏幕增加音乐播放器和相框widgets<br>● 应用程序自动随着手机旋转<br>● 短信，Gmail，日历，浏览器的用户界面大幅改善，比如说Gmail现在可以批量删除邮件了<br>● 相机启动速度加快，拍摄图片可以直接上传到picasa<br>● 来电照片显示  </p>\n<h4 id=\"1-6-Donut\"><a href=\"#1-6-Donut\" class=\"headerlink\" title=\"1.6 (Donut)\"></a>1.6 (Donut)</h4><p>基于Linux Kernel 2.6.29 2009年9月15日, 1.6(Donut)版本SDK发布。主要的更新如下:<br>● 完全重新设计的Android Market<br>● 手势支持<br>● 支持CDMA网络<br>● 文字转语音系统(TXT-2-speech)<br>● 快速搜索框<br>● 全新的拍照界面<br>● 应用程序耗电查看<br>● 支持VPN<br>● 支持更多的屏幕分辨率<br>● 支持OpenCore2媒体引擎<br>● 新增面向视觉或听觉困难人群的易用性插件  </p>\n<h4 id=\"2-0-2-0-1-2-1-Eclair\"><a href=\"#2-0-2-0-1-2-1-Eclair\" class=\"headerlink\" title=\"2.0/2.0.1/2.1(Eclair)\"></a>2.0/2.0.1/2.1(Eclair)</h4><p>基于Linux Kernel 2.6.29 2009年10月26日, 2.0(Eclair)版本SDK发布。主要的更新如下:<br>● 优化硬件速度<br>● “Car Home”程序<br>● 支持更多的屏幕分辨率<br>● 重整界面<br>● 新的浏览器的用户界面和支持HTML5<br>● 新的联系人名单<br>● 更好的白色/黑色背景比率<br>● 改进Google Maps 3.1.2<br>● 支持Microsoft Exchange<br>● 支持内置相机闪光灯<br>● 数字变焦<br>● 改进的虚拟键盘<br>● 蓝牙2.1<br>Android的代号序列会按甜点名字中首个英文字母(C、D、E、F)的排列顺序。<br>下一个版本的Android将会命名为Froyo(冻酸奶,基于Linux Kernel 2.6.32)。Froyo 之后的版本的Android将会命名为Gingerbread(姜饼,基于Linux Kernel 2.6.33/34)。</p>\n<p><strong>Android**</strong>版本**</p>\n<p><strong>发布日期</strong></p>\n<p><strong>代号</strong></p>\n<p><strong>Android 1.1</strong></p>\n<p><strong>Android 1.5</strong></p>\n<p>2009年4月30日</p>\n<p>Cupcake（纸杯蛋糕）</p>\n<p><strong>Android 1.6</strong></p>\n<p>2009年9月15日</p>\n<p>Donut（炸面圈）</p>\n<p><strong>Android 2.0/2.1</strong></p>\n<p>2009年10月26日</p>\n<p>Eclair（长松饼）</p>\n<p><strong>Android 2.2</strong></p>\n<p>2010年5月20日</p>\n<p>Froyo（冻酸奶）</p>\n<p><strong>Android 2.3</strong></p>\n<p>2010年12月6日</p>\n<p>Gingerbread（姜饼）</p>\n<p><strong>Android 3.0/3.1/3.2</strong></p>\n<p>2011年2月22日</p>\n<p>Honeycomb（蜂巢）</p>\n<p><strong>Android 4.0</strong></p>\n<p>2011年10月19日</p>\n<p>Ice Cream Sandwich（冰淇淋三明治）</p>\n<p><strong>Android 4.1</strong></p>\n<p>2012年6月28日</p>\n<p>Jelly Bean（果冻豆）</p>\n<p><strong>Android 4.2</strong></p>\n<p>2012年10月8日</p>\n<p>Jelly Bean（果冻豆）</p>\n<p><strong>Android5.0</strong></p>\n<p>待定</p>\n<p>Lime Pie（酸橙派）</p>\n<h3 id=\"1-2-Android系统的架构与特性\"><a href=\"#1-2-Android系统的架构与特性\" class=\"headerlink\" title=\"1.2 Android系统的架构与特性\"></a>1.2 Android系统的架构与特性</h3><h4 id=\"1-2-1-Android系统架构\"><a href=\"#1-2-1-Android系统架构\" class=\"headerlink\" title=\"1.2.1 Android系统架构\"></a>1.2.1 Android系统架构</h4><p>Android系统的底层是建立在Linux系统之上的，它采用软件叠层（Software Stack）的方式进行构建。使得层与层之间相互分离，明确各层的分工。这种分工保证了层与层之间的低苟合，当下层发生改变的时候，上层应用程序无需做任何改变。</p>\n<p>下图为Android系统的系统架构图：</p>\n<p><img src=\"http://s1.51cto.com/wyfs02/M01/25/73/wKioL1NgW-Si7ae7AAEJ_vZkaJ0908.jpg\" alt></p>\n<p>如图可知，Android系统分为四个层，从高到底分别是：应用程序层（Application）、应用程序框架层（Application Framework）、系统运行库层（Libraries）和Linux内核层（Linux Kernel）。</p>\n<p>Android操作系统可以在四个主要层面上分为5个部分：</p>\n<h5 id=\"1-应用程序层（Application）\"><a href=\"#1-应用程序层（Application）\" class=\"headerlink\" title=\"1. 应用程序层（Application）\"></a>1. 应用程序层（Application）</h5><p>Android系统包含了一系列核心应用程序，包括电子邮件、短信SMS、日历、拨号器、地图、浏览器、联系人等。这些应用程序都是用Java语言编写。本书重点讲解如何编写Android系统上运行的应用程序，在程序分层上，与系统核心应用程序平级。</p>\n<h5 id=\"2-应用程序框架层（Application-Framework）\"><a href=\"#2-应用程序框架层（Application-Framework）\" class=\"headerlink\" title=\"2. 应用程序框架层（Application Framework）\"></a>2. 应用程序框架层（Application Framework）</h5><p>Android应用程序框架提供了大量的API供开发人员使用，Android应用程序的开发，就是调用这些API，根据需求实现功能。</p>\n<p>应用程序框架是应用程序的基础。为了软件的复用，任何一个应用程序都可以开发Android系统的功能模块，只要发布的时候遵循应用程序框架的规范，其它应用程序也可以使用这个功能模块。</p>\n<h5 id=\"3-系统运行库层（Libraries）\"><a href=\"#3-系统运行库层（Libraries）\" class=\"headerlink\" title=\"3. 系统运行库层（Libraries）**\"></a>3. 系统运行库层（Libraries）**</h5><p>Android系统运行库是用C/C++语言编写的，是一套被不同组件所使用的函数库组成的集合。一般来说，Android应用开发者无法直接调用这套函数库，都是通过它上层的应用程序框架提供的API来对这些函数库进行调用。</p>\n<p>下面对一些核心库进行简单的介绍：</p>\n<blockquote>\n<p><strong>Libc：</strong>从BSD系统派生出来的标准C系统库，在此基础之上，为了便携式Linux系统专门进行了调整。</p>\n<p><strong>Medio Framework：</strong>基于PacketView的OpenCORE，这套媒体库支持播放与录制硬盘及视频格式的文件，并能查看静态图片。</p>\n<p><strong>Surface Manager：</strong>在执行多个应用程序的时，负责管理显示与存取操作间的互动，同时负责2D绘图与3D绘图进行显示合成。</p>\n<p><strong>WebKit：</strong>Web浏览器引擎，该引擎为Android浏览器提供支持。</p>\n<p><strong>SGL：</strong>底层的2D图像引擎。</p>\n<p><strong>3D libraries：</strong>基于OpenGL ES 1.0API，提供使用软硬件实现3D加速的功能。</p>\n<p><strong>FreeType：</strong>提供位图和向量字体的支持。</p>\n<p><strong>SQLite：</strong>轻量级的关系型数据库。</p>\n</blockquote>\n<h5 id=\"4-Android运行时\"><a href=\"#4-Android运行时\" class=\"headerlink\" title=\"4. Android运行时**\"></a>4. Android运行时**</h5><pre><code>Android运行时由两部分完成：Android核心库和Dalvik虚拟机。其中核心库集提供了Java语言核心库所能使用的绝大部分功能，Dalvik虚拟机负责运行Android应用程序。\n\n虽然Android应用程序通过Java语言编写，而每个Java程序都会在Java虚拟机JVM内运行，但是Android系统毕竟是运行在移动设备上的，由于硬件的限制， Android应用程序并不使用Java的虚拟机JVM来运行程序，而是使用自己独立的虚拟机Dalvik VM，它针对多个同时高效运行的虚拟机进行了优化。每个Android应用程序都运行在单独的一个Dalvik虚拟机内，因此Android系统可以方便对应用程序进行隔离。</code></pre><h5 id=\"5-Linux内核\"><a href=\"#5-Linux内核\" class=\"headerlink\" title=\"5. Linux内核\"></a>5. Linux内核</h5><p>Android系统是基于Linux2.6之上建立的操作系统，它的Linux内核为Android系统提供了安全性、内存管理、进程管理、网络协议栈、驱动模型等核心系统服务。Linux内核帮助Android系统实现了底层硬件与上层软件之间的抽象。</p>\n<h4 id=\"1-2-2-Dalvik-VM和JVM的区别\"><a href=\"#1-2-2-Dalvik-VM和JVM的区别\" class=\"headerlink\" title=\"1.2.2 Dalvik VM和JVM的区别\"></a>1.2.2 Dalvik VM和JVM的区别</h4><p>JVM（Java虚拟机）是一个虚构出来的运行Java程序的运行时，是通过在实际的计算机上仿真模拟各种计算机功能的实现。它具有完善的硬件架构（如处理器、堆栈、寄存器等），还具有相应的指令系统，使用JVM就是使Java程序支持与操作系统无关。理论上在任何操作系统中，只要有对应的JVM，即可运行Java程序。</p>\n<p>Dalvik VM是在Android系统上运行Android程序的虚拟机，其指令集是基于寄存器架构的，执行特有的文件格式-dex字节码来完成对象生命周期管理、堆栈管理、线程管理、安全异常管理、垃圾回收等重要功能。</p>\n<p>由于Android应用程序的开发编程语言是Java，而Java程序运行在JVM（Java虚拟机）上的，因此有些人会把Android的虚拟机DalvikVM和JVM弄混淆，但是实际上Dalvik并未遵守JVM规范，而且两者也是互不兼容。</p>\n<p>从Dalvik VM和JVM的编译过程分析，它们的编译过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JVM：.java→.class→.jar</span><br><span class=\"line\">Dalvik VM：.java→.class→.dex</span><br></pre></td></tr></table></figure>\n\n<p>从它们的编译过程可以看出，JVM运行的是.class文件的Java字节码，但是Dalvik VM运行的是其转换后的dex（Dalvik Executable）文件。JVM字节从.class文件或者JAR包中加载字节码然后运行，而Dalvik VM无法直接从.class文件或JAR包中加载字节码，它需要通过DX工具将应用程序所有的.class文件编译成一个.dex文件，Dalvik VM则运行这个.dex文件。</p>\n<p>下图显示了Dalvik VM与JVM编译过程的区别：</p>\n<p><img src=\"http://s4.51cto.com/wyfs02/M01/25/73/wKiom1NgXMOTVyNiAAB-h8_94xE986.jpg\" alt></p>\n<p>从图中可以看出，Dalvik VM把.java文件编译成.class后，会对.class进行重构，整合的基本元素（常量池、类定义、数据段）,最后压缩写进一个.dex文件中。其中，常量池描述了所有的常量，包括引用、方法名、数值常量等；类定义包括访问标识、类名等基本信息；数据段中包含各种被VM指定的方法代码以及类和方法的相关信息和实例变量。这种把多个.class文件进行整合的方法，大大提高了Android程序的运行速度，例如：应用程序中多个类定义了字符串常量TAG，而在JVM中，会编译成多个.class文件，每个.class文件的常量池中，均包含这个TAG常量，但是Dalvik VM在编译成.dex文件之后，其常量池里只有一个TAG常量。</p>\n<p>JVM和Dalvik VM还有一点非常重要的不同，就是基于的架构不同。JVM是基于栈的架构，而Dalvik VM是基于寄存器的架构。相对于基于栈的JVM而言，基于寄存器的Dalvik VM实现虽然牺牲了一些硬件上的通用性，但是它在代码的执行效率上要更胜一筹。一般来讲，VM中指令的解释执行的时间主要花费在以下三个方面：</p>\n<blockquote>\n<p>分发指令；</p>\n<p>访问运算数；</p>\n<p>执行运算；</p>\n</blockquote>\n<p>其中分发指令这个环节对性能的影响最大。在基于寄存器的Dalvik VM中，可以更有效的减少冗余指令的分发，减少内存的读写访问。</p>\n<p>从JVM和Dalvik VM的区别上来说，Dalvik VM主要是针对Android这个嵌入式操作系统的特点进行了各种优化，使其更省电、更省内存、运行效率更高，但是牺牲了一些JVM的与平台无关的特性。实际上，Dalvik VM本就是为Android设计的，无需考虑其它平台的问题。这里只是介绍了JVM和Dalvik VM的两个重要的区别，毕竟本书并不是讲解Android内核的，这里只是点明Dalvik VM的特点，读者对这部分的内容了解即可。</p>\n<h3 id=\"1-2-3-Android系统平台的优势\"><a href=\"#1-2-3-Android系统平台的优势\" class=\"headerlink\" title=\"1.2.3 Android系统平台的优势\"></a>1.2.3 Android系统平台的优势</h3><p>Android系统相对于其它操作系统，有如下几点优势：</p>\n<h4 id=\"1-开放性\"><a href=\"#1-开放性\" class=\"headerlink\" title=\"1. 开放性\"></a>1. 开放性</h4><p>首先就是Android系统的开放性，其开发平台允许任何移动终端厂商加入到Android联盟中来，降低了开发门槛，使其拥有更多的开发者，随着用户和应用的日益丰富，也将推进Android系统的成熟。同时，开放性有利于Android设备的普及以及市场竞争力，这样有利于消费者买到更低价位的Android设备。</p>\n<h4 id=\"2-丰富的硬件选择\"><a href=\"#2-丰富的硬件选择\" class=\"headerlink\" title=\"2. 丰富的硬件选择\"></a>2. 丰富的硬件选择</h4><p>同样由于Android系统的开放性，众多硬件厂商可以推出各种的搭载Android系统的设备。现如今，Android系统不仅仅只是运行在手机上，越来越多的设备开始支持Android系统，如电视、可佩戴设备、数码相机等。</p>\n<h4 id=\"3-便于开发\"><a href=\"#3-便于开发\" class=\"headerlink\" title=\"3. 便于开发\"></a>3. 便于开发</h4><p>Google开放了Android的系统源码，提供了开发者一个自由的开发环境，不必受到各种条条框框的束缚。</p>\n<h4 id=\"4-Google服务的支持\"><a href=\"#4-Google服务的支持\" class=\"headerlink\" title=\"4. Google服务的支持\"></a>4. Google服务的支持</h4><p>Google公司作为一个做服务的公司，它提供了如地图、邮件、搜索等服务，Android系统可以对这些服务进行无缝的结合。</p>\n"},{"title":"StatefulWidget和StatelessWidget","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T05:54:00.000Z","_content":"\n## 介绍\nFlutter提供了一套丰富、强大的基础widget，在基础widget库之上Flutter又提供了一套Material风格（Android默认的视觉风格）和一套Cupertino风格（iOS视觉风格）的widget库。要使用基础widget库，需要先导入：\n```dart\nimport 'package:flutter/widgets.dart';\n```\n\n## 基础widget\n- `Text`：该 widget 可让您创建一个带格式的文本。\n- `Row`、 `Column`： 这些具有弹性空间的布局类Widget可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于web开发中的Flexbox布局模型。\n- `Stack`： 取代线性布局 (译者语：和Android中的FrameLayout相似)，Stack允许子 widget 堆叠， 你可以使用 Positioned 来定位他们相对于Stack的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。\n- `Container`：可让您创建矩形视觉元素。container 可以装饰一个BoxDecoration, 如 background、一个边框、或者一个阴影。 Container 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外，  Container可以使用矩阵在三维空间中对其进行变换。\n\n## 什么是 Material Design 和 Flutter Material 组件？\nMaterial Design 意在为你构建一个大胆而且美观的数字产品设计系统。将风格、品牌、交互、动效通过统一的准则结合，发掘产品最大的设计潜力。\n\n**Flutter 的 Material 组件（MDC - Flutter）** 通过在应用间和平台间提供一个统一的用户体验组件库，把设计和工程合二为一。秉承着 Google 的前端开发标准，Material Design 系统正在向多端一致体验、像素级完美呈现的方向发展。Material Design 组件（MDC）也同样适用于 Android、iOS 和 Web。\n\n## Material widget\nFlutter提供了一套丰富的Material widget，可帮助您构建遵循Material Design的应用程序。Material应用程序以MaterialApp widget开始， 该widget在应用程序的根部创建了一些有用的widget，比如一个Theme，它配置了应用的主题。 是否使用MaterialApp完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个Material widget了，如：Scaffold、AppBar、FlatButton等。要使用Material widget，需要先引入它：\n```dart\nimport 'package:flutter/material.dart';\n```\n\n## Cupertino widget\nFlutter也提供了一套丰富的Cupertino风格的widget，尽管目前还没有Material widget那么丰富，但也在不断的完善中。值得一提的是在Material widget库中，有一些widget可以根据实际运行平台来切换表现风格，比如MaterialPageRoute，在路由切换时，如果是Android系统，它将会使用Android系统默认的页面切换动画(从底向上)，如果是iOS系统时，它会使用iOS系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino widget的示例，我们实现一个简单的Cupertino页面：\n```dart\n//导入cupertino widget库\nimport 'package:flutter/cupertino.dart';\n\nclass CupertinoTestRoute extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CupertinoPageScaffold(\n      navigationBar: CupertinoNavigationBar(\n        middle: Text(\"Cupertino Demo\"),\n      ),\n      child: Center(\n        child: CupertinoButton(\n            color: CupertinoColors.activeBlue,\n            child: Text(\"Press\"),\n            onPressed: () {}\n        ),\n      ),\n    );\n  }\n}\n```\n\n\n## Widget与Element\n>Widget的功能是“描述一个UI元素的配置数据”,Flutter中真正代表屏幕上显示元素的类是Element。\n- Widget实际上就是Element的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由Element构成；不过，由于Element是通过Widget生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。\n- 一个Widget对象可以对应多个Element对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。\n\n## 主要接口\n```dart\n@immutable\nabstract class Widget extends DiagnosticableTree {\n  const Widget({ this.key });\n  final Key key;\n\n  @protected\n  Element createElement();\n\n  @override\n  String toStringShort() {\n    return key == null ? '$runtimeType' : '$runtimeType-$key';\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;\n  }\n\n  static bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n  }\n}\n```\n- Widget类继承自`DiagnosticableTree`，DiagnosticableTree即“诊断树”，主要作用是提供调试信息。\n- `Key`: 这个key属性类似于React/Vue中的key，主要的作用是决定是否在下一次build时复用旧的widget，决定的条件在`canUpdate()`方法中。\n- `createElement()`：正如前文所述“一个Widget可以对应多个Element”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的Element对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。\n- `debugFillProperties(...)` 复写父类的方法，主要是设置诊断树的一些特性。\n- `canUpdate(...)`是一个静态方法，它主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；通过其源码我们可以看到，只要newWidget与oldWidget的runtimeType和key同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。\n\n## StatelessWidget\n> StatelessWidget用于不需要维护状态的场景，它通常在build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。\n```dart\nclass Echo extends StatelessWidget {\n  const Echo({\n    Key key,  \n    @required this.text,\n    this.backgroundColor:Colors.grey,\n  }):super(key:key);\n\n  final String text;\n  final Color backgroundColor;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        color: backgroundColor,\n        child: Text(text),\n      ),\n    );\n  }\n}\n```\n\n## StatefulWidget\n> 具有可变状态(`state`)的`Widget`.\n```dart\nabstract class StatefulWidget extends Widget {\n  const StatefulWidget({ Key key }) : super(key: key);\n\n  @override\n  StatefulElement createElement() => new StatefulElement(this);\n\n  @protected\n  State createState();\n}\n```\n- `StatefulElement` 间接继承自`Element`类，与`StatefulWidget`相对应（作为其配置数据）。`StatefulElement`中可能会多次调用`createState()`来创建状态(`State`)对象。\n- `createState()` 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的`State`实例，其实，本质上就是一个`StatefulElement`对应一个`State`实例。\n\n## State\n> 一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态。\n1. 在widget build时可以被同步读取。\n1. 在widget生命周期中可以被改变，当`State`被改变时，可以手动调用其`setState()`方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其build方法重新构建widget树，从而达到更新UI的目的。\n\n### 常用属性\n- widget\n  >它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用声明周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。\n- context\n  >它是BuildContext类的一个实例，表示构建widget的上下文，它是操作widget在树中位置的一个句柄，它包含了一些查找、遍历当前Widget树的一些方法。每一个widget都有一个自己的context对象。\n\n### 生命周期\n![](../img/state_life.png)\n\n大致可以看成三个阶段\n1. 初始化（插入渲染树）\n2. 状态改变（在渲染树中存在）\n3. 销毁（从渲染树中移除）\n\n### 主要函数\n- initState\n  > 当插入渲染树的时候调用，这个函数在生命周期中只调用一次。这里可以做一些初始化工作，比如初始化State的变量。\n- didChangeDependencies\n  > 这个函数会紧跟在initState之后调用，并且可以调用BuildContext.inheritFromWidgetOfExactType\n- didUpdateWidget\n  > 当组件的状态改变的时候就会调用didUpdateWidget,比如调用了setState.\n- deactivate\n  > 在dispose之前，会调用这个函数。\n- dispose\n  > 一旦到这个阶段，组件就要被销毁了，这个函数一般会移除监听，清理环境。","source":"_posts/flutter/widget/FlutterWidget.md","raw":"---\ntitle: StatefulWidget和StatelessWidget\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- Widget\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 13:54:00   \n---\n\n## 介绍\nFlutter提供了一套丰富、强大的基础widget，在基础widget库之上Flutter又提供了一套Material风格（Android默认的视觉风格）和一套Cupertino风格（iOS视觉风格）的widget库。要使用基础widget库，需要先导入：\n```dart\nimport 'package:flutter/widgets.dart';\n```\n\n## 基础widget\n- `Text`：该 widget 可让您创建一个带格式的文本。\n- `Row`、 `Column`： 这些具有弹性空间的布局类Widget可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于web开发中的Flexbox布局模型。\n- `Stack`： 取代线性布局 (译者语：和Android中的FrameLayout相似)，Stack允许子 widget 堆叠， 你可以使用 Positioned 来定位他们相对于Stack的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。\n- `Container`：可让您创建矩形视觉元素。container 可以装饰一个BoxDecoration, 如 background、一个边框、或者一个阴影。 Container 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外，  Container可以使用矩阵在三维空间中对其进行变换。\n\n## 什么是 Material Design 和 Flutter Material 组件？\nMaterial Design 意在为你构建一个大胆而且美观的数字产品设计系统。将风格、品牌、交互、动效通过统一的准则结合，发掘产品最大的设计潜力。\n\n**Flutter 的 Material 组件（MDC - Flutter）** 通过在应用间和平台间提供一个统一的用户体验组件库，把设计和工程合二为一。秉承着 Google 的前端开发标准，Material Design 系统正在向多端一致体验、像素级完美呈现的方向发展。Material Design 组件（MDC）也同样适用于 Android、iOS 和 Web。\n\n## Material widget\nFlutter提供了一套丰富的Material widget，可帮助您构建遵循Material Design的应用程序。Material应用程序以MaterialApp widget开始， 该widget在应用程序的根部创建了一些有用的widget，比如一个Theme，它配置了应用的主题。 是否使用MaterialApp完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个Material widget了，如：Scaffold、AppBar、FlatButton等。要使用Material widget，需要先引入它：\n```dart\nimport 'package:flutter/material.dart';\n```\n\n## Cupertino widget\nFlutter也提供了一套丰富的Cupertino风格的widget，尽管目前还没有Material widget那么丰富，但也在不断的完善中。值得一提的是在Material widget库中，有一些widget可以根据实际运行平台来切换表现风格，比如MaterialPageRoute，在路由切换时，如果是Android系统，它将会使用Android系统默认的页面切换动画(从底向上)，如果是iOS系统时，它会使用iOS系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino widget的示例，我们实现一个简单的Cupertino页面：\n```dart\n//导入cupertino widget库\nimport 'package:flutter/cupertino.dart';\n\nclass CupertinoTestRoute extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return CupertinoPageScaffold(\n      navigationBar: CupertinoNavigationBar(\n        middle: Text(\"Cupertino Demo\"),\n      ),\n      child: Center(\n        child: CupertinoButton(\n            color: CupertinoColors.activeBlue,\n            child: Text(\"Press\"),\n            onPressed: () {}\n        ),\n      ),\n    );\n  }\n}\n```\n\n\n## Widget与Element\n>Widget的功能是“描述一个UI元素的配置数据”,Flutter中真正代表屏幕上显示元素的类是Element。\n- Widget实际上就是Element的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由Element构成；不过，由于Element是通过Widget生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。\n- 一个Widget对象可以对应多个Element对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。\n\n## 主要接口\n```dart\n@immutable\nabstract class Widget extends DiagnosticableTree {\n  const Widget({ this.key });\n  final Key key;\n\n  @protected\n  Element createElement();\n\n  @override\n  String toStringShort() {\n    return key == null ? '$runtimeType' : '$runtimeType-$key';\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;\n  }\n\n  static bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n  }\n}\n```\n- Widget类继承自`DiagnosticableTree`，DiagnosticableTree即“诊断树”，主要作用是提供调试信息。\n- `Key`: 这个key属性类似于React/Vue中的key，主要的作用是决定是否在下一次build时复用旧的widget，决定的条件在`canUpdate()`方法中。\n- `createElement()`：正如前文所述“一个Widget可以对应多个Element”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的Element对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。\n- `debugFillProperties(...)` 复写父类的方法，主要是设置诊断树的一些特性。\n- `canUpdate(...)`是一个静态方法，它主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；通过其源码我们可以看到，只要newWidget与oldWidget的runtimeType和key同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。\n\n## StatelessWidget\n> StatelessWidget用于不需要维护状态的场景，它通常在build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。\n```dart\nclass Echo extends StatelessWidget {\n  const Echo({\n    Key key,  \n    @required this.text,\n    this.backgroundColor:Colors.grey,\n  }):super(key:key);\n\n  final String text;\n  final Color backgroundColor;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        color: backgroundColor,\n        child: Text(text),\n      ),\n    );\n  }\n}\n```\n\n## StatefulWidget\n> 具有可变状态(`state`)的`Widget`.\n```dart\nabstract class StatefulWidget extends Widget {\n  const StatefulWidget({ Key key }) : super(key: key);\n\n  @override\n  StatefulElement createElement() => new StatefulElement(this);\n\n  @protected\n  State createState();\n}\n```\n- `StatefulElement` 间接继承自`Element`类，与`StatefulWidget`相对应（作为其配置数据）。`StatefulElement`中可能会多次调用`createState()`来创建状态(`State`)对象。\n- `createState()` 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的`State`实例，其实，本质上就是一个`StatefulElement`对应一个`State`实例。\n\n## State\n> 一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态。\n1. 在widget build时可以被同步读取。\n1. 在widget生命周期中可以被改变，当`State`被改变时，可以手动调用其`setState()`方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其build方法重新构建widget树，从而达到更新UI的目的。\n\n### 常用属性\n- widget\n  >它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用声明周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。\n- context\n  >它是BuildContext类的一个实例，表示构建widget的上下文，它是操作widget在树中位置的一个句柄，它包含了一些查找、遍历当前Widget树的一些方法。每一个widget都有一个自己的context对象。\n\n### 生命周期\n![](../img/state_life.png)\n\n大致可以看成三个阶段\n1. 初始化（插入渲染树）\n2. 状态改变（在渲染树中存在）\n3. 销毁（从渲染树中移除）\n\n### 主要函数\n- initState\n  > 当插入渲染树的时候调用，这个函数在生命周期中只调用一次。这里可以做一些初始化工作，比如初始化State的变量。\n- didChangeDependencies\n  > 这个函数会紧跟在initState之后调用，并且可以调用BuildContext.inheritFromWidgetOfExactType\n- didUpdateWidget\n  > 当组件的状态改变的时候就会调用didUpdateWidget,比如调用了setState.\n- deactivate\n  > 在dispose之前，会调用这个函数。\n- dispose\n  > 一旦到这个阶段，组件就要被销毁了，这个函数一般会移除监听，清理环境。","slug":"flutter/widget/FlutterWidget","published":1,"updated":"2019-10-02T11:51:36.452Z","layout":"post","photos":[],"link":"","_id":"ck19bvb6m006j00wkwidtm8ku","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Flutter提供了一套丰富、强大的基础widget，在基础widget库之上Flutter又提供了一套Material风格（Android默认的视觉风格）和一套Cupertino风格（iOS视觉风格）的widget库。要使用基础widget库，需要先导入：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/widgets.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基础widget\"><a href=\"#基础widget\" class=\"headerlink\" title=\"基础widget\"></a>基础widget</h2><ul>\n<li><code>Text</code>：该 widget 可让您创建一个带格式的文本。</li>\n<li><code>Row</code>、 <code>Column</code>： 这些具有弹性空间的布局类Widget可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于web开发中的Flexbox布局模型。</li>\n<li><code>Stack</code>： 取代线性布局 (译者语：和Android中的FrameLayout相似)，Stack允许子 widget 堆叠， 你可以使用 Positioned 来定位他们相对于Stack的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。</li>\n<li><code>Container</code>：可让您创建矩形视觉元素。container 可以装饰一个BoxDecoration, 如 background、一个边框、或者一个阴影。 Container 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外，  Container可以使用矩阵在三维空间中对其进行变换。</li>\n</ul>\n<h2 id=\"什么是-Material-Design-和-Flutter-Material-组件？\"><a href=\"#什么是-Material-Design-和-Flutter-Material-组件？\" class=\"headerlink\" title=\"什么是 Material Design 和 Flutter Material 组件？\"></a>什么是 Material Design 和 Flutter Material 组件？</h2><p>Material Design 意在为你构建一个大胆而且美观的数字产品设计系统。将风格、品牌、交互、动效通过统一的准则结合，发掘产品最大的设计潜力。</p>\n<p><strong>Flutter 的 Material 组件（MDC - Flutter）</strong> 通过在应用间和平台间提供一个统一的用户体验组件库，把设计和工程合二为一。秉承着 Google 的前端开发标准，Material Design 系统正在向多端一致体验、像素级完美呈现的方向发展。Material Design 组件（MDC）也同样适用于 Android、iOS 和 Web。</p>\n<h2 id=\"Material-widget\"><a href=\"#Material-widget\" class=\"headerlink\" title=\"Material widget\"></a>Material widget</h2><p>Flutter提供了一套丰富的Material widget，可帮助您构建遵循Material Design的应用程序。Material应用程序以MaterialApp widget开始， 该widget在应用程序的根部创建了一些有用的widget，比如一个Theme，它配置了应用的主题。 是否使用MaterialApp完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个Material widget了，如：Scaffold、AppBar、FlatButton等。要使用Material widget，需要先引入它：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cupertino-widget\"><a href=\"#Cupertino-widget\" class=\"headerlink\" title=\"Cupertino widget\"></a>Cupertino widget</h2><p>Flutter也提供了一套丰富的Cupertino风格的widget，尽管目前还没有Material widget那么丰富，但也在不断的完善中。值得一提的是在Material widget库中，有一些widget可以根据实际运行平台来切换表现风格，比如MaterialPageRoute，在路由切换时，如果是Android系统，它将会使用Android系统默认的页面切换动画(从底向上)，如果是iOS系统时，它会使用iOS系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino widget的示例，我们实现一个简单的Cupertino页面：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//导入cupertino widget库</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/cupertino.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CupertinoTestRoute</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CupertinoPageScaffold(</span><br><span class=\"line\">      navigationBar: CupertinoNavigationBar(</span><br><span class=\"line\">        middle: Text(<span class=\"string\">\"Cupertino Demo\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      child: Center(</span><br><span class=\"line\">        child: CupertinoButton(</span><br><span class=\"line\">            color: CupertinoColors.activeBlue,</span><br><span class=\"line\">            child: Text(<span class=\"string\">\"Press\"</span>),</span><br><span class=\"line\">            onPressed: () &#123;&#125;</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Widget与Element\"><a href=\"#Widget与Element\" class=\"headerlink\" title=\"Widget与Element\"></a>Widget与Element</h2><blockquote>\n<p>Widget的功能是“描述一个UI元素的配置数据”,Flutter中真正代表屏幕上显示元素的类是Element。</p>\n<ul>\n<li>Widget实际上就是Element的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由Element构成；不过，由于Element是通过Widget生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。</li>\n<li>一个Widget对象可以对应多个Element对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。</li>\n</ul>\n</blockquote>\n<h2 id=\"主要接口\"><a href=\"#主要接口\" class=\"headerlink\" title=\"主要接口\"></a>主要接口</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@immutable</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> <span class=\"keyword\">extends</span> <span class=\"title\">DiagnosticableTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Widget(&#123; <span class=\"keyword\">this</span>.key &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Key key;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@protected</span></span><br><span class=\"line\">  <span class=\"built_in\">Element</span> createElement();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> toStringShort() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key == <span class=\"keyword\">null</span> ? <span class=\"string\">'<span class=\"subst\">$runtimeType</span>'</span> : <span class=\"string\">'<span class=\"subst\">$runtimeType</span>-<span class=\"subst\">$key</span>'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.debugFillProperties(properties);</span><br><span class=\"line\">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Widget类继承自<code>DiagnosticableTree</code>，DiagnosticableTree即“诊断树”，主要作用是提供调试信息。</li>\n<li><code>Key</code>: 这个key属性类似于React/Vue中的key，主要的作用是决定是否在下一次build时复用旧的widget，决定的条件在<code>canUpdate()</code>方法中。</li>\n<li><code>createElement()</code>：正如前文所述“一个Widget可以对应多个Element”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的Element对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。</li>\n<li><code>debugFillProperties(...)</code> 复写父类的方法，主要是设置诊断树的一些特性。</li>\n<li><code>canUpdate(...)</code>是一个静态方法，它主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；通过其源码我们可以看到，只要newWidget与oldWidget的runtimeType和key同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。</li>\n</ul>\n<h2 id=\"StatelessWidget\"><a href=\"#StatelessWidget\" class=\"headerlink\" title=\"StatelessWidget\"></a>StatelessWidget</h2><blockquote>\n<p>StatelessWidget用于不需要维护状态的场景，它通常在build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Echo</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Echo(&#123;</span><br><span class=\"line\">    Key key,  </span><br><span class=\"line\">    <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.text,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.backgroundColor:Colors.grey,</span><br><span class=\"line\">  &#125;):<span class=\"keyword\">super</span>(key:key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> text;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Color backgroundColor;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Center(</span><br><span class=\"line\">      child: Container(</span><br><span class=\"line\">        color: backgroundColor,</span><br><span class=\"line\">        child: Text(text),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"StatefulWidget\"><a href=\"#StatefulWidget\" class=\"headerlink\" title=\"StatefulWidget\"></a>StatefulWidget</h2><blockquote>\n<p>具有可变状态(<code>state</code>)的<code>Widget</code>.</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulWidget</span> <span class=\"keyword\">extends</span> <span class=\"title\">Widget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> StatefulWidget(&#123; Key key &#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  StatefulElement createElement() =&gt; <span class=\"keyword\">new</span> StatefulElement(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@protected</span></span><br><span class=\"line\">  State createState();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>StatefulElement</code> 间接继承自<code>Element</code>类，与<code>StatefulWidget</code>相对应（作为其配置数据）。<code>StatefulElement</code>中可能会多次调用<code>createState()</code>来创建状态(<code>State</code>)对象。</li>\n<li><code>createState()</code> 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的<code>State</code>实例，其实，本质上就是一个<code>StatefulElement</code>对应一个<code>State</code>实例。</li>\n</ul>\n<h2 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h2><blockquote>\n<p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态。</p>\n<ol>\n<li>在widget build时可以被同步读取。</li>\n<li>在widget生命周期中可以被改变，当<code>State</code>被改变时，可以手动调用其<code>setState()</code>方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其build方法重新构建widget树，从而达到更新UI的目的。</li>\n</ol>\n</blockquote>\n<h3 id=\"常用属性\"><a href=\"#常用属性\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h3><ul>\n<li>widget<blockquote>\n<p>它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用声明周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。</p>\n</blockquote>\n</li>\n<li>context<blockquote>\n<p>它是BuildContext类的一个实例，表示构建widget的上下文，它是操作widget在树中位置的一个句柄，它包含了一些查找、遍历当前Widget树的一些方法。每一个widget都有一个自己的context对象。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p><img src=\"../img/state_life.png\" alt></p>\n<p>大致可以看成三个阶段</p>\n<ol>\n<li>初始化（插入渲染树）</li>\n<li>状态改变（在渲染树中存在）</li>\n<li>销毁（从渲染树中移除）</li>\n</ol>\n<h3 id=\"主要函数\"><a href=\"#主要函数\" class=\"headerlink\" title=\"主要函数\"></a>主要函数</h3><ul>\n<li>initState<blockquote>\n<p>当插入渲染树的时候调用，这个函数在生命周期中只调用一次。这里可以做一些初始化工作，比如初始化State的变量。</p>\n</blockquote>\n</li>\n<li>didChangeDependencies<blockquote>\n<p>这个函数会紧跟在initState之后调用，并且可以调用BuildContext.inheritFromWidgetOfExactType</p>\n</blockquote>\n</li>\n<li>didUpdateWidget<blockquote>\n<p>当组件的状态改变的时候就会调用didUpdateWidget,比如调用了setState.</p>\n</blockquote>\n</li>\n<li>deactivate<blockquote>\n<p>在dispose之前，会调用这个函数。</p>\n</blockquote>\n</li>\n<li>dispose<blockquote>\n<p>一旦到这个阶段，组件就要被销毁了，这个函数一般会移除监听，清理环境。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Flutter提供了一套丰富、强大的基础widget，在基础widget库之上Flutter又提供了一套Material风格（Android默认的视觉风格）和一套Cupertino风格（iOS视觉风格）的widget库。要使用基础widget库，需要先导入：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/widgets.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"基础widget\"><a href=\"#基础widget\" class=\"headerlink\" title=\"基础widget\"></a>基础widget</h2><ul>\n<li><code>Text</code>：该 widget 可让您创建一个带格式的文本。</li>\n<li><code>Row</code>、 <code>Column</code>： 这些具有弹性空间的布局类Widget可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于web开发中的Flexbox布局模型。</li>\n<li><code>Stack</code>： 取代线性布局 (译者语：和Android中的FrameLayout相似)，Stack允许子 widget 堆叠， 你可以使用 Positioned 来定位他们相对于Stack的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。</li>\n<li><code>Container</code>：可让您创建矩形视觉元素。container 可以装饰一个BoxDecoration, 如 background、一个边框、或者一个阴影。 Container 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外，  Container可以使用矩阵在三维空间中对其进行变换。</li>\n</ul>\n<h2 id=\"什么是-Material-Design-和-Flutter-Material-组件？\"><a href=\"#什么是-Material-Design-和-Flutter-Material-组件？\" class=\"headerlink\" title=\"什么是 Material Design 和 Flutter Material 组件？\"></a>什么是 Material Design 和 Flutter Material 组件？</h2><p>Material Design 意在为你构建一个大胆而且美观的数字产品设计系统。将风格、品牌、交互、动效通过统一的准则结合，发掘产品最大的设计潜力。</p>\n<p><strong>Flutter 的 Material 组件（MDC - Flutter）</strong> 通过在应用间和平台间提供一个统一的用户体验组件库，把设计和工程合二为一。秉承着 Google 的前端开发标准，Material Design 系统正在向多端一致体验、像素级完美呈现的方向发展。Material Design 组件（MDC）也同样适用于 Android、iOS 和 Web。</p>\n<h2 id=\"Material-widget\"><a href=\"#Material-widget\" class=\"headerlink\" title=\"Material widget\"></a>Material widget</h2><p>Flutter提供了一套丰富的Material widget，可帮助您构建遵循Material Design的应用程序。Material应用程序以MaterialApp widget开始， 该widget在应用程序的根部创建了一些有用的widget，比如一个Theme，它配置了应用的主题。 是否使用MaterialApp完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个Material widget了，如：Scaffold、AppBar、FlatButton等。要使用Material widget，需要先引入它：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cupertino-widget\"><a href=\"#Cupertino-widget\" class=\"headerlink\" title=\"Cupertino widget\"></a>Cupertino widget</h2><p>Flutter也提供了一套丰富的Cupertino风格的widget，尽管目前还没有Material widget那么丰富，但也在不断的完善中。值得一提的是在Material widget库中，有一些widget可以根据实际运行平台来切换表现风格，比如MaterialPageRoute，在路由切换时，如果是Android系统，它将会使用Android系统默认的页面切换动画(从底向上)，如果是iOS系统时，它会使用iOS系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino widget的示例，我们实现一个简单的Cupertino页面：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//导入cupertino widget库</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/cupertino.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CupertinoTestRoute</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CupertinoPageScaffold(</span><br><span class=\"line\">      navigationBar: CupertinoNavigationBar(</span><br><span class=\"line\">        middle: Text(<span class=\"string\">\"Cupertino Demo\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      child: Center(</span><br><span class=\"line\">        child: CupertinoButton(</span><br><span class=\"line\">            color: CupertinoColors.activeBlue,</span><br><span class=\"line\">            child: Text(<span class=\"string\">\"Press\"</span>),</span><br><span class=\"line\">            onPressed: () &#123;&#125;</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Widget与Element\"><a href=\"#Widget与Element\" class=\"headerlink\" title=\"Widget与Element\"></a>Widget与Element</h2><blockquote>\n<p>Widget的功能是“描述一个UI元素的配置数据”,Flutter中真正代表屏幕上显示元素的类是Element。</p>\n<ul>\n<li>Widget实际上就是Element的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由Element构成；不过，由于Element是通过Widget生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。</li>\n<li>一个Widget对象可以对应多个Element对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。</li>\n</ul>\n</blockquote>\n<h2 id=\"主要接口\"><a href=\"#主要接口\" class=\"headerlink\" title=\"主要接口\"></a>主要接口</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@immutable</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> <span class=\"keyword\">extends</span> <span class=\"title\">DiagnosticableTree</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Widget(&#123; <span class=\"keyword\">this</span>.key &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Key key;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@protected</span></span><br><span class=\"line\">  <span class=\"built_in\">Element</span> createElement();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> toStringShort() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key == <span class=\"keyword\">null</span> ? <span class=\"string\">'<span class=\"subst\">$runtimeType</span>'</span> : <span class=\"string\">'<span class=\"subst\">$runtimeType</span>-<span class=\"subst\">$key</span>'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.debugFillProperties(properties);</span><br><span class=\"line\">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Widget类继承自<code>DiagnosticableTree</code>，DiagnosticableTree即“诊断树”，主要作用是提供调试信息。</li>\n<li><code>Key</code>: 这个key属性类似于React/Vue中的key，主要的作用是决定是否在下一次build时复用旧的widget，决定的条件在<code>canUpdate()</code>方法中。</li>\n<li><code>createElement()</code>：正如前文所述“一个Widget可以对应多个Element”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的Element对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。</li>\n<li><code>debugFillProperties(...)</code> 复写父类的方法，主要是设置诊断树的一些特性。</li>\n<li><code>canUpdate(...)</code>是一个静态方法，它主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；通过其源码我们可以看到，只要newWidget与oldWidget的runtimeType和key同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。</li>\n</ul>\n<h2 id=\"StatelessWidget\"><a href=\"#StatelessWidget\" class=\"headerlink\" title=\"StatelessWidget\"></a>StatelessWidget</h2><blockquote>\n<p>StatelessWidget用于不需要维护状态的场景，它通常在build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Echo</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> Echo(&#123;</span><br><span class=\"line\">    Key key,  </span><br><span class=\"line\">    <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.text,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.backgroundColor:Colors.grey,</span><br><span class=\"line\">  &#125;):<span class=\"keyword\">super</span>(key:key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> text;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Color backgroundColor;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Center(</span><br><span class=\"line\">      child: Container(</span><br><span class=\"line\">        color: backgroundColor,</span><br><span class=\"line\">        child: Text(text),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"StatefulWidget\"><a href=\"#StatefulWidget\" class=\"headerlink\" title=\"StatefulWidget\"></a>StatefulWidget</h2><blockquote>\n<p>具有可变状态(<code>state</code>)的<code>Widget</code>.</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulWidget</span> <span class=\"keyword\">extends</span> <span class=\"title\">Widget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> StatefulWidget(&#123; Key key &#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  StatefulElement createElement() =&gt; <span class=\"keyword\">new</span> StatefulElement(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@protected</span></span><br><span class=\"line\">  State createState();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>StatefulElement</code> 间接继承自<code>Element</code>类，与<code>StatefulWidget</code>相对应（作为其配置数据）。<code>StatefulElement</code>中可能会多次调用<code>createState()</code>来创建状态(<code>State</code>)对象。</li>\n<li><code>createState()</code> 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的<code>State</code>实例，其实，本质上就是一个<code>StatefulElement</code>对应一个<code>State</code>实例。</li>\n</ul>\n<h2 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h2><blockquote>\n<p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态。</p>\n<ol>\n<li>在widget build时可以被同步读取。</li>\n<li>在widget生命周期中可以被改变，当<code>State</code>被改变时，可以手动调用其<code>setState()</code>方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其build方法重新构建widget树，从而达到更新UI的目的。</li>\n</ol>\n</blockquote>\n<h3 id=\"常用属性\"><a href=\"#常用属性\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h3><ul>\n<li>widget<blockquote>\n<p>它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用声明周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。</p>\n</blockquote>\n</li>\n<li>context<blockquote>\n<p>它是BuildContext类的一个实例，表示构建widget的上下文，它是操作widget在树中位置的一个句柄，它包含了一些查找、遍历当前Widget树的一些方法。每一个widget都有一个自己的context对象。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p><img src=\"../img/state_life.png\" alt></p>\n<p>大致可以看成三个阶段</p>\n<ol>\n<li>初始化（插入渲染树）</li>\n<li>状态改变（在渲染树中存在）</li>\n<li>销毁（从渲染树中移除）</li>\n</ol>\n<h3 id=\"主要函数\"><a href=\"#主要函数\" class=\"headerlink\" title=\"主要函数\"></a>主要函数</h3><ul>\n<li>initState<blockquote>\n<p>当插入渲染树的时候调用，这个函数在生命周期中只调用一次。这里可以做一些初始化工作，比如初始化State的变量。</p>\n</blockquote>\n</li>\n<li>didChangeDependencies<blockquote>\n<p>这个函数会紧跟在initState之后调用，并且可以调用BuildContext.inheritFromWidgetOfExactType</p>\n</blockquote>\n</li>\n<li>didUpdateWidget<blockquote>\n<p>当组件的状态改变的时候就会调用didUpdateWidget,比如调用了setState.</p>\n</blockquote>\n</li>\n<li>deactivate<blockquote>\n<p>在dispose之前，会调用这个函数。</p>\n</blockquote>\n</li>\n<li>dispose<blockquote>\n<p>一旦到这个阶段，组件就要被销毁了，这个函数一般会移除监听，清理环境。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"布局限制容器ConstrainedBox和SizedBox","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T09:27:00.000Z","_content":"## 介绍\n> ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的。SizedBox只是ConstrainedBox一个定制，本节把他们放在一起讨论。\n\n## ConstrainedBox\nConstrainedBox用于对齐子Widget添加额外约束。例如，如果想让子Widget的最小高度为80像素，可以使用`const BoxConstraints(minHeight: 80.0)`作为widget的约束。\n\n我们先定义一个redBox，设置他的背景为红色，不指定高宽\n```dart\nWidget redBox = DecorateBox(\n    decoration: BoxCoration(color: Colors.red),\n);\n```\n\n我们实现一个最小高度为50，宽度尽可能大的红色容器\n```dart\nConstrainedBox(\n    constraints: BoxConstraints(\n    minWidth: double.infinity,// 尽可能大\n    minHeight: 50.0,// 最小高度 50像素\n    ),\n    child: Container(\n    height: 5.0,\n    child: redBox,\n    ),\n);\n```\n可以看到，我们虽然将Container的高度设置为5像素，但是最终却是50像素，这正是ConstrainedBox的最小高度限制生效了。如果将Container的高度设置为80像素，那么最终红色区域的高度也会是80像素，因为在此示例中，ConstrainedBox只限制了最小高度，并未限制最大高度。\n\n## BoxConstraints\nBoxConstraints用于设置限制条件\n```dart\nconst BoxConstraints({\n    this.minWidth = 0.0,// 最小宽度\n    this.maxWidth = double.infinity,// 最大宽度\n    this.minHeight = 0.0,// 最小高度\n    this.maxHeight = double.infinity // 最大高度    \n})\n```\nBoxConstraints还定义了一些便捷的构造函数，用于快速生成特定限制规则的BoxConstraints，如`BoxConstraints.tight(Size size)`，它可以生成给定大小的限制；const `BoxConstraints.expand()`可以生成一个尽可能大的用以填充另一个容器的BoxConstraints。\n\n## SizedBox\n> 为子Widget指定指定高宽\n```dart\nSizedBox(\n  width: 80.0,\n  height: 80.0,\n  child: redBox\n)\n```\n实际上SizedBox和只是ConstrainedBox一个定制，上面代码等价于：\n```dart\nConstrainedBox(\n  constraints: BoxConstraints.tightFor(width: 80.0,height: 80.0),\n  child: redBox, \n)\n```\n而BoxConstraints.tightFor(width: 80.0,height: 80.0)等价于：\n```dart\nBoxConstraints(minHeight: 80.0,maxHeight: 80.0,minWidth: 80.0,maxWidth: 80.0)\n```\n而实际上ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的，我们可以看到ConstrainedBox和SizedBox的createRenderObject()方法都返回的是一个RenderConstrainedBox对象：\n```dart\n@override\nRenderConstrainedBox createRenderObject(BuildContext context) {\n  return new RenderConstrainedBox(\n    additionalConstraints: ...,\n  );\n}\n```\n\n## 多重限制\n如果某一个widget有多个父ConstrainedBox限制，那么最终会是哪个生效？我们看一个例子：\n```dart\nConstrainedBox(\n    constraints: BoxConstraints(minWidth: 60.0, minHeight: 60.0), //父\n    child: ConstrainedBox(\n      constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子\n      child: redBox,\n    )\n)\n```\n上面我们有父子两个ConstrainedBox，他们的限制条件不同。\n\n最终显示效果是宽90，高60，也就是说是子ConstrainedBox的minWidth生效，而minHeight是父ConstrainedBox生效。单凭这个例子，我们还总结不出什么规律，我们将上例中父子限制条件换一下：\n```dart\nConstrainedBox(\n    constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),\n    child: ConstrainedBox(\n      constraints: BoxConstraints(minWidth: 60.0, minHeight: 60.0),\n      child: redBox,\n    )\n)\n```\n\n最终的显示效果仍然是90，高60，效果相同，但意义不同，因为此时minWidth生效的是父ConstrainedBox，而minHeight是子ConstrainedBox生效。\n\n通过上面示例，我们发现有多重限制时，对于minWidth和minHeight来说，是取父子中相应数值较大的。实际上，只有这样才能保证父限制与子限制不冲突。\n\n## UnconstrainedBox\nUnconstrainedBox不会对子Widget产生任何限制，它允许其子Widget按照其本身大小绘制。一般情况下，我们会很少直接使用此widget，但在\"去除\"多重限制的时候也许会有帮助，我们看一下面的代码：\n```dart\nConstrainedBox(\n    constraints: BoxConstraints(minWidth: 60.0, minHeight: 100.0),  //父\n    child: UnconstrainedBox( //“去除”父级限制\n      child: ConstrainedBox(\n        constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子\n        child: redBox,\n      ),\n    )\n)\n```\n上面代码中，如果没有中间的UnconstrainedBox，那么根据上面所述的多重限制规则，那么最终将显示一个90×100的红色框。但是由于 UnconstrainedBox “去除”了父ConstrainedBox的限制，则最终会按照子ConstrainedBox的限制来绘制redBox，即90×20：\n\n\n但是，UnconstrainedBox对父限制的“去除”并非是真正的去除，上面例子中虽然红色区域大小是90×20，但上方仍然有80的空白空间。也就是说父限制的minHeight(100.0)仍然是生效的，只不过它不影响最终子元素的大小，但仍然还是占有相应的空间，可以认为此时的父ConstrainedBox是作用于子ConstrainedBox上，而redBox只受子ConstrainedBox限制，这一点请读者务必注意。\n\n那么有什么方法可以彻底去除父BoxConstraints的限制吗？答案是否定的！所以在此提示读者，在定义一个通用的widget时，如果对子widget指定限制时一定要注意，因为一旦指定限制条件，子widget如果要进行相关自定义大小时将可能非常困难，因为子widget在不更改父widget的代码的情况下无法彻底去除其限制条件。\n\n## DecoratedBox\n\nDecoratedBox可以在其子widget绘制前(或后)绘制一个装饰Decoration（如背景、边框、渐变等）。DecoratedBox定义如下：\n```dart\nconst DecoratedBox({\n  Decoration decoration,\n  DecorationPosition position = DecorationPosition.background,\n  Widget child\n})\n```\n- decoration：代表将要绘制的装饰，它类型为Decoration，Decoration是一个抽象类，它定义了一个接口 createBoxPainter()，子类的主要职责是需要通过实现它来创建一个画笔，该画笔用于绘制装饰。\n- position：此属性决定在哪里绘制Decoration，它接收DecorationPosition的枚举类型，该枚举类两个值：\n- background：在子widget之后绘制，即背景装饰。\n- foreground：在子widget之上绘制，即前景。\n## BoxDecoration\n我们通常会直接使用BoxDecoration，它是一个Decoration的子类，实现了常用的装饰元素的绘制。\n```dart\nBoxDecoration({\n  Color color, //颜色\n  DecorationImage image,//图片\n  BoxBorder border, //边框\n  BorderRadiusGeometry borderRadius, //圆角\n  List<BoxShadow> boxShadow, //阴影,可以指定多个\n  Gradient gradient, //渐变\n  BlendMode backgroundBlendMode, //背景混合模式\n  BoxShape shape = BoxShape.rectangle, //形状\n})\n```\n各个属性名都是自解释的，详情读者可以查看API文档，我们看一个示例：\n```dart\n DecoratedBox(\n    decoration: BoxDecoration(\n      gradient: LinearGradient(colors:[Colors.red,Colors.orange[700]]), //背景渐变\n      borderRadius: BorderRadius.circular(3.0), //3像素圆角\n      boxShadow: [ //阴影\n        BoxShadow(\n            color:Colors.black54,\n            offset: Offset(2.0,2.0),\n            blurRadius: 4.0\n        )\n      ]\n    ),\n  child: Padding(padding: EdgeInsets.symmetric(horizontal: 80.0, vertical: 18.0),\n    child: Text(\"Login\", style: TextStyle(color: Colors.white),),\n  )\n)\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910115903588.png)\n\n怎么样，通过BoxDecoration，我们实现了一个渐变按钮的外观，但此示例还不是一个标准的按钮，因为它还不能响应点击事件，我们将在本章末尾来实现一个完整的GradientButton。","source":"_posts/flutter/容器/布局限制容器ConstrainedBox和SizedBox.md","raw":"---\ntitle: 布局限制容器ConstrainedBox和SizedBox\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- 容器\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 17:27:00   \n---\n## 介绍\n> ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的。SizedBox只是ConstrainedBox一个定制，本节把他们放在一起讨论。\n\n## ConstrainedBox\nConstrainedBox用于对齐子Widget添加额外约束。例如，如果想让子Widget的最小高度为80像素，可以使用`const BoxConstraints(minHeight: 80.0)`作为widget的约束。\n\n我们先定义一个redBox，设置他的背景为红色，不指定高宽\n```dart\nWidget redBox = DecorateBox(\n    decoration: BoxCoration(color: Colors.red),\n);\n```\n\n我们实现一个最小高度为50，宽度尽可能大的红色容器\n```dart\nConstrainedBox(\n    constraints: BoxConstraints(\n    minWidth: double.infinity,// 尽可能大\n    minHeight: 50.0,// 最小高度 50像素\n    ),\n    child: Container(\n    height: 5.0,\n    child: redBox,\n    ),\n);\n```\n可以看到，我们虽然将Container的高度设置为5像素，但是最终却是50像素，这正是ConstrainedBox的最小高度限制生效了。如果将Container的高度设置为80像素，那么最终红色区域的高度也会是80像素，因为在此示例中，ConstrainedBox只限制了最小高度，并未限制最大高度。\n\n## BoxConstraints\nBoxConstraints用于设置限制条件\n```dart\nconst BoxConstraints({\n    this.minWidth = 0.0,// 最小宽度\n    this.maxWidth = double.infinity,// 最大宽度\n    this.minHeight = 0.0,// 最小高度\n    this.maxHeight = double.infinity // 最大高度    \n})\n```\nBoxConstraints还定义了一些便捷的构造函数，用于快速生成特定限制规则的BoxConstraints，如`BoxConstraints.tight(Size size)`，它可以生成给定大小的限制；const `BoxConstraints.expand()`可以生成一个尽可能大的用以填充另一个容器的BoxConstraints。\n\n## SizedBox\n> 为子Widget指定指定高宽\n```dart\nSizedBox(\n  width: 80.0,\n  height: 80.0,\n  child: redBox\n)\n```\n实际上SizedBox和只是ConstrainedBox一个定制，上面代码等价于：\n```dart\nConstrainedBox(\n  constraints: BoxConstraints.tightFor(width: 80.0,height: 80.0),\n  child: redBox, \n)\n```\n而BoxConstraints.tightFor(width: 80.0,height: 80.0)等价于：\n```dart\nBoxConstraints(minHeight: 80.0,maxHeight: 80.0,minWidth: 80.0,maxWidth: 80.0)\n```\n而实际上ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的，我们可以看到ConstrainedBox和SizedBox的createRenderObject()方法都返回的是一个RenderConstrainedBox对象：\n```dart\n@override\nRenderConstrainedBox createRenderObject(BuildContext context) {\n  return new RenderConstrainedBox(\n    additionalConstraints: ...,\n  );\n}\n```\n\n## 多重限制\n如果某一个widget有多个父ConstrainedBox限制，那么最终会是哪个生效？我们看一个例子：\n```dart\nConstrainedBox(\n    constraints: BoxConstraints(minWidth: 60.0, minHeight: 60.0), //父\n    child: ConstrainedBox(\n      constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子\n      child: redBox,\n    )\n)\n```\n上面我们有父子两个ConstrainedBox，他们的限制条件不同。\n\n最终显示效果是宽90，高60，也就是说是子ConstrainedBox的minWidth生效，而minHeight是父ConstrainedBox生效。单凭这个例子，我们还总结不出什么规律，我们将上例中父子限制条件换一下：\n```dart\nConstrainedBox(\n    constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),\n    child: ConstrainedBox(\n      constraints: BoxConstraints(minWidth: 60.0, minHeight: 60.0),\n      child: redBox,\n    )\n)\n```\n\n最终的显示效果仍然是90，高60，效果相同，但意义不同，因为此时minWidth生效的是父ConstrainedBox，而minHeight是子ConstrainedBox生效。\n\n通过上面示例，我们发现有多重限制时，对于minWidth和minHeight来说，是取父子中相应数值较大的。实际上，只有这样才能保证父限制与子限制不冲突。\n\n## UnconstrainedBox\nUnconstrainedBox不会对子Widget产生任何限制，它允许其子Widget按照其本身大小绘制。一般情况下，我们会很少直接使用此widget，但在\"去除\"多重限制的时候也许会有帮助，我们看一下面的代码：\n```dart\nConstrainedBox(\n    constraints: BoxConstraints(minWidth: 60.0, minHeight: 100.0),  //父\n    child: UnconstrainedBox( //“去除”父级限制\n      child: ConstrainedBox(\n        constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子\n        child: redBox,\n      ),\n    )\n)\n```\n上面代码中，如果没有中间的UnconstrainedBox，那么根据上面所述的多重限制规则，那么最终将显示一个90×100的红色框。但是由于 UnconstrainedBox “去除”了父ConstrainedBox的限制，则最终会按照子ConstrainedBox的限制来绘制redBox，即90×20：\n\n\n但是，UnconstrainedBox对父限制的“去除”并非是真正的去除，上面例子中虽然红色区域大小是90×20，但上方仍然有80的空白空间。也就是说父限制的minHeight(100.0)仍然是生效的，只不过它不影响最终子元素的大小，但仍然还是占有相应的空间，可以认为此时的父ConstrainedBox是作用于子ConstrainedBox上，而redBox只受子ConstrainedBox限制，这一点请读者务必注意。\n\n那么有什么方法可以彻底去除父BoxConstraints的限制吗？答案是否定的！所以在此提示读者，在定义一个通用的widget时，如果对子widget指定限制时一定要注意，因为一旦指定限制条件，子widget如果要进行相关自定义大小时将可能非常困难，因为子widget在不更改父widget的代码的情况下无法彻底去除其限制条件。\n\n## DecoratedBox\n\nDecoratedBox可以在其子widget绘制前(或后)绘制一个装饰Decoration（如背景、边框、渐变等）。DecoratedBox定义如下：\n```dart\nconst DecoratedBox({\n  Decoration decoration,\n  DecorationPosition position = DecorationPosition.background,\n  Widget child\n})\n```\n- decoration：代表将要绘制的装饰，它类型为Decoration，Decoration是一个抽象类，它定义了一个接口 createBoxPainter()，子类的主要职责是需要通过实现它来创建一个画笔，该画笔用于绘制装饰。\n- position：此属性决定在哪里绘制Decoration，它接收DecorationPosition的枚举类型，该枚举类两个值：\n- background：在子widget之后绘制，即背景装饰。\n- foreground：在子widget之上绘制，即前景。\n## BoxDecoration\n我们通常会直接使用BoxDecoration，它是一个Decoration的子类，实现了常用的装饰元素的绘制。\n```dart\nBoxDecoration({\n  Color color, //颜色\n  DecorationImage image,//图片\n  BoxBorder border, //边框\n  BorderRadiusGeometry borderRadius, //圆角\n  List<BoxShadow> boxShadow, //阴影,可以指定多个\n  Gradient gradient, //渐变\n  BlendMode backgroundBlendMode, //背景混合模式\n  BoxShape shape = BoxShape.rectangle, //形状\n})\n```\n各个属性名都是自解释的，详情读者可以查看API文档，我们看一个示例：\n```dart\n DecoratedBox(\n    decoration: BoxDecoration(\n      gradient: LinearGradient(colors:[Colors.red,Colors.orange[700]]), //背景渐变\n      borderRadius: BorderRadius.circular(3.0), //3像素圆角\n      boxShadow: [ //阴影\n        BoxShadow(\n            color:Colors.black54,\n            offset: Offset(2.0,2.0),\n            blurRadius: 4.0\n        )\n      ]\n    ),\n  child: Padding(padding: EdgeInsets.symmetric(horizontal: 80.0, vertical: 18.0),\n    child: Text(\"Login\", style: TextStyle(color: Colors.white),),\n  )\n)\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910115903588.png)\n\n怎么样，通过BoxDecoration，我们实现了一个渐变按钮的外观，但此示例还不是一个标准的按钮，因为它还不能响应点击事件，我们将在本章末尾来实现一个完整的GradientButton。","slug":"flutter/容器/布局限制容器ConstrainedBox和SizedBox","published":1,"updated":"2019-10-02T11:58:29.247Z","layout":"post","photos":[],"link":"","_id":"ck19bvb6q006m00wkc6236kzp","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的。SizedBox只是ConstrainedBox一个定制，本节把他们放在一起讨论。</p>\n</blockquote>\n<h2 id=\"ConstrainedBox\"><a href=\"#ConstrainedBox\" class=\"headerlink\" title=\"ConstrainedBox\"></a>ConstrainedBox</h2><p>ConstrainedBox用于对齐子Widget添加额外约束。例如，如果想让子Widget的最小高度为80像素，可以使用<code>const BoxConstraints(minHeight: 80.0)</code>作为widget的约束。</p>\n<p>我们先定义一个redBox，设置他的背景为红色，不指定高宽</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget redBox = DecorateBox(</span><br><span class=\"line\">    decoration: BoxCoration(color: Colors.red),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>我们实现一个最小高度为50，宽度尽可能大的红色容器</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints(</span><br><span class=\"line\">    minWidth: <span class=\"built_in\">double</span>.infinity,<span class=\"comment\">// 尽可能大</span></span><br><span class=\"line\">    minHeight: <span class=\"number\">50.0</span>,<span class=\"comment\">// 最小高度 50像素</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    child: Container(</span><br><span class=\"line\">    height: <span class=\"number\">5.0</span>,</span><br><span class=\"line\">    child: redBox,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，我们虽然将Container的高度设置为5像素，但是最终却是50像素，这正是ConstrainedBox的最小高度限制生效了。如果将Container的高度设置为80像素，那么最终红色区域的高度也会是80像素，因为在此示例中，ConstrainedBox只限制了最小高度，并未限制最大高度。</p>\n<h2 id=\"BoxConstraints\"><a href=\"#BoxConstraints\" class=\"headerlink\" title=\"BoxConstraints\"></a>BoxConstraints</h2><p>BoxConstraints用于设置限制条件</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BoxConstraints(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.minWidth = <span class=\"number\">0.0</span>,<span class=\"comment\">// 最小宽度</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxWidth = <span class=\"built_in\">double</span>.infinity,<span class=\"comment\">// 最大宽度</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.minHeight = <span class=\"number\">0.0</span>,<span class=\"comment\">// 最小高度</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxHeight = <span class=\"built_in\">double</span>.infinity <span class=\"comment\">// 最大高度    </span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>BoxConstraints还定义了一些便捷的构造函数，用于快速生成特定限制规则的BoxConstraints，如<code>BoxConstraints.tight(Size size)</code>，它可以生成给定大小的限制；const <code>BoxConstraints.expand()</code>可以生成一个尽可能大的用以填充另一个容器的BoxConstraints。</p>\n<h2 id=\"SizedBox\"><a href=\"#SizedBox\" class=\"headerlink\" title=\"SizedBox\"></a>SizedBox</h2><blockquote>\n<p>为子Widget指定指定高宽</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SizedBox(</span><br><span class=\"line\">  width: <span class=\"number\">80.0</span>,</span><br><span class=\"line\">  height: <span class=\"number\">80.0</span>,</span><br><span class=\"line\">  child: redBox</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>实际上SizedBox和只是ConstrainedBox一个定制，上面代码等价于：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">  constraints: BoxConstraints.tightFor(width: <span class=\"number\">80.0</span>,height: <span class=\"number\">80.0</span>),</span><br><span class=\"line\">  child: redBox, </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>而BoxConstraints.tightFor(width: 80.0,height: 80.0)等价于：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BoxConstraints(minHeight: <span class=\"number\">80.0</span>,maxHeight: <span class=\"number\">80.0</span>,minWidth: <span class=\"number\">80.0</span>,maxWidth: <span class=\"number\">80.0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>而实际上ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的，我们可以看到ConstrainedBox和SizedBox的createRenderObject()方法都返回的是一个RenderConstrainedBox对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">RenderConstrainedBox createRenderObject(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RenderConstrainedBox(</span><br><span class=\"line\">    additionalConstraints: ...,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多重限制\"><a href=\"#多重限制\" class=\"headerlink\" title=\"多重限制\"></a>多重限制</h2><p>如果某一个widget有多个父ConstrainedBox限制，那么最终会是哪个生效？我们看一个例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints(minWidth: <span class=\"number\">60.0</span>, minHeight: <span class=\"number\">60.0</span>), <span class=\"comment\">//父</span></span><br><span class=\"line\">    child: ConstrainedBox(</span><br><span class=\"line\">      constraints: BoxConstraints(minWidth: <span class=\"number\">90.0</span>, minHeight: <span class=\"number\">20.0</span>),<span class=\"comment\">//子</span></span><br><span class=\"line\">      child: redBox,</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>上面我们有父子两个ConstrainedBox，他们的限制条件不同。</p>\n<p>最终显示效果是宽90，高60，也就是说是子ConstrainedBox的minWidth生效，而minHeight是父ConstrainedBox生效。单凭这个例子，我们还总结不出什么规律，我们将上例中父子限制条件换一下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints(minWidth: <span class=\"number\">90.0</span>, minHeight: <span class=\"number\">20.0</span>),</span><br><span class=\"line\">    child: ConstrainedBox(</span><br><span class=\"line\">      constraints: BoxConstraints(minWidth: <span class=\"number\">60.0</span>, minHeight: <span class=\"number\">60.0</span>),</span><br><span class=\"line\">      child: redBox,</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>最终的显示效果仍然是90，高60，效果相同，但意义不同，因为此时minWidth生效的是父ConstrainedBox，而minHeight是子ConstrainedBox生效。</p>\n<p>通过上面示例，我们发现有多重限制时，对于minWidth和minHeight来说，是取父子中相应数值较大的。实际上，只有这样才能保证父限制与子限制不冲突。</p>\n<h2 id=\"UnconstrainedBox\"><a href=\"#UnconstrainedBox\" class=\"headerlink\" title=\"UnconstrainedBox\"></a>UnconstrainedBox</h2><p>UnconstrainedBox不会对子Widget产生任何限制，它允许其子Widget按照其本身大小绘制。一般情况下，我们会很少直接使用此widget，但在”去除”多重限制的时候也许会有帮助，我们看一下面的代码：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints(minWidth: <span class=\"number\">60.0</span>, minHeight: <span class=\"number\">100.0</span>),  <span class=\"comment\">//父</span></span><br><span class=\"line\">    child: UnconstrainedBox( <span class=\"comment\">//“去除”父级限制</span></span><br><span class=\"line\">      child: ConstrainedBox(</span><br><span class=\"line\">        constraints: BoxConstraints(minWidth: <span class=\"number\">90.0</span>, minHeight: <span class=\"number\">20.0</span>),<span class=\"comment\">//子</span></span><br><span class=\"line\">        child: redBox,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果没有中间的UnconstrainedBox，那么根据上面所述的多重限制规则，那么最终将显示一个90×100的红色框。但是由于 UnconstrainedBox “去除”了父ConstrainedBox的限制，则最终会按照子ConstrainedBox的限制来绘制redBox，即90×20：</p>\n<p>但是，UnconstrainedBox对父限制的“去除”并非是真正的去除，上面例子中虽然红色区域大小是90×20，但上方仍然有80的空白空间。也就是说父限制的minHeight(100.0)仍然是生效的，只不过它不影响最终子元素的大小，但仍然还是占有相应的空间，可以认为此时的父ConstrainedBox是作用于子ConstrainedBox上，而redBox只受子ConstrainedBox限制，这一点请读者务必注意。</p>\n<p>那么有什么方法可以彻底去除父BoxConstraints的限制吗？答案是否定的！所以在此提示读者，在定义一个通用的widget时，如果对子widget指定限制时一定要注意，因为一旦指定限制条件，子widget如果要进行相关自定义大小时将可能非常困难，因为子widget在不更改父widget的代码的情况下无法彻底去除其限制条件。</p>\n<h2 id=\"DecoratedBox\"><a href=\"#DecoratedBox\" class=\"headerlink\" title=\"DecoratedBox\"></a>DecoratedBox</h2><p>DecoratedBox可以在其子widget绘制前(或后)绘制一个装饰Decoration（如背景、边框、渐变等）。DecoratedBox定义如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DecoratedBox(&#123;</span><br><span class=\"line\">  Decoration decoration,</span><br><span class=\"line\">  DecorationPosition position = DecorationPosition.background,</span><br><span class=\"line\">  Widget child</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>decoration：代表将要绘制的装饰，它类型为Decoration，Decoration是一个抽象类，它定义了一个接口 createBoxPainter()，子类的主要职责是需要通过实现它来创建一个画笔，该画笔用于绘制装饰。</li>\n<li>position：此属性决定在哪里绘制Decoration，它接收DecorationPosition的枚举类型，该枚举类两个值：</li>\n<li>background：在子widget之后绘制，即背景装饰。</li>\n<li>foreground：在子widget之上绘制，即前景。<h2 id=\"BoxDecoration\"><a href=\"#BoxDecoration\" class=\"headerlink\" title=\"BoxDecoration\"></a>BoxDecoration</h2>我们通常会直接使用BoxDecoration，它是一个Decoration的子类，实现了常用的装饰元素的绘制。<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BoxDecoration(&#123;</span><br><span class=\"line\">  Color color, <span class=\"comment\">//颜色</span></span><br><span class=\"line\">  DecorationImage image,<span class=\"comment\">//图片</span></span><br><span class=\"line\">  BoxBorder border, <span class=\"comment\">//边框</span></span><br><span class=\"line\">  BorderRadiusGeometry borderRadius, <span class=\"comment\">//圆角</span></span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;BoxShadow&gt; boxShadow, <span class=\"comment\">//阴影,可以指定多个</span></span><br><span class=\"line\">  Gradient gradient, <span class=\"comment\">//渐变</span></span><br><span class=\"line\">  BlendMode backgroundBlendMode, <span class=\"comment\">//背景混合模式</span></span><br><span class=\"line\">  BoxShape shape = BoxShape.rectangle, <span class=\"comment\">//形状</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>各个属性名都是自解释的，详情读者可以查看API文档，我们看一个示例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> DecoratedBox(</span><br><span class=\"line\">    decoration: BoxDecoration(</span><br><span class=\"line\">      gradient: LinearGradient(colors:[Colors.red,Colors.orange[<span class=\"number\">700</span>]]), <span class=\"comment\">//背景渐变</span></span><br><span class=\"line\">      borderRadius: BorderRadius.circular(<span class=\"number\">3.0</span>), <span class=\"comment\">//3像素圆角</span></span><br><span class=\"line\">      boxShadow: [ <span class=\"comment\">//阴影</span></span><br><span class=\"line\">        BoxShadow(</span><br><span class=\"line\">            color:Colors.black54,</span><br><span class=\"line\">            offset: Offset(<span class=\"number\">2.0</span>,<span class=\"number\">2.0</span>),</span><br><span class=\"line\">            blurRadius: <span class=\"number\">4.0</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  child: Padding(padding: EdgeInsets.symmetric(horizontal: <span class=\"number\">80.0</span>, vertical: <span class=\"number\">18.0</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"Login\"</span>, style: TextStyle(color: Colors.white),),</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910115903588.png\" alt></p>\n<p>怎么样，通过BoxDecoration，我们实现了一个渐变按钮的外观，但此示例还不是一个标准的按钮，因为它还不能响应点击事件，我们将在本章末尾来实现一个完整的GradientButton。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><blockquote>\n<p>ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的。SizedBox只是ConstrainedBox一个定制，本节把他们放在一起讨论。</p>\n</blockquote>\n<h2 id=\"ConstrainedBox\"><a href=\"#ConstrainedBox\" class=\"headerlink\" title=\"ConstrainedBox\"></a>ConstrainedBox</h2><p>ConstrainedBox用于对齐子Widget添加额外约束。例如，如果想让子Widget的最小高度为80像素，可以使用<code>const BoxConstraints(minHeight: 80.0)</code>作为widget的约束。</p>\n<p>我们先定义一个redBox，设置他的背景为红色，不指定高宽</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget redBox = DecorateBox(</span><br><span class=\"line\">    decoration: BoxCoration(color: Colors.red),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>我们实现一个最小高度为50，宽度尽可能大的红色容器</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints(</span><br><span class=\"line\">    minWidth: <span class=\"built_in\">double</span>.infinity,<span class=\"comment\">// 尽可能大</span></span><br><span class=\"line\">    minHeight: <span class=\"number\">50.0</span>,<span class=\"comment\">// 最小高度 50像素</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    child: Container(</span><br><span class=\"line\">    height: <span class=\"number\">5.0</span>,</span><br><span class=\"line\">    child: redBox,</span><br><span class=\"line\">    ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，我们虽然将Container的高度设置为5像素，但是最终却是50像素，这正是ConstrainedBox的最小高度限制生效了。如果将Container的高度设置为80像素，那么最终红色区域的高度也会是80像素，因为在此示例中，ConstrainedBox只限制了最小高度，并未限制最大高度。</p>\n<h2 id=\"BoxConstraints\"><a href=\"#BoxConstraints\" class=\"headerlink\" title=\"BoxConstraints\"></a>BoxConstraints</h2><p>BoxConstraints用于设置限制条件</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BoxConstraints(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.minWidth = <span class=\"number\">0.0</span>,<span class=\"comment\">// 最小宽度</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxWidth = <span class=\"built_in\">double</span>.infinity,<span class=\"comment\">// 最大宽度</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.minHeight = <span class=\"number\">0.0</span>,<span class=\"comment\">// 最小高度</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxHeight = <span class=\"built_in\">double</span>.infinity <span class=\"comment\">// 最大高度    </span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>BoxConstraints还定义了一些便捷的构造函数，用于快速生成特定限制规则的BoxConstraints，如<code>BoxConstraints.tight(Size size)</code>，它可以生成给定大小的限制；const <code>BoxConstraints.expand()</code>可以生成一个尽可能大的用以填充另一个容器的BoxConstraints。</p>\n<h2 id=\"SizedBox\"><a href=\"#SizedBox\" class=\"headerlink\" title=\"SizedBox\"></a>SizedBox</h2><blockquote>\n<p>为子Widget指定指定高宽</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SizedBox(</span><br><span class=\"line\">  width: <span class=\"number\">80.0</span>,</span><br><span class=\"line\">  height: <span class=\"number\">80.0</span>,</span><br><span class=\"line\">  child: redBox</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>实际上SizedBox和只是ConstrainedBox一个定制，上面代码等价于：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">  constraints: BoxConstraints.tightFor(width: <span class=\"number\">80.0</span>,height: <span class=\"number\">80.0</span>),</span><br><span class=\"line\">  child: redBox, </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>而BoxConstraints.tightFor(width: 80.0,height: 80.0)等价于：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BoxConstraints(minHeight: <span class=\"number\">80.0</span>,maxHeight: <span class=\"number\">80.0</span>,minWidth: <span class=\"number\">80.0</span>,maxWidth: <span class=\"number\">80.0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>而实际上ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的，我们可以看到ConstrainedBox和SizedBox的createRenderObject()方法都返回的是一个RenderConstrainedBox对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">RenderConstrainedBox createRenderObject(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RenderConstrainedBox(</span><br><span class=\"line\">    additionalConstraints: ...,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多重限制\"><a href=\"#多重限制\" class=\"headerlink\" title=\"多重限制\"></a>多重限制</h2><p>如果某一个widget有多个父ConstrainedBox限制，那么最终会是哪个生效？我们看一个例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints(minWidth: <span class=\"number\">60.0</span>, minHeight: <span class=\"number\">60.0</span>), <span class=\"comment\">//父</span></span><br><span class=\"line\">    child: ConstrainedBox(</span><br><span class=\"line\">      constraints: BoxConstraints(minWidth: <span class=\"number\">90.0</span>, minHeight: <span class=\"number\">20.0</span>),<span class=\"comment\">//子</span></span><br><span class=\"line\">      child: redBox,</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>上面我们有父子两个ConstrainedBox，他们的限制条件不同。</p>\n<p>最终显示效果是宽90，高60，也就是说是子ConstrainedBox的minWidth生效，而minHeight是父ConstrainedBox生效。单凭这个例子，我们还总结不出什么规律，我们将上例中父子限制条件换一下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints(minWidth: <span class=\"number\">90.0</span>, minHeight: <span class=\"number\">20.0</span>),</span><br><span class=\"line\">    child: ConstrainedBox(</span><br><span class=\"line\">      constraints: BoxConstraints(minWidth: <span class=\"number\">60.0</span>, minHeight: <span class=\"number\">60.0</span>),</span><br><span class=\"line\">      child: redBox,</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>最终的显示效果仍然是90，高60，效果相同，但意义不同，因为此时minWidth生效的是父ConstrainedBox，而minHeight是子ConstrainedBox生效。</p>\n<p>通过上面示例，我们发现有多重限制时，对于minWidth和minHeight来说，是取父子中相应数值较大的。实际上，只有这样才能保证父限制与子限制不冲突。</p>\n<h2 id=\"UnconstrainedBox\"><a href=\"#UnconstrainedBox\" class=\"headerlink\" title=\"UnconstrainedBox\"></a>UnconstrainedBox</h2><p>UnconstrainedBox不会对子Widget产生任何限制，它允许其子Widget按照其本身大小绘制。一般情况下，我们会很少直接使用此widget，但在”去除”多重限制的时候也许会有帮助，我们看一下面的代码：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints(minWidth: <span class=\"number\">60.0</span>, minHeight: <span class=\"number\">100.0</span>),  <span class=\"comment\">//父</span></span><br><span class=\"line\">    child: UnconstrainedBox( <span class=\"comment\">//“去除”父级限制</span></span><br><span class=\"line\">      child: ConstrainedBox(</span><br><span class=\"line\">        constraints: BoxConstraints(minWidth: <span class=\"number\">90.0</span>, minHeight: <span class=\"number\">20.0</span>),<span class=\"comment\">//子</span></span><br><span class=\"line\">        child: redBox,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，如果没有中间的UnconstrainedBox，那么根据上面所述的多重限制规则，那么最终将显示一个90×100的红色框。但是由于 UnconstrainedBox “去除”了父ConstrainedBox的限制，则最终会按照子ConstrainedBox的限制来绘制redBox，即90×20：</p>\n<p>但是，UnconstrainedBox对父限制的“去除”并非是真正的去除，上面例子中虽然红色区域大小是90×20，但上方仍然有80的空白空间。也就是说父限制的minHeight(100.0)仍然是生效的，只不过它不影响最终子元素的大小，但仍然还是占有相应的空间，可以认为此时的父ConstrainedBox是作用于子ConstrainedBox上，而redBox只受子ConstrainedBox限制，这一点请读者务必注意。</p>\n<p>那么有什么方法可以彻底去除父BoxConstraints的限制吗？答案是否定的！所以在此提示读者，在定义一个通用的widget时，如果对子widget指定限制时一定要注意，因为一旦指定限制条件，子widget如果要进行相关自定义大小时将可能非常困难，因为子widget在不更改父widget的代码的情况下无法彻底去除其限制条件。</p>\n<h2 id=\"DecoratedBox\"><a href=\"#DecoratedBox\" class=\"headerlink\" title=\"DecoratedBox\"></a>DecoratedBox</h2><p>DecoratedBox可以在其子widget绘制前(或后)绘制一个装饰Decoration（如背景、边框、渐变等）。DecoratedBox定义如下：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> DecoratedBox(&#123;</span><br><span class=\"line\">  Decoration decoration,</span><br><span class=\"line\">  DecorationPosition position = DecorationPosition.background,</span><br><span class=\"line\">  Widget child</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>decoration：代表将要绘制的装饰，它类型为Decoration，Decoration是一个抽象类，它定义了一个接口 createBoxPainter()，子类的主要职责是需要通过实现它来创建一个画笔，该画笔用于绘制装饰。</li>\n<li>position：此属性决定在哪里绘制Decoration，它接收DecorationPosition的枚举类型，该枚举类两个值：</li>\n<li>background：在子widget之后绘制，即背景装饰。</li>\n<li>foreground：在子widget之上绘制，即前景。<h2 id=\"BoxDecoration\"><a href=\"#BoxDecoration\" class=\"headerlink\" title=\"BoxDecoration\"></a>BoxDecoration</h2>我们通常会直接使用BoxDecoration，它是一个Decoration的子类，实现了常用的装饰元素的绘制。<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BoxDecoration(&#123;</span><br><span class=\"line\">  Color color, <span class=\"comment\">//颜色</span></span><br><span class=\"line\">  DecorationImage image,<span class=\"comment\">//图片</span></span><br><span class=\"line\">  BoxBorder border, <span class=\"comment\">//边框</span></span><br><span class=\"line\">  BorderRadiusGeometry borderRadius, <span class=\"comment\">//圆角</span></span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;BoxShadow&gt; boxShadow, <span class=\"comment\">//阴影,可以指定多个</span></span><br><span class=\"line\">  Gradient gradient, <span class=\"comment\">//渐变</span></span><br><span class=\"line\">  BlendMode backgroundBlendMode, <span class=\"comment\">//背景混合模式</span></span><br><span class=\"line\">  BoxShape shape = BoxShape.rectangle, <span class=\"comment\">//形状</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>各个属性名都是自解释的，详情读者可以查看API文档，我们看一个示例：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> DecoratedBox(</span><br><span class=\"line\">    decoration: BoxDecoration(</span><br><span class=\"line\">      gradient: LinearGradient(colors:[Colors.red,Colors.orange[<span class=\"number\">700</span>]]), <span class=\"comment\">//背景渐变</span></span><br><span class=\"line\">      borderRadius: BorderRadius.circular(<span class=\"number\">3.0</span>), <span class=\"comment\">//3像素圆角</span></span><br><span class=\"line\">      boxShadow: [ <span class=\"comment\">//阴影</span></span><br><span class=\"line\">        BoxShadow(</span><br><span class=\"line\">            color:Colors.black54,</span><br><span class=\"line\">            offset: Offset(<span class=\"number\">2.0</span>,<span class=\"number\">2.0</span>),</span><br><span class=\"line\">            blurRadius: <span class=\"number\">4.0</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  child: Padding(padding: EdgeInsets.symmetric(horizontal: <span class=\"number\">80.0</span>, vertical: <span class=\"number\">18.0</span>),</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"Login\"</span>, style: TextStyle(color: Colors.white),),</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180910115903588.png\" alt></p>\n<p>怎么样，通过BoxDecoration，我们实现了一个渐变按钮的外观，但此示例还不是一个标准的按钮，因为它还不能响应点击事件，我们将在本章末尾来实现一个完整的GradientButton。</p>\n"},{"title":"Stack&Positioned","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T08:33:00.000Z","_content":"## 层叠布局\n层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。\n## Stack\n```dart\nStack({\n  this.alignment = AlignmentDirectional.topStart,\n  this.textDirection,\n  this.fit = StackFit.loose,\n  this.overflow = Overflow.clip,\n  List<Widget> children = const <Widget>[],\n})\n```\n- alignment：此参数决定如何去对齐没有定位（没有使用Positioned）或部分定位的子widget。所谓部分定位，在这里特指没有在某一个轴上定位：left、right为横轴，top、bottom为纵轴，只要包含某个轴上的一个定位属性就算在该轴上有定位。\n- textDirection：和Row、Wrap的textDirection功能一样，都用于决定alignment对齐的参考系即：textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右；textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左。\n- fit：此参数用于决定没有定位的子widget如何去适应Stack的大小。StackFit.loose表示使用子widget的大小，StackFit.expand表示扩伸到Stack的大小。\n- overflow：此属性决定如何显示超出Stack显示空间的子widget，值为Overflow.clip时，超出部分会被剪裁（隐藏），值为Overflow.visible 时则不会。\n\n## Positioned\n```dart\nconst Positioned({\n  Key key,\n  this.left, \n  this.top,\n  this.right,\n  this.bottom,\n  this.width,\n  this.height,\n  @required Widget child,\n})\n```\nleft、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离。width和height用于指定定位元素的宽度和高度，注意，此处的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位widget，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理。\n\n示例\n```dart\n//通过ConstrainedBox来确保Stack占满屏幕\nConstrainedBox(\n    constraints: BoxConstraints.expand(),\n    child: Stack(\n    alignment: Alignment.center, //指定未定位或部分定位widget的对齐方式\n    children: <Widget>[\n        Container(\n        child: Text(\"第一层\", style: TextStyle(color: Colors.white)),\n        color: Colors.red,\n        ),\n        Positioned(\n        left: 18.0,\n        child: Text(\"第二层\"),\n        ),\n        Container(\n        alignment: Alignment.centerRight,\n        child: Text(\"第三层半透明\", style: TextStyle(color: Colors.blue)),\n        color: Color.fromARGB(100, 255, 0, 255),\n        ),\n        Positioned(\n        top: 18.0,\n        child: Text(\"第四层\"),\n        )\n    ],\n    ),\n);\n```\n![](../img/stack_positioned.png)\n\n","source":"_posts/flutter/布局/Stack&Positioned.md","raw":"---\ntitle: Stack&Positioned\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- 布局\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 16:33:00   \n---\n## 层叠布局\n层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。\n## Stack\n```dart\nStack({\n  this.alignment = AlignmentDirectional.topStart,\n  this.textDirection,\n  this.fit = StackFit.loose,\n  this.overflow = Overflow.clip,\n  List<Widget> children = const <Widget>[],\n})\n```\n- alignment：此参数决定如何去对齐没有定位（没有使用Positioned）或部分定位的子widget。所谓部分定位，在这里特指没有在某一个轴上定位：left、right为横轴，top、bottom为纵轴，只要包含某个轴上的一个定位属性就算在该轴上有定位。\n- textDirection：和Row、Wrap的textDirection功能一样，都用于决定alignment对齐的参考系即：textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右；textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左。\n- fit：此参数用于决定没有定位的子widget如何去适应Stack的大小。StackFit.loose表示使用子widget的大小，StackFit.expand表示扩伸到Stack的大小。\n- overflow：此属性决定如何显示超出Stack显示空间的子widget，值为Overflow.clip时，超出部分会被剪裁（隐藏），值为Overflow.visible 时则不会。\n\n## Positioned\n```dart\nconst Positioned({\n  Key key,\n  this.left, \n  this.top,\n  this.right,\n  this.bottom,\n  this.width,\n  this.height,\n  @required Widget child,\n})\n```\nleft、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离。width和height用于指定定位元素的宽度和高度，注意，此处的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位widget，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理。\n\n示例\n```dart\n//通过ConstrainedBox来确保Stack占满屏幕\nConstrainedBox(\n    constraints: BoxConstraints.expand(),\n    child: Stack(\n    alignment: Alignment.center, //指定未定位或部分定位widget的对齐方式\n    children: <Widget>[\n        Container(\n        child: Text(\"第一层\", style: TextStyle(color: Colors.white)),\n        color: Colors.red,\n        ),\n        Positioned(\n        left: 18.0,\n        child: Text(\"第二层\"),\n        ),\n        Container(\n        alignment: Alignment.centerRight,\n        child: Text(\"第三层半透明\", style: TextStyle(color: Colors.blue)),\n        color: Color.fromARGB(100, 255, 0, 255),\n        ),\n        Positioned(\n        top: 18.0,\n        child: Text(\"第四层\"),\n        )\n    ],\n    ),\n);\n```\n![](../img/stack_positioned.png)\n\n","slug":"flutter/布局/Stack&Positioned","published":1,"updated":"2019-10-02T11:55:20.803Z","layout":"post","photos":[],"link":"","_id":"ck19bvb6u006o00wkytfev1he","content":"<h2 id=\"层叠布局\"><a href=\"#层叠布局\" class=\"headerlink\" title=\"层叠布局\"></a>层叠布局</h2><p>层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。</p>\n<h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack(&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alignment = AlignmentDirectional.topStart,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textDirection,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.fit = StackFit.loose,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.overflow = Overflow.clip,</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>alignment：此参数决定如何去对齐没有定位（没有使用Positioned）或部分定位的子widget。所谓部分定位，在这里特指没有在某一个轴上定位：left、right为横轴，top、bottom为纵轴，只要包含某个轴上的一个定位属性就算在该轴上有定位。</li>\n<li>textDirection：和Row、Wrap的textDirection功能一样，都用于决定alignment对齐的参考系即：textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右；textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左。</li>\n<li>fit：此参数用于决定没有定位的子widget如何去适应Stack的大小。StackFit.loose表示使用子widget的大小，StackFit.expand表示扩伸到Stack的大小。</li>\n<li>overflow：此属性决定如何显示超出Stack显示空间的子widget，值为Overflow.clip时，超出部分会被剪裁（隐藏），值为Overflow.visible 时则不会。</li>\n</ul>\n<h2 id=\"Positioned\"><a href=\"#Positioned\" class=\"headerlink\" title=\"Positioned\"></a>Positioned</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Positioned(&#123;</span><br><span class=\"line\">  Key key,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.left, </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.top,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.right,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bottom,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.width,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.height,</span><br><span class=\"line\">  <span class=\"meta\">@required</span> Widget child,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>left、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离。width和height用于指定定位元素的宽度和高度，注意，此处的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位widget，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理。</p>\n<p>示例</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过ConstrainedBox来确保Stack占满屏幕</span></span><br><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints.expand(),</span><br><span class=\"line\">    child: Stack(</span><br><span class=\"line\">    alignment: Alignment.center, <span class=\"comment\">//指定未定位或部分定位widget的对齐方式</span></span><br><span class=\"line\">    children: &lt;Widget&gt;[</span><br><span class=\"line\">        Container(</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"第一层\"</span>, style: TextStyle(color: Colors.white)),</span><br><span class=\"line\">        color: Colors.red,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        Positioned(</span><br><span class=\"line\">        left: <span class=\"number\">18.0</span>,</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"第二层\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        Container(</span><br><span class=\"line\">        alignment: Alignment.centerRight,</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"第三层半透明\"</span>, style: TextStyle(color: Colors.blue)),</span><br><span class=\"line\">        color: Color.fromARGB(<span class=\"number\">100</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        Positioned(</span><br><span class=\"line\">        top: <span class=\"number\">18.0</span>,</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"第四层\"</span>),</span><br><span class=\"line\">        )</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"../img/stack_positioned.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"层叠布局\"><a href=\"#层叠布局\" class=\"headerlink\" title=\"层叠布局\"></a>层叠布局</h2><p>层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子widget可以根据到父容器四个角的位置来确定本身的位置。绝对定位允许子widget堆叠（按照代码中声明的顺序）。Flutter中使用Stack和Positioned来实现绝对定位，Stack允许子widget堆叠，而Positioned可以给子widget定位（根据Stack的四个角）。</p>\n<h2 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack(&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alignment = AlignmentDirectional.topStart,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textDirection,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.fit = StackFit.loose,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.overflow = Overflow.clip,</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>alignment：此参数决定如何去对齐没有定位（没有使用Positioned）或部分定位的子widget。所谓部分定位，在这里特指没有在某一个轴上定位：left、right为横轴，top、bottom为纵轴，只要包含某个轴上的一个定位属性就算在该轴上有定位。</li>\n<li>textDirection：和Row、Wrap的textDirection功能一样，都用于决定alignment对齐的参考系即：textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右；textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左。</li>\n<li>fit：此参数用于决定没有定位的子widget如何去适应Stack的大小。StackFit.loose表示使用子widget的大小，StackFit.expand表示扩伸到Stack的大小。</li>\n<li>overflow：此属性决定如何显示超出Stack显示空间的子widget，值为Overflow.clip时，超出部分会被剪裁（隐藏），值为Overflow.visible 时则不会。</li>\n</ul>\n<h2 id=\"Positioned\"><a href=\"#Positioned\" class=\"headerlink\" title=\"Positioned\"></a>Positioned</h2><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Positioned(&#123;</span><br><span class=\"line\">  Key key,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.left, </span><br><span class=\"line\">  <span class=\"keyword\">this</span>.top,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.right,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bottom,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.width,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.height,</span><br><span class=\"line\">  <span class=\"meta\">@required</span> Widget child,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>left、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离。width和height用于指定定位元素的宽度和高度，注意，此处的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位widget，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理。</p>\n<p>示例</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过ConstrainedBox来确保Stack占满屏幕</span></span><br><span class=\"line\">ConstrainedBox(</span><br><span class=\"line\">    constraints: BoxConstraints.expand(),</span><br><span class=\"line\">    child: Stack(</span><br><span class=\"line\">    alignment: Alignment.center, <span class=\"comment\">//指定未定位或部分定位widget的对齐方式</span></span><br><span class=\"line\">    children: &lt;Widget&gt;[</span><br><span class=\"line\">        Container(</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"第一层\"</span>, style: TextStyle(color: Colors.white)),</span><br><span class=\"line\">        color: Colors.red,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        Positioned(</span><br><span class=\"line\">        left: <span class=\"number\">18.0</span>,</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"第二层\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        Container(</span><br><span class=\"line\">        alignment: Alignment.centerRight,</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"第三层半透明\"</span>, style: TextStyle(color: Colors.blue)),</span><br><span class=\"line\">        color: Color.fromARGB(<span class=\"number\">100</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        Positioned(</span><br><span class=\"line\">        top: <span class=\"number\">18.0</span>,</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"第四层\"</span>),</span><br><span class=\"line\">        )</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    ),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"../img/stack_positioned.png\" alt></p>\n"},{"title":"Wrap&Flow","author":"JsonYe","copyright":true,"comments":1,"toc":true,"date":"2019-02-26T08:16:00.000Z","_content":"## Wrap\n在介绍Row和Colum时，如果子widget超出屏幕范围，则会报溢出错误，如：\n```dart\nRow(\n  children: <Widget>[\n    Text(\"xxx\"*100)\n  ],\n);\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905171113290.png)\n\n可以看到，右边溢出部分报错。这是因为Row默认只有一行，如果超出屏幕不会折行。我们把超出屏幕显示范围会自动折行的布局称为流式布局。Flutter中通过Wrap和Flow来支持流式布局，将上例中的Row换成Wrap后溢出部分则会自动折行。下面是Wrap的定义:\n\n```dart\nWrap({\n  ...\n  this.direction = Axis.horizontal,\n  this.alignment = WrapAlignment.start,\n  this.spacing = 0.0,\n  this.runAlignment = WrapAlignment.start,\n  this.runSpacing = 0.0,\n  this.crossAxisAlignment = WrapCrossAlignment.start,\n  this.textDirection,\n  this.verticalDirection = VerticalDirection.down,\n  List<Widget> children = const <Widget>[],\n})\n```\n\n我们可以看到Wrap的很多属性在Row（包括Flex和Column）中也有，如`direction`、`crossAxisAlignment`、`textDirection`、`verticalDirection`等，这些参数意义是相同的，我们不再重复介绍，读者可以查阅前面介绍Row的部分。读者可以认为Wrap和Flex（包括Row和Column）除了超出显示范围后Wrap会折行外，其它行为基本相同。下面我们看一下Wrap特有的几个属性：\n- spacing：主轴方向子widget的间距\n- runSpacing：纵轴方向的间距\n- runAlignment：纵轴方向的对齐方式\n下面看一个示例子：\n```dart\nWrap(\n  spacing: 8.0, // 主轴(水平)方向间距\n  runSpacing: 4.0, // 纵轴（垂直）方向间距\n  alignment: WrapAlignment.center, //沿主轴方向居中\n  children: <Widget>[\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('A')),\n      label: new Text('Hamilton'),\n    ),\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('M')),\n      label: new Text('Lafayette'),\n    ),\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('H')),\n      label: new Text('Mulligan'),\n    ),\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('J')),\n      label: new Text('Laurens'),\n    ),\n  ],\n)\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905173658950.png)\n\n## Flow\n我们一般很少会使用Flow，因为其过于复杂，需要自己实现子widget的位置转换，在很多场景下首先要考虑的是Wrap是否满足需求。Flow主要用于一些需要自定义布局策略或性能要求较高(如动画中)的场景。\n\n### 优点\n\n- **性能好**：Flow是一个对child尺寸以及位置调整非常高效的控件，Flow用转换矩阵（transformation matrices）在对child进行位置调整的时候进行了优化：在Flow定位过后，如果child的尺寸或者位置发生了变化，在FlowDelegate中的paintChildren()方法中调用context.paintChild 进行重绘，而context.paintChild在重绘时使用了转换矩阵（transformation matrices），并没有实际调整Widget位置。\n- **灵活**：由于我们需要自己实现FlowDelegate的paintChildren()方法，所以我们需要自己计算每一个widget的位置，因此，可以自定义布局策略。\n- \n### 缺点\n\n- 使用复杂.\n- 不能自适应子widget大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。\n\n### 我们对六个色块进行自定义流式布局：\n\n```dart\nFlow(\n  delegate: TestFlowDelegate(margin: EdgeInsets.all(10.0)),\n  children: <Widget>[\n    new Container(width: 80.0, height:80.0, color: Colors.red,),\n    new Container(width: 80.0, height:80.0, color: Colors.green,),\n    new Container(width: 80.0, height:80.0, color: Colors.blue,),\n    new Container(width: 80.0, height:80.0,  color: Colors.yellow,),\n    new Container(width: 80.0, height:80.0, color: Colors.brown,),\n    new Container(width: 80.0, height:80.0,  color: Colors.purple,),\n  ],\n)\n\nclass TestFlowDelegate extends FlowDelegate {\n  EdgeInsets margin = EdgeInsets.zero;\n  TestFlowDelegate({this.margin});\n  @override\n  void paintChildren(FlowPaintingContext context) {\n    var x = margin.left;\n    var y = margin.top;\n    //计算每一个子widget的位置  \n    for (int i = 0; i < context.childCount; i++) {\n      var w = context.getChildSize(i).width + x + margin.right;\n      if (w < context.size.width) {\n        context.paintChild(i,\n            transform: new Matrix4.translationValues(\n                x, y, 0.0));\n        x = w + margin.left;\n      } else {\n        x = margin.left;\n        y += context.getChildSize(i).height + margin.top + margin.bottom;\n        //绘制子widget(有优化)  \n        context.paintChild(i,\n            transform: new Matrix4.translationValues(\n                x, y, 0.0));\n         x += context.getChildSize(i).width + margin.left + margin.right;\n      }\n    }\n  }\n\n  getSize(BoxConstraints constraints){\n    //指定Flow的大小  \n    return Size(double.infinity,200.0);\n  }\n\n  @override\n  bool shouldRepaint(FlowDelegate oldDelegate) {\n    return oldDelegate != this;\n  }\n}\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905184427501.png)\n\n可以看到我们主要的任务就是实现paintChildren，它的主要任务是确定每个子widget位置。由于Flow不能自适应子widget的大小，我们通过在getSize返回一个固定大小来指定Flow的大小。","source":"_posts/flutter/布局/Wrap&Flow.md","raw":"---\ntitle: Wrap&Flow\nauthor: JsonYe\ntags:\n- flutter\ncategories:\n- Flutter\n- 布局\ncopyright: true\ncomments: true\ntoc: true\ndate: 2019-02-26 16:16:00   \n---\n## Wrap\n在介绍Row和Colum时，如果子widget超出屏幕范围，则会报溢出错误，如：\n```dart\nRow(\n  children: <Widget>[\n    Text(\"xxx\"*100)\n  ],\n);\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905171113290.png)\n\n可以看到，右边溢出部分报错。这是因为Row默认只有一行，如果超出屏幕不会折行。我们把超出屏幕显示范围会自动折行的布局称为流式布局。Flutter中通过Wrap和Flow来支持流式布局，将上例中的Row换成Wrap后溢出部分则会自动折行。下面是Wrap的定义:\n\n```dart\nWrap({\n  ...\n  this.direction = Axis.horizontal,\n  this.alignment = WrapAlignment.start,\n  this.spacing = 0.0,\n  this.runAlignment = WrapAlignment.start,\n  this.runSpacing = 0.0,\n  this.crossAxisAlignment = WrapCrossAlignment.start,\n  this.textDirection,\n  this.verticalDirection = VerticalDirection.down,\n  List<Widget> children = const <Widget>[],\n})\n```\n\n我们可以看到Wrap的很多属性在Row（包括Flex和Column）中也有，如`direction`、`crossAxisAlignment`、`textDirection`、`verticalDirection`等，这些参数意义是相同的，我们不再重复介绍，读者可以查阅前面介绍Row的部分。读者可以认为Wrap和Flex（包括Row和Column）除了超出显示范围后Wrap会折行外，其它行为基本相同。下面我们看一下Wrap特有的几个属性：\n- spacing：主轴方向子widget的间距\n- runSpacing：纵轴方向的间距\n- runAlignment：纵轴方向的对齐方式\n下面看一个示例子：\n```dart\nWrap(\n  spacing: 8.0, // 主轴(水平)方向间距\n  runSpacing: 4.0, // 纵轴（垂直）方向间距\n  alignment: WrapAlignment.center, //沿主轴方向居中\n  children: <Widget>[\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('A')),\n      label: new Text('Hamilton'),\n    ),\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('M')),\n      label: new Text('Lafayette'),\n    ),\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('H')),\n      label: new Text('Mulligan'),\n    ),\n    new Chip(\n      avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('J')),\n      label: new Text('Laurens'),\n    ),\n  ],\n)\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905173658950.png)\n\n## Flow\n我们一般很少会使用Flow，因为其过于复杂，需要自己实现子widget的位置转换，在很多场景下首先要考虑的是Wrap是否满足需求。Flow主要用于一些需要自定义布局策略或性能要求较高(如动画中)的场景。\n\n### 优点\n\n- **性能好**：Flow是一个对child尺寸以及位置调整非常高效的控件，Flow用转换矩阵（transformation matrices）在对child进行位置调整的时候进行了优化：在Flow定位过后，如果child的尺寸或者位置发生了变化，在FlowDelegate中的paintChildren()方法中调用context.paintChild 进行重绘，而context.paintChild在重绘时使用了转换矩阵（transformation matrices），并没有实际调整Widget位置。\n- **灵活**：由于我们需要自己实现FlowDelegate的paintChildren()方法，所以我们需要自己计算每一个widget的位置，因此，可以自定义布局策略。\n- \n### 缺点\n\n- 使用复杂.\n- 不能自适应子widget大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。\n\n### 我们对六个色块进行自定义流式布局：\n\n```dart\nFlow(\n  delegate: TestFlowDelegate(margin: EdgeInsets.all(10.0)),\n  children: <Widget>[\n    new Container(width: 80.0, height:80.0, color: Colors.red,),\n    new Container(width: 80.0, height:80.0, color: Colors.green,),\n    new Container(width: 80.0, height:80.0, color: Colors.blue,),\n    new Container(width: 80.0, height:80.0,  color: Colors.yellow,),\n    new Container(width: 80.0, height:80.0, color: Colors.brown,),\n    new Container(width: 80.0, height:80.0,  color: Colors.purple,),\n  ],\n)\n\nclass TestFlowDelegate extends FlowDelegate {\n  EdgeInsets margin = EdgeInsets.zero;\n  TestFlowDelegate({this.margin});\n  @override\n  void paintChildren(FlowPaintingContext context) {\n    var x = margin.left;\n    var y = margin.top;\n    //计算每一个子widget的位置  \n    for (int i = 0; i < context.childCount; i++) {\n      var w = context.getChildSize(i).width + x + margin.right;\n      if (w < context.size.width) {\n        context.paintChild(i,\n            transform: new Matrix4.translationValues(\n                x, y, 0.0));\n        x = w + margin.left;\n      } else {\n        x = margin.left;\n        y += context.getChildSize(i).height + margin.top + margin.bottom;\n        //绘制子widget(有优化)  \n        context.paintChild(i,\n            transform: new Matrix4.translationValues(\n                x, y, 0.0));\n         x += context.getChildSize(i).width + margin.left + margin.right;\n      }\n    }\n  }\n\n  getSize(BoxConstraints constraints){\n    //指定Flow的大小  \n    return Size(double.infinity,200.0);\n  }\n\n  @override\n  bool shouldRepaint(FlowDelegate oldDelegate) {\n    return oldDelegate != this;\n  }\n}\n```\n![](https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905184427501.png)\n\n可以看到我们主要的任务就是实现paintChildren，它的主要任务是确定每个子widget位置。由于Flow不能自适应子widget的大小，我们通过在getSize返回一个固定大小来指定Flow的大小。","slug":"flutter/布局/Wrap&Flow","published":1,"updated":"2019-10-02T11:55:49.109Z","layout":"post","photos":[],"link":"","_id":"ck19bvb6z006s00wklvn0nec4","content":"<h2 id=\"Wrap\"><a href=\"#Wrap\" class=\"headerlink\" title=\"Wrap\"></a>Wrap</h2><p>在介绍Row和Colum时，如果子widget超出屏幕范围，则会报溢出错误，如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Row(</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    Text(<span class=\"string\">\"xxx\"</span>*<span class=\"number\">100</span>)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905171113290.png\" alt></p>\n<p>可以看到，右边溢出部分报错。这是因为Row默认只有一行，如果超出屏幕不会折行。我们把超出屏幕显示范围会自动折行的布局称为流式布局。Flutter中通过Wrap和Flow来支持流式布局，将上例中的Row换成Wrap后溢出部分则会自动折行。下面是Wrap的定义:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wrap(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.direction = Axis.horizontal,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alignment = WrapAlignment.start,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.spacing = <span class=\"number\">0.0</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.runAlignment = WrapAlignment.start,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.runSpacing = <span class=\"number\">0.0</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textDirection,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到Wrap的很多属性在Row（包括Flex和Column）中也有，如<code>direction</code>、<code>crossAxisAlignment</code>、<code>textDirection</code>、<code>verticalDirection</code>等，这些参数意义是相同的，我们不再重复介绍，读者可以查阅前面介绍Row的部分。读者可以认为Wrap和Flex（包括Row和Column）除了超出显示范围后Wrap会折行外，其它行为基本相同。下面我们看一下Wrap特有的几个属性：</p>\n<ul>\n<li>spacing：主轴方向子widget的间距</li>\n<li>runSpacing：纵轴方向的间距</li>\n<li>runAlignment：纵轴方向的对齐方式<br>下面看一个示例子：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wrap(</span><br><span class=\"line\">  spacing: <span class=\"number\">8.0</span>, <span class=\"comment\">// 主轴(水平)方向间距</span></span><br><span class=\"line\">  runSpacing: <span class=\"number\">4.0</span>, <span class=\"comment\">// 纵轴（垂直）方向间距</span></span><br><span class=\"line\">  alignment: WrapAlignment.center, <span class=\"comment\">//沿主轴方向居中</span></span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Chip(</span><br><span class=\"line\">      avatar: <span class=\"keyword\">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class=\"string\">'A'</span>)),</span><br><span class=\"line\">      label: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Hamilton'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Chip(</span><br><span class=\"line\">      avatar: <span class=\"keyword\">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class=\"string\">'M'</span>)),</span><br><span class=\"line\">      label: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Lafayette'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Chip(</span><br><span class=\"line\">      avatar: <span class=\"keyword\">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class=\"string\">'H'</span>)),</span><br><span class=\"line\">      label: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Mulligan'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Chip(</span><br><span class=\"line\">      avatar: <span class=\"keyword\">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class=\"string\">'J'</span>)),</span><br><span class=\"line\">      label: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Laurens'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905173658950.png\" alt></p>\n<h2 id=\"Flow\"><a href=\"#Flow\" class=\"headerlink\" title=\"Flow\"></a>Flow</h2><p>我们一般很少会使用Flow，因为其过于复杂，需要自己实现子widget的位置转换，在很多场景下首先要考虑的是Wrap是否满足需求。Flow主要用于一些需要自定义布局策略或性能要求较高(如动画中)的场景。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li><p><strong>性能好</strong>：Flow是一个对child尺寸以及位置调整非常高效的控件，Flow用转换矩阵（transformation matrices）在对child进行位置调整的时候进行了优化：在Flow定位过后，如果child的尺寸或者位置发生了变化，在FlowDelegate中的paintChildren()方法中调用context.paintChild 进行重绘，而context.paintChild在重绘时使用了转换矩阵（transformation matrices），并没有实际调整Widget位置。</p>\n</li>\n<li><p><strong>灵活</strong>：由于我们需要自己实现FlowDelegate的paintChildren()方法，所以我们需要自己计算每一个widget的位置，因此，可以自定义布局策略。</p>\n</li>\n<li><h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3></li>\n<li><p>使用复杂.</p>\n</li>\n<li><p>不能自适应子widget大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。</p>\n</li>\n</ul>\n<h3 id=\"我们对六个色块进行自定义流式布局：\"><a href=\"#我们对六个色块进行自定义流式布局：\" class=\"headerlink\" title=\"我们对六个色块进行自定义流式布局：\"></a>我们对六个色块进行自定义流式布局：</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flow(</span><br><span class=\"line\">  delegate: TestFlowDelegate(margin: EdgeInsets.all(<span class=\"number\">10.0</span>)),</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>, color: Colors.red,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>, color: Colors.green,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>, color: Colors.blue,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>,  color: Colors.yellow,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>, color: Colors.brown,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>,  color: Colors.purple,),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFlowDelegate</span> <span class=\"keyword\">extends</span> <span class=\"title\">FlowDelegate</span> </span>&#123;</span><br><span class=\"line\">  EdgeInsets margin = EdgeInsets.zero;</span><br><span class=\"line\">  TestFlowDelegate(&#123;<span class=\"keyword\">this</span>.margin&#125;);</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> paintChildren(FlowPaintingContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = margin.left;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y = margin.top;</span><br><span class=\"line\">    <span class=\"comment\">//计算每一个子widget的位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; context.childCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> w = context.getChildSize(i).width + x + margin.right;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (w &lt; context.size.width) &#123;</span><br><span class=\"line\">        context.paintChild(i,</span><br><span class=\"line\">            transform: <span class=\"keyword\">new</span> Matrix4.translationValues(</span><br><span class=\"line\">                x, y, <span class=\"number\">0.0</span>));</span><br><span class=\"line\">        x = w + margin.left;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        x = margin.left;</span><br><span class=\"line\">        y += context.getChildSize(i).height + margin.top + margin.bottom;</span><br><span class=\"line\">        <span class=\"comment\">//绘制子widget(有优化)  </span></span><br><span class=\"line\">        context.paintChild(i,</span><br><span class=\"line\">            transform: <span class=\"keyword\">new</span> Matrix4.translationValues(</span><br><span class=\"line\">                x, y, <span class=\"number\">0.0</span>));</span><br><span class=\"line\">         x += context.getChildSize(i).width + margin.left + margin.right;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getSize(BoxConstraints constraints)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//指定Flow的大小  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Size(<span class=\"built_in\">double</span>.infinity,<span class=\"number\">200.0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> shouldRepaint(FlowDelegate oldDelegate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldDelegate != <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905184427501.png\" alt></p>\n<p>可以看到我们主要的任务就是实现paintChildren，它的主要任务是确定每个子widget位置。由于Flow不能自适应子widget的大小，我们通过在getSize返回一个固定大小来指定Flow的大小。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Wrap\"><a href=\"#Wrap\" class=\"headerlink\" title=\"Wrap\"></a>Wrap</h2><p>在介绍Row和Colum时，如果子widget超出屏幕范围，则会报溢出错误，如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Row(</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    Text(<span class=\"string\">\"xxx\"</span>*<span class=\"number\">100</span>)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905171113290.png\" alt></p>\n<p>可以看到，右边溢出部分报错。这是因为Row默认只有一行，如果超出屏幕不会折行。我们把超出屏幕显示范围会自动折行的布局称为流式布局。Flutter中通过Wrap和Flow来支持流式布局，将上例中的Row换成Wrap后溢出部分则会自动折行。下面是Wrap的定义:</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wrap(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.direction = Axis.horizontal,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alignment = WrapAlignment.start,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.spacing = <span class=\"number\">0.0</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.runAlignment = WrapAlignment.start,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.runSpacing = <span class=\"number\">0.0</span>,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.textDirection,</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Widget&gt; children = <span class=\"keyword\">const</span> &lt;Widget&gt;[],</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到Wrap的很多属性在Row（包括Flex和Column）中也有，如<code>direction</code>、<code>crossAxisAlignment</code>、<code>textDirection</code>、<code>verticalDirection</code>等，这些参数意义是相同的，我们不再重复介绍，读者可以查阅前面介绍Row的部分。读者可以认为Wrap和Flex（包括Row和Column）除了超出显示范围后Wrap会折行外，其它行为基本相同。下面我们看一下Wrap特有的几个属性：</p>\n<ul>\n<li>spacing：主轴方向子widget的间距</li>\n<li>runSpacing：纵轴方向的间距</li>\n<li>runAlignment：纵轴方向的对齐方式<br>下面看一个示例子：<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wrap(</span><br><span class=\"line\">  spacing: <span class=\"number\">8.0</span>, <span class=\"comment\">// 主轴(水平)方向间距</span></span><br><span class=\"line\">  runSpacing: <span class=\"number\">4.0</span>, <span class=\"comment\">// 纵轴（垂直）方向间距</span></span><br><span class=\"line\">  alignment: WrapAlignment.center, <span class=\"comment\">//沿主轴方向居中</span></span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Chip(</span><br><span class=\"line\">      avatar: <span class=\"keyword\">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class=\"string\">'A'</span>)),</span><br><span class=\"line\">      label: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Hamilton'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Chip(</span><br><span class=\"line\">      avatar: <span class=\"keyword\">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class=\"string\">'M'</span>)),</span><br><span class=\"line\">      label: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Lafayette'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Chip(</span><br><span class=\"line\">      avatar: <span class=\"keyword\">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class=\"string\">'H'</span>)),</span><br><span class=\"line\">      label: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Mulligan'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Chip(</span><br><span class=\"line\">      avatar: <span class=\"keyword\">new</span> CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class=\"string\">'J'</span>)),</span><br><span class=\"line\">      label: <span class=\"keyword\">new</span> Text(<span class=\"string\">'Laurens'</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905173658950.png\" alt></p>\n<h2 id=\"Flow\"><a href=\"#Flow\" class=\"headerlink\" title=\"Flow\"></a>Flow</h2><p>我们一般很少会使用Flow，因为其过于复杂，需要自己实现子widget的位置转换，在很多场景下首先要考虑的是Wrap是否满足需求。Flow主要用于一些需要自定义布局策略或性能要求较高(如动画中)的场景。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li><p><strong>性能好</strong>：Flow是一个对child尺寸以及位置调整非常高效的控件，Flow用转换矩阵（transformation matrices）在对child进行位置调整的时候进行了优化：在Flow定位过后，如果child的尺寸或者位置发生了变化，在FlowDelegate中的paintChildren()方法中调用context.paintChild 进行重绘，而context.paintChild在重绘时使用了转换矩阵（transformation matrices），并没有实际调整Widget位置。</p>\n</li>\n<li><p><strong>灵活</strong>：由于我们需要自己实现FlowDelegate的paintChildren()方法，所以我们需要自己计算每一个widget的位置，因此，可以自定义布局策略。</p>\n</li>\n<li><h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3></li>\n<li><p>使用复杂.</p>\n</li>\n<li><p>不能自适应子widget大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。</p>\n</li>\n</ul>\n<h3 id=\"我们对六个色块进行自定义流式布局：\"><a href=\"#我们对六个色块进行自定义流式布局：\" class=\"headerlink\" title=\"我们对六个色块进行自定义流式布局：\"></a>我们对六个色块进行自定义流式布局：</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flow(</span><br><span class=\"line\">  delegate: TestFlowDelegate(margin: EdgeInsets.all(<span class=\"number\">10.0</span>)),</span><br><span class=\"line\">  children: &lt;Widget&gt;[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>, color: Colors.red,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>, color: Colors.green,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>, color: Colors.blue,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>,  color: Colors.yellow,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>, color: Colors.brown,),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Container(width: <span class=\"number\">80.0</span>, height:<span class=\"number\">80.0</span>,  color: Colors.purple,),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFlowDelegate</span> <span class=\"keyword\">extends</span> <span class=\"title\">FlowDelegate</span> </span>&#123;</span><br><span class=\"line\">  EdgeInsets margin = EdgeInsets.zero;</span><br><span class=\"line\">  TestFlowDelegate(&#123;<span class=\"keyword\">this</span>.margin&#125;);</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> paintChildren(FlowPaintingContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = margin.left;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y = margin.top;</span><br><span class=\"line\">    <span class=\"comment\">//计算每一个子widget的位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; context.childCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> w = context.getChildSize(i).width + x + margin.right;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (w &lt; context.size.width) &#123;</span><br><span class=\"line\">        context.paintChild(i,</span><br><span class=\"line\">            transform: <span class=\"keyword\">new</span> Matrix4.translationValues(</span><br><span class=\"line\">                x, y, <span class=\"number\">0.0</span>));</span><br><span class=\"line\">        x = w + margin.left;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        x = margin.left;</span><br><span class=\"line\">        y += context.getChildSize(i).height + margin.top + margin.bottom;</span><br><span class=\"line\">        <span class=\"comment\">//绘制子widget(有优化)  </span></span><br><span class=\"line\">        context.paintChild(i,</span><br><span class=\"line\">            transform: <span class=\"keyword\">new</span> Matrix4.translationValues(</span><br><span class=\"line\">                x, y, <span class=\"number\">0.0</span>));</span><br><span class=\"line\">         x += context.getChildSize(i).width + margin.left + margin.right;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getSize(BoxConstraints constraints)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//指定Flow的大小  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Size(<span class=\"built_in\">double</span>.infinity,<span class=\"number\">200.0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> shouldRepaint(FlowDelegate oldDelegate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldDelegate != <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180905184427501.png\" alt></p>\n<p>可以看到我们主要的任务就是实现paintChildren，它的主要任务是确定每个子widget位置。由于Flow不能自适应子widget的大小，我们通过在getSize返回一个固定大小来指定Flow的大小。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck19bvapr000600wk2z55r2rn","category_id":"ck19bvapi000300wkejexrt20","_id":"ck19bvaq9000e00wkolsojjky"},{"post_id":"ck19bvap3000100wkep5jefqx","category_id":"ck19bvapi000300wkejexrt20","_id":"ck19bvaqi000j00wkp66wgr59"},{"post_id":"ck19bvape000200wk2jhsrdwj","category_id":"ck19bvapi000300wkejexrt20","_id":"ck19bvaqo000m00wkk4dc5syn"},{"post_id":"ck19bvapo000500wk1pkj13kz","category_id":"ck19bvapi000300wkejexrt20","_id":"ck19bvaqw000r00wk4u589vft"},{"post_id":"ck19bvaqq000p00wklz1j5wp6","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvar4000x00wkps45b9bc"},{"post_id":"ck19bvapu000700wk63w4h6zd","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvar8001100wkwfruckxx"},{"post_id":"ck19bvaqu000q00wkm4l4oxfo","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvara001300wk68i5p0v0"},{"post_id":"ck19bvaq3000b00wkg9xx6t04","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvare001600wk7w3yyxqx"},{"post_id":"ck19bvaq7000d00wkeizv5tzg","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvarh001900wkr707p8d9"},{"post_id":"ck19bvaqe000i00wklriutil8","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvarl001d00wk02gusk0p"},{"post_id":"ck19bvaqk000k00wk8l9cyncc","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvaro001g00wklglo5xta"},{"post_id":"ck19bvar0000v00wk8ebhxsqe","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvarq001i00wk84qglegc"},{"post_id":"ck19bvayz001o00wkjiz3ksvq","category_id":"ck19bvayu001l00wk9quo0cyq","_id":"ck19bvaze001v00wk6nlkr1ie"},{"post_id":"ck19bvayn001j00wkbbw2q6ev","category_id":"ck19bvayu001l00wk9quo0cyq","_id":"ck19bvazk001z00wkupm2gfrh"},{"post_id":"ck19bvayq001k00wklv5gi413","category_id":"ck19bvaz5001q00wky1hu5fok","_id":"ck19bvazp002300wko66s3jnm"},{"post_id":"ck19bvayw001n00wkqm2ijrt8","category_id":"ck19bvaz5001q00wky1hu5fok","_id":"ck19bvb01002800wktqtqxvpg"},{"post_id":"ck19bvazs002500wke0dpexgi","category_id":"ck19bvazp002200wkuac4zbih","_id":"ck19bvb0a002e00wk2rvdjo5k"},{"post_id":"ck19bvaz2001p00wk2ld2xfwt","category_id":"ck19bvazp002200wkuac4zbih","_id":"ck19bvb0g002i00wk9lxwtk7n"},{"post_id":"ck19bvazw002700wkqsrinajs","category_id":"ck19bvayu001l00wk9quo0cyq","_id":"ck19bvb0n002l00wkcq2zoncl"},{"post_id":"ck19bvaz9001t00wkkj13xmwp","category_id":"ck19bvazp002200wkuac4zbih","_id":"ck19bvb0u002q00wkagfcu7ka"},{"post_id":"ck19bvb0e002h00wkai62q4qa","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvb0z002t00wkfb7e01yp"},{"post_id":"ck19bvazc001u00wkff04myyn","category_id":"ck19bvazp002200wkuac4zbih","_id":"ck19bvb13002w00wkb0ewhzz5"},{"post_id":"ck19bvb0l002k00wk6dcwxcab","category_id":"ck19bvapi000300wkejexrt20","_id":"ck19bvb16002z00wk4wow4vnr"},{"post_id":"ck19bvb0s002p00wkqwg0vr8q","category_id":"ck19bvapi000300wkejexrt20","_id":"ck19bvb19003200wkimiwq40q"},{"post_id":"ck19bvazi001y00wkay8518d7","category_id":"ck19bvazp002200wkuac4zbih","_id":"ck19bvb1c003500wk5b84w33w"},{"post_id":"ck19bvb0x002s00wkuzun60m9","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvb1e003700wkhmmskivn"},{"post_id":"ck19bvazm002100wkw7ayedcs","category_id":"ck19bvazp002200wkuac4zbih","_id":"ck19bvb1h003900wkrg06ftkr"},{"post_id":"ck19bvb04002b00wktssq84qb","category_id":"ck19bvb17003000wknru5ork7","_id":"ck19bvb1j003b00wkl7qocl2o"},{"post_id":"ck19bvb08002d00wk5x75cj06","category_id":"ck19bvb17003000wknru5ork7","_id":"ck19bvb1m003e00wk2i9wwcy7"},{"post_id":"ck19bvb2w004100wkhxol74pj","category_id":"ck19bvayu001l00wk9quo0cyq","_id":"ck19bvb36004600wk2deh3ufj"},{"post_id":"ck19bvb2y004200wk1jx8bg99","category_id":"ck19bvazp002200wkuac4zbih","_id":"ck19bvb3a004900wk2amxxt1n"},{"post_id":"ck19bvb34004500wkaumt47fb","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb3l004f00wk5xkb5qms"},{"post_id":"ck19bvb38004800wkvm1j53ko","category_id":"ck19bvaqm000l00wkbn0g6g2l","_id":"ck19bvb3t004k00wk0z6pz2zn"},{"post_id":"ck19bvb31004400wktkxh8lag","category_id":"ck19bvb37004700wk6obmjdmb","_id":"ck19bvb3y004n00wkuthmlxqc"},{"post_id":"ck19bvb3w004m00wkskd0qb4l","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb4a004v00wkz5pf7u9l"},{"post_id":"ck19bvb3w004m00wkskd0qb4l","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb4g004z00wkxnkxqo9h"},{"post_id":"ck19bvb3f004c00wkmycf7cxn","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb4k005200wk900x3bif"},{"post_id":"ck19bvb3f004c00wkmycf7cxn","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb4q005500wk0r891lrx"},{"post_id":"ck19bvb40004p00wk2ynedz3k","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb4z005800wkvkyv6q7c"},{"post_id":"ck19bvb40004p00wk2ynedz3k","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb53005b00wk5dm50342"},{"post_id":"ck19bvb45004s00wkxol680pa","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb5a005e00wkuzlt2f5j"},{"post_id":"ck19bvb45004s00wkxol680pa","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb5h005i00wknitife30"},{"post_id":"ck19bvb3j004e00wk2yv4iama","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb5j005k00wkzyhls770"},{"post_id":"ck19bvb3j004e00wk2yv4iama","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb5l005n00wk80b59zjt"},{"post_id":"ck19bvb48004u00wkr312ra07","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb5n005p00wkd80xv6sh"},{"post_id":"ck19bvb48004u00wkr312ra07","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb5q005s00wkw1sxfh4a"},{"post_id":"ck19bvb4d004y00wk3e07t5tr","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb5s005u00wk5aw6ae0z"},{"post_id":"ck19bvb4d004y00wk3e07t5tr","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb5t005w00wkzcn1du8x"},{"post_id":"ck19bvb3p004i00wk6etgetwm","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb5u005x00wkns9vc7vr"},{"post_id":"ck19bvb3p004i00wk6etgetwm","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb5v005y00wkhf68539e"},{"post_id":"ck19bvb4h005100wky2iotofj","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb5w005z00wkamvv2pmh"},{"post_id":"ck19bvb4h005100wky2iotofj","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb5w006000wkr3dz30yl"},{"post_id":"ck19bvb4l005400wkxaickp9p","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb5x006100wks8oxftfm"},{"post_id":"ck19bvb4l005400wkxaickp9p","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb5y006200wksi2grgqk"},{"post_id":"ck19bvb4s005700wk45za9b8r","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb5y006300wk0gqxvsjb"},{"post_id":"ck19bvb4s005700wk45za9b8r","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb5z006400wki04rqxew"},{"post_id":"ck19bvb51005a00wkrzhu6yzh","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb60006500wkhf3oygiv"},{"post_id":"ck19bvb51005a00wkrzhu6yzh","category_id":"ck19bvb5g005h00wkg6llnmq6","_id":"ck19bvb60006600wkobblpv4y"},{"post_id":"ck19bvb56005d00wktxnrgrw4","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb61006700wkrsv2vvfc"},{"post_id":"ck19bvb56005d00wktxnrgrw4","category_id":"ck19bvb5g005h00wkg6llnmq6","_id":"ck19bvb62006800wkj8c7ot1d"},{"post_id":"ck19bvb5e005g00wkg0kl6468","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb62006900wkoqxgk0tq"},{"post_id":"ck19bvb5e005g00wkg0kl6468","category_id":"ck19bvb5g005h00wkg6llnmq6","_id":"ck19bvb63006a00wky44twdx4"},{"post_id":"ck19bvb6i006h00wka88au6nu","category_id":"ck19bvb37004700wk6obmjdmb","_id":"ck19bvb6v006p00wk58x763we"},{"post_id":"ck19bvb69006b00wkbelf22ho","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb71006t00wktx3l9alm"},{"post_id":"ck19bvb69006b00wkbelf22ho","category_id":"ck19bvb6g006f00wk05b76wqe","_id":"ck19bvb73006v00wkrofc4wrr"},{"post_id":"ck19bvb6m006j00wkwidtm8ku","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb75006x00wkswpkm0r7"},{"post_id":"ck19bvb6m006j00wkwidtm8ku","category_id":"ck19bvb3s004j00wkxpjfygdz","_id":"ck19bvb76006y00wk8v2logn8"},{"post_id":"ck19bvb6q006m00wkc6236kzp","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb77006z00wk0cc1zboj"},{"post_id":"ck19bvb6q006m00wkc6236kzp","category_id":"ck19bvb5g005h00wkg6llnmq6","_id":"ck19bvb78007000wk5q53ko9m"},{"post_id":"ck19bvb6b006c00wk867foyjq","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb78007100wkr44ta0qf"},{"post_id":"ck19bvb6b006c00wk867foyjq","category_id":"ck19bvb6g006f00wk05b76wqe","_id":"ck19bvb79007200wk9s5tl530"},{"post_id":"ck19bvb6u006o00wkytfev1he","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb7a007300wk09htuqzr"},{"post_id":"ck19bvb6u006o00wkytfev1he","category_id":"ck19bvb6g006f00wk05b76wqe","_id":"ck19bvb7d007400wk7qy1w4mr"},{"post_id":"ck19bvb6z006s00wklvn0nec4","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb7e007500wkgcgj51h3"},{"post_id":"ck19bvb6z006s00wklvn0nec4","category_id":"ck19bvb6g006f00wk05b76wqe","_id":"ck19bvb7f007600wkhbhzuxsm"},{"post_id":"ck19bvb6e006e00wkhp08fa0t","category_id":"ck19bvark001c00wk6i6d5m5j","_id":"ck19bvb7f007700wknauc6hor"},{"post_id":"ck19bvb6e006e00wkhp08fa0t","category_id":"ck19bvb6g006f00wk05b76wqe","_id":"ck19bvb7g007800wk2vwx2e2j"}],"PostTag":[{"post_id":"ck19bvapr000600wk2z55r2rn","tag_id":"ck19bvapm000400wk7hgag10j","_id":"ck19bvaq2000a00wkhovhqs08"},{"post_id":"ck19bvap3000100wkep5jefqx","tag_id":"ck19bvapm000400wk7hgag10j","_id":"ck19bvaq6000c00wk00cojywn"},{"post_id":"ck19bvape000200wk2jhsrdwj","tag_id":"ck19bvapm000400wk7hgag10j","_id":"ck19bvaqd000h00wkjmahkaj8"},{"post_id":"ck19bvapo000500wk1pkj13kz","tag_id":"ck19bvapm000400wk7hgag10j","_id":"ck19bvaqq000o00wkq8s9bl87"},{"post_id":"ck19bvaqq000p00wklz1j5wp6","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvar0000u00wkiicyvpcw"},{"post_id":"ck19bvapu000700wk63w4h6zd","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvar3000w00wkcsn4srua"},{"post_id":"ck19bvaqu000q00wkm4l4oxfo","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvar7001000wksw8ggsap"},{"post_id":"ck19bvaq3000b00wkg9xx6t04","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvar9001200wkztqkt0vf"},{"post_id":"ck19bvaq7000d00wkeizv5tzg","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvare001700wksdjptrzj"},{"post_id":"ck19bvaqe000i00wklriutil8","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvarj001b00wkh1arwxp9"},{"post_id":"ck19bvaqk000k00wk8l9cyncc","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvarn001f00wk5tljnkcj"},{"post_id":"ck19bvar0000v00wk8ebhxsqe","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvarp001h00wkipl613x0"},{"post_id":"ck19bvayn001j00wkbbw2q6ev","tag_id":"ck19bvayv001m00wk5q0ks4cs","_id":"ck19bvaz8001s00wk4zleikhx"},{"post_id":"ck19bvayq001k00wklv5gi413","tag_id":"ck19bvaz6001r00wkui19xbum","_id":"ck19bvazl002000wkle3i8zh0"},{"post_id":"ck19bvayw001n00wkqm2ijrt8","tag_id":"ck19bvaz6001r00wkui19xbum","_id":"ck19bvazt002600wku16pehc0"},{"post_id":"ck19bvayz001o00wkjiz3ksvq","tag_id":"ck19bvazq002400wkd8xe4i0j","_id":"ck19bvb07002c00wklpw0rsvi"},{"post_id":"ck19bvaz2001p00wk2ld2xfwt","tag_id":"ck19bvb03002a00wk0hqrskc5","_id":"ck19bvb0k002j00wkq6kgdabx"},{"post_id":"ck19bvb0e002h00wkai62q4qa","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvb0p002n00wk19uovvm5"},{"post_id":"ck19bvb0l002k00wk6dcwxcab","tag_id":"ck19bvapm000400wk7hgag10j","_id":"ck19bvb0w002r00wkr5tcp47g"},{"post_id":"ck19bvb0s002p00wkqwg0vr8q","tag_id":"ck19bvapm000400wk7hgag10j","_id":"ck19bvb11002v00wk27nkyiyb"},{"post_id":"ck19bvb0x002s00wkuzun60m9","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvb15002y00wkq4dgbvi3"},{"post_id":"ck19bvaz9001t00wkkj13xmwp","tag_id":"ck19bvb03002a00wk0hqrskc5","_id":"ck19bvb18003100wkael5pwdm"},{"post_id":"ck19bvaz9001t00wkkj13xmwp","tag_id":"ck19bvb0q002o00wks2qt1vqj","_id":"ck19bvb1b003400wkszpdwb7m"},{"post_id":"ck19bvazc001u00wkff04myyn","tag_id":"ck19bvb03002a00wk0hqrskc5","_id":"ck19bvb1i003a00wkllvhifvd"},{"post_id":"ck19bvazc001u00wkff04myyn","tag_id":"ck19bvb1a003300wkt99k8gso","_id":"ck19bvb1k003c00wky2sx8iur"},{"post_id":"ck19bvazi001y00wkay8518d7","tag_id":"ck19bvb03002a00wk0hqrskc5","_id":"ck19bvb1p003g00wkqdyepgx8"},{"post_id":"ck19bvazi001y00wkay8518d7","tag_id":"ck19bvb1l003d00wkaxwby4uw","_id":"ck19bvb1q003h00wkqh6at70e"},{"post_id":"ck19bvazm002100wkw7ayedcs","tag_id":"ck19bvb03002a00wk0hqrskc5","_id":"ck19bvb1v003k00wkqy8j4srk"},{"post_id":"ck19bvazm002100wkw7ayedcs","tag_id":"ck19bvb1r003i00wkqlzmhr2o","_id":"ck19bvb1w003l00wk3f9rzp81"},{"post_id":"ck19bvazs002500wke0dpexgi","tag_id":"ck19bvb03002a00wk0hqrskc5","_id":"ck19bvb20003o00wk3pv93r0u"},{"post_id":"ck19bvazs002500wke0dpexgi","tag_id":"ck19bvb1x003m00wkjzklyss1","_id":"ck19bvb21003p00wk2uclijju"},{"post_id":"ck19bvazw002700wkqsrinajs","tag_id":"ck19bvb1z003n00wk8arnj2iu","_id":"ck19bvb25003s00wk1r6e6w64"},{"post_id":"ck19bvazw002700wkqsrinajs","tag_id":"ck19bvb22003q00wk4hwooweu","_id":"ck19bvb27003t00wkh6e4tjyy"},{"post_id":"ck19bvb04002b00wktssq84qb","tag_id":"ck19bvb1z003n00wk8arnj2iu","_id":"ck19bvb2b003w00wk2buhyy3o"},{"post_id":"ck19bvb04002b00wktssq84qb","tag_id":"ck19bvb22003q00wk4hwooweu","_id":"ck19bvb2c003x00wkbbnpi6y7"},{"post_id":"ck19bvb08002d00wk5x75cj06","tag_id":"ck19bvb1z003n00wk8arnj2iu","_id":"ck19bvb2f003z00wkxolukryz"},{"post_id":"ck19bvb08002d00wk5x75cj06","tag_id":"ck19bvb22003q00wk4hwooweu","_id":"ck19bvb2g004000wk7llufqi1"},{"post_id":"ck19bvb34004500wkaumt47fb","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb3c004b00wk08870oeu"},{"post_id":"ck19bvb2w004100wkhxol74pj","tag_id":"ck19bvb30004300wkvp9p57r3","_id":"ck19bvb3i004d00wkly4pa1zy"},{"post_id":"ck19bvb38004800wkvm1j53ko","tag_id":"ck19bvaqo000n00wkbzy6voe6","_id":"ck19bvb3o004h00wk5z0zkj3s"},{"post_id":"ck19bvb3f004c00wkmycf7cxn","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb3v004l00wk5p5xihjf"},{"post_id":"ck19bvb2y004200wk1jx8bg99","tag_id":"ck19bvb03002a00wk0hqrskc5","_id":"ck19bvb3z004o00wkzrepjdqa"},{"post_id":"ck19bvb2y004200wk1jx8bg99","tag_id":"ck19bvb3b004a00wk79oyn0uc","_id":"ck19bvb44004r00wkrrxhh9wb"},{"post_id":"ck19bvb3j004e00wk2yv4iama","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb47004t00wkiqfu51rw"},{"post_id":"ck19bvb3p004i00wk6etgetwm","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb4d004x00wkyiky85bf"},{"post_id":"ck19bvb31004400wktkxh8lag","tag_id":"ck19bvb3m004g00wksfzlk4pm","_id":"ck19bvb4h005000wkq74yfdze"},{"post_id":"ck19bvb3w004m00wkskd0qb4l","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb4l005300wkizvnzcvt"},{"post_id":"ck19bvb40004p00wk2ynedz3k","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb4r005600wko7qjhml5"},{"post_id":"ck19bvb45004s00wkxol680pa","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb50005900wkf5106vm6"},{"post_id":"ck19bvb48004u00wkr312ra07","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb54005c00wkuyveezav"},{"post_id":"ck19bvb4d004y00wk3e07t5tr","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb5c005f00wki1e0nq0b"},{"post_id":"ck19bvb4h005100wky2iotofj","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb5i005j00wkyvmwi10s"},{"post_id":"ck19bvb4l005400wkxaickp9p","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb5k005l00wk47j45ccb"},{"post_id":"ck19bvb4s005700wk45za9b8r","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb5n005o00wkc9l0wbi5"},{"post_id":"ck19bvb51005a00wkrzhu6yzh","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb5o005q00wku8fhcx3s"},{"post_id":"ck19bvb56005d00wktxnrgrw4","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb5r005t00wkzq4txbd2"},{"post_id":"ck19bvb5e005g00wkg0kl6468","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb5t005v00wki366ku99"},{"post_id":"ck19bvb69006b00wkbelf22ho","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb6e006d00wkx914zmkw"},{"post_id":"ck19bvb6b006c00wk867foyjq","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb6h006g00wki7c84ima"},{"post_id":"ck19bvb6e006e00wkhp08fa0t","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb6l006i00wkrgbz2w9j"},{"post_id":"ck19bvb6i006h00wka88au6nu","tag_id":"ck19bvb3m004g00wksfzlk4pm","_id":"ck19bvb6q006l00wko1g7966j"},{"post_id":"ck19bvb6m006j00wkwidtm8ku","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb6t006n00wkypj56z0f"},{"post_id":"ck19bvb6q006m00wkc6236kzp","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb6y006r00wkg5ech106"},{"post_id":"ck19bvb6u006o00wkytfev1he","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb72006u00wkxgoci9cj"},{"post_id":"ck19bvb6z006s00wklvn0nec4","tag_id":"ck19bvarm001e00wk7yo7br3x","_id":"ck19bvb75006w00wk4pv4yrck"}],"Tag":[{"name":"c","_id":"ck19bvapm000400wk7hgag10j"},{"name":"dart","_id":"ck19bvaqo000n00wkbzy6voe6"},{"name":"flutter","_id":"ck19bvarm001e00wk7yo7br3x"},{"name":"eclipse","_id":"ck19bvayv001m00wk5q0ks4cs"},{"name":"hexo","_id":"ck19bvaz6001r00wkui19xbum"},{"name":"php","_id":"ck19bvazq002400wkd8xe4i0j"},{"name":"uml","_id":"ck19bvb03002a00wk0hqrskc5"},{"name":"用例图","_id":"ck19bvb0q002o00wks2qt1vqj"},{"name":"状态图","_id":"ck19bvb1a003300wkt99k8gso"},{"name":"部署图","_id":"ck19bvb1l003d00wkaxwby4uw"},{"name":"活动图","_id":"ck19bvb1r003i00wkqlzmhr2o"},{"name":"时序图","_id":"ck19bvb1x003m00wkjzklyss1"},{"name":"mysql","_id":"ck19bvb1z003n00wk8arnj2iu"},{"name":"数据库","_id":"ck19bvb22003q00wk4hwooweu"},{"name":"git","_id":"ck19bvb30004300wkvp9p57r3"},{"name":"静态图","_id":"ck19bvb3b004a00wk79oyn0uc"},{"name":"Android","_id":"ck19bvb3m004g00wksfzlk4pm"}]}}